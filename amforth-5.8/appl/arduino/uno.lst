
AVRASM ver. 2.1.52  uno.asm Wed Mar 25 21:24:34 2015

uno.asm(5): Including file '../../avr8\preamble.inc'
../../avr8\preamble.inc(2): Including file '../../avr8\macros.asm'
../../avr8\macros.asm(6): Including file '../../avr8\user.inc'
../../avr8\preamble.inc(6): Including file '../../avr8/devices/atmega328p\device.asm'
../../avr8/devices/atmega328p\device.asm(5): Including file '../../avr8/Atmel/Appnotes2\m328Pdef.inc'
uno.asm(8): Including file '../../avr8\drivers/usart_0.asm'
../../avr8\drivers/usart_0.asm(32): Including file '../../avr8\drivers/usart_common.asm'
../../avr8\drivers/usart_common.asm(5): Including file '../../avr8\drivers/usart-isr-rx.asm'
../../avr8\drivers/usart_common.asm(17): Including file '../../avr8\words/usart-tx-poll.asm'
../../avr8\drivers/usart_common.asm(22): Including file '../../avr8\words/ubrr.asm'
../../avr8\drivers/usart_common.asm(23): Including file '../../avr8\words/usart.asm'
uno.asm(13): Including file '../../avr8\drivers/1wire.asm'
uno.asm(15): Including file '../../avr8\amforth.asm'
../../avr8\amforth.asm(12): Including file '../../avr8\drivers/generic-isr.asm'
../../avr8\amforth.asm(14): Including file '../../avr8\dict/rww.inc'
../../avr8\dict/rww.inc(1): Including file '../../avr8\words/mplus.asm'
../../avr8\dict/rww.inc(2): Including file '../../common\words/ud-star.asm'
../../avr8\dict/rww.inc(3): Including file '../../common\words/umax.asm'
../../avr8\dict/rww.inc(4): Including file '../../common\words/umin.asm'
../../avr8\dict/rww.inc(5): Including file '../../avr8\words/immediate-q.asm'
../../avr8\dict/rww.inc(6): Including file '../../avr8\words/name2flags.asm'
../../avr8\dict/rww.inc(11): Including file '../../avr8\dict/appl_4k.inc'
../../avr8\dict/appl_4k.inc(1): Including file '../../common\words/ver.asm'
../../avr8\dict/appl_4k.inc(4): Including file '../../avr8\words/noop.asm'
../../avr8\dict/appl_4k.inc(5): Including file '../../avr8\words/unused.asm'
../../avr8\dict/appl_4k.inc(6): Including file '../../avr8\words/to.asm'
../../avr8\dict/appl_4k.inc(7): Including file '../../avr8\words/icompare.asm'
../../avr8\dict/appl_4k.inc(8): Including file '../../common\words/star.asm'
../../avr8\dict/appl_4k.inc(9): Including file '../../avr8\words/j.asm'
../../avr8\dict/appl_4k.inc(10): Including file '../../avr8\words/dabs.asm'
../../avr8\dict/appl_4k.inc(11): Including file '../../avr8\words/dnegate.asm'
../../avr8\dict/appl_4k.inc(12): Including file '../../avr8\words/cmove.asm'
../../avr8\dict/appl_4k.inc(13): Including file '../../common\words/2swap.asm'
../../avr8\dict/appl_4k.inc(14): Including file '../../avr8\words/tib.asm'
../../avr8\dict/appl_4k.inc(15): Including file '../../avr8\words/init-user.asm'
../../avr8\dict/appl_4k.inc(19): Including file '../../avr8\words/environment.asm'
../../avr8\dict/appl_4k.inc(20): Including file '../../avr8\words/env-wordlists.asm'
../../avr8\dict/appl_4k.inc(21): Including file '../../avr8\words/env-slashpad.asm'
../../avr8\dict/appl_4k.inc(22): Including file '../../avr8\words/env-slashhold.asm'
../../avr8\dict/appl_4k.inc(23): Including file '../../common\words/env-forthname.asm'
../../avr8\dict/appl_4k.inc(24): Including file '../../common\words/env-forthversion.asm'
../../avr8\dict/appl_4k.inc(25): Including file '../../common\words/env-cpu.asm'
../../avr8\dict/appl_4k.inc(26): Including file '../../avr8\words/env-mcuinfo.asm'
../../avr8\dict/appl_4k.inc(27): Including file '../../avr8\words/env-usersize.asm'
../../avr8\dict/appl_4k.inc(29): Including file '../../avr8\words/hld.asm'
../../avr8\dict/appl_4k.inc(30): Including file '../../common\words/hold.asm'
../../avr8\dict/appl_4k.inc(31): Including file '../../common\words/less-sharp.asm'
../../avr8\dict/appl_4k.inc(32): Including file '../../common\words/sharp.asm'
../../avr8\dict/appl_4k.inc(33): Including file '../../common\words/sharp-s.asm'
../../avr8\dict/appl_4k.inc(34): Including file '../../common\words/sharp-greater.asm'
../../avr8\dict/appl_4k.inc(35): Including file '../../common\words/sign.asm'
../../avr8\dict/appl_4k.inc(36): Including file '../../common\words/d-dot-r.asm'
../../avr8\dict/appl_4k.inc(37): Including file '../../common\words/dot-r.asm'
../../avr8\dict/appl_4k.inc(38): Including file '../../common\words/d-dot.asm'
../../avr8\dict/appl_4k.inc(39): Including file '../../common\words/dot.asm'
../../avr8\dict/appl_4k.inc(40): Including file '../../common\words/ud-dot.asm'
../../avr8\dict/appl_4k.inc(41): Including file '../../common\words/ud-dot-r.asm'
../../avr8\dict/appl_4k.inc(42): Including file '../../common\words/ud-slash-mod.asm'
../../avr8\dict/appl_4k.inc(43): Including file '../../common\words/digit-q.asm'
../../avr8\dict/appl_4k.inc(45): Including file '../../avr8\words/do-sliteral.asm'
../../avr8\dict/appl_4k.inc(46): Including file '../../avr8\words/scomma.asm'
../../avr8\dict/appl_4k.inc(47): Including file '../../avr8\words/itype.asm'
../../avr8\dict/appl_4k.inc(48): Including file '../../avr8\words/icount.asm'
../../avr8\dict/appl_4k.inc(49): Including file '../../common\words/type.asm'
../../avr8\dict/appl_4k.inc(50): Including file '../../common\words/tick.asm'
../../avr8\dict/appl_4k.inc(52): Including file '../../common\words/cskip.asm'
../../avr8\dict/appl_4k.inc(53): Including file '../../common\words/cscan.asm'
../../avr8\dict/appl_4k.inc(54): Including file '../../common\words/accept.asm'
../../avr8\dict/appl_4k.inc(55): Including file '../../avr8\words/refill.asm'
../../avr8\dict/appl_4k.inc(56): Including file '../../common\words/char.asm'
../../avr8\dict/appl_4k.inc(57): Including file '../../common\words/number.asm'
../../avr8\dict/appl_4k.inc(58): Including file '../../common\words/q-sign.asm'
../../avr8\dict/appl_4k.inc(59): Including file '../../common\words/set-base.asm'
../../avr8\dict/appl_4k.inc(60): Including file '../../common\words/to-number.asm'
../../avr8\dict/appl_4k.inc(61): Including file '../../common\words/parse.asm'
../../avr8\dict/appl_4k.inc(62): Including file '../../avr8\words/source.asm'
../../avr8\dict/appl_4k.inc(63): Including file '../../common\words/slash-string.asm'
../../avr8\dict/appl_4k.inc(64): Including file '../../common\words/parse-name.asm'
../../avr8\dict/appl_4k.inc(65): Including file '../../avr8\words/sp0.asm'
../../avr8\dict/appl_4k.inc(66): Including file '../../avr8\words/rp0.asm'
../../avr8\dict/appl_4k.inc(67): Including file '../../common\words/depth.asm'
../../avr8\dict/appl_4k.inc(68): Including file '../../common\words/do-recognizer.asm'
../../avr8\dict/appl_4k.inc(69): Including file '../../common\words/interpret.asm'
../../avr8\dict/appl_4k.inc(70): Including file '../../common\words/r-intnumber.asm'
../../avr8\dict/appl_4k.inc(71): Including file '../../common\words/r-word.asm'
../../avr8\dict/appl_4k.inc(72): Including file '../../common\words/r-fail.asm'
../../avr8\dict/appl_4k.inc(73): Including file '../../common\words/search-wordlist.asm'
../../avr8\dict/appl_4k.inc(74): Including file '../../common\words/traverse-wordlist.asm'
../../avr8\dict/appl_4k.inc(75): Including file '../../common\words/name2string.asm'
../../avr8\dict/appl_4k.inc(76): Including file '../../avr8\words/nfa2cfa.asm'
../../avr8\dict/appl_4k.inc(77): Including file '../../common\words/find-name.asm'
../../avr8\dict/appl_4k.inc(79): Including file '../../avr8\dict/compiler1.inc'
../../avr8\dict/compiler1.inc(2): Including file '../../avr8\words/docreate.asm'
../../avr8\dict/compiler1.inc(3): Including file '../../common\words/backslash.asm'
../../avr8\dict/compiler1.inc(4): Including file '../../common\words/l-paren.asm'
../../avr8\dict/compiler1.inc(6): Including file '../../common\words/compile.asm'
../../avr8\dict/compiler1.inc(7): Including file '../../avr8\words/comma.asm'
../../avr8\dict/compiler1.inc(8): Including file '../../common\words/brackettick.asm'
../../avr8\dict/compiler1.inc(11): Including file '../../common\words/literal.asm'
../../avr8\dict/compiler1.inc(12): Including file '../../common\words/sliteral.asm'
../../avr8\dict/compiler1.inc(13): Including file '../../avr8\words/g-mark.asm'
../../avr8\dict/compiler1.inc(14): Including file '../../avr8\words/g-resolve.asm'
../../avr8\dict/compiler1.inc(15): Including file '../../avr8\words/l_mark.asm'
../../avr8\dict/compiler1.inc(16): Including file '../../avr8\words/l_resolve.asm'
../../avr8\dict/compiler1.inc(18): Including file '../../common\words/ahead.asm'
../../avr8\dict/compiler1.inc(19): Including file '../../common\words/if.asm'
../../avr8\dict/compiler1.inc(20): Including file '../../common\words/else.asm'
../../avr8\dict/compiler1.inc(21): Including file '../../common\words/then.asm'
../../avr8\dict/compiler1.inc(22): Including file '../../common\words/begin.asm'
../../avr8\dict/compiler1.inc(23): Including file '../../common\words/while.asm'
../../avr8\dict/compiler1.inc(24): Including file '../../common\words/repeat.asm'
../../avr8\dict/compiler1.inc(25): Including file '../../common\words/until.asm'
../../avr8\dict/compiler1.inc(26): Including file '../../common\words/again.asm'
../../avr8\dict/compiler1.inc(27): Including file '../../common\words/do.asm'
../../avr8\dict/compiler1.inc(28): Including file '../../common\words/loop.asm'
../../avr8\dict/compiler1.inc(29): Including file '../../common\words/plusloop.asm'
../../avr8\dict/compiler1.inc(30): Including file '../../common\words/leave.asm'
../../avr8\dict/compiler1.inc(31): Including file '../../common\words/qdo.asm'
../../avr8\dict/compiler1.inc(32): Including file '../../common\words/endloop.asm'
../../avr8\dict/compiler1.inc(34): Including file '../../common\words/l-from.asm'
../../avr8\dict/compiler1.inc(35): Including file '../../common\words/to-l.asm'
../../avr8\dict/compiler1.inc(36): Including file '../../avr8\words/lp0.asm'
../../avr8\dict/compiler1.inc(37): Including file '../../avr8\words/lp.asm'
../../avr8\dict/compiler1.inc(39): Including file '../../avr8\words/create.asm'
../../avr8\dict/compiler1.inc(40): Including file '../../avr8\words/header.asm'
../../avr8\dict/compiler1.inc(41): Including file '../../avr8\words/wlscope.asm'
../../avr8\dict/compiler1.inc(42): Including file '../../avr8\words/reveal.asm'
../../avr8\dict/compiler1.inc(43): Including file '../../avr8\words/latest.asm'
../../avr8\dict/compiler1.inc(44): Including file '../../avr8\words/does.asm'
../../avr8\dict/compiler1.inc(45): Including file '../../common\words/colon.asm'
../../avr8\dict/compiler1.inc(46): Including file '../../avr8\words/colon-noname.asm'
../../avr8\dict/compiler1.inc(47): Including file '../../common\words/semicolon.asm'
../../avr8\dict/compiler1.inc(48): Including file '../../common\words/right-bracket.asm'
../../avr8\dict/compiler1.inc(49): Including file '../../common\words/left-bracket.asm'
../../avr8\dict/compiler1.inc(50): Including file '../../common\words/variable.asm'
../../avr8\dict/compiler1.inc(51): Including file '../../common\words/constant.asm'
../../avr8\dict/compiler1.inc(52): Including file '../../avr8\words/user.asm'
../../avr8\dict/compiler1.inc(54): Including file '../../avr8\words/recurse.asm'
../../avr8\dict/compiler1.inc(55): Including file '../../avr8\words/immediate.asm'
../../avr8\dict/compiler1.inc(57): Including file '../../common\words/bracketchar.asm'
../../avr8\dict/compiler1.inc(58): Including file '../../common\words/abort-string.asm'
../../avr8\dict/compiler1.inc(59): Including file '../../common\words/abort.asm'
../../avr8\dict/compiler1.inc(60): Including file '../../common\words/q-abort.asm'
../../avr8\dict/compiler1.inc(62): Including file '../../common\words/get-stack.asm'
../../avr8\dict/compiler1.inc(63): Including file '../../common\words/set-stack.asm'
../../avr8\dict/compiler1.inc(64): Including file '../../common\words/map-stack.asm'
../../avr8\dict/compiler1.inc(65): Including file '../../avr8\words/get-current.asm'
../../avr8\dict/compiler1.inc(66): Including file '../../common\words/get-order.asm'
../../avr8\dict/compiler1.inc(68): Including file '../../avr8\words/compare.asm'
../../avr8\dict/compiler1.inc(69): Including file '../../avr8\words/nfa2lfa.asm'
../../avr8\amforth.asm(15): Including file 'dict_appl.inc'
dict_appl.inc(4): Including file '../../avr8\dict/compiler2.inc'
../../avr8\dict/compiler2.inc(8): Including file '../../avr8\words/set-current.asm'
../../avr8\dict/compiler2.inc(9): Including file '../../avr8\words/wordlist.asm'
../../avr8\dict/compiler2.inc(11): Including file '../../avr8\words/only.asm'
../../avr8\dict/compiler2.inc(12): Including file '../../avr8\words/forth-wordlist.asm'
../../avr8\dict/compiler2.inc(13): Including file '../../common\words/set-order.asm'
../../avr8\dict/compiler2.inc(14): Including file '../../common\words/set-recognizer.asm'
../../avr8\dict/compiler2.inc(15): Including file '../../common\words/get-recognizer.asm'
../../avr8\dict/compiler2.inc(16): Including file '../../avr8\words/code.asm'
../../avr8\dict/compiler2.inc(17): Including file '../../avr8\words/end-code.asm'
../../avr8\dict/compiler2.inc(18): Including file '../../avr8\words/marker.asm'
../../avr8\dict/compiler2.inc(19): Including file '../../common\words/postpone.asm'
../../avr8\dict/compiler2.inc(20): Including file '../../avr8\words/i-cellplus.asm'
dict_appl.inc(6): Including file 'words/applturnkey.asm'
../../avr8\amforth.asm(23): Including file '../../avr8\amforth-interpreter.asm'
../../avr8\amforth.asm(24): Including file '../../avr8\dict/nrww.inc'
../../avr8\dict/nrww.inc(4): Including file '../../avr8\words/exit.asm'
../../avr8\dict/nrww.inc(5): Including file '../../avr8\words/execute.asm'
../../avr8\dict/nrww.inc(6): Including file '../../avr8\words/dobranch.asm'
../../avr8\dict/nrww.inc(7): Including file '../../avr8\words/docondbranch.asm'
../../avr8\dict/nrww.inc(10): Including file '../../avr8\words/doliteral.asm'
../../avr8\dict/nrww.inc(11): Including file '../../avr8\words/dovariable.asm'
../../avr8\dict/nrww.inc(12): Including file '../../avr8\words/doconstant.asm'
../../avr8\dict/nrww.inc(13): Including file '../../avr8\words/douser.asm'
../../avr8\dict/nrww.inc(14): Including file '../../avr8\words/do-value.asm'
../../avr8\dict/nrww.inc(15): Including file '../../avr8\words/fetch.asm'
../../avr8\dict/nrww.inc(16): Including file '../../avr8\words/store.asm'
../../avr8\dict/nrww.inc(17): Including file '../../avr8\words/cstore.asm'
../../avr8\dict/nrww.inc(18): Including file '../../avr8\words/cfetch.asm'
../../avr8\dict/nrww.inc(19): Including file '../../avr8\words/fetch-u.asm'
../../avr8\dict/nrww.inc(20): Including file '../../avr8\words/store-u.asm'
../../avr8\dict/nrww.inc(23): Including file '../../avr8\words/dup.asm'
../../avr8\dict/nrww.inc(24): Including file '../../avr8\words/qdup.asm'
../../avr8\dict/nrww.inc(25): Including file '../../avr8\words/swap.asm'
../../avr8\dict/nrww.inc(26): Including file '../../avr8\words/over.asm'
../../avr8\dict/nrww.inc(27): Including file '../../avr8\words/drop.asm'
../../avr8\dict/nrww.inc(28): Including file '../../avr8\words/rot.asm'
../../avr8\dict/nrww.inc(29): Including file '../../avr8\words/nip.asm'
../../avr8\dict/nrww.inc(31): Including file '../../avr8\words/r_from.asm'
../../avr8\dict/nrww.inc(32): Including file '../../avr8\words/to_r.asm'
../../avr8\dict/nrww.inc(33): Including file '../../avr8\words/r_fetch.asm'
../../avr8\dict/nrww.inc(36): Including file '../../common\words/not-equal.asm'
../../avr8\dict/nrww.inc(37): Including file '../../avr8\words/equalzero.asm'
../../avr8\dict/nrww.inc(38): Including file '../../avr8\words/lesszero.asm'
../../avr8\dict/nrww.inc(39): Including file '../../avr8\words/greaterzero.asm'
../../avr8\dict/nrww.inc(40): Including file '../../avr8\words/d-greaterzero.asm'
../../avr8\dict/nrww.inc(41): Including file '../../avr8\words/d-lesszero.asm'
../../avr8\dict/nrww.inc(43): Including file '../../avr8\words/true.asm'
../../avr8\dict/nrww.inc(44): Including file '../../avr8\words/zero.asm'
../../avr8\dict/nrww.inc(45): Including file '../../avr8\words/uless.asm'
../../avr8\dict/nrww.inc(46): Including file '../../common\words/u-greater.asm'
../../avr8\dict/nrww.inc(47): Including file '../../avr8\words/less.asm'
../../avr8\dict/nrww.inc(48): Including file '../../avr8\words/greater.asm'
../../avr8\dict/nrww.inc(50): Including file '../../avr8\words/log2.asm'
../../avr8\dict/nrww.inc(51): Including file '../../avr8\words/minus.asm'
../../avr8\dict/nrww.inc(52): Including file '../../avr8\words/plus.asm'
../../avr8\dict/nrww.inc(53): Including file '../../avr8\words/mstar.asm'
../../avr8\dict/nrww.inc(54): Including file '../../avr8\words/umslashmod.asm'
../../avr8\dict/nrww.inc(55): Including file '../../avr8\words/umstar.asm'
../../avr8\dict/nrww.inc(57): Including file '../../avr8\words/invert.asm'
../../avr8\dict/nrww.inc(58): Including file '../../avr8\words/2slash.asm'
../../avr8\dict/nrww.inc(59): Including file '../../avr8\words/2star.asm'
../../avr8\dict/nrww.inc(60): Including file '../../avr8\words/and.asm'
../../avr8\dict/nrww.inc(61): Including file '../../avr8\words/or.asm'
../../avr8\dict/nrww.inc(62): Including file '../../avr8\words/xor.asm'
../../avr8\dict/nrww.inc(64): Including file '../../avr8\words/1plus.asm'
../../avr8\dict/nrww.inc(65): Including file '../../avr8\words/1minus.asm'
../../avr8\dict/nrww.inc(66): Including file '../../avr8\words/lshift.asm'
../../avr8\dict/nrww.inc(67): Including file '../../avr8\words/rshift.asm'
../../avr8\dict/nrww.inc(68): Including file '../../avr8\words/plusstore.asm'
../../avr8\dict/nrww.inc(70): Including file '../../avr8\words/rpfetch.asm'
../../avr8\dict/nrww.inc(71): Including file '../../avr8\words/rpstore.asm'
../../avr8\dict/nrww.inc(72): Including file '../../avr8\words/spfetch.asm'
../../avr8\dict/nrww.inc(73): Including file '../../avr8\words/spstore.asm'
../../avr8\dict/nrww.inc(75): Including file '../../avr8\words/dodo.asm'
../../avr8\dict/nrww.inc(76): Including file '../../avr8\words/i.asm'
../../avr8\dict/nrww.inc(77): Including file '../../avr8\words/doplusloop.asm'
../../avr8\dict/nrww.inc(78): Including file '../../avr8\words/doloop.asm'
../../avr8\dict/nrww.inc(79): Including file '../../avr8\words/unloop.asm'
../../avr8\dict/nrww.inc(83): Including file '../../avr8\words/cmove_g.asm'
../../avr8\dict/nrww.inc(84): Including file '../../avr8\words/byteswap.asm'
../../avr8\dict/nrww.inc(85): Including file '../../avr8\words/up.asm'
../../avr8\dict/nrww.inc(86): Including file '../../avr8\words/1ms.asm'
../../avr8\dict/nrww.inc(87): Including file '../../avr8\words/2to_r.asm'
../../avr8\dict/nrww.inc(88): Including file '../../avr8\words/2r_from.asm'
../../avr8\dict/nrww.inc(90): Including file '../../avr8\words/store-e.asm'
../../avr8\dict/nrww.inc(91): Including file '../../avr8\words/fetch-e.asm'
../../avr8\dict/nrww.inc(92): Including file '../../avr8\words/store-i.asm'
../../avr8\dict/nrww.inc(96): Including file '../../avr8\words/store-i_nrww.asm'
../../avr8\dict/nrww.inc(98): Including file '../../avr8\words/fetch-i.asm'
../../avr8\dict/nrww.inc(103): Including file '../../avr8\dict/core_4k.inc'
../../avr8\dict/core_4k.inc(3): Including file '../../avr8\words/n_to_r.asm'
../../avr8\dict/core_4k.inc(4): Including file '../../avr8\words/n_r_from.asm'
../../avr8\dict/core_4k.inc(5): Including file '../../avr8\words/d-2star.asm'
../../avr8\dict/core_4k.inc(6): Including file '../../avr8\words/d-2slash.asm'
../../avr8\dict/core_4k.inc(7): Including file '../../avr8\words/d-plus.asm'
../../avr8\dict/core_4k.inc(8): Including file '../../avr8\words/d-minus.asm'
../../avr8\dict/core_4k.inc(9): Including file '../../avr8\words/d-invert.asm'
../../avr8\dict/core_4k.inc(10): Including file '../../avr8\words/slashmod.asm'
../../avr8\dict/core_4k.inc(11): Including file '../../avr8\words/abs.asm'
../../avr8\dict/core_4k.inc(12): Including file '../../common\words/pick.asm'
../../avr8\dict/core_4k.inc(13): Including file '../../avr8\words/cellplus.asm'
../../avr8\dict/core_4k.inc(14): Including file '../../avr8\dict/interrupt.inc'
../../avr8\dict/interrupt.inc(2): Including file '../../avr8\words/int-on.asm'
../../avr8\dict/interrupt.inc(3): Including file '../../avr8\words/int-off.asm'
../../avr8\dict/interrupt.inc(4): Including file '../../avr8\words/int-store.asm'
../../avr8\dict/interrupt.inc(5): Including file '../../avr8\words/int-fetch.asm'
../../avr8\dict/interrupt.inc(6): Including file '../../avr8\words/int-trap.asm'
../../avr8\dict/interrupt.inc(8): Including file '../../avr8\words/isr-exec.asm'
../../avr8\dict/interrupt.inc(9): Including file '../../avr8\words/isr-end.asm'
../../avr8\dict/core_4k.inc(17): Including file '../../common\words/prompt-ok.asm'
../../avr8\dict/core_4k.inc(18): Including file '../../common\words/prompt-ready.asm'
../../avr8\dict/core_4k.inc(19): Including file '../../common\words/prompt-error.asm'
../../avr8\dict/core_4k.inc(21): Including file '../../common\words/quit.asm'
../../avr8\dict/core_4k.inc(22): Including file '../../avr8\words/pause.asm'
../../avr8\dict/core_4k.inc(23): Including file '../../avr8\words/cold.asm'
../../avr8\dict/core_4k.inc(24): Including file '../../avr8\words/warm.asm'
../../avr8\dict/core_4k.inc(26): Including file '../../common\words/handler.asm'
../../avr8\dict/core_4k.inc(27): Including file '../../common\words/catch.asm'
../../avr8\dict/core_4k.inc(28): Including file '../../common\words/throw.asm'
../../avr8\dict/core_4k.inc(31): Including file '../../avr8\words/edefer-fetch.asm'
../../avr8\dict/core_4k.inc(32): Including file '../../avr8\words/edefer-store.asm'
../../avr8\dict/core_4k.inc(33): Including file '../../avr8\words/rdefer-fetch.asm'
../../avr8\dict/core_4k.inc(34): Including file '../../avr8\words/rdefer-store.asm'
../../avr8\dict/core_4k.inc(35): Including file '../../avr8\words/udefer-fetch.asm'
../../avr8\dict/core_4k.inc(36): Including file '../../avr8\words/udefer-store.asm'
../../avr8\dict/core_4k.inc(37): Including file '../../avr8\words/defer-store.asm'
../../avr8\dict/core_4k.inc(38): Including file '../../avr8\words/defer-fetch.asm'
../../avr8\dict/core_4k.inc(39): Including file '../../avr8\words/do-defer.asm'
../../avr8\dict/core_4k.inc(41): Including file '../../avr8\words/d-equal.asm'
../../avr8\dict/core_4k.inc(42): Including file '../../common\words/u-dot.asm'
../../avr8\dict/core_4k.inc(43): Including file '../../common\words/u-dot-r.asm'
../../avr8\dict/core_4k.inc(46): Including file '../../avr8\words/uslashmod.asm'
../../avr8\dict/core_4k.inc(47): Including file '../../avr8\words/negate.asm'
../../avr8\dict/core_4k.inc(48): Including file '../../common\words/slash.asm'
../../avr8\dict/core_4k.inc(49): Including file '../../common\words/mod.asm'
../../avr8\dict/core_4k.inc(51): Including file '../../common\words/min.asm'
../../avr8\dict/core_4k.inc(52): Including file '../../common\words/max.asm'
../../avr8\dict/core_4k.inc(53): Including file '../../common\words/within.asm'
../../avr8\dict/core_4k.inc(55): Including file '../../common\words/show-wordlist.asm'
../../avr8\dict/core_4k.inc(56): Including file '../../avr8\words/words.asm'
../../avr8\dict/core_4k.inc(58): Including file '../../common\words/dot-quote.asm'
../../avr8\dict/core_4k.inc(59): Including file '../../common\words/squote.asm'
../../avr8\dict/core_4k.inc(60): Including file '../../avr8\words/fill.asm'
../../avr8\dict/core_4k.inc(62): Including file '../../common\words/f_cpu.asm'
../../avr8\dict/core_4k.inc(63): Including file '../../avr8\words/state.asm'
../../avr8\dict/core_4k.inc(64): Including file '../../common\words/base.asm'
../../avr8\dict/core_4k.inc(66): Including file '../../avr8\words/cells.asm'
../../avr8\dict/core_4k.inc(68): Including file '../../common\words/2dup.asm'
../../avr8\dict/core_4k.inc(69): Including file '../../common\words/2drop.asm'
../../avr8\dict/core_4k.inc(70): Including file '../../common\words/tuck.asm'
../../avr8\dict/core_4k.inc(72): Including file '../../common\words/to-in.asm'
../../avr8\dict/core_4k.inc(73): Including file '../../avr8\words/sharptib.asm'
../../avr8\dict/core_4k.inc(74): Including file '../../avr8\words/pad.asm'
../../avr8\dict/core_4k.inc(75): Including file '../../avr8\words/emit.asm'
../../avr8\dict/core_4k.inc(76): Including file '../../avr8\words/emitq.asm'
../../avr8\dict/core_4k.inc(77): Including file '../../avr8\words/key.asm'
../../avr8\dict/core_4k.inc(78): Including file '../../avr8\words/keyq.asm'
../../avr8\dict/core_4k.inc(80): Including file '../../avr8\words/dp.asm'
../../avr8\dict/core_4k.inc(81): Including file '../../avr8\words/ehere.asm'
../../avr8\dict/core_4k.inc(82): Including file '../../avr8\words/here.asm'
../../avr8\dict/core_4k.inc(83): Including file '../../avr8\words/allot.asm'
../../avr8\dict/core_4k.inc(85): Including file '../../common\words/bin.asm'
../../avr8\dict/core_4k.inc(86): Including file '../../common\words/decimal.asm'
../../avr8\dict/core_4k.inc(87): Including file '../../common\words/hex.asm'
../../avr8\dict/core_4k.inc(88): Including file '../../common\words/bl.asm'
../../avr8\dict/core_4k.inc(90): Including file '../../avr8\words/turnkey.asm'
../../avr8\dict/core_4k.inc(91): Including file '../../common\words/to-upper.asm'
../../avr8\dict/core_4k.inc(92): Including file '../../common\words/to-lower.asm'
../../avr8\dict/core_4k.inc(94): Including file '../../common\words/q-stack.asm'
../../avr8\dict/core_4k.inc(95): Including file '../../common\words/bounds.asm'
../../avr8\dict/core_4k.inc(96): Including file '../../common\words/cr.asm'
../../avr8\dict/core_4k.inc(97): Including file '../../common\words/space.asm'
../../avr8\dict/core_4k.inc(98): Including file '../../common\words/spaces.asm'
../../avr8\dict/core_4k.inc(99): Including file '../../common\words/s-to-d.asm'
../../avr8\dict/nrww.inc(111): Including file '../../avr8\words/2literal.asm'
../../avr8\dict/nrww.inc(112): Including file '../../avr8\words/equal.asm'
../../avr8\dict/nrww.inc(113): Including file '../../common\words/num-constants.asm'
../../avr8\amforth.asm(25): Including file 'dict_appl_core.inc'
../../avr8\amforth.asm(36): Including file '../../avr8\amforth-eeprom.inc'
                 
                 
                 ; file see ../template/template.asm. You may want to
                 ; copy that file to this one and edit it afterwards.
                 
                 .include "preamble.inc"
                 
                 .include "macros.asm"
                 
                 .set DICT_COMPILER2 = 0 ;
                 .set cpu_msp430 = 0
                 .set cpu_avr8   = 1
                 
                 .include "user.inc"
                 
                 ; 
                 
                 ; used by the multitasker
                 .set USER_STATE    = 0
                 .set USER_FOLLOWER = 2
                 
                 ; stackpointer, used by mulitasker
                 .set USER_RP      = 4
                 .set USER_SP0     = 6
                 .set USER_SP      = 8
                 
                 ; excpection handling
                 .set USER_HANDLER = 10
                 
                 ; numeric IO
                 .set USER_BASE  = 12
                 
                 ; character IO 
                 .set USER_EMIT  = 14
                 .set USER_EMITQ = 16
                 .set USER_KEY   = 18
                 .set USER_KEYQ  = 20
                 
                 .set USER_SOURCE  = 22
                 .set USER_TO_IN   = 24
                 .set USER_REFILL  = 26
                 
                 .set SYSUSERSIZE = 28
                 ; 
                 
                   .def zerol = r2
                   .def zeroh = r3
                   .def upl = r4
                   .def uph = r5
                 
                   .def al  = r6
                   .def ah  = r7
                   .def bl  = r8
                   .def bh  = r9
                 
                 ; internal
                   .def mcu_boot      = r10
                   .def erase_counter = r11
                 
                   .def temp4 = r14
                   .def temp5 = r15
                 
                   .def temp0 = r16
                   .def temp1 = r17
                   .def temp2 = r18
                   .def temp3 = r19
                 
                   .def temp6 = r20
                   .def temp7 = r21
                 
                   .def tosl = r24
                   .def tosh = r25
                 
                   .def wl = r22
                   .def wh = r23
                 
                 .macro loadtos
                     ld tosl, Y+
                     ld tosh, Y+
                 .endmacro
                 
                 .macro savetos
                     st -Y, tosh
                     st -Y, tosl
                 .endmacro
                 
                 .macro in_
                 .if (@1 < $40)
                   in @0,@1
                 .else
                   lds @0,@1
                 .endif
                 .endmacro
                 
                 .macro out_
                 .if (@0 < $40)
                   out @0,@1
                 .else
                   sts @0,@1
                 .endif
                 .endmacro
                 
                 .macro sbi_
                 .if (@0 < $40)
                   sbi @0,@1
                 .else
                   in_ @2,@0
                   ori @2,exp2(@1)
                   out_ @0,@2
                 .endif
                 .endmacro
                 
                 .macro cbi_
                 .if (@0 < $40)
                   cbi @0,@1
                 .else
                   in_ @2,@0
                   andi @2,~(exp2(@1))
                   out_ @0,@2
                 .endif
                 .endmacro
                 
                 .macro jmp_
                 	; a more flexible macro
                     .ifdef @0
                     .if (@0-pc > 2040) || (pc-@0>2040)
                 	jmp @0
                 	.else
                 	rjmp @0
                 	.endif
                 	.else
                 	jmp @0
                 	.endif
                 .endmacro
                 .macro call_
                 	; a more flexible macro
                     .ifdef @0
                     .if (@0-pc > 2040) || (pc-@0>2040)
                 	call @0
                 	.else
                 	rcall @0
                 	.endif
                 	.else
                 	call @0
                 	.endif
                 .endmacro
                 
                 ;               F_CPU
                 ;    µsec   16000000   14745600    8000000  1000000
                 ;    1            16      14,74          8        1
                 ;    10          160     147,45         80       10
                 ;    100        1600    1474,56        800      100
                 ;    1000      16000   14745,6        8000     1000
                 ;
                 ; cycles = µsec * f_cpu / 1e6
                 ; n_loops=cycles/5
                 ;
                 ;     cycles already used will be subtracted from the delay
                 ;     the waittime resolution is 1 cycle (delay from exact to +1 cycle)
                 ;     the maximum delay at 20MHz (50ns/clock) is 38350ns
                 ;     waitcount register must specify an immediate register
                 ;
                 ; busy waits a specfied amount of microseconds
                 .macro   delay
                       .set cycles = ( ( @0 * F_CPU ) / 1000000 )
                       .if (cycles > ( 256 * 255 * 4 + 2))
                         .error "MACRO delay - too many cycles to burn"
                       .else
                         .if (cycles > 6)
                           .set  loop_cycles = (cycles / 4)      
                           ldi   zl,low(loop_cycles)
                           ldi   zh,high(loop_cycles)
                           sbiw  Z, 1
                           brne  pc-1
                           .set  cycles = (cycles - (loop_cycles * 4))
                         .endif
                         .if (cycles > 0)
                           .if   (cycles & 4)
                             rjmp  pc+1
                             rjmp  pc+1
                           .endif
                           .if   (cycles & 2)
                             rjmp  pc+1
                           .endif
                           .if   (cycles & 1)
                             nop
                           .endif
                         .endif
                       .endif
                 .endmacro
                 
                 ; portability macros, they come from the msp430 branches
                 
                 .macro DEST
                     .dw @0
                 .endm
                 
                 ; controller specific file selected via include
                 ; directory definition when calling the assembler (-I)
                 .include "device.asm"
                 
                 ; generated automatically, do not edit
                 
                 .list
                 
                 .equ ramstart =  256
                 .equ CELLSIZE = 2
                 .macro readflashcell
                 	lsl zl
                 	rol zh
                 	lpm @0, Z+
                 	lpm @1, Z+
                 .endmacro
                 .macro writeflashcell
                 	lsl zl
                 	rol zh
                 .endmacro
                 .set WANT_USART0 = 0
                 .set WANT_TWI = 0
                 .set WANT_TIMER_COUNTER_1 = 0
                 .set WANT_TIMER_COUNTER_2 = 0
                 .set WANT_AD_CONVERTER = 0
                 .set WANT_ANALOG_COMPARATOR = 0
                 .set WANT_PORTB = 0
                 .set WANT_PORTC = 0
                 .set WANT_PORTD = 0
                 .set WANT_TIMER_COUNTER_0 = 0
                 .set WANT_EXTERNAL_INTERRUPT = 0
                 .set WANT_SPI = 0
                 .set WANT_WATCHDOG = 0
                 .set WANT_CPU = 0
                 .set WANT_EEPROM = 0
                 .equ intvecsize = 2 ; please verify; flash size: 32768 bytes
                 .equ pclen = 2 ; please verify
                 .overlap
                 .org 2
000002 d114      	 rcall isr ; External Interrupt Request 0
                 .org 4
000004 d112      	 rcall isr ; External Interrupt Request 1
                 .org 6
000006 d110      	 rcall isr ; Pin Change Interrupt Request 0
                 .org 8
000008 d10e      	 rcall isr ; Pin Change Interrupt Request 0
                 .org 10
00000a d10c      	 rcall isr ; Pin Change Interrupt Request 1
                 .org 12
00000c d10a      	 rcall isr ; Watchdog Time-out Interrupt
                 .org 14
00000e d108      	 rcall isr ; Timer/Counter2 Compare Match A
                 .org 16
000010 d106      	 rcall isr ; Timer/Counter2 Compare Match A
                 .org 18
000012 d104      	 rcall isr ; Timer/Counter2 Overflow
                 .org 20
000014 d102      	 rcall isr ; Timer/Counter1 Capture Event
                 .org 22
000016 d100      	 rcall isr ; Timer/Counter1 Compare Match A
                 .org 24
000018 d0fe      	 rcall isr ; Timer/Counter1 Compare Match B
                 .org 26
00001a d0fc      	 rcall isr ; Timer/Counter1 Overflow
                 .org 28
00001c d0fa      	 rcall isr ; TimerCounter0 Compare Match A
                 .org 30
00001e d0f8      	 rcall isr ; TimerCounter0 Compare Match B
                 .org 32
000020 d0f6      	 rcall isr ; Timer/Couner0 Overflow
                 .org 34
000022 d0f4      	 rcall isr ; SPI Serial Transfer Complete
                 .org 36
000024 d0f2      	 rcall isr ; USART Rx Complete
                 .org 38
000026 d0f0      	 rcall isr ; USART, Data Register Empty
                 .org 40
000028 d0ee      	 rcall isr ; USART Tx Complete
                 .org 42
00002a d0ec      	 rcall isr ; ADC Conversion Complete
                 .org 44
00002c d0ea      	 rcall isr ; EEPROM Ready
                 .org 46
00002e d0e8      	 rcall isr ; Analog Comparator
                 .org 48
000030 d0e6      	 rcall isr ; Two-wire Serial Interface
                 .org 50
000032 d0e4      	 rcall isr ; Store Program Memory Read
                 .equ INTVECTORS = 26
                 .nooverlap
                 
                 ; compatability layer (maybe empty)
                 .equ SPMEN = SELFPRGEN
                 
                 ; controller data area, environment query mcu-info
                 mcu_info:
                 mcu_ramsize:
000033 0800      	.dw 2048
                 mcu_eepromsize:
000034 0400      	.dw 1024
                 mcu_maxdp:
000035 7000      	.dw 28672 
                 mcu_numints:
000036 001a      	.dw 26
                 mcu_name:
000037 000a      	.dw 10
000038 5441
000039 656d
00003a 6167
00003b 3233
00003c 5038      	.db "ATmega328P"
                 .set codestart=pc
                 
                 ; some defaults, change them in your application master file
                 ; see template.asm for an example
                 
                 .set AMFORTH_RO_SEG = NRWW_START_ADDR
                 
                 ; receiving is asynchron, so an interrupt queue is useful.
                 .set WANT_ISR_RX = 1
                 
                 ; case insensitve dictionary lookup.
                 .set WANT_IGNORECASE = 0
                 
                 ; map all memories to one address space. Details in the
                 ; technical guide
                 .set WANT_UNIFIED = 0
                 
                 ; terminal input buffer
                 .set TIBSIZE  = 90    ; ANS94 needs at least 80 characters per line
                 
                 ; USER variables *in addition* to system ones
                 .set APPUSERSIZE = 10  ; size of application specific user area in bytes
                 
                 ; addresses of various data segments
                 .set rstackstart = RAMEND      ; start address of return stack, grows downward
                 .set stackstart  = RAMEND - 80 ; start address of data stack, grows downward
                 ; change only if you know what to you do
                 .set NUMWORDLISTS = 8 ; number of word lists in the searh order, at least 8
                 .set NUMRECOGNIZERS = 4 ; total number of recognizers, two are always used.
                 
                 ; 10 per mille (1 per cent) is ok.
                 .set BAUD = 38400
                 .set BAUD_MAXERROR = 10
                 
                 ; Dictionary setup
                 .set VE_HEAD = $0000
                 .set VE_ENVHEAD = $0000
                 
                 
                 .equ F_CPU = 16000000
                 .include "drivers/usart_0.asm"
                 
                   .equ BAUDRATE_HIGH = UBRR0H
                   .equ USART_C = UCSR0C
                   .equ USART_B = UCSR0B
                   .equ USART_A = UCSR0A
                   .equ USART_DATA = UDR0
                   .ifndef URXCaddr
                   .endif
                 
                 .equ bm_USART_RXRD = 1 << RXC0
                 .equ bm_USART_TXRD = 1 << UDRE0
                 .equ bm_ENABLE_TX  = 1 << TXEN0
                 .equ bm_ENABLE_RX  = 1 << RXEN0
                 .equ bm_ENABLE_INT_RX = 1<<RXCIE0
                 .equ bm_ENABLE_INT_TX = 1<<UDRIE0
                 
                 .equ bm_USARTC_en   = 0
                 .equ bm_ASYNC       = 0 << 6
                 .equ bm_SYNC        = 1 << 6
                 .equ bm_NO_PARITY   = 0 << 4
                 .equ bm_EVEN_PARITY = 2 << 4
                 .equ bm_ODD_PARITY  = 3 << 4
                 .equ bm_1STOPBIT    = 0 << 3
                 .equ bm_2STOPBIT    = 1 << 3
                 .equ bm_5BIT        = 0 << 1
                 .equ bm_6BIT        = 1 << 1
                 .equ bm_7BIT        = 2 << 1
                 .equ bm_8BIT        = 3 << 1
                 
                 .include "drivers/usart_common.asm"
                 
                 .set USART_C_VALUE = bm_ASYNC | bm_NO_PARITY | bm_1STOPBIT | bm_8BIT
                 .if WANT_ISR_RX == 1
                   .set USART_B_VALUE = bm_ENABLE_TX | bm_ENABLE_RX | bm_ENABLE_INT_RX
                   .include "drivers/usart-isr-rx.asm"
                 
                 
                 ; sizes have to be powers of 2!
                 .equ usart_rx_size = $10
                 .equ usart_rx_mask = usart_rx_size - 1
                 .dseg
000100           usart_rx_data: .byte usart_rx_size+2
000112           usart_rx_in: .byte 2
000114           usart_rx_out: .byte 2
                 
                 .cseg
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 ; forth code:
                 ; : rx-isr USART_DATA c@
                 ;    usart_rx_data usart_rx_in c@ dup >r
                 ;    + !
                 ;    r> 1+ usart_rx_mask and usart_rx_in c!
                 ; ;
                 ; setup with
                 ; ' rx-isr URXCaddr int!
                 usart_rx_isr:
00003d 93af        push xl
00003e b7af        in xl, SREG
00003f 93af        push xl
000040 93bf        push xh
000041 93ef        push zl
000042 93ff        push zh
                 
000043 91b0 00c6   lds xh, USART_DATA
                 usart_rx_store:
000045 91a0 0112   lds xl, usart_rx_in
000047 e0e0        ldi zl, low(usart_rx_data)
000048 e0f1        ldi zh, high(usart_rx_data)
000049 0fea        add zl, xl
00004a 1df3        adc zh, zeroh
00004b 83b0        st Z, xh
                 
00004c 95a3        inc xl
00004d 70af        andi xl,usart_rx_mask
                 
00004e 93a0 0112   sts usart_rx_in, xl
                 
                 usart_rx_isr_finish:
000050 91ff        pop zh
000051 91ef        pop zl
000052 91bf        pop xh
000053 91af        pop xl
000054 bfaf        out SREG, xl
000055 91af        pop xl
000056 9518        reti
                 
                 .set usartpc = pc
                 .org URXCaddr
000024 c018        jmp_ usart_rx_isr
                 .org usartpc
                 
                 
                 ; ( -- ) Hardware Access
                 ; R( --)
                 ; initialize usart
                 ;VE_USART_INIT_RX:
                 ;  .dw $ff06
                 ;  .db "+usart"
                 ;  .dw VE_HEAD
                 ;  .set VE_HEAD = VE_USART_INIT_RX
                 XT_USART_INIT_RX_ISR:
000057 3800        .dw DO_COLON
                 PFA_USART_INIT_RX_ISR:          ; ( -- )
000058 394e        .dw XT_ZERO
000059 3837        .dw XT_DOLITERAL
00005a 0112        .dw usart_rx_in
00005b 3887        .dw XT_CSTORE
00005c 394e        .dw XT_ZERO
00005d 3837        .dw XT_DOLITERAL
00005e 0114        .dw usart_rx_out
00005f 3887        .dw XT_CSTORE
                 
000060 381a        .dw XT_EXIT
                 
                 ; ( -- c)
                 ; MCU
                 ; get 1 character from input queue, wait if needed using interrupt driver
                 VE_RX_ISR:
000061 ff06          .dw $ff06
000062 7872
000063 692d
000064 7273          .db "rx-isr"
000065 0000          .dw VE_HEAD
                     .set VE_HEAD = VE_RX_ISR
                 XT_RX_ISR:
000066 3800          .dw DO_COLON
                 PFA_RX_ISR:
000067 0080        .dw XT_RXQ_ISR
000068 3830        .dw XT_DOCONDBRANCH
000069 0067        .dw PFA_RX_ISR
00006a 3837        .dw XT_DOLITERAL
00006b 0114        .dw usart_rx_out
00006c 3892        .dw XT_CFETCH
00006d 38ab        .dw XT_DUP
00006e 3a29        .dw XT_1PLUS
00006f 3837        .dw XT_DOLITERAL
000070 000f        .dw usart_rx_mask
000071 3a0d        .dw XT_AND
000072 3837        .dw XT_DOLITERAL
000073 0114        .dw usart_rx_out
000074 3887        .dw XT_CSTORE
000075 3837        .dw XT_DOLITERAL
000076 0100        .dw usart_rx_data
000077 3997        .dw XT_PLUS
000078 3892        .dw XT_CFETCH
000079 381a        .dw XT_EXIT
                 
                 ; ( -- f)  
                 ; MCU
                 ; check if unread characters are in the input queue using interrupt driver
                 VE_RXQ_ISR:
00007a ff07          .dw $ff07
00007b 7872
00007c 2d3f
00007d 7369
00007e 0072          .db "rx?-isr",0
00007f 0061          .dw VE_HEAD
                     .set VE_HEAD = VE_RXQ_ISR
                 XT_RXQ_ISR:
000080 3800          .dw DO_COLON
                 PFA_RXQ_ISR:
000081 3d11        .dw XT_PAUSE
000082 3837        .dw XT_DOLITERAL
000083 0114        .dw usart_rx_out
000084 3892        .dw XT_CFETCH
000085 3837        .dw XT_DOLITERAL
000086 0112        .dw usart_rx_in
000087 3892        .dw XT_CFETCH
000088 390d        .dw XT_NOTEQUAL
000089 381a        .dw XT_EXIT
                   .set XT_RX  = XT_RX_ISR
                   .set XT_RXQ = XT_RXQ_ISR
                   .set XT_USART_INIT_RX = XT_USART_INIT_RX_ISR
                 .else
                 .endif
                 
                 .include "words/usart-tx-poll.asm"
                 
                 ; MCU
                 ; check availability and send one character to the terminal using register poll
                 VE_TX_POLL:
00008a ff07          .dw $ff07
00008b 7874
00008c 702d
00008d 6c6f
00008e 006c          .db "tx-poll",0
00008f 007a          .dw VE_HEAD
                     .set VE_HEAD = VE_TX_POLL
                 XT_TX_POLL:
000090 3800          .dw DO_COLON
                 PFA_TX_POLL:
                   ; wait for data ready
000091 009e        .dw XT_TXQ_POLL
000092 3830        .dw XT_DOCONDBRANCH
000093 0091        .dw PFA_TX_POLL
                   ; send to usart
000094 3837        .dw XT_DOLITERAL
000095 00c6        .dw USART_DATA
000096 3887        .dw XT_CSTORE
000097 381a        .dw XT_EXIT
                 
                 ; ( -- f) MCU
                 ; MCU
                 ; check if a character can be send using register poll
                 VE_TXQ_POLL:
000098 ff08          .dw $ff08
000099 7874
00009a 2d3f
00009b 6f70
00009c 6c6c          .db "tx?-poll"
00009d 008a          .dw VE_HEAD
                     .set VE_HEAD = VE_TXQ_POLL
                 XT_TXQ_POLL:
00009e 3800          .dw DO_COLON
                 PFA_TXQ_POLL:
00009f 3d11        .dw XT_PAUSE
0000a0 3837        .dw XT_DOLITERAL
0000a1 00c0        .dw USART_A
0000a2 3892        .dw XT_CFETCH
0000a3 3837        .dw XT_DOLITERAL
0000a4 0020        .dw bm_USART_TXRD
0000a5 3a0d        .dw XT_AND
0000a6 381a        .dw XT_EXIT
                 .set XT_TX  = XT_TX_POLL
                 .set XT_TXQ = XT_TXQ_POLL
                 .set XT_USART_INIT_TX = 0
                 
                 .include "words/ubrr.asm"
                 
                 ; MCU
                 ; returns usart UBRR settings
                 VE_UBRR:
0000a7 ff04        .dw $ff04
0000a8 6275
0000a9 7272        .db "ubrr"
0000aa 0098        .dw VE_HEAD
                   .set VE_HEAD = VE_UBRR
                 XT_UBRR:
0000ab 3869        .dw PFA_DOVALUE1
                 PFA_UBRR:          ; ( -- )
0000ac 0086        .dw EE_UBRRVAL
0000ad 3d7a        .dw XT_EDEFERFETCH
0000ae 3d84        .dw XT_EDEFERSTORE
                 .include "words/usart.asm"
                 
                 ; MCU
                 ; initialize usart
                 VE_USART:
0000af ff06        .dw $ff06
0000b0 752b
0000b1 6173
0000b2 7472        .db "+usart"
0000b3 00a7        .dw VE_HEAD
                   .set VE_HEAD = VE_USART
                 XT_USART:
0000b4 3800        .dw DO_COLON
                 PFA_USART:          ; ( -- )
                 
0000b5 3837        .dw XT_DOLITERAL
0000b6 0098        .dw USART_B_VALUE
0000b7 3837        .dw XT_DOLITERAL
0000b8 00c1        .dw USART_B
0000b9 3887        .dw XT_CSTORE
                 
0000ba 3837        .dw XT_DOLITERAL
0000bb 0006        .dw USART_C_VALUE
0000bc 3837        .dw XT_DOLITERAL
0000bd 00c2        .dw USART_C | bm_USARTC_en
0000be 3887        .dw XT_CSTORE
                 
0000bf 00ab        .dw XT_UBRR
0000c0 38ab        .dw XT_DUP
0000c1 3ae7        .dw XT_BYTESWAP
0000c2 3837        .dw XT_DOLITERAL
0000c3 00c5        .dw BAUDRATE_HIGH
0000c4 3887        .dw XT_CSTORE
0000c5 3837        .dw XT_DOLITERAL
0000c6 00c4        .dw BAUDRATE_LOW
0000c7 3887        .dw XT_CSTORE
                 .if XT_USART_INIT_RX!=0
0000c8 0057        .dw XT_USART_INIT_RX
                 .endif
                 .if XT_USART_INIT_TX!=0
                 .endif
                 
0000c9 381a        .dw XT_EXIT
                 
                 ; settings for 1wire interface, if desired
                 .equ OW_PORT=PORTB
                 .EQU OW_BIT=4
                 .include "drivers/1wire.asm"
                 
                 ;   B. J. Rodriguez (MSP 430)
                 ;   Matthias Trute (AVR Atmega)
                 ; COPYRIGHT
                 ;   (c) 2012 Bradford J. Rodriguez for the 430 code and API
                 
                 ;  adapted 430 assembly code to AVR
                 ;  wishlist: 
                 ;     use a configurable pin at runtime, compatible with bitnames.frt
                 ;     no external pull up, no external power supply for devices
                 ;     ???
                 ;
                 ;.EQU OW_BIT=4
                 ;.equ OW_PORT=PORTE
                 .set OW_DDR=(OW_PORT-1)
                 .set OW_PIN=(OW_DDR-1)
                 
                 ;****f* 1W.RESET
                 ; NAME
                 ;   1W.RESET
                 ; SYNOPSIS
                 ;   1W.RESET ( -- f )  Initialize 1-wire devices; return true if present
                 ; DESCRIPTION
                 ;   This configures the port pin used by the 1-wire interface, and then
                 ;   sends an "initialize" sequence to the 1-wire devices.  If any device
                 ;   is present, it will be detected.
                 ;
                 ;   Timing, per DS18B20 data sheet:
                 ;   a) Output "0" (drive output low) for >480 usec.
                 ;   b) Output "1" (let output float).
                 ;   c) After 15 to 60 usec, device will drive pin low for 60 to 240 usec.
                 ;      So, wait 75 usec and sample input.
                 ;   d) Leave output high (floating) for at least 480 usec.
                 ;******
                 ; ( -- f )
                 ; Hardware
                 ; Initialize 1-wire devices; return true if present
                 VE_OW_RESET:
0000ca ff08          .dw $ff08
0000cb 7731
0000cc 722e
0000cd 7365
0000ce 7465          .db "1w.reset"
0000cf 00af          .dw VE_HEAD
                     .set VE_HEAD = VE_OW_RESET
                 XT_OW_RESET:
0000d0 00d1          .dw PFA_OW_RESET
                 PFA_OW_RESET:
0000d1 939a
0000d2 938a          savetos
0000d3 2799          clr tosh
                     ; setup to output
0000d4 9a24          sbi OW_DDR, OW_BIT
                     ; Pull output low
0000d5 982c          cbi OW_PORT, OW_BIT
                     ; Delay >480 usec        
0000d6 e8e0
0000d7 e0f7
0000d8 9731
0000d9 f7f1          DELAY   480
                     ; Critical timing period, disable interrupts.
0000da b71f          in temp1, SREG
0000db 94f8          cli
                     ; Pull output high
0000dc 9a2c          sbi OW_PORT, OW_BIT
                     ; make pin input, sends "1"
0000dd 9824          cbi OW_DDR, OW_BIT 
0000de e0e0
0000df e0f1
0000e0 9731
0000e1 f7f1          DELAY   64 ; delayB
                     ; Sample input pin, set TOS if input is zero
0000e2 b183          in tosl, OW_PIN
0000e3 ff84          sbrs tosl, OW_BIT
0000e4 ef9f          ser  tosh
                     ; End critical timing period, enable interrupts
0000e5 bf1f          out SREG, temp1
                     ; release bus
0000e6 9824          cbi OW_DDR, OW_BIT
0000e7 982c          cbi OW_PORT, OW_BIT
                 
                     ; Delay rest of 480 usec 
0000e8 e8e0
0000e9 e0f6
0000ea 9731
0000eb f7f1          DELAY   416
                     ; we now have the result flag in TOS        
0000ec 2f89          mov tosl, tosh
0000ed 940c 3804     jmp_ DO_NEXT
                     
                 ;****f* 1W.SLOT
                 ; NAME
                 ;   1W.SLOT
                 ; SYNOPSIS
                 ;   1W.SLOT ( c -- c' ) Write and read one bit to/from 1-wire.
                 ; DESCRIPTION
                 ;   The "touch byte" function is described in Dallas App Note 74.
                 ;   It outputs a byte to the 1-wire pin, LSB first, and reads back
                 ;   the state of the 1-wire pin after a suitable delay.
                 ;   To read a byte, output $FF and read the reply data.
                 ;   To write a byte, output that byte and discard the reply.
                 ;
                 ;   This function performs one bit of the "touch" operation --
                 ;   one read/write "slot" in Dallas jargon.  Perform this eight
                 ;   times in a row to get the "touch byte" function.
                 ;
                 ; PARAMETERS
                 ;   The input parameter is xxxxxxxxbbbbbbbo where
                 ;   'xxxxxxxx' are don't cares,
                 ;   'bbbbbbb' are bits to be shifted down, and
                 ;   'o' is the bit to be output in the slot.  This must be 1
                 ;   to create a read slot.
                 ;
                 ;   The returned value is xxxxxxxxibbbbbbb where
                 ;   'xxxxxxxx' are not known (the input shifted down 1 position),
                 ;   'i' is the bit read during the slot.  This has no meaning
                 ;   if it was a write slot.
                 ;   'bbbbbbb' are the 7 input bits, shifted down one position.
                 ;
                 ;   This peculiar parameter usage allows OWTOUCH to be written as
                 ;     OWSLOT OWSLOT OWSLOT OWSLOT OWSLOT OWSLOT OWSLOT OWSLOT 
                 ;
                 ; NOTES 
                 ;   Interrupts are disabled during each bit.
                 
                 ;   Timing, per DS18B20 data sheet:
                 ;   a) Output "0" for start period.  (> 1 us, < 15 us, typ. 6 us*)
                 ;   b) Output data bit (0 or 1), open drain 
                 ;   c) After MS from start of cycle, sample input (15 to 60 us, typ. 25 us*)
                 ;   d) After write-0 period from start of cycle, output "1" (>60 us)
                 ;   e) After recovery period, loop or return. (> 1 us)
                 ;   For writes, DS18B20 samples input 15 to 60 usec from start of cycle.
                 ;   * "Typical" values are per App Note 132 for a 300m cable length.
                 
                 ;   ---------        -------------------------------
                 ;            \      /                        /
                 ;             ------------------------------- 
                 ;            a      b          c             d     e
                 ;            |  6us |   19us   |    35us     | 2us |
                 ;******
                 ; ( c -- c' )
                 ; Hardware
                 ; Write and read one bit to/from 1-wire.
                 VE_OW_SLOT:
0000ef ff07          .dw $ff07
0000f0 7731
0000f1 732e
0000f2 6f6c
0000f3 0074          .db "1w.slot",0
0000f4 00ca          .dw VE_HEAD
                     .set VE_HEAD = VE_OW_SLOT
                 XT_OW_SLOT:
0000f5 00f6          .dw PFA_OW_SLOT
                 PFA_OW_SLOT:
                     ; pull low
0000f6 9a24          sbi OW_DDR, OW_BIT
0000f7 982c          cbi OW_PORT, OW_BIT
                     ; disable interrupts
0000f8 b71f          in temp1, SREG
0000f9 94f8          cli
0000fa e1e8
0000fb e0f0
0000fc 9731
0000fd f7f1          DELAY   6 ; DELAY A
                     ; check bit
0000fe 9488          clc
0000ff 9587          ror tosl
000100 f410          brcc PFA_OW_SLOT0 ; a 0 keeps the bus low
                       ; release bus, a 1 is written
000101 9824            cbi OW_DDR, OW_BIT
000102 9a2c            sbi OW_PORT, OW_BIT
                 PFA_OW_SLOT0:
                     ; sample the input (no action required if zero)
000103 e2e4
000104 e0f0
000105 9731
000106 f7f1          DELAY 9   ; wait DELAY E to sample
000107 b103          in temp0, OW_PIN
000108 fd04          sbrc temp0, OW_BIT
000109 6880          ori tosl, $80
                 
00010a ecec
00010b e0f0
00010c 9731
00010d f7f1          DELAY   51 ; DELAY B
00010e 9824          cbi OW_DDR, OW_BIT
00010f 9a2c          sbi OW_PORT, OW_BIT ; release bus
000110 e0e8
000111 e0f0
000112 9731
000113 f7f1          delay 2
                     ; re-enable interrupts
000114 bf1f          out SREG, temp1
000115 940c 3804     jmp_ DO_NEXT
                 
                 .include "amforth.asm"
                 
                 ;;;;
                 ;;;; GPL V2 (only)
                 
                 .set AMFORTH_NRWW_SIZE=(FLASHEND-AMFORTH_RO_SEG)*2
                 
                 .set corepc = pc
                 .org $0000
000000 940c 3d1a   jmp_ PFA_COLD
                 
                 .org corepc
                 .include "drivers/generic-isr.asm"
                 
                 .dseg
000116           intcur: .byte 1
                 .eseg
000000           intvec: .byte INTVECTORS * CELLSIZE
                 .cseg
                 
                 ; interrupt routine gets called (again) by rcall! This gives the
                 ; address of the int-vector on the stack.
                 isr:
000117 920a          st -Y, r0
000118 b60f          in r0, SREG
000119 920a          st -Y, r0
                 .if (pclen==3)
                 .endif
00011a 900f          pop r0
00011b 900f          pop r0          ; = intnum * intvectorsize + 1 (address following the rcall)
00011c 940a          dec r0
                 .if intvecsize == 1 ;
                 .endif
00011d 9200 0116     sts intcur, r0
00011f 9009          ld r0, Y+
000120 be0f          out SREG, r0
000121 9009          ld r0, Y+
000122 9468          set ; set the interrupt flag for the inner interpreter
000123 9508          ret ; returns the interrupt, the rcall stack frame is removed!
                 
                 ; lower part of the dictionary
                 .include "dict/rww.inc"
                 
                 
                 ; Arithmetics
                 ; add a number to a double cell
                 VE_MPLUS:
000124 ff02          .dw $ff02
000125 2b6d          .db "m+"
000126 00ef          .dw VE_HEAD
                     .set VE_HEAD = VE_MPLUS
                 XT_MPLUS:
000127 3800          .dw DO_COLON
                 PFA_MPLUS:
000128 3faf          .dw XT_S2D
000129 3c04          .dw XT_DPLUS
00012a 381a          .dw XT_EXIT
                 .include "words/ud-star.asm"
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_UDSTAR:
00012b ff03          .dw $ff03
00012c 6475
../../common\words/ud-star.asm(9): warning: .cseg .db misalignment - padding zero byte
00012d 002a          .db "ud*"
00012e 0124          .dw VE_HEAD
                     .set VE_HEAD = VE_UDSTAR
                 XT_UDSTAR:
00012f 3800          .dw DO_COLON
                 PFA_UDSTAR:
                 
                 .endif
                 ;Z UD*      ud1 d2 -- ud3      32*16->32 multiply
                 ;   XT_DUP >R UM* DROP  XT_SWAP R> UM* ROT + ;
                 
000130 38ab
000131 38f9
000132 39da
000133 38d3              .DW XT_DUP,XT_TO_R,XT_UMSTAR,XT_DROP
000134 38be
000135 38f0
000136 39da
000137 38db
000138 3997
000139 381a              .DW XT_SWAP,XT_R_FROM,XT_UMSTAR,XT_ROT,XT_PLUS,XT_EXIT
                 .include "words/umax.asm"
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_UMAX:
00013a ff04          .dw $ff04
00013b 6d75
00013c 7861          .db "umax"
00013d 012b          .dw VE_HEAD
                     .set VE_HEAD = VE_UMAX
                 XT_UMAX:
00013e 3800          .dw DO_COLON
                 PFA_UMAX:
                 .endif
                 
00013f 3eaa
000140 3956              .DW XT_2DUP,XT_ULESS
000141 3830      	.dw XT_DOCONDBRANCH
000142 0144      	 DEST(UMAX1)
000143 38be              .DW XT_SWAP
000144 38d3      UMAX1:  .DW XT_DROP
000145 381a      	.dw XT_EXIT
                 .include "words/umin.asm"
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_UMIN:
000146 ff04          .dw $ff04
000147 6d75
000148 6e69          .db "umin"
000149 013a          .dw VE_HEAD
                     .set VE_HEAD = VE_UMIN
                 XT_UMIN:
00014a 3800          .dw DO_COLON
                 PFA_UMIN:
                 .endif
00014b 3eaa
00014c 3961              .DW XT_2DUP,XT_UGREATER
00014d 3830      	.dw XT_DOCONDBRANCH
00014e 0150      	DEST(UMIN1)
00014f 38be              .DW XT_SWAP
000150 38d3      UMIN1:  .DW XT_DROP
000151 381a      	.dw XT_EXIT
                 .include "words/immediate-q.asm"
                 
                 ; Tools
                 ; get count information out of a counted string in flash
                 ;VE_IMMEDIATEQ:
                 ;    .dw $ff06
                 ;    .db "immediate?"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_IMMEDIATEQ
                 XT_IMMEDIATEQ:
000152 3800          .dw DO_COLON
                 PFA_IMMEDIATEQ:
000153 3837          .dw XT_DOLITERAL
000154 8000          .dw $8000
000155 3a0d          .dw XT_AND
000156 3914          .dw XT_ZEROEQUAL
000157 3830          .dw XT_DOCONDBRANCH
000158 015c          DEST(IMMEDIATEQ1)
000159 3837           .dw XT_DOLITERAL
00015a 0001           .dw 1
00015b 381a           .dw XT_EXIT
                 IMMEDIATEQ1:
                     ; not immediate
00015c 3945          .dw XT_TRUE
00015d 381a          .dw XT_EXIT
                 .include "words/name2flags.asm"
                 
                 ; Tools
                 ; get the flags from a name token
                 VE_NAME2FLAGS:
00015e ff0a          .dw $ff0a
00015f 616e
000160 656d
000161 663e
000162 616c
000163 7367          .db "name>flags"
000164 0146          .dw VE_HEAD
                     .set VE_HEAD = VE_NAME2FLAGS
                 XT_NAME2FLAGS:
000165 3800          .dw DO_COLON
                 PFA_NAME2FLAGS:
000166 3bba          .dw XT_FETCHI ; skip to link field
000167 3837          .dw XT_DOLITERAL
000168 ff00          .dw $ff00
000169 3a0d          .dw XT_AND
00016a 381a          .dw XT_EXIT
                 
                 .if AMFORTH_NRWW_SIZE > 8000
                 .elif AMFORTH_NRWW_SIZE > 4000
                 .include "dict/appl_4k.inc"
                 
                 
                 ; Tools
                 ; print the version string
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DOT_VER:
00016b ff03          .dw $ff03
00016c 6576
../../common\words/ver.asm(12): warning: .cseg .db misalignment - padding zero byte
00016d 0072          .db "ver"
00016e 015e          .dw VE_HEAD
                     .set VE_HEAD = VE_DOT_VER
                 XT_DOT_VER:
00016f 3800          .dw DO_COLON
                 PFA_DOT_VER:
                 .endif
000170 02b3          .dw XT_ENV_FORTHNAME
000171 03dc          .dw XT_ITYPE
000172 3f96          .dw XT_SPACE
000173 3e9e          .dw XT_BASE
000174 3873          .dw XT_FETCH
                 
000175 02c1          .dw XT_ENV_FORTHVERSION
000176 3f29          .dw XT_DECIMAL
000177 3faf          .dw XT_S2D
000178 02fa          .dw XT_L_SHARP
000179 0302          .dw XT_SHARP
00017a 3837          .dw XT_DOLITERAL
00017b 002e          .dw '.'
00017c 02eb          .dw XT_HOLD
00017d 0318          .dw XT_SHARP_S
00017e 0323          .dw XT_SHARP_G
00017f 0412          .dw XT_TYPE
000180 3e9e          .dw XT_BASE
000181 387b          .dw XT_STORE
000182 3f96          .dw XT_SPACE
000183 02c9          .dw XT_ENV_CPU
000184 03dc          .dw XT_ITYPE
                 
000185 381a          .dw XT_EXIT
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/noop.asm"
                 
                 ; Tools
                 ; do nothing
                 VE_NOOP:
000186 ff04          .dw $ff04
000187 6f6e
000188 706f          .db "noop"
000189 016b          .dw VE_HEAD
                     .set VE_HEAD = VE_NOOP
                 XT_NOOP:
00018a 018b          .dw PFA_NOOP
                 PFA_NOOP:
00018b 940c 3804     jmp_ DO_NEXT
                 .include "words/unused.asm"
                 
                 ; Tools
                 ; Amount of available RAM (incl. PAD)
                 VE_UNUSED:
00018d ff06          .dw $ff06
00018e 6e75
00018f 7375
000190 6465          .db "unused"
000191 0186          .dw VE_HEAD
                     .set VE_HEAD = VE_UNUSED
                 XT_UNUSED:
000192 3800          .dw DO_COLON
                 PFA_UNUSED:
000193 3a7b          .dw XT_SP_FETCH
000194 3f0a          .dw XT_HERE
000195 398d          .dw XT_MINUS
000196 381a          .dw XT_EXIT
                 .include "words/to.asm"
                 
                 ; Tools
                 ; store the TOS to the named value (eeprom cell)
                 VE_TO:
000197 0002          .dw $0002
000198 6f74          .db "to"
000199 018d          .dw VE_HEAD
                     .set VE_HEAD = VE_TO
                 XT_TO:
00019a 3800          .dw DO_COLON
                 PFA_TO:
00019b 0421          .dw XT_TICK
00019c 0a84          .dw XT_ICELLPLUS  ; to body
00019d 3e98          .dw XT_STATE
00019e 3873          .dw XT_FETCH
00019f 3830          .dw XT_DOCONDBRANCH
0001a0 01ab          .dw PFA_TO1
0001a1 0729          .dw XT_COMPILE
0001a2 01a5          .dw XT_DOTO
0001a3 0734          .dw XT_COMMA
0001a4 381a          .dw XT_EXIT
                 
                 ; ( n -- ) (R: IP -- IP+1)
                 ; Tools
                 ; runtime portion of to
                 ;VE_DOTO:
                 ;    .dw $ff04
                 ;    .db "(to)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOTO
                 XT_DOTO:
0001a5 3800          .dw DO_COLON
                 PFA_DOTO:
0001a6 38f0          .dw XT_R_FROM
0001a7 38ab          .dw XT_DUP
0001a8 0a84          .dw XT_ICELLPLUS
0001a9 38f9          .dw XT_TO_R
0001aa 3bba          .dw XT_FETCHI
                 PFA_TO1:
0001ab 38ab          .dw XT_DUP
0001ac 0a84          .dw XT_ICELLPLUS
0001ad 0a84          .dw XT_ICELLPLUS
0001ae 3bba          .dw XT_FETCHI
0001af 3824          .dw XT_EXECUTE
0001b0 381a          .dw XT_EXIT
                 .include "words/icompare.asm"
                 
                 ; Tools
                 ; compares string in RAM with string in flash. f is zero if equal like COMPARE
                 VE_ICOMPARE:
0001b1 ff08          .dw $ff08
0001b2 6369
0001b3 6d6f
0001b4 6170
0001b5 6572          .db "icompare"
0001b6 0197          .dw VE_HEAD
                     .set VE_HEAD = VE_ICOMPARE
                 XT_ICOMPARE:
0001b7 3800          .dw DO_COLON
                 PFA_ICOMPARE:
0001b8 38f9          .dw XT_TO_R    ; ( -- r-addr r-len f-addr)
0001b9 38c9          .dw XT_OVER    ; ( -- r-addr r-len f-addr r-len)
0001ba 38f0          .dw XT_R_FROM  ; ( -- r-addr r-len f-addr r-len f-len )
0001bb 390d          .dw XT_NOTEQUAL ; ( -- r-addr r-len f-addr flag )
0001bc 3830          .dw XT_DOCONDBRANCH
0001bd 01c2          .dw PFA_ICOMPARE_SAMELEN
0001be 3eb3            .dw XT_2DROP
0001bf 38d3            .dw XT_DROP
0001c0 3945            .dw XT_TRUE
0001c1 381a            .dw XT_EXIT
                 PFA_ICOMPARE_SAMELEN:
0001c2 38be          .dw XT_SWAP ; ( -- r-addr f-addr len )
0001c3 394e          .dw XT_ZERO
0001c4 07f9          .dw XT_QDOCHECK
0001c5 3830          .dw XT_DOCONDBRANCH
0001c6 01e5          .dw PFA_ICOMPARE_DONE
0001c7 3a89          .dw XT_DODO
                 PFA_ICOMPARE_LOOP:
                     ; ( r-addr f-addr --)
0001c8 38c9          .dw XT_OVER
0001c9 3873          .dw XT_FETCH
                 .if WANT_IGNORECASE == 1
                 .endif
0001ca 38c9          .dw XT_OVER
0001cb 3bba          .dw XT_FETCHI ; ( -- r-addr f-addr r-cc f- cc)
                 .if WANT_IGNORECASE == 1
                 .endif
                     ; flash strings are zero-padded at the last cell
                     ; that means: if the flash cell is less $0100, than mask the
                     ; high byte in the ram cell
0001cc 38ab          .dw XT_DUP
                     ;.dw XT_BYTESWAP
0001cd 3837          .dw XT_DOLITERAL
0001ce 0100          .dw $100
0001cf 3956          .dw XT_ULESS
0001d0 3830          .dw XT_DOCONDBRANCH
0001d1 01d6          .dw PFA_ICOMPARE_LASTCELL
0001d2 38be          .dw XT_SWAP
0001d3 3837          .dw XT_DOLITERAL
0001d4 00ff          .dw $00FF
0001d5 3a0d          .dw XT_AND  ; the final swap can be omitted
                 PFA_ICOMPARE_LASTCELL:
0001d6 390d          .dw XT_NOTEQUAL
0001d7 3830          .dw XT_DOCONDBRANCH
0001d8 01dd          .dw PFA_ICOMPARE_NEXTLOOP
0001d9 3eb3          .dw XT_2DROP
0001da 3945          .dw XT_TRUE
0001db 3ac2          .dw XT_UNLOOP
0001dc 381a          .dw XT_EXIT
                 PFA_ICOMPARE_NEXTLOOP:
0001dd 3a29          .dw XT_1PLUS
0001de 38be          .dw XT_SWAP
0001df 3c82          .dw XT_CELLPLUS
0001e0 38be          .dw XT_SWAP
0001e1 3837          .dw XT_DOLITERAL
0001e2 0002          .dw 2
0001e3 3aa8          .dw XT_DOPLUSLOOP
0001e4 01c8          .dw PFA_ICOMPARE_LOOP
                 PFA_ICOMPARE_DONE:
0001e5 3eb3          .dw XT_2DROP
0001e6 394e          .dw XT_ZERO
0001e7 381a          .dw XT_EXIT
                 
                 .if WANT_IGNORECASE == 1
                 .endif
                 .include "words/star.asm"
                 
                 ; Arithmetics
                 ; multiply routine
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_STAR:
0001e8 ff01          .dw $ff01
0001e9 002a          .db "*",0
0001ea 01b1          .dw VE_HEAD
                     .set VE_HEAD = VE_STAR
                 XT_STAR:
0001eb 3800          .dw DO_COLON
                 PFA_STAR:
                 .endif
                 
0001ec 39a0          .dw XT_MSTAR
0001ed 38d3          .dw XT_DROP
0001ee 381a          .dw XT_EXIT
                 .include "words/j.asm"
                 
                 ; Compiler
                 ; loop counter of outer loop
                 VE_J:
0001ef ff01          .dw $FF01
0001f0 006a          .db "j",0
0001f1 01e8          .dw VE_HEAD
                     .set VE_HEAD = VE_J
                 XT_J:
0001f2 3800          .dw DO_COLON
                 PFA_J:
0001f3 3a64          .dw XT_RP_FETCH
0001f4 3837          .dw XT_DOLITERAL
0001f5 0007          .dw 7
0001f6 3997          .dw XT_PLUS
0001f7 3873          .dw XT_FETCH
0001f8 3a64          .dw XT_RP_FETCH
0001f9 3837          .dw XT_DOLITERAL
0001fa 0009          .dw 9
0001fb 3997          .dw XT_PLUS
0001fc 3873          .dw XT_FETCH
0001fd 3997          .dw XT_PLUS
0001fe 381a          .dw XT_EXIT
                 .include "words/dabs.asm"
                 
                 ; Arithmetics
                 ; double cell absolute value
                 VE_DABS:
0001ff ff04          .dw $ff04
000200 6164
000201 7362          .db "dabs"
000202 01ef          .dw VE_HEAD
                     .set VE_HEAD = VE_DABS
                 XT_DABS:
000203 3800          .dw DO_COLON
                 PFA_DABS:
000204 38ab          .dw XT_DUP
000205 391b          .dw XT_ZEROLESS
000206 3830          .dw XT_DOCONDBRANCH
000207 0209          .dw PFA_DABS1
000208 0210          .dw XT_DNEGATE
                 PFA_DABS1:
000209 381a          .dw XT_EXIT
                 ; : dabs      ( ud1 -- +d2 ) dup 0< if dnegate then ;
                 .include "words/dnegate.asm"
                 
                 ; Arithmetics
                 ; double cell negation
                 VE_DNEGATE:
00020a ff07          .dw $ff07
00020b 6e64
00020c 6765
00020d 7461
00020e 0065          .db "dnegate",0
00020f 01ff          .dw VE_HEAD
                     .set VE_HEAD = VE_DNEGATE
                 XT_DNEGATE:
000210 3800          .dw DO_COLON
                 PFA_DNEGATE:
000211 3c2a          .dw XT_DINVERT
000212 3837          .dw XT_DOLITERAL
000213 0001          .dw 1
000214 394e          .dw XT_ZERO
000215 3c04          .dw XT_DPLUS
000216 381a          .dw XT_EXIT
                 ; : dnegate   ( ud1 -- ud2 ) dinvert 1. d+ ;
                 .include "words/cmove.asm"
                 
                 ; Memory
                 ; copy data in RAM, from lower to higher addresses
                 VE_CMOVE:
000217 ff05          .dw $ff05
000218 6d63
000219 766f
00021a 0065          .db "cmove",0
00021b 020a          .dw VE_HEAD
                     .set VE_HEAD  = VE_CMOVE
                 XT_CMOVE:
00021c 021d          .dw PFA_CMOVE
                 PFA_CMOVE:
00021d 93bf          push xh
00021e 93af          push xl
00021f 91e9          ld zl, Y+
000220 91f9          ld zh, Y+ ; addr-to
000221 91a9          ld xl, Y+
000222 91b9          ld xh, Y+ ; addr-from
000223 2f09          mov temp0, tosh
000224 2b08          or temp0, tosl
000225 f021          brbs 1, PFA_CMOVE1
                 PFA_CMOVE2:
000226 911d          ld temp1, X+
000227 9311          st Z+, temp1
000228 9701          sbiw tosl, 1
000229 f7e1          brbc 1, PFA_CMOVE2
                 PFA_CMOVE1:
00022a 91af          pop xl
00022b 91bf          pop xh
00022c 9189
00022d 9199          loadtos
00022e 940c 3804     jmp_ DO_NEXT
                 .include "words/2swap.asm"
                 
                 ; Stack
                 ; Exchange the two top cell pairs
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_2SWAP:
000230 ff05          .dw $ff05
000231 7332
000232 6177
000233 0070          .db "2swap",0
000234 0217          .dw VE_HEAD
                     .set VE_HEAD = VE_2SWAP
                 XT_2SWAP:
000235 3800          .dw DO_COLON
                 PFA_2SWAP:
                 
                 .endif
000236 38db          .dw XT_ROT
000237 38f9          .dw XT_TO_R
000238 38db          .dw XT_ROT
000239 38f0          .dw XT_R_FROM
00023a 381a          .dw XT_EXIT
                 .include "words/tib.asm"
                 
                 ; System Variable
                 ; terminal input buffer address
                 VE_TIB:
00023b ff03          .dw $ff03
00023c 6974
00023d 0062          .db "tib",0
00023e 0230          .dw VE_HEAD
                     .set VE_HEAD = VE_TIB
                 XT_TIB:
00023f 3842          .dw PFA_DOVARIABLE
                 PFA_TIB:
000240 0117          .dw ram_tib
                     
                 .dseg
000117           ram_tib: .byte TIBSIZE
                 .cseg
                 ; ( -- f ) 
                 ; System
                 ; refills the input buffer
                 VE_REFILLTIB:
000241 ff0a          .dw $ff0a
000242 6572
000243 6966
000244 6c6c
000245 742d
000246 6269          .db "refill-tib"
000247 023b          .dw VE_HEAD
                     .set VE_HEAD = VE_REFILLTIB
                 XT_REFILLTIB:
000248 3800          .dw DO_COLON
                 PFA_REFILLTIB:
000249 023f          .dw XT_TIB
00024a 3837          .dw XT_DOLITERAL
00024b 005a          .dw TIBSIZE
00024c 0468          .dw XT_ACCEPT
00024d 3ec9          .dw XT_NUMBERTIB
00024e 387b          .dw XT_STORE
00024f 394e          .dw XT_ZERO
000250 3ec3          .dw XT_TO_IN
000251 387b          .dw XT_STORE
000252 3945          .dw XT_TRUE ; -1
000253 381a          .dw XT_EXIT
                 
                 ; ( -- addr n ) 
                 ; System
                 ; address and current length of the input buffer
                 VE_SOURCETIB:
000254 ff0a          .dw $FF0A
000255 6f73
000256 7275
000257 6563
000258 742d
000259 6269          .db "source-tib"
00025a 0241          .dw VE_HEAD
                     .set VE_HEAD = VE_SOURCETIB
                 XT_SOURCETIB:
00025b 3800          .dw DO_COLON
                 PFA_SOURCETIB:
00025c 023f          .dw XT_TIB
00025d 3ec9          .dw XT_NUMBERTIB
00025e 3873          .dw XT_FETCH
00025f 381a          .dw XT_EXIT
                 .include "words/init-user.asm"
                 
                 ; Tools
                 ; copy len cells from eeprom to ram
                 VE_EE2RAM:
000260 ff06        .dw $ff06
000261 6565
000262 723e
000263 6d61        .db "ee>ram"
000264 0254        .dw VE_HEAD
                   .set VE_HEAD = VE_EE2RAM
                 XT_EE2RAM:
000265 3800        .dw DO_COLON
                 PFA_EE2RAM:          ; ( -- )
000266 394e          .dw XT_ZERO
000267 3a89          .dw XT_DODO
                 PFA_EE2RAM_1:
                     ; ( -- e-addr r-addr )
000268 38c9          .dw XT_OVER
000269 3b4d          .dw XT_FETCHE
00026a 38c9          .dw XT_OVER
00026b 387b          .dw XT_STORE
00026c 3c82          .dw XT_CELLPLUS
00026d 38be          .dw XT_SWAP
00026e 3c82          .dw XT_CELLPLUS
00026f 38be          .dw XT_SWAP
000270 3ab7          .dw XT_DOLOOP
000271 0268          .dw PFA_EE2RAM_1
                 PFA_EE2RAM_2:
000272 3eb3          .dw XT_2DROP
000273 381a          .dw XT_EXIT
                 
                 ; ( -- )
                 ; Tools
                 ; setup the default user area from eeprom
                 VE_INITUSER:
000274 ff09        .dw $ff09
000275 6e69
000276 7469
000277 752d
000278 6573
000279 0072        .db "init-user",0
00027a 0260        .dw VE_HEAD
                   .set VE_HEAD = VE_INITUSER
                 XT_INITUSER:
00027b 3800        .dw DO_COLON
                 PFA_INITUSER:          ; ( -- )
00027c 3837          .dw XT_DOLITERAL
00027d 006a          .dw EE_INITUSER
00027e 3af0          .dw XT_UP_FETCH
00027f 3837          .dw XT_DOLITERAL
000280 001c          .dw SYSUSERSIZE
000281 39fe          .dw XT_2SLASH
000282 0265          .dw XT_EE2RAM
000283 381a          .dw XT_EXIT
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 
                 
                 .include "words/environment.asm"
                 
                 ; System Value
                 ; word list identifier of the environmental search list
                 VE_ENVIRONMENT:
000284 ff0b          .dw $ff0b
000285 6e65
000286 6976
000287 6f72
000288 6d6e
000289 6e65
00028a 0074          .db "environment",0
00028b 0274          .dw VE_HEAD
                     .set VE_HEAD = VE_ENVIRONMENT
                 XT_ENVIRONMENT:
00028c 3842          .dw PFA_DOVARIABLE
                 PFA_ENVIRONMENT:
00028d 0040          .dw EE_ENVIRONMENT
                 .include "words/env-wordlists.asm"
                 
                 ; Environment
                 ; maximum number of wordlists in the dictionary search order
                 VE_ENVWORDLISTS:
00028e ff09          .dw $ff09
00028f 6f77
000290 6472
000291 696c
000292 7473
000293 0073          .db "wordlists",0
000294 0000          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENVWORDLISTS
                 XT_ENVWORDLISTS:
000295 3800          .dw DO_COLON
                 PFA_ENVWORDLISTS:
000296 3837          .dw XT_DOLITERAL
000297 0008          .dw NUMWORDLISTS
000298 381a          .dw XT_EXIT
                 .include "words/env-slashpad.asm"
                 
                 ; Environment
                 ; Size of the PAD buffer in bytes
                 VE_ENVSLASHPAD:
000299 ff04          .dw $ff04
00029a 702f
00029b 6461          .db "/pad"
00029c 028e          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENVSLASHPAD
                 XT_ENVSLASHPAD:
00029d 3800          .dw DO_COLON
                 PFA_ENVSLASHPAD:
00029e 3a7b          .dw XT_SP_FETCH
00029f 3ecf          .dw XT_PAD
0002a0 398d          .dw XT_MINUS
0002a1 381a          .dw XT_EXIT
                 .include "words/env-slashhold.asm"
                 
                 ; Environment
                 ; size of the pictured numeric output buffer in bytes
                 VE_ENVSLASHHOLD:
0002a2 ff05          .dw $ff05
0002a3 682f
0002a4 6c6f
0002a5 0064          .db "/hold",0
0002a6 0299          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENVSLASHHOLD
                 XT_ENVSLASHHOLD:
0002a7 3800          .dw DO_COLON
                 PFA_ENVSLASHHOLD:
0002a8 3ecf          .dw XT_PAD
0002a9 3f0a          .dw XT_HERE
0002aa 398d          .dw XT_MINUS
0002ab 381a          .dw XT_EXIT
                 .include "words/env-forthname.asm"
                 
                 ; Environment
                 ; flash address of the amforth name string
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_ENV_FORTHNAME:
0002ac ff0a          .dw $ff0a
0002ad 6f66
0002ae 7472
0002af 2d68
0002b0 616e
0002b1 656d          .db "forth-name"
0002b2 02a2          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENV_FORTHNAME
                 XT_ENV_FORTHNAME:
0002b3 3800          .dw DO_COLON
                 PFA_EN_FORTHNAME:
0002b4 03a9          .dw XT_DOSLITERAL
0002b5 0007          .dw 7
                 .endif
0002b6 6d61
0002b7 6f66
0002b8 7472
../../common\words/env-forthname.asm(22): warning: .cseg .db misalignment - padding zero byte
0002b9 0068          .db "amforth"
                 .if cpu_msp430==1
                 .endif
0002ba 381a          .dw XT_EXIT
                 .include "words/env-forthversion.asm"
                 
                 ; Environment
                 ; version number of amforth
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_ENV_FORTHVERSION:
0002bb ff07          .dw $ff07
0002bc 6576
0002bd 7372
0002be 6f69
0002bf 006e          .db "version",0
0002c0 02ac          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENV_FORTHVERSION
                 XT_ENV_FORTHVERSION:
0002c1 3800          .dw DO_COLON
                 PFA_EN_FORTHVERSION:
                 .endif
0002c2 3837          .dw XT_DOLITERAL
0002c3 003a          .dw 58
0002c4 381a          .dw XT_EXIT
                 .include "words/env-cpu.asm"
                 
                 ; Environment
                 ; flash address of the CPU identification string
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_ENV_CPU:
0002c5 ff03          .dw $ff03
0002c6 7063
0002c7 0075          .db "cpu",0
0002c8 02bb          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENV_CPU
                 XT_ENV_CPU:
0002c9 3800          .dw DO_COLON
                 PFA_EN_CPU:
0002ca 3837          .dw XT_DOLITERAL
0002cb 0037          .dw mcu_name
0002cc 0408          .dw XT_ICOUNT
                 .endif
0002cd 381a          .dw XT_EXIT
                 .include "words/env-mcuinfo.asm"
                 
                 ; Environment
                 ; flash address of some CPU specific parameters
                 VE_ENV_MCUINFO:
0002ce ff08          .dw $ff08
0002cf 636d
0002d0 2d75
0002d1 6e69
0002d2 6f66          .db "mcu-info"
0002d3 02c5          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENV_MCUINFO
                 XT_ENV_MCUINFO:
0002d4 3800          .dw DO_COLON
                 PFA_EN_MCUINFO:
0002d5 3837          .dw XT_DOLITERAL
0002d6 0033          .dw mcu_info
0002d7 381a          .dw XT_EXIT
                 .include "words/env-usersize.asm"
                 
                 ; Environment
                 ; size of the USER area in bytes
                 VE_ENVUSERSIZE:
0002d8 ff05          .dw $ff05
0002d9 752f
0002da 6573
0002db 0072          .db "/user",0
0002dc 02ce          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENVUSERSIZE
                 XT_ENVUSERSIZE:
0002dd 3800          .dw DO_COLON
                 PFA_ENVUSERSIZE:
0002de 3837          .dw XT_DOLITERAL
0002df 0026          .dw SYSUSERSIZE + APPUSERSIZE
0002e0 381a          .dw XT_EXIT
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/hld.asm"
                 
                 ; Numeric IO
                 ; pointer to current write position in the Pictured Numeric Output buffer
                 VE_HLD:
0002e1 ff03          .dw $ff03
0002e2 6c68
0002e3 0064          .db "hld",0
0002e4 0284          .dw VE_HEAD
                     .set VE_HEAD = VE_HLD
                 XT_HLD:
0002e5 3842          .dw PFA_DOVARIABLE
                 PFA_HLD:
0002e6 0171          .dw ram_hld
                 
                 .dseg
000171           ram_hld: .byte 2
                 .cseg
                 .include "words/hold.asm"
                 
                 ; Numeric IO
                 ; prepend character to pictured numeric output buffer
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_HOLD:
0002e7 ff04          .dw $ff04
0002e8 6f68
0002e9 646c          .db "hold"
0002ea 02e1          .dw VE_HEAD
                     .set VE_HEAD = VE_HOLD
                 XT_HOLD:
0002eb 3800          .dw DO_COLON
                 PFA_HOLD:
                 .endif
0002ec 02e5          .dw XT_HLD
0002ed 38ab          .dw XT_DUP
0002ee 3873          .dw XT_FETCH
0002ef 3a2f          .dw XT_1MINUS
0002f0 38ab          .dw XT_DUP
0002f1 38f9          .dw XT_TO_R
0002f2 38be          .dw XT_SWAP
0002f3 387b          .dw XT_STORE
0002f4 38f0          .dw XT_R_FROM
0002f5 3887          .dw XT_CSTORE
0002f6 381a          .dw XT_EXIT
                 .include "words/less-sharp.asm" ; <#
                 
                 ; Numeric IO
                 ; initialize the pictured numeric output conversion process
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_L_SHARP:
0002f7 ff02          .dw $ff02
0002f8 233c          .db "<#"
0002f9 02e7          .dw VE_HEAD
                     .set VE_HEAD = VE_L_SHARP
                 XT_L_SHARP:
0002fa 3800          .dw DO_COLON
                 PFA_L_SHARP:
                 .endif
0002fb 3ecf          .dw XT_PAD
0002fc 02e5          .dw XT_HLD
0002fd 387b          .dw XT_STORE
0002fe 381a          .dw XT_EXIT
                 .include "words/sharp.asm"
                 
                 ; Numeric IO
                 ; pictured numeric output: convert one digit
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 
                 VE_SHARP:
0002ff ff01          .dw $ff01
000300 0023          .db "#",0
000301 02f7          .dw VE_HEAD
                     .set VE_HEAD = VE_SHARP
                 XT_SHARP:
000302 3800          .dw DO_COLON
                 PFA_SHARP:
                 .endif
000303 3e9e          .dw XT_BASE
000304 3873          .dw XT_FETCH
000305 037f          .dw XT_UDSLASHMOD
000306 38db          .dw XT_ROT
000307 3837          .dw XT_DOLITERAL
000308 0009          .dw 9
000309 38c9          .dw XT_OVER
00030a 3968          .dw XT_LESS
00030b 3830          .dw XT_DOCONDBRANCH
00030c 0310          DEST(PFA_SHARP1)
00030d 3837          .dw XT_DOLITERAL
00030e 0007          .dw 7
00030f 3997          .dw XT_PLUS
                 PFA_SHARP1:
000310 3837          .dw XT_DOLITERAL
000311 0030          .dw 48 ; ASCII 0
000312 3997          .dw XT_PLUS
000313 02eb          .dw XT_HOLD
000314 381a          .dw XT_EXIT
                 ; : #    ( ud1 -- ud2 ) 
                 ;        base @ ud/mod rot 9 over < if 7 + then 30 + hold ; 
                 .include "words/sharp-s.asm"
                 
                 ; Numeric IO
                 ; pictured numeric output: convert all digits until 0 (zero) is reached
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SHARP_S:
000315 ff02          .dw $ff02
000316 7323          .db "#s"
000317 02ff          .dw VE_HEAD
                     .set VE_HEAD = VE_SHARP_S
                 XT_SHARP_S:
000318 3800          .dw DO_COLON
                 PFA_SHARP_S:
                 .endif
                 NUMS1:
000319 0302          .dw XT_SHARP
00031a 3eaa          .dw XT_2DUP
00031b 3a16          .dw XT_OR
00031c 3914          .dw XT_ZEROEQUAL
00031d 3830          .dw XT_DOCONDBRANCH
00031e 0319          DEST(NUMS1) ; PFA_SHARP_S
00031f 381a          .dw XT_EXIT
                 .include "words/sharp-greater.asm" ; #>
                 
                 ; Numeric IO
                 ; Pictured Numeric Output: convert PNO buffer into an string
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SHARP_G:
000320 ff02          .dw $ff02
000321 3e23          .db "#>"
000322 0315          .dw VE_HEAD
                     .set VE_HEAD = VE_SHARP_G
                 XT_SHARP_G:
000323 3800          .dw DO_COLON
                 PFA_SHARP_G:
                 .endif
000324 3eb3          .dw XT_2DROP
000325 02e5          .dw XT_HLD
000326 3873          .dw XT_FETCH
000327 3ecf          .dw XT_PAD
000328 38c9          .dw XT_OVER
000329 398d          .dw XT_MINUS
00032a 381a          .dw XT_EXIT
                 .include "words/sign.asm"
                 
                 ; Numeric IO
                 ; place a - in HLD if n is negative
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SIGN:
00032b ff04          .dw $ff04
00032c 6973
00032d 6e67          .db "sign"
00032e 0320          .dw VE_HEAD
                     .set VE_HEAD = VE_SIGN
                 XT_SIGN:
00032f 3800          .dw DO_COLON
                 PFA_SIGN:
                 .endif
000330 391b          .dw XT_ZEROLESS
000331 3830          .dw XT_DOCONDBRANCH
000332 0336          DEST(PFA_SIGN1)
000333 3837          .dw XT_DOLITERAL
000334 002d          .dw 45 ; ascii -
000335 02eb          .dw XT_HOLD
                 PFA_SIGN1:
000336 381a          .dw XT_EXIT
                 .include "words/d-dot-r.asm"
                 
                 ; Numeric IO
                 ; singed PNO with double cell numbers, right aligned in width w
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DDOTR:
000337 ff03          .dw $ff03
000338 2e64
000339 0072          .db "d.r",0
00033a 032b          .dw VE_HEAD
                     .set VE_HEAD = VE_DDOTR
                 XT_DDOTR:
00033b 3800          .dw DO_COLON
                 PFA_DDOTR:
                 
                 .endif
00033c 38f9          .dw XT_TO_R
00033d 3ebb          .dw XT_TUCK
00033e 0203          .dw XT_DABS
00033f 02fa          .dw XT_L_SHARP
000340 0318          .dw XT_SHARP_S
000341 38db          .dw XT_ROT
000342 032f          .dw XT_SIGN
000343 0323          .dw XT_SHARP_G
000344 38f0          .dw XT_R_FROM
000345 38c9          .dw XT_OVER
000346 398d          .dw XT_MINUS
000347 3f9f          .dw XT_SPACES
000348 0412          .dw XT_TYPE
000349 381a          .dw XT_EXIT
                 ; : d.r       ( d n -- )
                 ;             >r swap over dabs <# #s rot sign #> r> over - spaces type ;
                 .include "words/dot-r.asm"
                 
                 ; Numeric IO
                 ; singed PNO with single cell numbers, right aligned in width w
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DOTR:
00034a ff02          .dw $ff02
00034b 722e          .db ".r"
00034c 0337          .dw VE_HEAD
                     .set VE_HEAD = VE_DOTR
                 XT_DOTR:
00034d 3800          .dw DO_COLON
                 PFA_DOTR:
                 
                 .endif
00034e 38f9          .dw XT_TO_R
00034f 3faf          .dw XT_S2D
000350 38f0          .dw XT_R_FROM
000351 033b          .dw XT_DDOTR
000352 381a          .dw XT_EXIT
                 ; : .r        ( s n -- )  >r s>d r> d.r ;
                 .include "words/d-dot.asm"
                 
                 ; Numeric IO
                 ; singed PNO with double cell numbers
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DDOT:
000353 ff02          .dw $ff02
000354 2e64          .db "d."
000355 034a          .dw VE_HEAD
                     .set VE_HEAD = VE_DDOT
                 XT_DDOT:
000356 3800          .dw DO_COLON
                 PFA_DDOT:
                 
                 .endif
000357 394e          .dw XT_ZERO
000358 033b          .dw XT_DDOTR
000359 3f96          .dw XT_SPACE
00035a 381a          .dw XT_EXIT
                 ; : d.        ( d -- )    0 d.r space ;
                 .include "words/dot.asm"
                 
                 ; Numeric IO
                 ; singed PNO with single cell numbers
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 
                 VE_DOT:
00035b ff01          .dw $ff01
00035c 002e          .db ".",0
00035d 0353          .dw VE_HEAD
                     .set VE_HEAD = VE_DOT
                 XT_DOT:
00035e 3800          .dw DO_COLON
                 PFA_DOT:
                 .endif
00035f 3faf          .dw XT_S2D
000360 0356          .dw XT_DDOT
000361 381a          .dw XT_EXIT
                 ; : .         ( s -- )    s>d d. ; 
                 .include "words/ud-dot.asm"
                 
                 ; Numeric IO
                 ; unsigned PNO with double cell numbers
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_UDDOT:
000362 ff03          .dw $ff03
000363 6475
000364 002e          .db "ud.",0
000365 035b          .dw VE_HEAD
                     .set VE_HEAD = VE_UDDOT
                 XT_UDDOT:
000366 3800          .dw DO_COLON
                 PFA_UDDOT:
                 .endif
000367 394e          .dw XT_ZERO
000368 036f          .dw XT_UDDOTR
000369 3f96          .dw XT_SPACE
00036a 381a          .dw XT_EXIT
                 .include "words/ud-dot-r.asm"
                 
                 ; Numeric IO
                 ; unsigned PNO with double cell numbers, right aligned in width w
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 
                 VE_UDDOTR:
00036b ff04          .dw $ff04
00036c 6475
00036d 722e          .db "ud.r"
00036e 0362          .dw VE_HEAD
                     .set VE_HEAD = VE_UDDOTR
                 XT_UDDOTR:
00036f 3800          .dw DO_COLON
                 PFA_UDDOTR:
                 .endif
000370 38f9          .dw XT_TO_R
000371 02fa          .dw XT_L_SHARP
000372 0318          .dw XT_SHARP_S
000373 0323          .dw XT_SHARP_G
000374 38f0          .dw XT_R_FROM
000375 38c9          .dw XT_OVER
000376 398d          .dw XT_MINUS
000377 3f9f          .dw XT_SPACES
000378 0412          .dw XT_TYPE
000379 381a          .dw XT_EXIT
                 .include "words/ud-slash-mod.asm"
                 
                 ; Arithmetics
                 ; unsigned double cell division with remainder
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_UDSLASHMOD:
00037a ff06          .dw $ff06
00037b 6475
00037c 6d2f
00037d 646f          .db "ud/mod"
00037e 036b          .dw VE_HEAD
                     .set VE_HEAD = VE_UDSLASHMOD
                 XT_UDSLASHMOD:
00037f 3800          .dw DO_COLON
                 PFA_UDSLASHMOD:
                 .endif
000380 38f9          .dw XT_TO_R
000381 394e          .dw XT_ZERO
000382 3902          .dw XT_R_FETCH
000383 39bc          .dw XT_UMSLASHMOD
000384 38f0          .dw XT_R_FROM
000385 38be          .dw XT_SWAP
000386 38f9          .dw XT_TO_R
000387 39bc          .dw XT_UMSLASHMOD
000388 38f0          .dw XT_R_FROM
000389 381a          .dw XT_EXIT
                 .include "words/digit-q.asm"
                 
                 ; Numeric IO
                 ; tries to convert a character to a number, set flag accordingly
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DIGITQ:
00038a ff06          .dw $ff06 
00038b 6964
00038c 6967
00038d 3f74          .db "digit?"
00038e 037a          .dw VE_HEAD
                     .set VE_HEAD = VE_DIGITQ
                 XT_DIGITQ:
00038f 3800          .dw DO_COLON 
                 PFA_DIGITQ:
                 .endif
000390 3f4e          .dw XT_TOUPPER
000391 38ab
000392 3837
000393 0039
000394 3972
000395 3837
000396 0100          .DW XT_DUP,XT_DOLITERAL,57,XT_GREATER,XT_DOLITERAL,256
000397 3a0d
000398 3997
000399 38ab
00039a 3837
00039b 0140
00039c 3972          .DW XT_AND,XT_PLUS,XT_DUP,XT_DOLITERAL,320,XT_GREATER
00039d 3837
00039e 0107
00039f 3a0d
0003a0 398d
0003a1 3837
0003a2 0030          .DW XT_DOLITERAL,263,XT_AND,XT_MINUS,XT_DOLITERAL,48
0003a3 398d
0003a4 38ab
0003a5 3e9e
0003a6 3873
0003a7 3956          .DW XT_MINUS,XT_DUP,XT_BASE,XT_FETCH,XT_ULESS
0003a8 381a          .DW XT_EXIT
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/do-sliteral.asm"
                 
                 ; String
                 ; runtime portion of sliteral
                 ;VE_DOSLITERAL:
                 ;  .dw $ff0a
                 ;  .db "(sliteral)"
                 ;  .dw VE_HEAD
                 ;  .set VE_HEAD = VE_DOSLITERAL
                 XT_DOSLITERAL:
0003a9 3800        .dw DO_COLON
                 PFA_DOSLITERAL:
0003aa 3902        .dw XT_R_FETCH   ; ( -- addr )
0003ab 0408        .dw XT_ICOUNT
0003ac 38f0        .dw XT_R_FROM
0003ad 38c9        .dw XT_OVER     ; ( -- addr' n addr n)
0003ae 3a29        .dw XT_1PLUS
0003af 39fe        .dw XT_2SLASH   ; ( -- addr' n addr k )
0003b0 3997        .dw XT_PLUS     ; ( -- addr' n addr'' )
0003b1 3a29        .dw XT_1PLUS
0003b2 38f9        .dw XT_TO_R     ; ( -- )
0003b3 381a        .dw XT_EXIT
                 .include "words/scomma.asm"
                 
                 ; Compiler
                 ; compiles a string from RAM to Flash
                 VE_SCOMMA:
0003b4 ff02        .dw $ff02
0003b5 2c73        .db "s",$2c
0003b6 038a        .dw VE_HEAD
                   .set VE_HEAD = VE_SCOMMA
                 XT_SCOMMA:
0003b7 3800          .dw DO_COLON
                 PFA_SCOMMA:
0003b8 38ab          .dw XT_DUP
0003b9 03bb          .dw XT_DOSCOMMA
0003ba 381a          .dw XT_EXIT
                 
                 ; ( addr len len' -- ) 
                 ; Compiler
                 ; compiles a string from RAM to Flash
                 ;VE_DOSCOMMA:
                 ;  .dw $ff04
                 ;  .db "(s",$2c,")"
                 ;  .dw VE_HEAD
                 ;  .set VE_HEAD = VE_DOSCOMMA
                 XT_DOSCOMMA:
0003bb 3800          .dw DO_COLON
                 PFA_DOSCOMMA:
0003bc 0734          .dw XT_COMMA
0003bd 38ab          .dw XT_DUP   ; ( --addr len len)
0003be 39fe          .dw XT_2SLASH ; ( -- addr len len/2
0003bf 3ebb          .dw XT_TUCK   ; ( -- addr len/2 len len/2
0003c0 3a05          .dw XT_2STAR  ; ( -- addr len/2 len len'
0003c1 398d          .dw XT_MINUS  ; ( -- addr len/2 rem
0003c2 38f9          .dw XT_TO_R
0003c3 394e          .dw XT_ZERO
0003c4 07f9          .dw XT_QDOCHECK
0003c5 3830          .dw XT_DOCONDBRANCH
0003c6 03ce          .dw PFA_SCOMMA2
0003c7 3a89          .dw XT_DODO
                 PFA_SCOMMA1:
0003c8 38ab          .dw XT_DUP         ; ( -- addr addr )
0003c9 3873          .dw XT_FETCH       ; ( -- addr c1c2 )
0003ca 0734          .dw XT_COMMA       ; ( -- addr )
0003cb 3c82          .dw XT_CELLPLUS    ; ( -- addr+cell )
0003cc 3ab7          .dw XT_DOLOOP
0003cd 03c8          .dw PFA_SCOMMA1
                 PFA_SCOMMA2:
0003ce 38f0          .dw XT_R_FROM
0003cf 3922          .dw XT_GREATERZERO
0003d0 3830          .dw XT_DOCONDBRANCH
0003d1 03d5          .dw PFA_SCOMMA3
0003d2 38ab            .dw XT_DUP     ; well, tricky
0003d3 3892            .dw XT_CFETCH
0003d4 0734            .dw XT_COMMA
                 PFA_SCOMMA3:
0003d5 38d3          .dw XT_DROP        ; ( -- )
0003d6 381a          .dw XT_EXIT
                 .include "words/itype.asm"
                 
                 ; Tools
                 ; reads string from flash and prints it
                 VE_ITYPE:
0003d7 ff05          .dw $ff05
0003d8 7469
0003d9 7079
0003da 0065          .db "itype",0
0003db 03b4          .dw VE_HEAD
                     .set VE_HEAD = VE_ITYPE
                 XT_ITYPE:
0003dc 3800          .dw DO_COLON
                 PFA_ITYPE:
0003dd 38ab          .dw XT_DUP    ; ( --addr len len)
0003de 39fe          .dw XT_2SLASH ; ( -- addr len len/2
0003df 3ebb          .dw XT_TUCK   ; ( -- addr len/2 len len/2
0003e0 3a05          .dw XT_2STAR  ; ( -- addr len/2 len len'
0003e1 398d          .dw XT_MINUS  ; ( -- addr len/2 rem
0003e2 38f9          .dw XT_TO_R
0003e3 394e          .dw XT_ZERO
0003e4 07f9          .dw XT_QDOCHECK
0003e5 3830          .dw XT_DOCONDBRANCH
0003e6 03f0          .dw PFA_ITYPE2
0003e7 3a89          .dw XT_DODO
                 PFA_ITYPE1:
0003e8 38ab          .dw XT_DUP         ; ( -- addr addr )
0003e9 3bba          .dw XT_FETCHI      ; ( -- addr c1c2 )
0003ea 38ab          .dw XT_DUP
0003eb 03fd          .dw XT_LOWEMIT
0003ec 03f9          .dw XT_HIEMIT
0003ed 3a29          .dw XT_1PLUS    ; ( -- addr+cell )
0003ee 3ab7          .dw XT_DOLOOP
0003ef 03e8          .dw PFA_ITYPE1
                 PFA_ITYPE2:
0003f0 38f0          .dw XT_R_FROM
0003f1 3922          .dw XT_GREATERZERO
0003f2 3830          .dw XT_DOCONDBRANCH
0003f3 03f7          .dw PFA_ITYPE3
0003f4 38ab            .dw XT_DUP     ; make sure the drop below has always something to do
0003f5 3bba            .dw XT_FETCHI
0003f6 03fd            .dw XT_LOWEMIT
                 PFA_ITYPE3:
0003f7 38d3          .dw XT_DROP
0003f8 381a          .dw XT_EXIT
                 
                 ; ( w -- )
                 ; R( -- )
                 ; content of cell fetched on stack.
                 ;VE_HIEMIT:
                 ;    .dw $ff06
                 ;    .db "hiemit"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_HIEMIT
                 XT_HIEMIT:
0003f9 3800          .dw DO_COLON
                 PFA_HIEMIT:
0003fa 3ae7          .dw XT_BYTESWAP
0003fb 03fd          .dw XT_LOWEMIT
0003fc 381a          .dw XT_EXIT
                 
                 ; ( w -- )
                 ; R( -- )
                 ; content of cell fetched on stack.
                 ;VE_LOWEMIT:
                 ;    .dw $ff07
                 ;    .db "lowemit"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_LOWEMIT
                 XT_LOWEMIT:
0003fd 3800          .dw DO_COLON
                 PFA_LOWEMIT:
0003fe 3837          .dw XT_DOLITERAL
0003ff 00ff          .dw $00ff
000400 3a0d          .dw XT_AND
000401 3ed9          .dw XT_EMIT
000402 381a          .dw XT_EXIT
                 .include "words/icount.asm"
                 
                 ; Tools
                 ; get count information out of a counted string in flash
                 VE_ICOUNT:
000403 ff06          .dw $ff06
000404 6369
000405 756f
000406 746e          .db "icount"
000407 03d7          .dw VE_HEAD
                     .set VE_HEAD = VE_ICOUNT
                 XT_ICOUNT:
000408 3800          .dw DO_COLON
                 PFA_ICOUNT:
000409 38ab          .dw XT_DUP
00040a 3a29          .dw XT_1PLUS
00040b 38be          .dw XT_SWAP
00040c 3bba          .dw XT_FETCHI
00040d 381a          .dw XT_EXIT
                 .include "words/type.asm"
                 
                 ; Character IO
                 ; print a RAM based string
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_TYPE:
00040e ff04          .dw $ff04
00040f 7974
000410 6570          .db "type"
000411 0403          .dw VE_HEAD
                     .set VE_HEAD = VE_TYPE
                 XT_TYPE:
000412 3800          .dw DO_COLON
                 PFA_TYPE:
                 
                 .endif
000413 3f81          .dw XT_BOUNDS
000414 07f9          .dw XT_QDOCHECK
000415 3830          .dw XT_DOCONDBRANCH
000416 041d          DEST(PFA_TYPE2)
000417 3a89          .dw XT_DODO
                 PFA_TYPE1:
000418 3a9a          .dw XT_I
000419 3892          .dw XT_CFETCH
00041a 3ed9          .dw XT_EMIT
00041b 3ab7          .dw XT_DOLOOP
00041c 0418          DEST(PFA_TYPE1)
                 PFA_TYPE2:
00041d 381a          .dw XT_EXIT
                 .include "words/tick.asm"
                 
                 ; Dictionary
                 ; search dictionary for name, return XT or throw an exception -13
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_TICK:
00041e ff01          .dw $ff01
00041f 0027          .db "'",0
000420 040e          .dw VE_HEAD
                     .set VE_HEAD = VE_TICK
                 XT_TICK:
000421 3800          .dw DO_COLON
                 PFA_TICK:
                 .endif
000422 058b          .dw XT_PARSENAME
000423 06e3          .dw XT_FINDNAME
000424 3914          .dw XT_ZEROEQUAL
000425 3830          .dw XT_DOCONDBRANCH
000426 042a          DEST(PFA_TICK1)
000427 3837          .dw XT_DOLITERAL
000428 fff3          .dw -13
000429 3d60          .dw XT_THROW
                 PFA_TICK1:
00042a 381a          .dw XT_EXIT
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/cskip.asm"
                 
                 ; String
                 ; skips leading occurancies in string at addr1/n1 leaving addr2/n2 pointing to the 1st non-c character
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_CSKIP:
00042b ff05          .dw $ff05
00042c 7363
00042d 696b
00042e 0070          .db "cskip",0
00042f 041e          .dw VE_HEAD
                     .set VE_HEAD = VE_CSKIP
                 XT_CSKIP:
000430 3800          .dw DO_COLON
                 PFA_CSKIP:
                 .endif
000431 38f9          .dw XT_TO_R           ; ( -- addr1 n1 )
                 PFA_CSKIP1:
000432 38ab          .dw XT_DUP            ; ( -- addr' n' n' )
000433 3830          .dw XT_DOCONDBRANCH   ; ( -- addr' n')
000434 0440          DEST(PFA_CSKIP2)
000435 38c9          .dw XT_OVER           ; ( -- addr' n' addr' )
000436 3892          .dw XT_CFETCH         ; ( -- addr' n' c' )
000437 3902          .dw XT_R_FETCH        ; ( -- addr' n' c' c )
000438 3fc5          .dw XT_EQUAL          ; ( -- addr' n' f )
000439 3830          .dw XT_DOCONDBRANCH   ; ( -- addr' n')
00043a 0440          DEST(PFA_CSKIP2)
00043b 3837          .dw XT_DOLITERAL
00043c 0001          .dw 1
00043d 057c          .dw XT_SLASHSTRING
00043e 3829          .dw XT_DOBRANCH
00043f 0432          DEST(PFA_CSKIP1)
                 PFA_CSKIP2:
000440 38f0          .dw XT_R_FROM
000441 38d3          .dw XT_DROP           ; ( -- addr2 n2)
000442 381a          .dw XT_EXIT
                 .include "words/cscan.asm"
                 
                 ; String
                 ; Scan string at addr1/n1 for the first occurance of c, leaving addr1/n2, char at n2 is first non-c character
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_CSCAN:
000443 ff05          .dw $ff05
000444 7363
000445 6163
../../common\words/cscan.asm(12): warning: .cseg .db misalignment - padding zero byte
000446 006e          .db "cscan"
000447 042b          .dw VE_HEAD
                     .set VE_HEAD = VE_CSCAN
                 XT_CSCAN:
000448 3800          .dw DO_COLON
                 PFA_CSCAN:
                 .endif
000449 38f9          .dw XT_TO_R
00044a 38c9          .dw XT_OVER
                 PFA_CSCAN1:
00044b 38ab          .dw XT_DUP
00044c 3892          .dw XT_CFETCH
00044d 3902          .dw XT_R_FETCH
00044e 3fc5          .dw XT_EQUAL
00044f 3914          .dw XT_ZEROEQUAL
000450 3830          .dw XT_DOCONDBRANCH
000451 045d          DEST(PFA_CSCAN2)
000452 38be            .dw XT_SWAP
000453 3a2f            .dw XT_1MINUS
000454 38be            .dw XT_SWAP
000455 38c9            .dw XT_OVER
000456 391b            .dw XT_ZEROLESS ; not negative
000457 3914            .dw XT_ZEROEQUAL
000458 3830            .dw XT_DOCONDBRANCH
000459 045d            DEST(PFA_CSCAN2)
00045a 3a29              .dw XT_1PLUS
00045b 3829              .dw XT_DOBRANCH
00045c 044b              DEST(PFA_CSCAN1)
                 PFA_CSCAN2:
00045d 38ea          .dw XT_NIP
00045e 38c9          .dw XT_OVER
00045f 398d          .dw XT_MINUS
000460 38f0          .dw XT_R_FROM
000461 38d3          .dw XT_DROP
000462 381a          .dw XT_EXIT
                 
                 ; : my-cscan ( addr len c -- addr len' )
                 ;    >r over ( -- addr len addr )
                 ;    begin
                 ;      dup c@ r@ <> while
                 ;       swap 1- swap over 0 >=  while
                 ;        1+ 
                 ;     repeat then
                 ;     nip over - r> drop 
                 ; ;
                 .include "words/accept.asm"
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_ACCEPT:
000463 ff06          .dw $ff06
000464 6361
000465 6563
000466 7470          .db "accept"
000467 0443          .dw VE_HEAD
                     .set VE_HEAD = VE_ACCEPT
                 XT_ACCEPT:
000468 3800          .dw DO_COLON
                 PFA_ACCEPT:
                 
                 .endif
000469 38c9
00046a 3997
00046b 3a2f
00046c 38c9              .DW XT_OVER,XT_PLUS,XT_1MINUS,XT_OVER
00046d 3eea
00046e 38ab
00046f 04a2
000470 3914
000471 3830      ACC1:   .DW XT_KEY,XT_DUP,XT_CRLFQ,XT_ZEROEQUAL,XT_DOCONDBRANCH
000472 0494              DEST(ACC5)
000473 38ab
000474 3837
000475 0008
000476 3fc5
000477 3830              .DW XT_DUP,XT_DOLITERAL,8,XT_EQUAL,XT_DOCONDBRANCH
000478 048b              DEST(ACC3)
000479 38d3
00047a 38db
00047b 3eaa
00047c 3972
00047d 38f9
00047e 38db
00047f 38db
000480 38f0
000481 3830              .DW XT_DROP,XT_ROT,XT_2DUP,XT_GREATER,XT_TO_R,XT_ROT,XT_ROT,XT_R_FROM,XT_DOCONDBRANCH
000482 0489      	DEST(ACC6)
000483 049a
000484 3a2f
000485 38f9
000486 38c9
000487 38f0
000488 013e      	.DW XT_BS,XT_1MINUS,XT_TO_R,XT_OVER,XT_R_FROM,XT_UMAX
                 ACC6:
000489 3829              .DW XT_DOBRANCH
00048a 0492              DEST(ACC4)
00048b 38ab
00048c 3ed9
00048d 38c9
00048e 3887
00048f 3a29
000490 38c9
000491 014a      ACC3:   .DW XT_DUP,XT_EMIT,XT_OVER,XT_CSTORE,XT_1PLUS,XT_OVER,XT_UMIN
000492 3829      ACC4:   .DW XT_DOBRANCH
000493 046d              DEST(ACC1)
000494 38d3
000495 38ea
000496 38be
000497 398d
000498 3f89
000499 381a      ACC5:   .DW XT_DROP,XT_NIP,XT_SWAP,XT_MINUS,XT_CR,XT_EXIT
                 
                 
                 ; ( --  ) 
                 ; System
                 ; send a backspace character to overwrite the current char
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 ;VE_BS:
                 ;    .dw $ff02
                 ;    .db "bs"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_BS
                 XT_BS:
00049a 3800          .dw DO_COLON
                 .endif
00049b 3837          .dw XT_DOLITERAL
00049c 0008          .dw 8
00049d 38ab          .dw XT_DUP
00049e 3ed9          .dw XT_EMIT
00049f 3f96          .dw XT_SPACE
0004a0 3ed9          .dw XT_EMIT
0004a1 381a          .dw XT_EXIT
                 
                 
                 ; ( c -- f ) 
                 ; System
                 ; is the character a line end character?
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 ;VE_CRLFQ:
                 ;    .dw $ff02
                 ;    .db "crlf?"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_CRLFQ
                 XT_CRLFQ:
0004a2 3800          .dw DO_COLON
                 .endif
0004a3 38ab          .dw XT_DUP
0004a4 3837          .dw XT_DOLITERAL
0004a5 000d          .dw 13
0004a6 3fc5          .dw XT_EQUAL
0004a7 38be          .dw XT_SWAP
0004a8 3837          .dw XT_DOLITERAL
0004a9 000a          .dw 10
0004aa 3fc5          .dw XT_EQUAL
0004ab 3a16          .dw XT_OR
0004ac 381a          .dw XT_EXIT
                 .include "words/refill.asm"
                 
                 ; System
                 ; refills the input buffer
                 VE_REFILL:
0004ad ff06          .dw $ff06
0004ae 6572
0004af 6966
0004b0 6c6c          .db "refill"
0004b1 0463          .dw VE_HEAD
                     .set VE_HEAD = VE_REFILL
                 XT_REFILL:
0004b2 3dd8          .dw PFA_DODEFER1
                 PFA_REFILL:
0004b3 001a          .dw USER_REFILL
0004b4 3da2          .dw XT_UDEFERFETCH
0004b5 3dae          .dw XT_UDEFERSTORE
                 
                 .include "words/char.asm"
                 
                 ; Tools
                 ; copy the first character of the next word onto the stack
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_CHAR:
0004b6 ff04          .dw $ff04
0004b7 6863
0004b8 7261          .db "char"
0004b9 04ad          .dw VE_HEAD
                     .set VE_HEAD = VE_CHAR
                 XT_CHAR:
0004ba 3800          .dw DO_COLON
                 PFA_CHAR:
                 .endif
0004bb 058b          .dw XT_PARSENAME
0004bc 38d3          .dw XT_DROP
0004bd 3892          .dw XT_CFETCH
0004be 381a          .dw XT_EXIT
                 .include "words/number.asm"
                 
                 ; Numeric IO
                 ; convert a string at addr to a number
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_NUMBER:
0004bf ff06          .dw $ff06
0004c0 756e
0004c1 626d
0004c2 7265          .db "number"
0004c3 04b6          .dw VE_HEAD
                     .set VE_HEAD = VE_NUMBER
                 XT_NUMBER:
0004c4 3800          .dw DO_COLON
                 PFA_NUMBER:
                 .endif
0004c5 3e9e          .dw XT_BASE
0004c6 3873          .dw XT_FETCH
0004c7 38f9          .dw XT_TO_R
0004c8 050b          .dw XT_QSIGN
0004c9 38f9          .dw XT_TO_R
0004ca 051f          .dw XT_SET_BASE
0004cb 050b          .dw XT_QSIGN
0004cc 38f0          .dw XT_R_FROM
0004cd 3a16          .dw XT_OR
0004ce 38f9          .dw XT_TO_R
                     ; check whether something is left
0004cf 38ab          .dw XT_DUP
0004d0 3914          .dw XT_ZEROEQUAL
0004d1 3830          .dw XT_DOCONDBRANCH
0004d2 04db          DEST(PFA_NUMBER0)
                       ; nothing is left. It cannot be a number at all
0004d3 3eb3            .dw XT_2DROP
0004d4 38f0            .dw XT_R_FROM
0004d5 38d3            .dw XT_DROP
0004d6 38f0            .dw XT_R_FROM
0004d7 3e9e            .dw XT_BASE
0004d8 387b            .dw XT_STORE
0004d9 394e            .dw XT_ZERO
0004da 381a            .dw XT_EXIT
                 PFA_NUMBER0:
0004db 3b0c          .dw XT_2TO_R
0004dc 394e          .dw XT_ZERO       ; starting value
0004dd 394e          .dw XT_ZERO
0004de 3b1b          .dw XT_2R_FROM
0004df 053e          .dw XT_TO_NUMBER ; ( 0. addr len -- d addr' len'
                     ; check length of the remaining string.
                     ; if zero: a single cell number is entered
0004e0 38b3          .dw XT_QDUP
0004e1 3830          .dw XT_DOCONDBRANCH
0004e2 04ff          DEST(PFA_NUMBER1)
                     ; if equal 1: mayba a trailing dot? --> double cell number
0004e3 3837          .dw XT_DOLITERAL
0004e4 0001          .dw 1
0004e5 3fc5          .dw XT_EQUAL
0004e6 3830          .dw XT_DOCONDBRANCH
0004e7 04f6          DEST(PFA_NUMBER2)
                 	; excatly one character is left
0004e8 3892      	.dw XT_CFETCH
0004e9 3837      	.dw XT_DOLITERAL
0004ea 002e      	.dw 46 ; .
0004eb 3fc5      	.dw XT_EQUAL
0004ec 3830      	.dw XT_DOCONDBRANCH
0004ed 04f7      	DEST(PFA_NUMBER6)
                 	; its a double cell number
                         ; incorporate sign into number
0004ee 38f0      	.dw XT_R_FROM
0004ef 3830              .dw XT_DOCONDBRANCH
0004f0 04f2      	DEST(PFA_NUMBER3)
0004f1 0210              .dw XT_DNEGATE
                 PFA_NUMBER3:
0004f2 3837      	.dw XT_DOLITERAL
0004f3 0002      	.dw 2
0004f4 3829      	.dw XT_DOBRANCH
0004f5 0506      	DEST(PFA_NUMBER5)
                 PFA_NUMBER2:
0004f6 38d3      	.dw XT_DROP
                 PFA_NUMBER6:
0004f7 3eb3      	.dw XT_2DROP
0004f8 38f0      	.dw XT_R_FROM
0004f9 38d3      	.dw XT_DROP
0004fa 38f0              .dw XT_R_FROM
0004fb 3e9e              .dw XT_BASE
0004fc 387b              .dw XT_STORE
0004fd 394e      	.dw XT_ZERO
0004fe 381a      	.dw XT_EXIT
                 PFA_NUMBER1:
0004ff 3eb3          .dw XT_2DROP ; remove the address
                     ; incorporate sign into number
000500 38f0          .dw XT_R_FROM
000501 3830          .dw XT_DOCONDBRANCH
000502 0504          DEST(PFA_NUMBER4)
000503 3e08          .dw XT_NEGATE
                 PFA_NUMBER4:
000504 3837          .dw XT_DOLITERAL
000505 0001          .dw 1
                 PFA_NUMBER5:
000506 38f0          .dw XT_R_FROM
000507 3e9e          .dw XT_BASE
000508 387b          .dw XT_STORE
000509 3945          .dw XT_TRUE
00050a 381a          .dw XT_EXIT
                 .include "words/q-sign.asm"
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 XT_QSIGN:
00050b 3800          .dw DO_COLON 
                 PFA_QSIGN:        ; ( c -- ) 
                 .endif
00050c 38c9          .dw XT_OVER    ; ( -- addr len addr )
00050d 3892          .dw XT_CFETCH
00050e 3837          .dw XT_DOLITERAL
00050f 002d          .dw '-'
000510 3fc5          .dw XT_EQUAL  ; ( -- addr len flag )
000511 38ab          .dw XT_DUP
000512 38f9          .dw XT_TO_R
000513 3830          .dw XT_DOCONDBRANCH
000514 0518          DEST(PFA_NUMBERSIGN_DONE)
000515 3837          .dw XT_DOLITERAL      ; skip sign character
000516 0001          .dw 1
000517 057c          .dw XT_SLASHSTRING
                 PFA_NUMBERSIGN_DONE:
000518 38f0          .dw XT_R_FROM
000519 381a          .dw XT_EXIT
                 .include "words/set-base.asm"
                 
                 ; Numeric IO
                 ; skip a numeric prefix character
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 XT_BASES:
00051a 384c          .dw PFA_DOCONSTANT
                 .endif
00051b 000a
00051c 0010
00051d 0002
00051e 000a          .dw 10,16,2,10 ; last one could a 8 instead.
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 XT_SET_BASE:
00051f 3800          .dw DO_COLON 
                 PFA_SET_BASE:        ; ( adr1 len1 -- adr2 len2 ) 
                 .endif
000520 38c9          .dw XT_OVER
000521 3892          .dw XT_CFETCH
000522 3837          .dw XT_DOLITERAL
000523 0023          .dw 35
000524 398d          .dw XT_MINUS
000525 38ab          .dw XT_DUP
000526 394e          .dw XT_ZERO
000527 3837          .dw XT_DOLITERAL
000528 0004          .dw 4
000529 3e38          .dw XT_WITHIN
00052a 3830          .dw XT_DOCONDBRANCH
00052b 0536          DEST(SET_BASE1)
                 	.if cpu_msp430==1
                 	.endif
00052c 051a      	.dw XT_BASES
00052d 3997      	.dw XT_PLUS
00052e 3bba      	.dw XT_FETCHI
00052f 3e9e      	.dw XT_BASE
000530 387b      	.dw XT_STORE
000531 3837      	.dw XT_DOLITERAL
000532 0001      	.dw 1
000533 057c      	.dw XT_SLASHSTRING
000534 3829      	.dw XT_DOBRANCH
000535 0537      	DEST(SET_BASE2)
                 SET_BASE1:
000536 38d3      	.dw XT_DROP
                 SET_BASE2:
000537 381a          .dw XT_EXIT 
                 
                 ; create bases 10 , 16 , 2 , 8 ,
                 ; : set-base 35 - dup 0 4 within if 
                 ;    bases + @i base ! 1 /string 
                 ;   else 
                 ;    drop
                 ;   then ;
                 .include "words/to-number.asm"
                 
                 ; Numeric IO
                 ; convert a string to a number  c-addr2/u2 is the unconverted string
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_TO_NUMBER:
000538 ff07          .dw $ff07
000539 6e3e
00053a 6d75
00053b 6562
00053c 0072          .db ">number",0
00053d 04bf          .dw VE_HEAD
                     .set VE_HEAD = VE_TO_NUMBER
                 XT_TO_NUMBER:
00053e 3800          .dw DO_COLON
                 
                 .endif
                 
00053f 38ab
000540 3830      TONUM1: .DW XT_DUP,XT_DOCONDBRANCH
000541 0557              DEST(TONUM3)
000542 38c9
000543 3892
000544 038f              .DW XT_OVER,XT_CFETCH,XT_DIGITQ
000545 3914
000546 3830              .DW XT_ZEROEQUAL,XT_DOCONDBRANCH
000547 054a              DEST(TONUM2)
000548 38d3
000549 381a              .DW XT_DROP,XT_EXIT
00054a 38f9
00054b 0235
00054c 3e9e
00054d 3873
00054e 012f      TONUM2: .DW XT_TO_R,XT_2SWAP,XT_BASE,XT_FETCH,XT_UDSTAR
00054f 38f0
000550 0127
000551 0235              .DW XT_R_FROM,XT_MPLUS,XT_2SWAP
000552 3837
000553 0001
000554 057c
000555 3829              .DW XT_DOLITERAL,1,XT_SLASHSTRING,XT_DOBRANCH
000556 053f              DEST(TONUM1)
000557 381a      TONUM3: .DW XT_EXIT
                 
                 ;C >NUMBER  ud adr u -- ud' adr' u'
                 ;C                      convert string to number
                 ;   BEGIN
                 ;   DUP WHILE
                 ;       OVER C@ DIGIT?
                 ;       0= IF DROP EXIT THEN
                 ;       >R 2SWAP BASE @ UD*
                 ;       R> M+ 2SWAP
                 ;       1 /STRING
                 ;   REPEAT ;
                 .include "words/parse.asm"
                 
                 ; String
                 ; in input buffer parse ccc delimited string by the delimiter char.
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_PARSE:
000558 ff05          .dw $ff05
000559 6170
00055a 7372
00055b 0065          .db "parse",0
00055c 0538          .dw VE_HEAD
                     .set VE_HEAD = VE_PARSE
                 XT_PARSE:
00055d 3800          .dw DO_COLON
                 PFA_PARSE:
                 .endif
00055e 38f9          .dw XT_TO_R     ; ( -- )
00055f 0572          .dw XT_SOURCE   ; ( -- addr len)
000560 3ec3          .dw XT_TO_IN     ; ( -- addr len >in)
000561 3873          .dw XT_FETCH
000562 057c          .dw XT_SLASHSTRING ; ( -- addr' len' )
                 
000563 38f0          .dw XT_R_FROM      ; ( -- addr' len' c)
000564 0448          .dw XT_CSCAN       ; ( -- addr' len'')
000565 38ab          .dw XT_DUP         ; ( -- addr' len'' len'')
000566 3a29          .dw XT_1PLUS
000567 3ec3          .dw XT_TO_IN        ; ( -- addr' len'' len'' >in)
000568 3a53          .dw XT_PLUSSTORE   ; ( -- addr' len')
000569 3837          .dw XT_DOLITERAL
00056a 0001          .dw 1
00056b 057c          .dw XT_SLASHSTRING
00056c 381a          .dw XT_EXIT
                 .include "words/source.asm"
                 
                 ; System
                 ; address and current length of the input buffer
                 VE_SOURCE:
00056d ff06          .dw $FF06
00056e 6f73
00056f 7275
000570 6563          .db "source"
000571 0558          .dw VE_HEAD
                     .set VE_HEAD = VE_SOURCE
                 XT_SOURCE:
000572 3dd8          .dw PFA_DODEFER1
                 PFA_SOURCE:
000573 0016          .dw USER_SOURCE
000574 3da2          .dw XT_UDEFERFETCH
000575 3dae          .dw XT_UDEFERSTORE
                 
                 
                 .include "words/slash-string.asm"
                 
                 ; String
                 ; adjust string from addr1 to addr1+n, reduce length from u1 to u2 by n
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SLASHSTRING:
000576 ff07          .dw $ff07
000577 732f
000578 7274
000579 6e69
00057a 0067          .db "/string",0
00057b 056d          .dw VE_HEAD
                     .set VE_HEAD = VE_SLASHSTRING
                 XT_SLASHSTRING:
00057c 3800          .dw DO_COLON
                 PFA_SLASHSTRING:
                 .endif
00057d 38db          .dw XT_ROT
00057e 38c9          .dw XT_OVER
00057f 3997          .dw XT_PLUS
000580 38db          .dw XT_ROT
000581 38db          .dw XT_ROT
000582 398d          .dw XT_MINUS
000583 381a          .dw XT_EXIT
                 
                 .include "words/parse-name.asm"
                 
                 ; String
                 ; In the SOURCE buffer parse whitespace delimited string. Returns string address within SOURCE.
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 VE_PARSENAME:
000584 ff0a          .dw $FF0A 
000585 6170
000586 7372
000587 2d65
000588 616e
000589 656d          .db "parse-name"
00058a 0576          .dw VE_HEAD
                     .set VE_HEAD = VE_PARSENAME
                 XT_PARSENAME:
00058b 3800          .dw DO_COLON 
                 PFA_PARSENAME:
                 .endif
00058c 3f3c          .dw XT_BL
00058d 058f          .dw XT_SKIPSCANCHAR
00058e 381a          .dw XT_EXIT 
                 
                 ; ( c -- addr2 len2 ) 
                 ; String
                 ; skips char and scan what's left in source for char
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 ;VE_SKIPSCANCHAR:
                 ;    .dw $FF0A 
                 ;    .db "skipscanchar"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_SKIPSCANCHAR
                 XT_SKIPSCANCHAR:
00058f 3800          .dw DO_COLON
                 PFA_SKIPSCANCHAR:
                 .endif
000590 38f9          .dw XT_TO_R
000591 0572          .dw XT_SOURCE 
000592 3ec3          .dw XT_TO_IN 
000593 3873          .dw XT_FETCH 
000594 057c          .dw XT_SLASHSTRING 
                 
000595 3902          .dw XT_R_FETCH
000596 0430          .dw XT_CSKIP
000597 38f0          .dw XT_R_FROM
000598 0448          .dw XT_CSCAN
                 
                     ; adjust >IN
000599 3eaa          .dw XT_2DUP
00059a 3997          .dw XT_PLUS
00059b 0572          .dw XT_SOURCE 
00059c 38d3          .dw XT_DROP
00059d 398d          .dw XT_MINUS
00059e 3ec3          .dw XT_TO_IN
00059f 387b          .dw XT_STORE
0005a0 381a          .dw XT_EXIT
                 .include "words/sp0.asm"
                 
                 ; Stack
                 ; start address of the data stack
                 VE_SP0:
0005a1 ff03          .dw $ff03
0005a2 7073
0005a3 0030          .db "sp0",0
0005a4 0584          .dw VE_HEAD
                     .set VE_HEAD = VE_SP0
                 XT_SP0:
0005a5 3869          .dw PFA_DOVALUE1
                 PFA_SP0:
0005a6 0006          .dw USER_SP0
0005a7 3da2          .dw XT_UDEFERFETCH
0005a8 3dae          .dw XT_UDEFERSTORE
                 
                 ; ( -- addr) 
                 ; Stack
                 ; address of user variable to store top-of-stack for inactive tasks
                 VE_SP:
0005a9 ff02          .dw $ff02
0005aa 7073          .db "sp"
0005ab 05a1          .dw VE_HEAD
                     .set VE_HEAD = VE_SP
                 XT_SP:
0005ac 3852          .dw PFA_DOUSER
                 PFA_SP:
0005ad 0008          .dw USER_SP
                 .include "words/rp0.asm"
                 
                 ; Stack
                 ; start address of return stack
                 VE_RP0:
0005ae ff03          .dw $ff03
0005af 7072
0005b0 0030          .db "rp0",0
0005b1 05a9          .dw VE_HEAD
                     .set VE_HEAD = VE_RP0
                 XT_RP0:
0005b2 3800          .dw DO_COLON
                 PFA_RP0:
0005b3 05b6          .dw XT_DORP0
0005b4 3873          .dw XT_FETCH
0005b5 381a          .dw XT_EXIT
                 
                 ; ( -- addr) 
                 ; Stack
                 ; user variable of the address of the initial return stack
                 ;VE_DORP0:
                 ;    .dw $ff05
                 ;    .db "(rp0)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DORP0
                 XT_DORP0:
0005b6 3852          .dw PFA_DOUSER
                 PFA_DORP0:
0005b7 0004          .dw USER_RP
                 .include "words/depth.asm"
                 
                 ; Stack
                 ; number of single-cell values contained in the data stack before n was placed on the stack.
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DEPTH:
0005b8 ff05          .dw $ff05
0005b9 6564
0005ba 7470
0005bb 0068          .db "depth",0
0005bc 05ae          .dw VE_HEAD
                     .set VE_HEAD = VE_DEPTH
                 XT_DEPTH:
0005bd 3800          .dw DO_COLON
                 PFA_DEPTH:
                 .endif
0005be 05a5          .dw XT_SP0
0005bf 3a7b          .dw XT_SP_FETCH
0005c0 398d          .dw XT_MINUS
0005c1 39fe          .dw XT_2SLASH
0005c2 3a2f          .dw XT_1MINUS
0005c3 381a          .dw XT_EXIT
                 .include "words/do-recognizer.asm"
                 
                 ; System
                 ; walk the recognizer stack
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DORECOGNIZER:
0005c4 ff0d          .dw $ff0d
0005c5 6f64
0005c6 722d
0005c7 6365
0005c8 676f
0005c9 696e
0005ca 657a
0005cb 0072          .db "do-recognizer",0
0005cc 05b8          .dw VE_HEAD
                     .set VE_HEAD = VE_DORECOGNIZER
                 XT_DORECOGNIZER:
0005cd 3800          .dw DO_COLON
                 PFA_DORECOGNIZER:
                 .endif
0005ce 3837          .dw XT_DOLITERAL
0005cf 05d9          .dw XT_DORECOGNIZER_A
0005d0 3837          .dw XT_DOLITERAL
0005d1 005a          .dw CFG_RECOGNIZERLISTLEN
0005d2 0983          .dw XT_MAPSTACK
0005d3 3914          .dw XT_ZEROEQUAL
0005d4 3830          .dw XT_DOCONDBRANCH
0005d5 05d8          DEST(PFA_DORECOGNIZER1)
0005d6 3eb3            .dw XT_2DROP
0005d7 066d            .dw XT_R_FAIL
                 PFA_DORECOGNIZER1:
0005d8 381a          .dw XT_EXIT
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 ; ( addr len XT -- addr len [ r:table -1 | 0 ] )
                 XT_DORECOGNIZER_A:
0005d9 3800         .dw DO_COLON
                 PFA_DORECOGNIZER_A:
                 .endif
0005da 38db         .dw XT_ROT  ; -- len xt addr
0005db 38db         .dw XT_ROT  ; -- xt addr len
0005dc 3eaa         .dw XT_2DUP 
0005dd 3b0c         .dw XT_2TO_R
0005de 38db         .dw XT_ROT  ; -- addr len xt
0005df 3824         .dw XT_EXECUTE ; -- i*x r:foo | r:fail
0005e0 3b1b         .dw XT_2R_FROM
0005e1 38db         .dw XT_ROT
0005e2 38ab         .dw XT_DUP
0005e3 066d         .dw XT_R_FAIL
0005e4 3fc5         .dw XT_EQUAL
0005e5 3830         .dw XT_DOCONDBRANCH
0005e6 05ea         DEST(PFA_DORECOGNIZER_A1)
0005e7 38d3           .dw XT_DROP
0005e8 394e           .dw XT_ZERO
0005e9 381a           .dw XT_EXIT
                 PFA_DORECOGNIZER_A1:
0005ea 38ea         .dw XT_NIP 
0005eb 38ea         .dw XT_NIP
0005ec 3945         .dw XT_TRUE
0005ed 381a         .dw XT_EXIT
                 
                 ; : do-recognizer ( addr len -- i*x r:table|r:fail )
                 ;    \ ( addr len -- addr len 0 | i*x r:table -1 )
                 ;    [: rot rot 2dup 2>r rot execute 2r> rot 
                 ;          dup r:fail = ( -- addr len r:table f )
                 ;          if drop 0 else nip nip -1 then
                 ;    ;] 
                 ;    EE_RECOGNIZERLISTLEN map-stack ( -- i*x addr len r:table f )
                 ;    0= if \ a recognizer did the job, remove addr/len
                 ;     2drop r:fail 
                 ;    then
                 ;
                 .include "words/interpret.asm"
                 
                 ; System
                 ; Interpret SOURCE word by word.
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_INTERPRET:
0005ee ff09          .dw $ff09
0005ef 6e69
0005f0 6574
0005f1 7072
0005f2 6572
0005f3 0074          .db "interpret",0
0005f4 05c4          .dw VE_HEAD
                     .set VE_HEAD = VE_INTERPRET
                 XT_INTERPRET:
0005f5 3800          .dw DO_COLON
                 .endif
                 PFA_INTERPRET:
0005f6 058b          .dw XT_PARSENAME ; ( -- addr len )
0005f7 38b3          .dw XT_QDUP   ; ( -- addr len len | addr 0)
0005f8 3830          .dw XT_DOCONDBRANCH
0005f9 0605          DEST(PFA_INTERPRET2)
0005fa 05cd          .dw XT_DORECOGNIZER
                 
0005fb 3e98          .dw XT_STATE
0005fc 3873          .dw XT_FETCH
0005fd 3830          .dw XT_DOCONDBRANCH
0005fe 0600          DEST(PFA_INTERPRET1)
0005ff 3a29            .dw XT_1PLUS   ; we need the compile action
                     .if cpu_msp430==1
                     .endif
                 PFA_INTERPRET1:
000600 3bba          .dw XT_FETCHI
000601 3824          .dw XT_EXECUTE
000602 3f73          .dw XT_QSTACK
000603 3829          .dw XT_DOBRANCH
000604 05f6          DEST(PFA_INTERPRET)
                 PFA_INTERPRET2:
000605 38d3          .dw XT_DROP
000606 381a          .dw XT_EXIT
                 .include "words/r-intnumber.asm"
                 
                 ; Interpreter
                 ; Method table for single cell integers
                 
                 
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_R_NUM:
000607 ff05          .dw $ff05
000608 3a72
000609 756e
00060a 006d          .db "r:num",0
00060b 05ee          .dw VE_HEAD
                     .set VE_HEAD = VE_R_NUM
                 XT_R_NUM:
00060c 384c          .dw PFA_DOCONSTANT
                 PFA_R_NUM:
                 .endif
00060d 018a          .dw XT_NOOP    ; interpret
00060e 074c          .dw XT_LITERAL ; compile
00060f 0619          .dw XT_FAILNUM ; postpone
                 
                 ; ( -- addr )
                 ; Interpreter
                 ; Method table for double cell integers
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_R_DNUM:
000610 ff06          .dw $ff06
000611 3a72
000612 6e64
000613 6d75          .db "r:dnum"
000614 0607          .dw VE_HEAD
                     .set VE_HEAD = VE_R_DNUM
                 XT_R_DNUM:
000615 384c          .dw PFA_DOCONSTANT
                 PFA_R_DNUM:
                 .endif
000616 018a          .dw XT_NOOP     ; interpret
000617 3fb9          .dw XT_2LITERAL ; compile
000618 061f          .dw XT_FAILDNUM ; postpone
                 
                 ; ( -- addr )
                 ; Interpreter
                 ; Method to print a number and throw exception "invalid postpone"
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 ;VE_FAILNUM:
                 ;    .dw $ff06
                 ;    .db "fail:i"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_FAILNUM
                 XT_FAILNUM:
000619 3800          .dw DO_COLON
                 PFA_FAILNUM:
                 .endif
00061a 035e          .dw XT_DOT
00061b 3837          .dw XT_DOLITERAL
00061c ffd0          .dw -48
00061d 3d60          .dw XT_THROW
00061e 381a          .dw XT_EXIT
                 
                 ; ( -- addr )
                 ; Interpreter
                 ; Method to print a double cell number and throw exception "invalid postpone"
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 VE_FAILDNUM:
                 ;    .dw $ff06
                 ;    .db "fail:d"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_FAILDNUM
                 XT_FAILDNUM:
00061f 3800          .dw DO_COLON
                 PFA_FAILDNUM:
                 .endif
000620 0356          .dw XT_DDOT
000621 3837          .dw XT_DOLITERAL
000622 ffd0          .dw -48
000623 3d60          .dw XT_THROW
000624 381a          .dw XT_EXIT
                 
                 ; ( addr len -- f )
                 ; Interpreter
                 ; recognizer for integer numbers
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 VE_REC_NUM:
000625 ff07          .dw $ff07
000626 6572
000627 3a63
000628 756e
000629 006d          .db "rec:num",0
00062a 0610          .dw VE_HEAD
                     .set VE_HEAD = VE_REC_NUM
                 XT_REC_NUM:
00062b 3800          .dw DO_COLON
                 PFA_REC_NUM:
                 .endif
                     ; try converting to a number
00062c 04c4          .dw XT_NUMBER
00062d 3830          .dw XT_DOCONDBRANCH
00062e 0638          DEST(PFA_REC_NONUMBER)
00062f 3837          .dw XT_DOLITERAL
000630 0001          .dw 1
000631 3fc5          .dw XT_EQUAL
000632 3830          .dw XT_DOCONDBRANCH
000633 0636          DEST(PFA_REC_INTNUM2)
000634 060c            .dw XT_R_NUM
000635 381a            .dw XT_EXIT
                 PFA_REC_INTNUM2:
000636 0615            .dw XT_R_DNUM
000637 381a            .dw XT_EXIT
                 PFA_REC_NONUMBER:
000638 066d          .dw XT_R_FAIL
000639 381a          .dw XT_EXIT
                 .include "words/r-word.asm"
                 
                 ; Interpreter
                 ; search for a word
                 .if cpu_msp430==1
                 .endif
                 .if cpu_avr8==1
                 VE_REC_WORD:
00063a ff08          .dw $ff08
00063b 6572
00063c 3a63
00063d 6f77
00063e 6472          .db "rec:word"
00063f 0625          .dw VE_HEAD
                     .set VE_HEAD = VE_REC_WORD
                 XT_REC_WORD:
000640 3800          .dw DO_COLON
                 PFA_REC_WORD:
                 .endif
000641 06e3          .DW XT_FINDNAME
000642 38ab          .dw XT_DUP
000643 3914          .dw XT_ZEROEQUAL
000644 3830          .dw XT_DOCONDBRANCH
000645 0649          DEST(PFA_REC_WORD_FOUND)
000646 38d3              .dw XT_DROP
000647 066d      	.dw XT_R_FAIL
000648 381a      	.dw XT_EXIT
                 PFA_REC_WORD_FOUND:
000649 0650          .dw XT_R_WORD
                 
00064a 381a          .dw XT_EXIT
                 
                 ; ( -- addr )
                 ; Interpreter
                 ; actions to handle execution tokens and their flags
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_R_WORD:
00064b ff06          .dw $ff06
00064c 3a72
00064d 6f77
00064e 6472          .db "r:word"
00064f 063a          .dw VE_HEAD
                     .set VE_HEAD = VE_R_WORD
                 XT_R_WORD:
000650 384c          .dw PFA_DOCONSTANT
                 PFA_R_WORD:
                 .endif
000651 0654          .dw XT_R_WORD_INTERPRET
000652 0658          .dw XT_R_WORD_COMPILE
000653 0660          .dw XT_R_WORD_POSTPONE
                 
                 ; ( XT flags -- )
                 ; Interpreter
                 ; interpret method for WORD recognizer
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 XT_R_WORD_INTERPRET:
000654 3800          .dw DO_COLON
                 PFA_R_WORD_INTERPRET:
                 .endif
000655 38d3          .dw XT_DROP ; the flags are in the way
000656 3824          .dw XT_EXECUTE
000657 381a          .dw XT_EXIT
                 
                 ; ( XT flags -- )
                 ; Interpreter
                 ; Compile method for WORD recognizer
                 .if cpu_msp430==1
                 .endif
                 .if cpu_avr8==1
                 XT_R_WORD_COMPILE:
000658 3800          .dw DO_COLON
                 PFA_R_WORD_COMPILE:
                 .endif
000659 391b          .dw XT_ZEROLESS
00065a 3830          .dw XT_DOCONDBRANCH
00065b 065e          DEST(PFA_R_WORD_COMPILE1)
00065c 0734      	.dw XT_COMMA
00065d 381a              .dw XT_EXIT
                 PFA_R_WORD_COMPILE1:
00065e 3824              .dw XT_EXECUTE
00065f 381a          .dw XT_EXIT
                 
                 ; ( XT flags -- )
                 ; Interpreter
                 ; Postpone method for WORD recognizer
                 .if cpu_msp430==1
                 .endif
                 .if cpu_avr8==1
                 XT_R_WORD_POSTPONE:
000660 3800          .dw DO_COLON
                 PFA_R_WORD_POSTPONE:
                 .endif
000661 391b          .dw XT_ZEROLESS
000662 3830          .dw XT_DOCONDBRANCH
000663 0666          DEST(PFA_R_WORD_POSTPONE1)
000664 0729            .dw XT_COMPILE
000665 0729            .dw XT_COMPILE
                 PFA_R_WORD_POSTPONE1:
000666 0734          .dw XT_COMMA
000667 381a          .dw XT_EXIT
                 .include "words/r-fail.asm"
                 
                 ; Interpreter
                 ; there is no parser for this recognizer, this is the default and failsafe part
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_R_FAIL:
000668 ff06          .dw $ff06
000669 3a72
00066a 6166
00066b 6c69          .db "r:fail"
00066c 064b          .dw VE_HEAD
                     .set VE_HEAD = VE_R_FAIL
                 XT_R_FAIL:
00066d 384c          .dw PFA_DOCONSTANT
                 PFA_R_FAIL:
                 .endif
00066e 0671          .dw XT_FAIL  ; interpret
00066f 0671          .dw XT_FAIL  ; compile
000670 0671          .dw XT_FAIL  ; postpone
                 
                 ; ( addr len -- )
                 ; Interpreter
                 ; default failure action: throw exception -13.
                 .if cpu_msp430==1
                 .endif
                 .if cpu_avr8==1
                 ;VE_FAIL:
                 ;    .dw $ff04
                 ;    .db "fail"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_FAIL
                 XT_FAIL:
000671 3800          .dw DO_COLON
                 PFA_FAIL:
                 .endif
000672 3837          .dw XT_DOLITERAL
000673 fff3          .dw -13
000674 3d60          .dw XT_THROW
                 .include "words/search-wordlist.asm"
                 
                 ; Search Order
                 ; searches the word list wid for the word at c-addr/len
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SEARCH_WORDLIST:
000675 ff0f          .dw $ff0f
000676 6573
000677 7261
000678 6863
000679 772d
00067a 726f
00067b 6c64
00067c 7369
00067d 0074          .db "search-wordlist",0
00067e 0668          .dw VE_HEAD
                     .set VE_HEAD = VE_SEARCH_WORDLIST
                 XT_SEARCH_WORDLIST:
00067f 3800          .dw DO_COLON
                 PFA_SEARCH_WORDLIST:
                 .endif
000680 38f9          .dw XT_TO_R
000681 394e          .dw XT_ZERO
000682 3837          .dw XT_DOLITERAL
000683 0694          .dw XT_ISWORD
000684 38f0          .dw XT_R_FROM
000685 06b1          .dw XT_TRAVERSEWORDLIST
000686 38ab          .dw XT_DUP
000687 3914          .dw XT_ZEROEQUAL
000688 3830          .dw XT_DOCONDBRANCH
000689 068e          DEST(PFA_SEARCH_WORDLIST1)
00068a 3eb3             .dw XT_2DROP
00068b 38d3             .dw XT_DROP
00068c 394e             .dw XT_ZERO
00068d 381a             .dw XT_EXIT
                 PFA_SEARCH_WORDLIST1:
                       ; ... get the XT ...
00068e 38ab            .dw XT_DUP
00068f 06d8            .dw XT_NFA2CFA
                       ; .. and get the header flag
000690 38be            .dw XT_SWAP
000691 0165            .dw XT_NAME2FLAGS
000692 0152            .dw XT_IMMEDIATEQ
000693 381a          .dw XT_EXIT
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 XT_ISWORD:
000694 3800          .dw DO_COLON
                 PFA_ISWORD:
                 .endif
                     ; ( c-addr len 0 nt -- c-addr len 0 true| nt false )
000695 38f9          .dw XT_TO_R
000696 38d3          .dw XT_DROP
000697 3eaa          .dw XT_2DUP
000698 3902          .dw XT_R_FETCH  ; -- addr len addr len nt
000699 06cc          .dw XT_NAME2STRING
00069a 01b7          .dw XT_ICOMPARE      ; (-- addr len f )
00069b 3830          .dw XT_DOCONDBRANCH
00069c 06a2          DEST(PFA_ISWORD3)
                       ; not now
00069d 38f0            .dw XT_R_FROM
00069e 38d3            .dw XT_DROP
00069f 394e            .dw XT_ZERO
0006a0 3945            .dw XT_TRUE         ; maybe next word
0006a1 381a            .dw XT_EXIT
                 PFA_ISWORD3:
                       ; we found the word, now clean up iteration data ...
0006a2 3eb3            .dw XT_2DROP
0006a3 38f0            .dw XT_R_FROM
0006a4 394e            .dw XT_ZERO       ; finish traverse-wordlist
0006a5 381a            .dw XT_EXIT
                 .include "words/traverse-wordlist.asm"
                 
                 ; Tools Ext (2012)
                 ; call the xt for every member of the wordlist wid until xt returns false
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_TRAVERSEWORDLIST:
0006a6 ff11          .dw $ff11
0006a7 7274
0006a8 7661
0006a9 7265
0006aa 6573
0006ab 772d
0006ac 726f
0006ad 6c64
0006ae 7369
0006af 0074          .db "traverse-wordlist",0
0006b0 0675          .dw VE_HEAD
                     .set VE_HEAD = VE_TRAVERSEWORDLIST
                 XT_TRAVERSEWORDLIST:
0006b1 3800          .dw DO_COLON
                 PFA_TRAVERSEWORDLIST:
                 
                 .endif
0006b2 3b4d          .dw XT_FETCHE
                 PFA_TRAVERSEWORDLIST1:
0006b3 38ab          .dw XT_DUP           ; ( -- xt nt nt )
0006b4 3830          .dw XT_DOCONDBRANCH  ; ( -- nt ) is nfa = counted string
0006b5 06c2          DEST(PFA_TRAVERSEWORDLIST2)
0006b6 3eaa          .dw XT_2DUP
0006b7 3b0c          .dw XT_2TO_R
0006b8 38be          .dw XT_SWAP
0006b9 3824          .dw XT_EXECUTE
0006ba 3b1b          .dw XT_2R_FROM
0006bb 38db          .dw XT_ROT
0006bc 3830          .dw XT_DOCONDBRANCH
0006bd 06c2          DEST(PFA_TRAVERSEWORDLIST2)
0006be 09ea          .dw XT_NFA2LFA
0006bf 3bba          .dw XT_FETCHI
0006c0 3829          .dw XT_DOBRANCH      ; ( -- addr )
0006c1 06b3          DEST(PFA_TRAVERSEWORDLIST1)       ; ( -- addr )
                 PFA_TRAVERSEWORDLIST2:
0006c2 3eb3          .dw XT_2DROP
0006c3 381a          .dw XT_EXIT
                 
                 ; : traverse-wordlist ( i*x xt wid -- i*x' ) 
                 ;        begin @ dup 
                 ;        while 
                 ;          2dup 2>r 
                 ;          cell + swap execute ( i*x nt -- i*x' f ) 
                 ;          2r> rot 
                 ;        while repeat then 2drop ; 
                 .include "words/name2string.asm"
                 
                 ; Tools Ext (2012)
                 ; get a (flash) string from a name token nt
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_NAME2STRING:
0006c4 ff0b          .dw $ff0b
0006c5 616e
0006c6 656d
0006c7 733e
0006c8 7274
0006c9 6e69
0006ca 0067          .db "name>string",0
0006cb 06a6          .dw VE_HEAD
                     .set VE_HEAD = VE_NAME2STRING
                 XT_NAME2STRING:
0006cc 3800          .dw DO_COLON
                 PFA_NAME2STRING:
                 
                 .endif
0006cd 0408          .dw XT_ICOUNT   ; ( -- addr n )
0006ce 3837          .dw XT_DOLITERAL
0006cf 00ff          .dw 255
0006d0 3a0d          .dw XT_AND      ; mask immediate bit
0006d1 381a          .dw XT_EXIT
                 .include "words/nfa2cfa.asm"
                 
                 ; Tools
                 ; get the XT from a name token
                 VE_NFA2CFA:
0006d2 ff07          .dw $ff07
0006d3 666e
0006d4 3e61
0006d5 6663
../../avr8\words/nfa2cfa.asm(6): warning: .cseg .db misalignment - padding zero byte
0006d6 0061          .db "nfa>cfa"
0006d7 06c4          .dw VE_HEAD
                     .set VE_HEAD = VE_NFA2CFA
                 XT_NFA2CFA:
0006d8 3800          .dw DO_COLON
                 PFA_NFA2CFA:
0006d9 09ea          .dw XT_NFA2LFA ; skip to link field
0006da 3a29          .dw XT_1PLUS   ; next is the execution token
0006db 381a          .dw XT_EXIT
                 .include "words/find-name.asm"
                 
                 ; Tools
                 ; search wordlists for an entry with the name from c-addr/len
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_FINDNAME:
0006dc ff09          .dw $ff09
0006dd 6966
0006de 646e
0006df 6e2d
0006e0 6d61
0006e1 0065          .db "find-name",0
0006e2 06d2          .dw VE_HEAD
                     .set VE_HEAD = VE_FINDNAME
                 XT_FINDNAME:
0006e3 3800          .dw DO_COLON
                 PFA_FINDNAME:
                 .endif
0006e4 3837          .dw XT_DOLITERAL
0006e5 06ef          .dw XT_FINDNAMEA
0006e6 3837          .dw XT_DOLITERAL
0006e7 0048          .dw CFG_ORDERLISTLEN
0006e8 0983          .dw XT_MAPSTACK
0006e9 3914          .dw XT_ZEROEQUAL
0006ea 3830          .dw XT_DOCONDBRANCH
0006eb 06ee          DEST(PFA_FINDNAME1)
0006ec 3eb3            .dw XT_2DROP
0006ed 394e            .dw XT_ZERO
                 PFA_FINDNAME1:
0006ee 381a          .dw XT_EXIT
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 XT_FINDNAMEA:
0006ef 3800          .dw DO_COLON
                 PFA_FINDNAMEA:
                 .endif
0006f0 38f9          .dw XT_TO_R
0006f1 3eaa          .dw XT_2DUP
0006f2 38f0          .dw XT_R_FROM
0006f3 067f          .dw XT_SEARCH_WORDLIST
0006f4 38ab          .dw XT_DUP
0006f5 3830          .dw XT_DOCONDBRANCH
0006f6 06fc          DEST(PFA_FINDNAMEA1)
0006f7 38f9            .dw XT_TO_R
0006f8 38ea            .dw XT_NIP
0006f9 38ea            .dw XT_NIP
0006fa 38f0            .dw XT_R_FROM
0006fb 3945            .dw XT_TRUE
                 PFA_FINDNAMEA1:
0006fc 381a          .dw XT_EXIT
                 
                 .include "dict/compiler1.inc"
                 
                 .include "words/docreate.asm"
                 
                 ; Compiler
                 ; parse the input and create an empty vocabulary entry without XT and data field (PF)
                 VE_DOCREATE:
0006fd ff08          .dw $ff08
0006fe 6328
0006ff 6572
000700 7461
000701 2965          .db "(create)"
000702 06dc          .dw VE_HEAD
                     .set VE_HEAD = VE_DOCREATE
                 XT_DOCREATE:
000703 3800          .dw DO_COLON
                 PFA_DOCREATE:
000704 058b          .dw XT_PARSENAME
000705 0864          .dw XT_WLSCOPE
000706 38ab          .dw XT_DUP
000707 38f9          .dw XT_TO_R
000708 0849          .dw XT_HEADER
000709 38f0          .dw XT_R_FROM
                 .dseg
000173           COLON_SMUDGE: .byte 4
                 .cseg
00070a 3837          .dw XT_DOLITERAL
00070b 0175          .dw COLON_SMUDGE+2
00070c 387b          .dw XT_STORE		; save wid
00070d 3837          .dw XT_DOLITERAL
00070e 0173          .dw COLON_SMUDGE+0
00070f 387b          .dw XT_STORE		; save NFA
                 
000710 381a          .dw XT_EXIT
                 .include "words/backslash.asm"
                 
                 ; Compiler
                 ; everything up to the end of the current line is a comment
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_BACKSLASH:
000711 0001          .dw $0001
000712 005c          .db $5c,0
000713 06fd          .dw VE_HEAD
                     .set VE_HEAD = VE_BACKSLASH
                 XT_BACKSLASH:
000714 3800          .dw DO_COLON
                 PFA_BACKSLASH:
                 .endif
000715 0572          .dw XT_SOURCE
000716 38ea          .dw XT_NIP
000717 3ec3          .dw XT_TO_IN
000718 387b          .dw XT_STORE
000719 381a          .dw XT_EXIT
                 .include "words/l-paren.asm"
                 
                 ; Compiler
                 ; skip everything up to the closing bracket on the same line
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_LPAREN:
00071a 0001          .dw $0001
00071b 0028          .db "(" ,0
00071c 0711          .dw VE_HEAD
                     .set VE_HEAD = VE_LPAREN
                 XT_LPAREN:
00071d 3800          .dw DO_COLON
                 PFA_LPAREN:
                 .endif
00071e 3837          .dw XT_DOLITERAL
00071f 0029          .dw ')'
000720 055d          .dw XT_PARSE
000721 3eb3          .dw XT_2DROP
000722 381a          .dw XT_EXIT
                 
                 .include "words/compile.asm"
                 
                 ; Dictionary
                 ; read the following cell from the dictionary and append it to the current dictionary position.
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_COMPILE:
000723 ff07          .dw $ff07
000724 6f63
000725 706d
000726 6c69
000727 0065          .db "compile",0
000728 071a          .dw  VE_HEAD
                     .set VE_HEAD = VE_COMPILE
                 XT_COMPILE:
000729 3800          .dw DO_COLON
                 PFA_COMPILE:
                 .endif
00072a 38f0          .dw XT_R_FROM
00072b 38ab          .dw XT_DUP
                 .if cpu_msp430==1
                 .endif
                 .if cpu_avr8==1
00072c 3a29          .dw XT_1PLUS
                 .endif
00072d 38f9          .dw XT_TO_R
00072e 3bba          .dw XT_FETCHI
00072f 0734          .dw XT_COMMA
000730 381a          .dw XT_EXIT
                 .include "words/comma.asm"
                 
                 ; Dictionary
                 ; compile 16 bit into flash at DP
                 VE_COMMA:
000731 ff01          .dw $ff01
000732 002c          .db ',',0 ; ,
000733 0723          .dw VE_HEAD
                     .set VE_HEAD = VE_COMMA
                 XT_COMMA:
000734 3800          .dw DO_COLON
                 PFA_COMMA:
000735 3ef9          .dw XT_DP
000736 3b61          .dw XT_STOREI
000737 3ef9          .dw XT_DP
000738 3a29          .dw XT_1PLUS
000739 01a5          .dw XT_DOTO
00073a 3efa          .dw PFA_DP
00073b 381a          .dw XT_EXIT
                 .include "words/brackettick.asm"
                 
                 ; Compiler
                 ; what ' does in the interpreter mode, do in colon definitions
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_BRACKETTICK:
00073c 0003          .dw $0003
00073d 275b
00073e 005d          .db "[']",0
00073f 0731          .dw VE_HEAD
                     .set VE_HEAD = VE_BRACKETTICK
                 XT_BRACKETTICK:
000740 3800          .dw DO_COLON
                 PFA_BRACKETTICK:
                 .endif
000741 0729          .dw XT_COMPILE
000742 3837          .dw XT_DOLITERAL
000743 0421          .dw XT_TICK
000744 0734          .dw XT_COMMA
000745 381a          .dw XT_EXIT
                 
                 
                 .include "words/literal.asm"
                 
                 ; Compiler
                 ; compile a literal in colon defintions
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_LITERAL:
000746 0007          .dw $0007
000747 696c
000748 6574
000749 6172
00074a 006c          .db "literal",0
00074b 073c          .dw VE_HEAD
                     .set VE_HEAD = VE_LITERAL
                 XT_LITERAL:
00074c 3800          .dw DO_COLON
                 PFA_LITERAL:
                 .endif
00074d 3e98
00074e 3873
00074f 3830              .DW XT_STATE,XT_FETCH,XT_DOCONDBRANCH
000750 0754              DEST(LITER1)
000751 0729
000752 3837
000753 0734              .DW XT_COMPILE,XT_DOLITERAL,XT_COMMA
000754 381a      LITER1: .DW XT_EXIT
                 .include "words/sliteral.asm"
                 
                 ; String
                 ; compiles a string to flash, at runtime leaves ( -- flash-addr count) on stack
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SLITERAL:
000755 0008        .dw $0008
000756 6c73
000757 7469
000758 7265
000759 6c61        .db "sliteral"
00075a 0746        .dw VE_HEAD
                   .set VE_HEAD = VE_SLITERAL
                 XT_SLITERAL:
00075b 3800          .dw DO_COLON
                 PFA_SLITERAL:
                 .endif
00075c 0729          .dw XT_COMPILE
00075d 03a9          .dw XT_DOSLITERAL    ; ( -- addr n)
00075e 03b7          .dw XT_SCOMMA
00075f 381a          .dw XT_EXIT
                 .include "words/g-mark.asm"
                 
                 ; Compiler
                 ; places current dictionary position for backward resolves
                 ;VE_GMARK:
                 ;    .dw $ff05
                 ;    .db ">mark"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_GMARK
                 XT_GMARK:
000760 3800          .dw DO_COLON
                 PFA_GMARK:
000761 3ef9          .dw XT_DP
000762 0729          .dw XT_COMPILE
000763 ffff          .dw -1           ; ffff does not erase flash
000764 381a          .dw XT_EXIT
                 .include "words/g-resolve.asm"
                 
                 ; Compiler
                 ; resolve backward jumps
                 ;VE_GRESOLVE:
                 ;    .dw $ff08
                 ;    .db ">resolve"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_GRESOLVE
                 XT_GRESOLVE:
000765 3800          .dw DO_COLON
                 PFA_GRESOLVE:
000766 3f73          .dw XT_QSTACK
000767 3ef9          .dw XT_DP
000768 38be          .dw XT_SWAP
000769 3b61          .dw XT_STOREI
00076a 381a          .dw XT_EXIT
                 .include "words/l_mark.asm"
                 
                 ; Compiler
                 ; place destination for backward branch
                 ;VE_LMARK:
                 ;    .dw $ff05
                 ;    .db "<mark"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_LMARK
                 XT_LMARK:
00076b 3800          .dw DO_COLON
                 PFA_LMARK:
00076c 3ef9          .dw XT_DP
00076d 381a          .dw XT_EXIT
                 .include "words/l_resolve.asm"
                 
                 ; Compiler
                 ; resolve backward branch
                 ;VE_LRESOLVE:
                 ;    .dw $ff08
                 ;    .db "<resolve"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_LRESOLVE
                 XT_LRESOLVE:
00076e 3800          .dw DO_COLON
                 PFA_LRESOLVE:
00076f 3f73          .dw XT_QSTACK
000770 0734          .dw XT_COMMA
000771 381a          .dw XT_EXIT
                 
                 .include "words/ahead.asm"
                 
                 ; Compiler
                 ; do a unconditional branch
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_AHEAD:
000772 0005          .dw $0005
000773 6861
000774 6165
000775 0064          .db "ahead",0
000776 0755          .dw VE_HEAD
                     .set VE_HEAD = VE_AHEAD
                 XT_AHEAD:
000777 3800          .dw DO_COLON
                 PFA_AHEAD:
                 .endif
000778 0729          .dw XT_COMPILE
000779 3829          .dw XT_DOBRANCH
00077a 0760          .dw XT_GMARK
00077b 381a          .dw XT_EXIT
                 .include "words/if.asm"
                 
                 ; Compiler
                 ; start conditional branch
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_IF:
00077c 0002          .dw $0002
00077d 6669          .db "if"
00077e 0772          .dw VE_HEAD
                     .set VE_HEAD = VE_IF
                 XT_IF:
00077f 3800          .dw DO_COLON
                 PFA_IF:
                 .endif
000780 0729          .dw XT_COMPILE
000781 3830          .dw XT_DOCONDBRANCH
000782 0760          .dw XT_GMARK
000783 381a          .dw XT_EXIT
                 .include "words/else.asm"
                 
                 ; Compiler
                 ; resolve the forward reference and place a new unresolved forward reference
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_ELSE:
000784 0004          .dw $0004
000785 6c65
000786 6573          .db "else"
000787 077c          .dw VE_HEAD
                     .set VE_HEAD = VE_ELSE
                 XT_ELSE:
000788 3800          .dw DO_COLON
                 PFA_ELSE:
                 .endif
000789 0729          .dw XT_COMPILE
00078a 3829          .dw XT_DOBRANCH
00078b 0760          .dw XT_GMARK
00078c 38be          .dw XT_SWAP
00078d 0765          .dw XT_GRESOLVE
00078e 381a          .dw XT_EXIT
                 .include "words/then.asm"
                 
                 ; Compiler
                 ; finish if
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_THEN:
00078f 0004          .dw $0004
000790 6874
000791 6e65          .db "then"
000792 0784          .dw VE_HEAD
                     .set VE_HEAD = VE_THEN
                 XT_THEN:
000793 3800          .dw DO_COLON
                 PFA_THEN:
                 .endif
000794 0765          .dw XT_GRESOLVE
000795 381a          .dw XT_EXIT
                 .include "words/begin.asm"
                 
                 ; Compiler
                 ; put the next location for a transfer of control onto the control flow stack
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_BEGIN:
000796 0005          .dw $0005
000797 6562
000798 6967
000799 006e          .db "begin",0
00079a 078f          .dw VE_HEAD
                     .set VE_HEAD = VE_BEGIN
                 XT_BEGIN:
00079b 3800          .dw DO_COLON
                 PFA_BEGIN:
                 .endif
00079c 076b          .dw XT_LMARK
00079d 381a          .dw XT_EXIT
                 .include "words/while.asm"
                 
                 ; Compiler
                 ; at runtime skip until repeat if non-true
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_WHILE:
00079e 0005          .dw $0005
00079f 6877
0007a0 6c69
0007a1 0065          .db "while",0
0007a2 0796          .dw VE_HEAD
                     .set VE_HEAD = VE_WHILE
                 XT_WHILE:
0007a3 3800          .dw DO_COLON
                 PFA_WHILE:
                 .endif
0007a4 077f          .dw XT_IF
0007a5 38be          .dw XT_SWAP
0007a6 381a          .dw XT_EXIT
                 .include "words/repeat.asm"
                 
                 ; Compiler
                 ; continue execution at dest, resolve orig
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_REPEAT:
0007a7 0006          .dw $0006
0007a8 6572
0007a9 6570
0007aa 7461          .db "repeat"
0007ab 079e          .dw VE_HEAD
                     .set VE_HEAD = VE_REPEAT
                 XT_REPEAT:
0007ac 3800          .dw DO_COLON
                 PFA_REPEAT:
                 .endif
0007ad 07c0          .dw XT_AGAIN
0007ae 0793          .dw XT_THEN
0007af 381a          .dw XT_EXIT
                 .include "words/until.asm"
                 
                 ; Compiler
                 ; finish begin with conditional branch, leaves the loop if true flag at runtime
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_UNTIL:
0007b0 0005          .dw $0005
0007b1 6e75
0007b2 6974
0007b3 006c          .db "until",0
0007b4 07a7          .dw VE_HEAD
                     .set VE_HEAD = VE_UNTIL
                 XT_UNTIL:
0007b5 3800          .dw DO_COLON
                 PFA_UNTIL:
                 .endif
0007b6 3837          .dw XT_DOLITERAL
0007b7 3830          .dw XT_DOCONDBRANCH
0007b8 0734          .dw XT_COMMA
                 
0007b9 076e          .dw XT_LRESOLVE
0007ba 381a          .dw XT_EXIT
                 .include "words/again.asm"
                 
                 ; Compiler
                 ; compile a jump back to dest
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_AGAIN:
0007bb 0005          .dw $0005
0007bc 6761
0007bd 6961
0007be 006e          .db "again",0
0007bf 07b0          .dw VE_HEAD
                     .set VE_HEAD = VE_AGAIN
                 XT_AGAIN:
0007c0 3800          .dw DO_COLON
                 PFA_AGAIN:
                 .endif
0007c1 0729          .dw XT_COMPILE
0007c2 3829          .dw XT_DOBRANCH
0007c3 076e          .dw XT_LRESOLVE
0007c4 381a          .dw XT_EXIT
                 .include "words/do.asm"
                 
                 ; Compiler
                 ; start do .. [+]loop
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DO:
0007c5 0002          .dw $0002
0007c6 6f64          .db "do"
0007c7 07bb          .dw VE_HEAD
                     .set VE_HEAD = VE_DO
                 XT_DO:
0007c8 3800          .dw DO_COLON
                 PFA_DO:
                 
                 .endif
0007c9 0729          .dw XT_COMPILE
0007ca 3a89          .dw XT_DODO
0007cb 076b          .dw XT_LMARK
0007cc 394e          .dw XT_ZERO
0007cd 0823          .dw XT_TO_L
0007ce 381a          .dw XT_EXIT
                 .include "words/loop.asm"
                 
                 ; Compiler
                 ; compile (loop) and resolve the backward branch
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_LOOP:
0007cf 0004          .dw $0004
0007d0 6f6c
0007d1 706f          .db "loop"
0007d2 07c5          .dw VE_HEAD
                     .set VE_HEAD = VE_LOOP
                 XT_LOOP:
0007d3 3800          .dw DO_COLON
                 PFA_LOOP:
                 .endif
0007d4 0729          .dw XT_COMPILE
0007d5 3ab7          .dw XT_DOLOOP
0007d6 080a          .dw XT_ENDLOOP
0007d7 381a          .dw XT_EXIT
                 .include "words/plusloop.asm"
                 
                 ; Compiler
                 ; compile (+loop) and resolve branches
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_PLUSLOOP:
0007d8 0005          .dw $0005
0007d9 6c2b
0007da 6f6f
0007db 0070          .db "+loop",0
0007dc 07cf          .dw VE_HEAD
                     .set VE_HEAD = VE_PLUSLOOP
                 XT_PLUSLOOP:
0007dd 3800          .dw DO_COLON
                 PFA_PLUSLOOP:
                 .endif
0007de 0729          .dw XT_COMPILE
0007df 3aa8          .dw XT_DOPLUSLOOP
0007e0 080a          .dw XT_ENDLOOP
0007e1 381a          .dw XT_EXIT
                 .include "words/leave.asm"
                 
                 ; Compiler
                 ; immediatly leave the current DO..LOOP
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_LEAVE:
0007e2 0005         .dw $0005
0007e3 656c
0007e4 7661
0007e5 0065         .db "leave",0
0007e6 07d8         .dw VE_HEAD
                    .set VE_HEAD = VE_LEAVE
                 XT_LEAVE:
0007e7 3800          .dw DO_COLON
                 PFA_LEAVE:
                 .endif
0007e8 0729
0007e9 3ac2          .DW XT_COMPILE,XT_UNLOOP
0007ea 0777
0007eb 0823
0007ec 381a          .DW XT_AHEAD,XT_TO_L,XT_EXIT
                 .include "words/qdo.asm"
                 
                 ; Compiler
                 ; start a ?do .. [+]loop control structure
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 VE_QDO:
0007ed 0003          .dw $0003
0007ee 643f
0007ef 006f          .db "?do",0
0007f0 07e2          .dw VE_HEAD
                     .set VE_HEAD = VE_QDO
                 XT_QDO:
0007f1 3800          .dw DO_COLON
                 PFA_QDO:
                 .endif
0007f2 0729          .dw XT_COMPILE
0007f3 07f9          .dw XT_QDOCHECK
0007f4 077f          .dw XT_IF
0007f5 07c8          .dw XT_DO
0007f6 38be          .dw XT_SWAP    ; DO sets a 0 marker on the leave stack
0007f7 0823          .dw XT_TO_L    ; then follows at the end.
0007f8 381a          .dw XT_EXIT
                 
                 ; there is no special runtime for ?do, the do runtime
                 ; gets wrapped with the sequence
                 ; ... ?do-check if do ..... loop then
                 ; with
                 ; : ?do-check ( n1 n2 -- n1 n2 true | false )
                 ;   2dup = dup >r if 2drop then r> invert ;
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 XT_QDOCHECK:
0007f9 3800          .dw DO_COLON
                 PFA_QDOCHECK:
                 .endif
0007fa 3eaa          .dw XT_2DUP
0007fb 3fc5          .dw XT_EQUAL
0007fc 38ab          .dw XT_DUP
0007fd 38f9          .dw XT_TO_R
0007fe 3830          .dw XT_DOCONDBRANCH
0007ff 0801          DEST(PFA_QDOCHECK1)
000800 3eb3          .dw XT_2DROP
                 PFA_QDOCHECK1:
000801 38f0          .dw XT_R_FROM
000802 39f7          .dw XT_INVERT
000803 381a          .dw XT_EXIT
                 .include "words/endloop.asm"
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_ENDLOOP:
000804 ff07          .dw $ff07
000805 6e65
000806 6c64
000807 6f6f
000808 0070          .db "endloop",0
000809 07ed          .dw VE_HEAD
                     .set VE_HEAD = VE_ENDLOOP
                 XT_ENDLOOP:
00080a 3800          .dw DO_COLON
                 PFA_ENDLOOP:
                 .endif
                 ;Z ENDLOOP   adrs xt --   L: 0 a1 a2 .. aN --
                 ;   <resolve                backward loop
                 ;   BEGIN L> ?DUP WHILE POSTPONE THEN REPEAT ;
                 ;                                 resolve LEAVEs
                 ; This is a common factor of LOOP and +LOOP.
                 
00080b 076e              .DW XT_LRESOLVE
00080c 0817
00080d 38b3
00080e 3830      LOOP1:  .DW XT_L_FROM,XT_QDUP,XT_DOCONDBRANCH
00080f 0813               DEST(LOOP2)
000810 0793              .DW XT_THEN
000811 3829      	.dw XT_DOBRANCH
000812 080c               DEST(LOOP1)
000813 381a      LOOP2:  .DW XT_EXIT
                 ; leave address stack
                 .include "words/l-from.asm"
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_L_FROM:
000814 ff02          .dw $ff02
000815 3e6c          .db "l>"
000816 0804          .dw VE_HEAD
                     .set VE_HEAD = VE_L_FROM
                 XT_L_FROM:
000817 3800          .dw DO_COLON
                 PFA_L_FROM:
                 
                 .endif
                 ;Z L>   -- x   L: x --      move from leave stack
                 ;   LP @ @  -2 LP +! ;
                 
000818 0837          .dw XT_LP
000819 3873          .dw XT_FETCH
00081a 3873          .dw XT_FETCH
00081b 3837          .dw XT_DOLITERAL
00081c fffe          .dw -2
00081d 0837          .dw XT_LP
00081e 3a53          .dw XT_PLUSSTORE
00081f 381a          .dw XT_EXIT
                 .include "words/to-l.asm"
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_TO_L:
000820 ff02          .dw $ff02
000821 6c3e          .db ">l"
000822 0814          .dw VE_HEAD
                     .set VE_HEAD = VE_TO_L
                 XT_TO_L:
000823 3800          .dw DO_COLON
                 PFA_TO_L:
                 .endif
                 ;Z >L   x --   L: -- x        move to leave stack
                 ;   CELL LP +!  LP @ ! ;      (L stack grows up)
                 
000824 3837              .dw XT_DOLITERAL
000825 0002      	.dw 2
000826 0837      	.dw XT_LP
000827 3a53      	.dw XT_PLUSSTORE
000828 0837      	.dw XT_LP
000829 3873      	.dw XT_FETCH
00082a 387b      	.dw XT_STORE
00082b 381a      	.dw XT_EXIT
                 .include "words/lp0.asm"
                 
                 ; Stack
                 ; start address of leave stack
                 VE_LP0:
00082c ff03          .dw $ff03
00082d 706c
00082e 0030          .db "lp0",0
00082f 0820          .dw VE_HEAD
                     .set VE_HEAD = VE_LP0
                 XT_LP0:
000830 3869          .dw PFA_DOVALUE1
                 PFA_LP0:
000831 0066          .dw EE_LP0
000832 3d7a          .dw XT_EDEFERFETCH
000833 3d84          .dw XT_EDEFERSTORE
                 .include "words/lp.asm"
                 
                 ; System Variable
                 ; leave stack pointer
                 VE_LP:
000834 ff02          .dw $ff02
000835 706c          .db "lp"
000836 082c          .dw VE_HEAD
                     .set VE_HEAD = VE_LP
                 XT_LP:
000837 3842          .dw PFA_DOVARIABLE
                 PFA_LP:
000838 0177          .dw ram_lp
                 
                 .dseg
000177           ram_lp: .byte 2
                 .cseg
                 
                 
                 .include "words/create.asm"
                 
                 ; Dictionary
                 ; create a dictionary header. XT is (constant), with the address of the data field of name
                 VE_CREATE:
000839 ff06          .dw $ff06
00083a 7263
00083b 6165
00083c 6574          .db "create"
00083d 0834          .dw VE_HEAD
                     .set VE_HEAD = VE_CREATE
                 XT_CREATE:
00083e 3800          .dw DO_COLON
                 PFA_CREATE:
00083f 0703          .dw XT_DOCREATE
000840 086d          .dw XT_REVEAL
000841 0729          .dw XT_COMPILE
000842 384c          .dw PFA_DOCONSTANT
000843 381a          .dw XT_EXIT
                 .include "words/header.asm"
                 
                 ; Compiler
                 ; creates the vocabulary header without XT and data field (PF) in the wordlist wid
                 VE_HEADER:
000844 ff06          .dw $ff06
000845 6568
000846 6461
000847 7265          .db "header"
000848 0839          .dw VE_HEAD
                     .set VE_HEAD = VE_HEADER
                 XT_HEADER:
000849 3800          .dw DO_COLON
                 PFA_HEADER:
00084a 3ef9          .dw XT_DP           ; the new Name Field
00084b 38f9          .dw XT_TO_R
00084c 38f9          .dw XT_TO_R		; ( R: NFA WID )
00084d 38ab          .dw XT_DUP    
00084e 3922          .dw XT_GREATERZERO 
00084f 3830          .dw XT_DOCONDBRANCH
000850 085b          .dw PFA_HEADER1
000851 38ab          .dw XT_DUP
000852 3837          .dw XT_DOLITERAL
000853 ff00          .dw $ff00           ; all flags are off (e.g. immediate)
000854 3a16          .dw XT_OR
000855 03bb          .dw XT_DOSCOMMA
                     ; make the link to the previous entry in this wordlist
000856 38f0          .dw XT_R_FROM
000857 3b4d          .dw XT_FETCHE
000858 0734          .dw XT_COMMA
000859 38f0          .dw XT_R_FROM
00085a 381a          .dw XT_EXIT
                 
                 PFA_HEADER1:
                     ; -16: attempt to use zero length string as a name
00085b 3837          .dw XT_DOLITERAL
00085c fff0          .dw -16
00085d 3d60          .dw XT_THROW
                 
                 .include "words/wlscope.asm"
                 
                 ; Compiler
                 ; dynamically place a word in a wordlist. The word name may be changed.
                 VE_WLSCOPE:
00085e ff07          .dw $ff07
00085f 6c77
000860 6373
000861 706f
000862 0065          .db "wlscope",0
000863 0844          .dw VE_HEAD
                     .set VE_HEAD = VE_WLSCOPE
                 XT_WLSCOPE:
000864 3dd8          .dw PFA_DODEFER1
                 PFA_WLSCOPE:
000865 0064          .dw EE_WLSCOPE
000866 3d7a          .dw XT_EDEFERFETCH
000867 3d84          .dw XT_EDEFERSTORE
                 
                 ; wlscope, "wordlist scope" ( addr len -- addr' len' wid ), is a deferred word
                 ; which enables the AmForth application to choose the wordlist ( wid ) for the
                 ; new voc entry based on the input ( addr len ) string. The name of the new voc
                 ; entry ( addr' len' ) may be different from the input string. Note that all
                 ; created voc entry types pass through the wlscope mechanism. The default
                 ; wlscope action passes the input string to the output without modification and
                 ; uses get-current to select the wid.
                 .include "words/reveal.asm"
                 
                 ; Dictionary
                 ; makes an entry in a wordlist visible, if not already done.
                 VE_REVEAL:
000868 ff06          .dw $ff06
000869 6572
00086a 6576
00086b 6c61          .db "reveal"
00086c 085e          .dw VE_HEAD
                     .set VE_HEAD = VE_REVEAL
                 XT_REVEAL:
00086d 3800          .dw DO_COLON
                 PFA_REVEAL:
00086e 3837          .dw XT_DOLITERAL
00086f 0173          .dw COLON_SMUDGE+0
000870 3873          .dw XT_FETCH
000871 38b3          .dw XT_QDUP
000872 3830          .dw XT_DOCONDBRANCH
000873 087c          .dw PFA_REVEAL1
                 ;
000874 3837          .dw XT_DOLITERAL
000875 0175          .dw COLON_SMUDGE+2
000876 3873          .dw XT_FETCH		; ( NFA WID )
000877 3b29          .dw XT_STOREE
                     ; prevent duplicate actions and cooperate with :noname
000878 394e          .dw XT_ZERO
000879 3837          .dw XT_DOLITERAL
00087a 0173          .dw COLON_SMUDGE+0
00087b 387b          .dw XT_STORE
                 PFA_REVEAL1:
00087c 381a          .dw XT_EXIT
                 .include "words/latest.asm"
                 
                 ; System Variable
                 ; system LATEST
                 VE_LATEST:
00087d ff06          .dw $ff06
00087e 616c
00087f 6574
000880 7473          .db "latest"
000881 0868          .dw VE_HEAD
                     .set VE_HEAD = VE_LATEST
                 XT_LATEST:
000882 3842          .dw PFA_DOVARIABLE
                 PFA_LATEST:
000883 0179          .dw ram_LATEST
                 
                 .dseg
000179           ram_LATEST: .byte 2
                 .cseg
                 .include "words/does.asm"
                 
                 ; Compiler
                 ; organize the XT replacement to call other colon code
                 VE_DOES:
000884 0005          .dw $0005
000885 6f64
000886 7365
000887 003e          .db "does>",0
000888 087d          .dw VE_HEAD
                     .set VE_HEAD = VE_DOES
                 XT_DOES:
000889 3800          .dw DO_COLON
                 PFA_DOES:
00088a 0729          .dw XT_COMPILE
00088b 089c          .dw XT_DODOES
00088c 0729          .dw XT_COMPILE  ; create a code snippet to be used in an embedded XT
00088d 940e          .dw $940e       ; the address of this compiled
00088e 0729          .dw XT_COMPILE  ; code will replace the XT of the 
00088f 0891          .dw DO_DODOES   ; word that CREATE created
000890 381a          .dw XT_EXIT     ; 
                 
                 DO_DODOES: ; ( -- PFA )
000891 939a
000892 938a          savetos
000893 01cb          movw tosl, wl
000894 9601          adiw tosl, 1
                     ; the following takes the address from a real uC-call
                 .if (pclen==3)
                 .endif
000895 917f          pop wh
000896 916f          pop wl
                 
000897 93bf          push XH
000898 93af          push XL
000899 01db          movw XL, wl
00089a 940c 3804     jmp_ DO_NEXT
                 
                 ; ( -- )
                 ; System
                 ; replace the XT written by CREATE to call the code that follows does>
                 ;VE_DODOES:
                 ;   .dw $ff07
                 ;   .db "(does>)"
                 ;   .set VE_HEAD = VE_DODOES
                 XT_DODOES:
00089c 3800          .dw DO_COLON
                 PFA_DODOES:
00089d 38f0          .dw XT_R_FROM
00089e 3837          .dw XT_DOLITERAL
00089f 0175          .dw COLON_SMUDGE+2
0008a0 3873          .dw XT_FETCH
0008a1 3b4d          .dw XT_FETCHE
0008a2 09ea          .dw XT_NFA2LFA
0008a3 3a29          .dw XT_1PLUS   ; lfa>xt
                 
0008a4 3b61          .dw XT_STOREI
0008a5 381a          .dw XT_EXIT
                 .include "words/colon.asm"
                 
                 ; Compiler
                 ; create a named entry in the dictionary, XT is DO_COLON
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_COLON:
0008a6 ff01          .dw $ff01
0008a7 003a          .db ":",0
0008a8 0884          .dw VE_HEAD
                     .set VE_HEAD = VE_COLON
                 XT_COLON:
0008a9 3800          .dw DO_COLON
                 PFA_COLON:
                 .endif
0008aa 0703          .dw XT_DOCREATE
0008ab 08b4          .dw XT_COLONNONAME
0008ac 38d3          .dw XT_DROP
0008ad 381a          .dw XT_EXIT
                 .include "words/colon-noname.asm"
                 
                 ; Compiler
                 ; create an unnamed entry in the dictionary, XT is DO_COLON
                 VE_COLONNONAME:
0008ae ff07          .dw $ff07
0008af 6e3a
0008b0 6e6f
0008b1 6d61
0008b2 0065          .db ":noname",0
0008b3 08a6          .dw VE_HEAD
                     .set VE_HEAD = VE_COLONNONAME
                 XT_COLONNONAME:
0008b4 3800          .dw DO_COLON
                 PFA_COLONNONAME:
0008b5 3ef9          .dw XT_DP
0008b6 38ab          .dw XT_DUP
0008b7 0882          .dw XT_LATEST
0008b8 387b          .dw XT_STORE
                 
0008b9 0729          .dw XT_COMPILE
0008ba 3800          .dw DO_COLON
                 
0008bb 08c9          .dw XT_RBRACKET
0008bc 381a          .dw XT_EXIT
                 .include "words/semicolon.asm"
                 
                 ; Compiler
                 ; finish colon defintion, compiles (exit) and returns to interpret state 
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 
                 VE_SEMICOLON:
0008bd 0001          .dw $0001
0008be 003b          .db $3b,0
0008bf 08ae          .dw VE_HEAD
                     .set VE_HEAD = VE_SEMICOLON
                 XT_SEMICOLON:
0008c0 3800          .dw DO_COLON
                 PFA_SEMICOLON:
                 .endif
0008c1 0729          .dw XT_COMPILE
0008c2 381a          .dw XT_EXIT
0008c3 08d2          .dw XT_LBRACKET
0008c4 086d          .dw XT_REVEAL
0008c5 381a          .dw XT_EXIT
                 .include "words/right-bracket.asm"
                 
                 ; Compiler
                 ; enter compiler mode
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_RBRACKET:
0008c6 ff01          .dw $ff01
0008c7 005d          .db "]",0
0008c8 08bd          .dw VE_HEAD
                     .set VE_HEAD = VE_RBRACKET
                 XT_RBRACKET:
0008c9 3800          .dw DO_COLON
                 PFA_RBRACKET:
                 .endif
0008ca 3837          .dw XT_DOLITERAL
0008cb 0001          .dw 1
0008cc 3e98          .dw XT_STATE
0008cd 387b          .dw XT_STORE
0008ce 381a          .dw XT_EXIT
                 .include "words/left-bracket.asm"
                 
                 ; Compiler
                 ; enter interpreter mode
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_LBRACKET:
0008cf 0001          .dw $0001
0008d0 005b          .db "[",0
0008d1 08c6          .dw VE_HEAD
                     .set VE_HEAD = VE_LBRACKET
                 XT_LBRACKET:
0008d2 3800          .dw DO_COLON
                 PFA_LBRACKET:
                 .endif
0008d3 394e          .dw XT_ZERO
0008d4 3e98          .dw XT_STATE
0008d5 387b          .dw XT_STORE
0008d6 381a          .dw XT_EXIT
                 .include "words/variable.asm"
                 
                 ; Compiler
                 ; create a dictionary entry for a variable and allocate 1 cell RAM
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 VE_VARIABLE:
0008d7 ff08          .dw $ff08
0008d8 6176
0008d9 6972
0008da 6261
0008db 656c          .db "variable"
0008dc 08cf          .dw VE_HEAD
                     .set VE_HEAD = VE_VARIABLE
                 XT_VARIABLE:
0008dd 3800          .dw DO_COLON
                 PFA_VARIABLE:
                 .endif
0008de 3f0a          .dw XT_HERE
0008df 08ea          .dw XT_CONSTANT
0008e0 3837          .dw XT_DOLITERAL
0008e1 0002          .dw 2
0008e2 3f13          .dw XT_ALLOT
0008e3 381a          .dw XT_EXIT
                 .include "words/constant.asm"
                 
                 ; Compiler
                 ; create a constant in the dictionary
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 VE_CONSTANT:
0008e4 ff08          .dw $ff08
0008e5 6f63
0008e6 736e
0008e7 6174
0008e8 746e          .db "constant"
0008e9 08d7          .dw VE_HEAD
                     .set VE_HEAD = VE_CONSTANT
                 XT_CONSTANT:
0008ea 3800          .dw DO_COLON
                 PFA_CONSTANT:
                 .endif
0008eb 0703          .dw XT_DOCREATE
0008ec 086d          .dw XT_REVEAL
0008ed 0729          .dw XT_COMPILE
0008ee 3842          .dw PFA_DOVARIABLE
0008ef 0734          .dw XT_COMMA
0008f0 381a          .dw XT_EXIT
                 .include "words/user.asm"
                 
                 ; Compiler
                 ; create a dictionary entry for a user variable at offset n
                 VE_USER:
0008f1 ff04          .dw $ff04
0008f2 7375
0008f3 7265          .db "user"
0008f4 08e4          .dw VE_HEAD
                     .set VE_HEAD = VE_USER
                 XT_USER:
0008f5 3800          .dw DO_COLON
                 PFA_USER:
0008f6 0703          .dw XT_DOCREATE
0008f7 086d          .dw XT_REVEAL
                 
0008f8 0729          .dw XT_COMPILE
0008f9 3852          .dw PFA_DOUSER
0008fa 0734          .dw XT_COMMA
0008fb 381a          .dw XT_EXIT
                 
                 .include "words/recurse.asm"
                 
                 ; Compiler
                 ; compile the XT of the word currently being defined into the dictionary
                 VE_RECURSE:
0008fc 0007          .dw $0007
0008fd 6572
0008fe 7563
0008ff 7372
000900 0065          .db "recurse",0
000901 08f1          .dw VE_HEAD
                     .set VE_HEAD = VE_RECURSE
                 XT_RECURSE:
000902 3800          .dw DO_COLON
                 PFA_RECURSE:
000903 0882          .dw XT_LATEST
000904 3873          .dw XT_FETCH
000905 0734          .dw XT_COMMA
000906 381a          .dw XT_EXIT
                 .include "words/immediate.asm"
                 
                 ; Compiler
                 ; set immediate flag for the most recent word definition
                 VE_IMMEDIATE:
000907 ff09          .dw $ff09
000908 6d69
000909 656d
00090a 6964
00090b 7461
00090c 0065          .db "immediate",0
00090d 08fc          .dw VE_HEAD
                     .set VE_HEAD = VE_IMMEDIATE
                 XT_IMMEDIATE:
00090e 3800          .dw DO_COLON
                 PFA_IMMEDIATE:
00090f 09ab          .dw XT_GET_CURRENT
000910 3b4d          .dw XT_FETCHE
000911 38ab          .dw XT_DUP
000912 3bba          .dw XT_FETCHI
000913 3837          .dw XT_DOLITERAL
000914 7fff          .dw $7fff
000915 3a0d          .dw XT_AND
000916 38be          .dw XT_SWAP
000917 3b61          .dw XT_STOREI
000918 381a          .dw XT_EXIT
                 
                 .include "words/bracketchar.asm"
                 
                 ; Tools
                 ; skip leading space delimites, place the first character of the word on the stack
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_BRACKETCHAR:
000919 0006          .dw $0006
00091a 635b
00091b 6168
00091c 5d72          .db "[char]"
00091d 0907          .dw VE_HEAD
                     .set VE_HEAD = VE_BRACKETCHAR
                 XT_BRACKETCHAR:
00091e 3800          .dw DO_COLON
                 PFA_BRACKETCHAR:
                 .endif
00091f 0729          .dw XT_COMPILE
000920 3837          .dw XT_DOLITERAL
000921 04ba          .dw XT_CHAR
000922 0734          .dw XT_COMMA
000923 381a          .dw XT_EXIT
                 .include "words/abort-string.asm"
                 
                 ;C         i*x x1 --       R: j*x --      x1<>0
                 ;   POSTPONE IS" POSTPONE ?ABORT ; IMMEDIATE
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_ABORTQUOTE:
000924 0006          .dw $0006
000925 6261
000926 726f
000927 2274          .db "abort",'"'
000928 0919          .dw VE_HEAD
                     .set VE_HEAD = VE_ABORTQUOTE
                 XT_ABORTQUOTE:
000929 3800          .dw DO_COLON
                 PFA_ABORTQUOTE:
                 .endif
00092a 3e6b          .dw XT_SQUOTE
00092b 0729          .dw XT_COMPILE
00092c 093c          .dw XT_QABORT
00092d 381a          .DW XT_EXIT
                 .include "words/abort.asm"
                 
                 ; Exceptions
                 ; send an exception -1
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_ABORT:
00092e ff05          .dw $ff05
00092f 6261
000930 726f
000931 0074          .db "abort",0
000932 0924          .dw VE_HEAD
                     .set VE_HEAD = VE_ABORT
                 XT_ABORT:
000933 3800          .dw DO_COLON
                 PFA_ABORT:
                 .endif
000934 3837          .dw XT_DOLITERAL
000935 ffff          .dw -1
000936 3d60          .dw XT_THROW
                 .include "words/q-abort.asm"
                 
                 ;   ROT IF ITYPE ABORT THEN 2DROP ;
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_QABORT:
000937 ff06          .dw $ff06
000938 613f
000939 6f62
00093a 7472          .db "?abort"
00093b 092e          .dw VE_HEAD
                     .set VE_HEAD = VE_QABORT
                 XT_QABORT:
00093c 3800          .dw DO_COLON
                 PFA_QABORT:
                 
                 .endif
00093d 38db
00093e 3830              .DW XT_ROT,XT_DOCONDBRANCH
00093f 0942              DEST(QABO1)
000940 03dc
000941 0933              .DW XT_ITYPE,XT_ABORT
000942 3eb3
000943 381a      QABO1:  .DW XT_2DROP,XT_EXIT
                 
                 .include "words/get-stack.asm"
                 
                 ; Tools
                 ; Get a stack from EEPROM
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_GET_STACK:
000944 ff09          .dw $ff09
000945 6567
000946 2d74
000947 7473
000948 6361
000949 006b          .db "get-stack",0
00094a 0937          .dw VE_HEAD
                     .set VE_HEAD = VE_GET_STACK
                 XT_GET_STACK:
00094b 3800          .dw DO_COLON
                 PFA_N_FETCH_E:
                 .endif
00094c 38ab          .dw XT_DUP
00094d 3c82          .dw XT_CELLPLUS
00094e 38be          .dw XT_SWAP
00094f 3b4d          .dw XT_FETCHE
000950 38ab          .dw XT_DUP
000951 38f9          .dw XT_TO_R
000952 394e          .dw XT_ZERO
000953 38be          .dw XT_SWAP    ; go from bigger to smaller addresses
000954 07f9          .dw XT_QDOCHECK
000955 3830          .dw XT_DOCONDBRANCH
000956 0962          DEST(PFA_N_FETCH_E2)
000957 3a89          .dw XT_DODO
                 PFA_N_FETCH_E1:
                     ; ( ee-addr )
000958 3a9a          .dw XT_I
000959 3a2f          .dw XT_1MINUS
00095a 3ea5          .dw XT_CELLS ; ( -- ee-addr i*2 )
00095b 38c9          .dw XT_OVER  ; ( -- ee-addr i*2 ee-addr )
00095c 3997          .dw XT_PLUS  ; ( -- ee-addr ee-addr+i
00095d 3b4d          .dw XT_FETCHE ;( -- ee-addr item_i )
00095e 38be          .dw XT_SWAP   ;( -- item_i ee-addr )
00095f 3945          .dw XT_TRUE  ; shortcut for -1
000960 3aa8          .dw XT_DOPLUSLOOP
000961 0958          DEST(PFA_N_FETCH_E1)
                 PFA_N_FETCH_E2:
000962 3eb3          .dw XT_2DROP
000963 38f0          .dw XT_R_FROM
000964 381a          .dw XT_EXIT
                 
                 .include "words/set-stack.asm"
                 
                 ; Tools
                 ; Write a stack to EEPROM
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SET_STACK:
000965 ff09          .dw $ff09
000966 6573
000967 2d74
000968 7473
000969 6361
00096a 006b          .db "set-stack",0
00096b 0944          .dw VE_HEAD
                     .set VE_HEAD = VE_SET_STACK
                 XT_SET_STACK:
00096c 3800          .dw DO_COLON
                 PFA_SET_STACK:
                 .endif
00096d 3eaa          .dw XT_2DUP
00096e 3b29          .dw XT_STOREE ; ( -- i_n .. i_0 n e-addr )
00096f 38be          .dw XT_SWAP    
000970 394e          .dw XT_ZERO
000971 07f9          .dw XT_QDOCHECK
000972 3830          .dw XT_DOCONDBRANCH
000973 097a          DEST(PFA_SET_STACK2)
000974 3a89          .dw XT_DODO
                 PFA_SET_STACK1:
000975 3c82          .dw XT_CELLPLUS ; ( -- i_x e-addr )
000976 3ebb          .dw XT_TUCK      ; ( -- e-addr i_x e-addr
000977 3b29          .dw XT_STOREE
000978 3ab7          .dw XT_DOLOOP
000979 0975          DEST(PFA_SET_STACK1)
                 PFA_SET_STACK2:
00097a 38d3          .dw XT_DROP
00097b 381a          .dw XT_EXIT
                 
                 .include "words/map-stack.asm"
                 
                 ; Tools
                 ; Iterate over a stack
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_MAPSTACK:
00097c ff09          .dw $ff09
00097d 616d
00097e 2d70
00097f 7473
000980 6361
000981 006b          .db "map-stack",0
000982 0965          .dw VE_HEAD
                     .set VE_HEAD = VE_MAPSTACK
                 XT_MAPSTACK:
000983 3800          .dw DO_COLON
                 PFA_MAPSTACK:
                 .endif
000984 38ab          .dw XT_DUP
000985 3c82          .dw XT_CELLPLUS
000986 38be          .dw XT_SWAP
000987 3b4d          .dw XT_FETCHE
000988 3ea5          .dw XT_CELLS
000989 3f81          .dw XT_BOUNDS
00098a 07f9          .dw XT_QDOCHECK
00098b 3830          .dw XT_DOCONDBRANCH
00098c 09a0          DEST(PFA_MAPSTACK3)
00098d 3a89          .dw XT_DODO
                 PFA_MAPSTACK1:
00098e 3a9a            .dw XT_I
00098f 3b4d            .dw XT_FETCHE   ; -- i*x XT id
000990 38be            .dw XT_SWAP
000991 38f9            .dw XT_TO_R
000992 3902            .dw XT_R_FETCH
000993 3824            .dw XT_EXECUTE  ; i*x id -- j*y true | i*x false
000994 38b3            .dw XT_QDUP
000995 3830            .dw XT_DOCONDBRANCH
000996 099b            DEST(PFA_MAPSTACK2)
000997 38f0               .dw XT_R_FROM
000998 38d3               .dw XT_DROP
000999 3ac2               .dw XT_UNLOOP
00099a 381a               .dw XT_EXIT
                 PFA_MAPSTACK2:
00099b 38f0            .dw XT_R_FROM
00099c 3837            .dw XT_DOLITERAL
00099d 0002            .dw 2
00099e 3aa8            .dw XT_DOPLUSLOOP
00099f 098e            DEST(PFA_MAPSTACK1)
                 PFA_MAPSTACK3:
0009a0 38d3          .dw XT_DROP
0009a1 394e          .dw XT_ZERO
0009a2 381a          .dw XT_EXIT
                 
                 ;
                 ; : map-stack ( i*x XT e-addr -- j*y )
                 ;     dup cell+ swap @e cells bounds ?do 
                 ;       ( -- i*x XT )
                 ;       i @e swap >r r@ execute
                 ;       ?dup if r> drop unloop exit then
                 ;       r>
                 ;     2 +loop drop 0
                 ;
                 .include "words/get-current.asm"
                 
                 ; Search Order
                 ; get the wid of the current compilation word list
                 VE_GET_CURRENT:
0009a3 ff0b          .dw $ff0b
0009a4 6567
0009a5 2d74
0009a6 7563
0009a7 7272
0009a8 6e65
0009a9 0074          .db "get-current",0
0009aa 097c          .dw VE_HEAD
                     .set VE_HEAD = VE_GET_CURRENT
                 XT_GET_CURRENT:
0009ab 3800          .dw DO_COLON
                 PFA_GET_CURRENT:
0009ac 3837          .dw XT_DOLITERAL
0009ad 0044          .dw EE_CURRENT
0009ae 3b4d          .dw XT_FETCHE
0009af 381a          .dw XT_EXIT
                 .include "words/get-order.asm"
                 
                 ; Search Order
                 ; Get the current search order word list
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_GET_ORDER:
0009b0 ff09          .dw $ff09
0009b1 6567
0009b2 2d74
0009b3 726f
0009b4 6564
0009b5 0072          .db "get-order",0
0009b6 09a3          .dw VE_HEAD
                     .set VE_HEAD = VE_GET_ORDER
                 XT_GET_ORDER:
0009b7 3800          .dw DO_COLON
                 PFA_GET_ORDER:
                 .endif
0009b8 3837          .dw XT_DOLITERAL
0009b9 0048          .dw CFG_ORDERLISTLEN
0009ba 094b          .dw XT_GET_STACK
0009bb 381a          .dw XT_EXIT
                 
                 .include "words/compare.asm"
                 
                 ; String
                 ; compares two strings in RAM
                 VE_COMPARE:
0009bc ff07          .dw $ff07
0009bd 6f63
0009be 706d
0009bf 7261
0009c0 0065          .db "compare",0
0009c1 09b0          .dw VE_HEAD
                     .set VE_HEAD = VE_COMPARE
                 XT_COMPARE:
0009c2 09c3          .dw PFA_COMPARE
                 PFA_COMPARE:
0009c3 93bf          push xh
0009c4 93af          push xl
0009c5 018c          movw temp0, tosl
0009c6 9189
0009c7 9199          loadtos
0009c8 01dc          movw xl, tosl
0009c9 9189
0009ca 9199          loadtos
0009cb 019c          movw temp2, tosl
0009cc 9189
0009cd 9199          loadtos
0009ce 01fc          movw zl, tosl
                 PFA_COMPARE_LOOP:
0009cf 90ed          ld temp4, X+
0009d0 90f1          ld temp5, Z+
0009d1 14ef          cp temp4, temp5
0009d2 f451          brne PFA_COMPARE_NOTEQUAL
0009d3 950a          dec temp0
0009d4 f019          breq PFA_COMPARE_ENDREACHED2
0009d5 952a          dec temp2
0009d6 f7c1          brne PFA_COMPARE_LOOP
0009d7 c001          rjmp PFA_COMPARE_ENDREACHED
                 PFA_COMPARE_ENDREACHED2:
0009d8 952a          dec temp2
                 PFA_COMPARE_ENDREACHED:
0009d9 2b02          or temp0, temp2
0009da f411          brne PFA_COMPARE_CHECKLASTCHAR
0009db 2788          clr tosl
0009dc c002          rjmp PFA_COMPARE_DONE
                 PFA_COMPARE_CHECKLASTCHAR:
                 PFA_COMPARE_NOTEQUAL:
0009dd ef8f          ser tosl
0009de c000          rjmp PFA_COMPARE_DONE
                 
                 PFA_COMPARE_DONE:
0009df 2f98          mov tosh, tosl
0009e0 91af          pop xl
0009e1 91bf          pop xh
0009e2 940c 3804     jmp_ DO_NEXT
                 .include "words/nfa2lfa.asm"
                 
                 ; System
                 ; get the link field address from the name field address
                 VE_NFA2LFA:
0009e4 ff07         .dw $ff07
0009e5 666e
0009e6 3e61
0009e7 666c
0009e8 0061         .db "nfa>lfa",0
0009e9 09bc         .dw VE_HEAD
                    .set VE_HEAD = VE_NFA2LFA
                 XT_NFA2LFA:
0009ea 3800          .dw DO_COLON
                 PFA_NFA2LFA:
0009eb 06cc          .dw XT_NAME2STRING
0009ec 3a29          .dw XT_1PLUS
0009ed 39fe          .dw XT_2SLASH
0009ee 3997          .dw XT_PLUS
0009ef 381a          .dw XT_EXIT
                 .elif AMFORTH_NRWW_SIZE > 2000
                 .else
                 .endif
                 .include "dict_appl.inc"
                 
                 ; they may be moved to the core dictionary if needed
                 
                 .include "dict/compiler2.inc" ; additional words for the compiler
                 
                 ; included almost independently from each other
                 ; on a include-per-use basis
                 ;
                 .if DICT_COMPILER2 == 0
                 .set DICT_COMPILER2 = 1
                 
                 .include "words/set-current.asm"
                 
                 ; Search Order
                 ; set current word list to the given word list wid
                 VE_SET_CURRENT:
0009f0 ff0b          .dw $ff0b
0009f1 6573
0009f2 2d74
0009f3 7563
0009f4 7272
0009f5 6e65
0009f6 0074          .db "set-current",0
0009f7 09e4          .dw VE_HEAD
                     .set VE_HEAD = VE_SET_CURRENT
                 XT_SET_CURRENT:
0009f8 3800          .dw DO_COLON
                 PFA_SET_CURRENT:
0009f9 3837          .dw XT_DOLITERAL
0009fa 0044          .dw EE_CURRENT
0009fb 3b29          .dw XT_STOREE
0009fc 381a          .dw XT_EXIT
                 .include "words/wordlist.asm"
                 
                 ; Search Order
                 ; create a new, empty wordlist
                 VE_WORDLIST:
0009fd ff08          .dw $ff08
0009fe 6f77
0009ff 6472
000a00 696c
000a01 7473          .db "wordlist"
000a02 09f0          .dw VE_HEAD
                     .set VE_HEAD = VE_WORDLIST
                 XT_WORDLIST:
000a03 3800          .dw DO_COLON
                 PFA_WORDLIST:
000a04 3f02          .dw XT_EHERE
000a05 394e          .dw XT_ZERO
000a06 38c9          .dw XT_OVER
000a07 3b29          .dw XT_STOREE
000a08 38ab          .dw XT_DUP
000a09 3c82          .dw XT_CELLPLUS
000a0a 01a5          .dw XT_DOTO
000a0b 3f03          .dw PFA_EHERE
000a0c 381a          .dw XT_EXIT
                 
                 .include "words/only.asm"
                 
                 ; Search Order
                 ; replace the order list with the system default list
                 VE_ONLY:
000a0d ff04          .dw $ff04
000a0e 6e6f
000a0f 796c          .db "only"
000a10 09fd          .dw VE_HEAD
                     .set VE_HEAD = VE_ONLY
                 XT_ONLY:
000a11 3800          .dw DO_COLON
                 PFA_ONLY:
000a12 3837          .dw XT_DOLITERAL
000a13 0046          .dw EE_FORTHWORDLIST
000a14 3837          .dw XT_DOLITERAL
000a15 0001          .dw 1
000a16 0a2c          .dw XT_SET_ORDER
000a17 381a          .dw XT_EXIT
                 .include "words/forth-wordlist.asm"
                 
                 ; Search Order
                 ; get the system default word list
                 VE_FORTH_WORDLIST:
000a18 ff0e          .dw $ff0e
000a19 6f66
000a1a 7472
000a1b 2d68
000a1c 6f77
000a1d 6472
000a1e 696c
000a1f 7473          .db "forth-wordlist"
000a20 0a0d          .dw VE_HEAD
                     .set VE_HEAD = VE_FORTH_WORDLIST
                 XT_FORTH_WORDLIST:
000a21 3869          .dw PFA_DOVALUE1
                 PFA_FORTH_WORDLIST:
000a22 0042          .dw EE_WL_FORTH
000a23 3d7a          .dw XT_EDEFERFETCH
000a24 3d84          .dw XT_EDEFERSTORE
                 .include "words/set-order.asm"
                 
                 ; Search Order
                 ; replace the search order list
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SET_ORDER:
000a25 ff09          .dw $ff09
000a26 6573
000a27 2d74
000a28 726f
000a29 6564
000a2a 0072          .db "set-order",0
000a2b 0a18          .dw VE_HEAD
                     .set VE_HEAD = VE_SET_ORDER
                 XT_SET_ORDER:
000a2c 3800          .dw DO_COLON
                 PFA_SET_ORDER:
                 .endif
000a2d 3837          .dw XT_DOLITERAL
000a2e 0048          .dw CFG_ORDERLISTLEN
000a2f 096c          .dw XT_SET_STACK
000a30 381a          .dw XT_EXIT
                 
                 .include "words/set-recognizer.asm"
                 
                 ; Interpreter
                 ; replace the recognizer list
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SET_RECOGNIZERS:
000a31 ff0f          .dw $ff0f
000a32 6573
000a33 2d74
000a34 6572
000a35 6f63
000a36 6e67
000a37 7a69
000a38 7265
000a39 0073          .db "set-recognizers",0
000a3a 0a25          .dw VE_HEAD
                     .set VE_HEAD = VE_SET_RECOGNIZERS
                 XT_SET_RECOGNIZERS:
000a3b 3800          .dw DO_COLON
                 PFA_SET_RECOGNIZERS:
                 .endif
000a3c 3837          .dw XT_DOLITERAL
000a3d 005a          .dw CFG_RECOGNIZERLISTLEN
000a3e 096c          .dw XT_SET_STACK
000a3f 381a          .dw XT_EXIT
                 
                 .include "words/get-recognizer.asm"
                 
                 ; Interpreter
                 ; Get the current recognizer list
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_GET_RECOGNIZERS:
000a40 ff0f          .dw $ff0f
000a41 6567
000a42 2d74
000a43 6572
000a44 6f63
000a45 6e67
000a46 7a69
000a47 7265
000a48 0073          .db "get-recognizers",0
000a49 0a31          .dw VE_HEAD
                     .set VE_HEAD = VE_GET_RECOGNIZERS
                 XT_GET_RECOGNIZERS:
000a4a 3800          .dw DO_COLON
                 PFA_GET_RECOGNIZERS:
                 .endif
000a4b 3837          .dw XT_DOLITERAL
000a4c 005a          .dw CFG_RECOGNIZERLISTLEN
000a4d 094b          .dw XT_GET_STACK
000a4e 381a          .dw XT_EXIT
                 .include "words/code.asm"
                 
                 ; Compiler
                 ; create named entry in the dictionary, XT is the data field
                 VE_CODE:
000a4f ff04          .dw $ff04
000a50 6f63
000a51 6564          .db "code"
000a52 0a40          .dw VE_HEAD
                     .set VE_HEAD = VE_CODE
                 XT_CODE:
000a53 3800          .dw DO_COLON
                 PFA_CODE:
000a54 0703          .dw XT_DOCREATE
000a55 086d          .dw XT_REVEAL
000a56 3ef9          .dw XT_DP
000a57 0a84          .dw XT_ICELLPLUS
000a58 0734          .dw XT_COMMA
000a59 381a          .dw XT_EXIT
                 .include "words/end-code.asm"
                 
                 ; Compiler
                 ; finish a code definition
                 VE_ENDCODE:
000a5a ff08          .dw $ff08
000a5b 6e65
000a5c 2d64
000a5d 6f63
000a5e 6564          .db "end-code"
000a5f 0a4f          .dw VE_HEAD
                     .set VE_HEAD = VE_ENDCODE
                 XT_ENDCODE:
000a60 3800          .dw DO_COLON
                 PFA_ENDCODE:
000a61 0729          .dw XT_COMPILE
000a62 940c          .dw $940c
000a63 0729          .dw XT_COMPILE
000a64 3804          .dw DO_NEXT
000a65 381a          .dw XT_EXIT
                 .include "words/marker.asm"
                 
                 ; System Value
                 ; The eeprom address until which MARKER saves and restores the eeprom data.
                 VE_MARKER:
000a66 ff08          .dw $ff08
000a67 6d28
000a68 7261
000a69 656b
000a6a 2972          .db "(marker)"
000a6b 0a5a          .dw VE_HEAD
                     .set VE_HEAD = VE_MARKER
                 XT_MARKER:
000a6c 3869          .dw PFA_DOVALUE1
                 PFA_MARKER:
000a6d 0068          .dw EE_MARKER
000a6e 3d7a          .dw XT_EDEFERFETCH
000a6f 3d84          .dw XT_EDEFERSTORE
                 .include "words/postpone.asm"
                 
                 ; Compiler
                 ; Append the compilation semantics of "name" to the dictionary
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_POSTPONE:
000a70 0008          .dw $0008
000a71 6f70
000a72 7473
000a73 6f70
000a74 656e          .db "postpone"
000a75 0a66          .dw VE_HEAD
                     .set VE_HEAD = VE_POSTPONE
                 XT_POSTPONE:
000a76 3800          .dw DO_COLON
                 PFA_POSTPONE:
                 .endif
000a77 058b          .dw XT_PARSENAME
000a78 05cd          .dw XT_DORECOGNIZER
000a79 0a84          .dw XT_ICELLPLUS 
000a7a 0a84          .dw XT_ICELLPLUS
000a7b 3bba          .dw XT_FETCHI
000a7c 3824          .dw XT_EXECUTE
000a7d 381a          .dw XT_EXIT
                 .include "words/i-cellplus.asm"
                 
                 ; Compiler
                 ; skip to the next cell in flash
                 VE_ICELLPLUS:
000a7e ff07          .dw $FF07
000a7f 2d69
000a80 6563
000a81 6c6c
000a82 002b          .db "i-cell+",0
000a83 0a70          .dw VE_HEAD
                     .set VE_HEAD = VE_ICELLPLUS
                 XT_ICELLPLUS:
000a84 3800          .dw DO_COLON
                 PFA_ICELLPLUS:
000a85 3a29          .dw XT_1PLUS
000a86 381a          .dw XT_EXIT
                 .endif
                 
                 .include "words/applturnkey.asm"
                 
                 ; R( -- )
                 ; application specific turnkey action
                 VE_APPLTURNKEY:
000a87 ff0b          .dw $ff0b
000a88 7061
000a89 6c70
000a8a 7574
000a8b 6e72
000a8c 656b
000a8d 0079          .db "applturnkey",0
000a8e 0a7e          .dw VE_HEAD
                     .set VE_HEAD = VE_APPLTURNKEY
                 XT_APPLTURNKEY:
000a8f 3800          .dw DO_COLON
                 PFA_APPLTURNKEY:
000a90 00b4          .dw XT_USART
000a91 3c89          .dw XT_INTON
000a92 016f          .dw XT_DOT_VER
000a93 3f96          .dw XT_SPACE
000a94 03a9          .dw XT_DOSLITERAL
000a95 000a          .dw 10
000a96 6f46
000a97 7472
000a98 6468
000a99 6975
000a9a 6f6e          .db "Forthduino"
000a9b 03dc          .dw XT_ITYPE
                 
000a9c 381a          .dw XT_EXIT
                 
                 
                 .set DPSTART = pc
                 .if(pc>AMFORTH_RO_SEG)
                 .endif
                 
                 .org AMFORTH_RO_SEG
                 .include "amforth-interpreter.asm"
                 
                 
                 DO_COLON:
003800 93bf          push XH
003801 93af          push XL          ; PUSH IP
003802 01db          movw XL, wl
003803 9611          adiw xl, 1
                 DO_NEXT:
003804 f06e          brts DO_INTERRUPT
003805 01fd          movw zl, XL        ; READ IP
003806 0fee
003807 1fff
003808 9165
003809 9175          readflashcell wl, wh
00380a 9611          adiw XL, 1        ; INC IP
                 
                 DO_EXECUTE:
00380b 01fb          movw zl, wl
00380c 0fee
00380d 1fff
00380e 9105
00380f 9115          readflashcell temp0,temp1
003810 01f8          movw zl, temp0
003811 9409          ijmp
                 
                 DO_INTERRUPT:
                     ; here we deal with interrupts the forth way
003812 94e8          clt
003813 eb64          ldi wl, LOW(XT_ISREXEC)
003814 e37c          ldi wh, HIGH(XT_ISREXEC)
003815 cff5          rjmp DO_EXECUTE
                 .include "dict/nrww.inc"
                 
                 ; section together with the forth inner interpreter
                 
                 .include "words/exit.asm"
                 
                 ; Compiler
                 ; end of current colon word
                 VE_EXIT:
003816 ff04          .dw $ff04
003817 7865
003818 7469          .db "exit"
003819 0a87          .dw VE_HEAD
                     .set VE_HEAD = VE_EXIT
                 XT_EXIT:
00381a 381b          .dw PFA_EXIT
                 PFA_EXIT:
00381b 91af          pop XL
00381c 91bf          pop XH
00381d cfe6          jmp_ DO_NEXT
                 .include "words/execute.asm"
                 
                 ; System
                 ; execute XT
                 VE_EXECUTE:
00381e ff07          .dw $ff07
00381f 7865
003820 6365
003821 7475
003822 0065          .db "execute",0
003823 3816          .dw VE_HEAD
                     .set VE_HEAD = VE_EXECUTE
                 XT_EXECUTE:
003824 3825          .dw PFA_EXECUTE
                 PFA_EXECUTE:
003825 01bc          movw wl, tosl
003826 9189
003827 9199          loadtos
003828 cfe2          jmp_ DO_EXECUTE
                 .include "words/dobranch.asm"
                 
                 ; System
                 ; runtime of branch
                 ;VE_DOBRANCH:
                 ;    .dw $ff08
                 ;    .db "(branch)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOBRANCH
                 XT_DOBRANCH:
003829 382a          .dw PFA_DOBRANCH
                 PFA_DOBRANCH:
00382a 01fd          movw zl, XL
00382b 0fee
00382c 1fff
00382d 91a5
00382e 91b5          readflashcell XL,XH
00382f cfd4          jmp_ DO_NEXT
                 .include "words/docondbranch.asm"
                 
                 ; System
                 ; runtime of ?branch
                 ;VE_DOCONDBRANCH:
                 ;    .dw $ff09
                 ;    .db "(?branch)"
                 ;    .dw  VE_HEAD
                 ;    .set VE_HEAD = VE_DOCONDBRANCH
                 XT_DOCONDBRANCH:
003830 3831          .dw PFA_DOCONDBRANCH
                 PFA_DOCONDBRANCH:
003831 2b98          or tosh, tosl
003832 9189
003833 9199          loadtos
003834 f3a9          brbs 1, PFA_DOBRANCH ; 1 is z flag; if tos is zero (false), do the branch
003835 9611          adiw XL, 1
003836 cfcd          jmp_ DO_NEXT
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/doliteral.asm"
                 
                 ; System
                 ; runtime of literal
                 ;VE_DOLITERAL:
                 ;    .dw $ff09
                 ;    .db "(literal)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOLITERAL
                 XT_DOLITERAL:
003837 3838          .dw PFA_DOLITERAL
                 PFA_DOLITERAL:
003838 939a
003839 938a          savetos
00383a 01fd          movw zl, xl
00383b 0fee
00383c 1fff
00383d 9185
00383e 9195          readflashcell tosl,tosh
00383f 9611          adiw xl, 1
003840 cfc3          jmp_ DO_NEXT
                 
                 .include "words/dovariable.asm"
                 
                 ; System
                 ; puts content of parameter field (1 cell) to TOS
                 ;VE_DOVARIABLE:
                 ;    .dw $ff0a
                 ;    .db "(variable)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOVARIABLE
                 XT_DOVARIABLE:
003841 3842          .dw PFA_DOVARIABLE
                 PFA_DOVARIABLE:
003842 939a
003843 938a          savetos
003844 01fb          movw zl, wl
003845 9631          adiw zl,1
003846 0fee
003847 1fff
003848 9185
003849 9195          readflashcell tosl,tosh
00384a cfb9          jmp_ DO_NEXT
                 .include "words/doconstant.asm"
                 
                 ; System
                 ; place data field address on TOS
                 ;VE_DOCONSTANT:
                 ;    .dw $ff0a
                 ;    .db "(constant)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOCONSTANT
                 XT_DOCONSTANT:
00384b 384c          .dw PFA_DOCONSTANT
                 PFA_DOCONSTANT:
00384c 939a
00384d 938a          savetos
00384e 01cb          movw tosl, wl
00384f 9601          adiw tosl, 1
003850 cfb3          jmp_ DO_NEXT
                 .include "words/douser.asm"
                 
                 ; System
                 ; runtime part of user
                 ;VE_DOUSER:
                 ;    .dw $ff06
                 ;    .db "(user)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOUSER
                 XT_DOUSER:
003851 3852          .dw PFA_DOUSER
                 PFA_DOUSER:
003852 939a
003853 938a          savetos
003854 01fb          movw zl, wl
003855 9631          adiw zl, 1
003856 0fee
003857 1fff
003858 9185
003859 9195          readflashcell tosl,tosh
00385a 0d84          add tosl, upl
00385b 1d95          adc tosh, uph
00385c cfa7          jmp_ DO_NEXT
                 .include "words/do-value.asm"
                 
                 ; System
                 ; runtime of value
                 VE_DOVALUE:
00385d ff07          .dw $ff07
00385e 7628
00385f 6c61
003860 6575
003861 0029          .db "(value)", 0
003862 381e          .dw VE_HEAD
                     .set VE_HEAD = VE_DOVALUE
                 XT_DOVALUE:
003863 3800          .dw DO_COLON
                 PFA_DOVALUE:
003864 0703          .dw XT_DOCREATE
003865 086d          .dw XT_REVEAL
003866 0729          .dw XT_COMPILE
003867 3869          .dw PFA_DOVALUE1
003868 381a          .dw XT_EXIT
                 PFA_DOVALUE1:
003869 940e 0891     call_ DO_DODOES
00386b 38ab          .dw XT_DUP
00386c 3a29          .dw XT_1PLUS
00386d 3bba          .dw XT_FETCHI
00386e 3824          .dw XT_EXECUTE
00386f 381a          .dw XT_EXIT
                 .include "words/fetch.asm"
                 
                 ; Memory
                 ; read 1 cell from RAM address
                 VE_FETCH:
003870 ff01          .dw $ff01
003871 0040          .db "@",0
003872 385d          .dw VE_HEAD
                     .set VE_HEAD = VE_FETCH
                 XT_FETCH:
003873 3874          .dw PFA_FETCH
                 PFA_FETCH:
                 .if WANT_UNIFIED == 1
                 .endif
                 PFA_FETCHRAM:
003874 01fc          movw zl, tosl
                     ; low byte is read before the high byte
003875 9181          ld tosl, z+
003876 9191          ld tosh, z+
003877 cf8c          jmp_ DO_NEXT
                 .if WANT_UNIFIED == 1
                 .endif
                 .include "words/store.asm"
                 
                 ; Memory
                 ; write n to RAM memory at addr, low byte first
                 VE_STORE:
003878 ff01          .dw $ff01
003879 0021          .db "!",0
00387a 3870          .dw VE_HEAD
                     .set VE_HEAD = VE_STORE
                 XT_STORE:
00387b 387c          .dw PFA_STORE
                 PFA_STORE:
                 .if WANT_UNIFIED == 1
                 .endif
                 PFA_STORERAM:
00387c 01fc          movw zl, tosl
00387d 9189
00387e 9199          loadtos
                     ; the high byte is written before the low byte
00387f 8391          std Z+1, tosh
003880 8380          std Z+0, tosl
003881 9189
003882 9199          loadtos
003883 cf80          jmp_ DO_NEXT
                 .if WANT_UNIFIED == 1
                 .endif
                 .include "words/cstore.asm"
                 
                 ; Memory
                 ; store a single byte to RAM address
                 VE_CSTORE:
003884 ff02          .dw $ff02
003885 2163          .db "c!"
003886 3878          .dw VE_HEAD
                     .set VE_HEAD = VE_CSTORE
                 XT_CSTORE:
003887 3888          .dw PFA_CSTORE
                 PFA_CSTORE:
003888 01fc          movw zl, tosl
003889 9189
00388a 9199          loadtos
00388b 8380          st Z, tosl
00388c 9189
00388d 9199          loadtos
00388e cf75          jmp_ DO_NEXT
                 .include "words/cfetch.asm"
                 
                 ; Memory
                 ; fetch a single byte from memory mapped locations
                 VE_CFETCH:
00388f ff02          .dw $ff02
003890 4063          .db "c@"
003891 3884          .dw VE_HEAD
                     .set VE_HEAD  = VE_CFETCH
                 XT_CFETCH:
003892 3893          .dw PFA_CFETCH
                 PFA_CFETCH:
003893 01fc          movw zl, tosl
003894 2799          clr tosh
003895 8180          ld tosl, Z
003896 cf6d          jmp_ DO_NEXT
                 .include "words/fetch-u.asm"
                 
                 ; Memory
                 ; read 1 cell from USER area
                 VE_FETCHU:
003897 ff02          .dw $ff02
003898 7540          .db "@u"
003899 388f          .dw VE_HEAD
                     .set VE_HEAD = VE_FETCHU
                 XT_FETCHU:
00389a 3800          .dw DO_COLON
                 PFA_FETCHU:
00389b 3af0          .dw XT_UP_FETCH
00389c 3997          .dw XT_PLUS
00389d 3873          .dw XT_FETCH
00389e 381a          .dw XT_EXIT
                 .include "words/store-u.asm"
                 
                 ; Memory
                 ; write n to USER area at offset
                 VE_STOREU:
00389f ff02          .dw $ff02
0038a0 7521          .db "!u"
0038a1 3897          .dw VE_HEAD
                     .set VE_HEAD = VE_STOREU
                 XT_STOREU:
0038a2 3800          .dw DO_COLON
                 PFA_STOREU:
0038a3 3af0          .dw XT_UP_FETCH
0038a4 3997          .dw XT_PLUS
0038a5 387b          .dw XT_STORE
0038a6 381a          .dw XT_EXIT
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/dup.asm"
                 
                 ; Stack
                 ; duplicate TOS
                 VE_DUP:
0038a7 ff03          .dw $ff03
0038a8 7564
0038a9 0070          .db "dup",0
0038aa 389f          .dw VE_HEAD
                     .set VE_HEAD = VE_DUP
                 XT_DUP:
0038ab 38ac          .dw PFA_DUP
                 PFA_DUP:
0038ac 939a
0038ad 938a          savetos
0038ae cf55          jmp_ DO_NEXT
                 .include "words/qdup.asm"
                 
                 ; Stack
                 ; duplicate TOS if non-zero
                 VE_QDUP:
0038af ff04          .dw $ff04
0038b0 643f
0038b1 7075          .db "?dup"
0038b2 38a7          .dw VE_HEAD
                     .set VE_HEAD = VE_QDUP
                 XT_QDUP:
0038b3 38b4          .dw PFA_QDUP
                 PFA_QDUP:
0038b4 2f08          mov temp0, tosl
0038b5 2b09          or temp0, tosh
0038b6 f011          breq PFA_QDUP1
0038b7 939a
0038b8 938a          savetos
                 PFA_QDUP1:
0038b9 cf4a          jmp_ DO_NEXT
                 .include "words/swap.asm"
                 
                 ; Stack
                 ; swaps the two top level stack cells
                 VE_SWAP:
0038ba ff04          .dw $ff04
0038bb 7773
0038bc 7061          .db "swap"
0038bd 38af          .dw VE_HEAD
                     .set VE_HEAD = VE_SWAP
                 XT_SWAP:
0038be 38bf          .dw PFA_SWAP
                 PFA_SWAP:
0038bf 018c          movw temp0, tosl
0038c0 9189
0038c1 9199          loadtos
0038c2 931a          st -Y, temp1
0038c3 930a          st -Y, temp0
0038c4 cf3f          jmp_ DO_NEXT
                 .include "words/over.asm"
                 
                 ; Stack
                 ; Place a copy of x1 on top of the stack
                 VE_OVER:
0038c5 ff04          .dw $ff04
0038c6 766f
0038c7 7265          .db "over"
0038c8 38ba          .dw VE_HEAD
                     .set VE_HEAD = VE_OVER
                 XT_OVER:
0038c9 38ca          .dw PFA_OVER
                 PFA_OVER:
0038ca 939a
0038cb 938a          savetos
0038cc 818a          ldd tosl, Y+2
0038cd 819b          ldd tosh, Y+3
                 
0038ce cf35          jmp_ DO_NEXT
                 .include "words/drop.asm"
                 
                 ; Stack
                 ; drop TOS
                 VE_DROP:
0038cf ff04          .dw $ff04
0038d0 7264
0038d1 706f          .db "drop"
0038d2 38c5          .dw VE_HEAD
                     .set VE_HEAD = VE_DROP
                 XT_DROP:
0038d3 38d4          .dw PFA_DROP
                 PFA_DROP:
0038d4 9189
0038d5 9199          loadtos
0038d6 cf2d          jmp_ DO_NEXT
                 .include "words/rot.asm"
                 
                 ; Stack
                 ; rotate the three top level cells
                 VE_ROT:
0038d7 ff03          .dw $ff03
0038d8 6f72
0038d9 0074          .db "rot",0
0038da 38cf          .dw VE_HEAD
                     .set VE_HEAD = VE_ROT
                 XT_ROT:
0038db 38dc          .dw PFA_ROT
                 PFA_ROT:
0038dc 018c          movw temp0, tosl
0038dd 9129          ld temp2, Y+
0038de 9139          ld temp3, Y+ 
0038df 9189
0038e0 9199          loadtos
                         
0038e1 933a          st -Y, temp3
0038e2 932a          st -Y, temp2
0038e3 931a          st -Y, temp1
0038e4 930a          st -Y, temp0
                 
0038e5 cf1e          jmp_ DO_NEXT
                 .include "words/nip.asm"
                 
                 ; Stack
                 ; Remove Second of Stack
                 VE_NIP:
0038e6 ff03          .dw $ff03
0038e7 696e
0038e8 0070          .db "nip",0
0038e9 38d7          .dw VE_HEAD
                     .set VE_HEAD = VE_NIP
                 XT_NIP:
0038ea 38eb          .dw PFA_NIP
                 PFA_NIP:
0038eb 9622          adiw yl, 2
0038ec cf17          jmp_ DO_NEXT
                 ;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/r_from.asm"
                 
                 ; Stack
                 ; move TOR to TOS
                 VE_R_FROM:
0038ed ff02          .dw $ff02
0038ee 3e72          .db "r>"
0038ef 38e6          .dw VE_HEAD
                     .set VE_HEAD = VE_R_FROM
                 XT_R_FROM:
0038f0 38f1          .dw PFA_R_FROM
                 PFA_R_FROM:
0038f1 939a
0038f2 938a          savetos
0038f3 918f          pop tosl
0038f4 919f          pop tosh
0038f5 cf0e          jmp_ DO_NEXT
                 .include "words/to_r.asm"
                 
                 ; Stack
                 ; move TOS to TOR
                 VE_TO_R:
0038f6 ff02          .dw $ff02
0038f7 723e          .db ">r"
0038f8 38ed          .dw VE_HEAD
                     .set VE_HEAD = VE_TO_R
                 XT_TO_R:
0038f9 38fa          .dw PFA_TO_R
                 PFA_TO_R:
0038fa 939f          push tosh
0038fb 938f          push tosl
0038fc 9189
0038fd 9199          loadtos
0038fe cf05          jmp_ DO_NEXT
                 .include "words/r_fetch.asm"
                 
                 ; Stack
                 ; fetch content of TOR
                 VE_R_FETCH:
0038ff ff02          .dw $ff02
003900 4072          .db "r@"
003901 38f6          .dw VE_HEAD
                     .set VE_HEAD = VE_R_FETCH
                 XT_R_FETCH:
003902 3903          .dw PFA_R_FETCH
                 PFA_R_FETCH:
003903 939a
003904 938a          savetos
003905 918f          pop tosl
003906 919f          pop tosh
003907 939f          push tosh
003908 938f          push tosl
003909 cefa          jmp_ DO_NEXT
                 
                 
                 .include "words/not-equal.asm"
                 
                 ; Compare
                 ; true if n1 is not equal to n2
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_NOTEQUAL:
00390a ff02          .dw $ff02
00390b 3e3c          .db "<>"
00390c 38ff          .dw VE_HEAD
                     .set VE_HEAD = VE_NOTEQUAL
                 XT_NOTEQUAL:
00390d 3800          .dw DO_COLON
                 PFA_NOTEQUAL:
                 .endif
                 
00390e 3fc5
00390f 3914
003910 381a          .DW XT_EQUAL,XT_ZEROEQUAL,XT_EXIT
                 .include "words/equalzero.asm"
                 
                 ; Compare
                 ; compare with 0 (zero)
                 VE_ZEROEQUAL:
003911 ff02          .dw $ff02
003912 3d30          .db "0="
003913 390a          .dw VE_HEAD
                     .set VE_HEAD = VE_ZEROEQUAL
                 XT_ZEROEQUAL:
003914 3915          .dw PFA_ZEROEQUAL
                 PFA_ZEROEQUAL:
003915 2b98          or tosh, tosl
003916 f5d1          brne PFA_ZERO1
003917 c030          rjmp PFA_TRUE1
                 .include "words/lesszero.asm"
                 
                 ; Compare
                 ; compare with zero
                 VE_ZEROLESS:
003918 ff02          .dw $ff02
003919 3c30          .db "0<"
00391a 3911          .dw VE_HEAD
                     .set VE_HEAD = VE_ZEROLESS
                 XT_ZEROLESS:
00391b 391c          .dw PFA_ZEROLESS
                 PFA_ZEROLESS:
00391c fd97          sbrc tosh,7
00391d c02a          rjmp PFA_TRUE1
00391e c032          rjmp PFA_ZERO1
                 .include "words/greaterzero.asm"
                 
                 ; Compare
                 ; true if n1 is greater than 0
                 VE_GREATERZERO:
00391f ff02          .dw $ff02
003920 3e30          .db "0>"
003921 3918          .dw VE_HEAD
                     .set VE_HEAD = VE_GREATERZERO
                 XT_GREATERZERO:
003922 3923          .dw PFA_GREATERZERO
                 PFA_GREATERZERO:
003923 1582          cp tosl, zerol
003924 0593          cpc tosh, zeroh
003925 f15c          brlt PFA_ZERO1
003926 f151          brbs 1, PFA_ZERO1
003927 c020          rjmp PFA_TRUE1
                 .include "words/d-greaterzero.asm"
                 
                 ; Compare
                 ; compares if a double double cell number is greater 0
                 VE_DGREATERZERO:
003928 ff03          .dw $ff03
003929 3064
00392a 003e          .db "d0>",0
00392b 391f          .dw VE_HEAD
                     .set VE_HEAD = VE_DGREATERZERO
                 XT_DGREATERZERO:
00392c 392d          .dw PFA_DGREATERZERO
                 PFA_DGREATERZERO:
00392d 1582          cp tosl, zerol
00392e 0593          cpc tosh, zeroh
00392f 9189
003930 9199          loadtos
003931 0582          cpc tosl, zerol
003932 0593          cpc tosh, zeroh
003933 f0ec          brlt PFA_ZERO1
003934 f0e1          brbs 1, PFA_ZERO1
003935 c012          rjmp PFA_TRUE1
                 .include "words/d-lesszero.asm"
                 
                 ; Compare
                 ; compares if a double double cell number is less than 0
                 VE_DXT_ZEROLESS:
003936 ff03          .dw $ff03
003937 3064
003938 003c          .db "d0<",0
003939 3928          .dw VE_HEAD
                     .set VE_HEAD = VE_DXT_ZEROLESS
                 XT_DXT_ZEROLESS:
00393a 393b          .dw PFA_DXT_ZEROLESS
                 PFA_DXT_ZEROLESS:
00393b 9622          adiw Y,2
00393c fd97          sbrc tosh,7
00393d 940c 3948     jmp PFA_TRUE1
00393f 940c 3951     jmp PFA_ZERO1
                 
                 .include "words/true.asm"
                 
                 ; Arithmetics
                 ; leaves the value -1 (true) on TOS
                 VE_TRUE:
003941 ff04          .dw $ff04
003942 7274
003943 6575          .db "true"
003944 3936          .dw VE_HEAD
                     .set VE_HEAD = VE_TRUE
                 XT_TRUE:
003945 3946          .dw PFA_TRUE
                 PFA_TRUE:
003946 939a
003947 938a          savetos
                 PFA_TRUE1:
003948 ef8f          ser tosl
003949 ef9f          ser tosh
00394a ceb9          jmp_ DO_NEXT
                 .include "words/zero.asm"
                 
                 ; Arithmetics
                 ; place a value 0 on TOS
                 VE_ZERO:
00394b ff01          .dw $ff01
00394c 0030          .db "0",0
00394d 3941          .dw VE_HEAD
                     .set VE_HEAD = VE_ZERO
                 XT_ZERO:
00394e 394f          .dw PFA_ZERO
                 PFA_ZERO:
00394f 939a
003950 938a          savetos
                 PFA_ZERO1:
003951 01c1          movw tosl, zerol
003952 ceb1          jmp_ DO_NEXT
                 .include "words/uless.asm"
                 
                 ; Compare
                 ; true if u1 < u2 (unsigned)
                 VE_ULESS:
003953 ff02          .dw $ff02
003954 3c75          .db "u<"
003955 394b          .dw VE_HEAD
                     .set VE_HEAD = VE_ULESS
                 XT_ULESS:
003956 3957          .dw PFA_ULESS
                 PFA_ULESS:
003957 9129          ld temp2, Y+
003958 9139          ld temp3, Y+
003959 1782          cp tosl, temp2
00395a 0793          cpc tosh, temp3
00395b f3a8          brlo PFA_ZERO1
00395c f3a1          brbs 1, PFA_ZERO1
00395d cfea          jmp_ PFA_TRUE1
                 .include "words/u-greater.asm"
                 
                 ; Compare
                 ; true if u1 > u2 (unsigned)
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_UGREATER:
00395e ff02          .dw $ff02
00395f 3e75          .db "u>"
003960 3953          .dw VE_HEAD
                     .set VE_HEAD = VE_UGREATER
                 XT_UGREATER:
003961 3800          .dw DO_COLON
                 PFA_UGREATER:
                 .endif
003962 38be          .DW XT_SWAP
003963 3956          .dw XT_ULESS
003964 381a          .dw XT_EXIT
                 .include "words/less.asm"
                 
                 ; Compare
                 ; true if n1 is less than n2
                     VE_LESS:
003965 ff01          .dw $ff01
003966 003c          .db "<",0
003967 395e          .dw VE_HEAD
                     .set VE_HEAD = VE_LESS
                 XT_LESS:
003968 3969          .dw PFA_LESS
                 PFA_LESS:
003969 9129          ld temp2, Y+
00396a 9139          ld temp3, Y+
00396b 1728          cp temp2, tosl
00396c 0739          cpc temp3, tosh
                 PFA_LESSDONE:
00396d f71c          brge PFA_ZERO1
00396e cfd9          rjmp PFA_TRUE1
                 .include "words/greater.asm"
                 
                 ; Compare
                 ; flag is true if n1 is greater than n2
                 VE_GREATER:
00396f ff01          .dw $ff01
003970 003e          .db ">",0
003971 3965          .dw VE_HEAD
                     .set VE_HEAD = VE_GREATER
                 XT_GREATER:
003972 3973          .dw PFA_GREATER
                 PFA_GREATER:
003973 9129          ld temp2, Y+
003974 9139          ld temp3, Y+
003975 1728          cp temp2, tosl
003976 0739          cpc temp3, tosh
                 PFA_GREATERDONE:
003977 f2cc          brlt PFA_ZERO1
003978 f2c1          brbs 1, PFA_ZERO1
003979 cfce          rjmp PFA_TRUE1
                 
                 .include "words/log2.asm"
                 
                 ; Arithmetics
                 ; logarithm to base 2 or highest set bitnumber
                 VE_LOG2:
00397a ff04          .dw $ff04
00397b 6f6c
00397c 3267          .db "log2"
00397d 396f          .dw VE_HEAD
                     .set VE_HEAD = VE_LOG2
                 XT_LOG2:
00397e 397f          .dw PFA_LOG2
                 PFA_LOG2:
00397f 01fc          movw zl, tosl
003980 2799          clr tosh
003981 e180          ldi tosl, 16
                 PFA_LOG2_1:
003982 958a          dec tosl
003983 f022          brmi PFA_LOG2_2 ; wrong data
003984 0fee          lsl  zl
003985 1fff          rol  zh
003986 f7d8          brcc PFA_LOG2_1
003987 ce7c          jmp_ DO_NEXT
                 
                 PFA_LOG2_2:
003988 959a          dec tosh
003989 ce7a          jmp_ DO_NEXT
                 .include "words/minus.asm"
                 
                 ; Arithmetics
                 ; subtract n2 from n1
                 VE_MINUS:
00398a ff01          .dw $ff01
00398b 002d          .db "-",0
00398c 397a          .dw VE_HEAD
                     .set VE_HEAD = VE_MINUS
                 XT_MINUS:
00398d 398e          .dw PFA_MINUS
                 PFA_MINUS:
00398e 9109          ld temp0, Y+
00398f 9119          ld temp1, Y+
003990 1b08          sub temp0, tosl
003991 0b19          sbc temp1, tosh
003992 01c8          movw tosl, temp0
003993 ce70          jmp_ DO_NEXT
                 .include "words/plus.asm"
                 
                 ; Arithmetics
                 ; add n1 and n2
                 VE_PLUS:
003994 ff01          .dw $ff01
003995 002b          .db "+",0
003996 398a          .dw VE_HEAD
                     .set VE_HEAD = VE_PLUS
                 XT_PLUS:
003997 3998          .dw PFA_PLUS
                 PFA_PLUS:
003998 9109          ld temp0, Y+
003999 9119          ld temp1, Y+
00399a 0f80          add tosl, temp0
00399b 1f91          adc tosh, temp1
00399c ce67          jmp_ DO_NEXT
                 .include "words/mstar.asm"
                 
                 ; Arithmetics
                 ; multiply 2 cells to a double cell
                 VE_MSTAR:
00399d ff02          .dw $ff02
00399e 2a6d          .db "m*"
00399f 3994          .dw VE_HEAD
                     .set VE_HEAD = VE_MSTAR
                 XT_MSTAR:
0039a0 39a1          .dw PFA_MSTAR
                 PFA_MSTAR:
0039a1 018c          movw temp0, tosl
0039a2 9189
0039a3 9199          loadtos
0039a4 019c          movw temp2, tosl
                     ; high cell ah*bh
0039a5 0231          muls temp3, temp1
0039a6 0170          movw temp4, r0
                     ; low cell  al*bl
0039a7 9f20          mul  temp2, temp0
0039a8 01c0          movw tosl, r0
                     ; signed ah*bl
0039a9 0330          mulsu temp3, temp0
0039aa 08f3          sbc   temp5, zeroh
0039ab 0d90          add   tosh,  r0
0039ac 1ce1          adc   temp4, r1
0039ad 1cf3          adc   temp5, zeroh
                     
                     ; signed al*bh
0039ae 0312          mulsu temp1, temp2
0039af 08f3          sbc   temp5, zeroh
0039b0 0d90          add   tosh,  r0
0039b1 1ce1          adc   temp4, r1
0039b2 1cf3          adc   temp5, zeroh
                 
0039b3 939a
0039b4 938a          savetos
0039b5 01c7          movw tosl, temp4
0039b6 ce4d          jmp_ DO_NEXT
                 .include "words/umslashmod.asm"
                 
                 ; Arithmetics
                 ; unsigned division ud / u2 with remainder
                 VE_UMSLASHMOD:
0039b7 ff06          .dw $ff06
0039b8 6d75
0039b9 6d2f
0039ba 646f          .db "um/mod"
0039bb 399d          .dw VE_HEAD
                     .set VE_HEAD = VE_UMSLASHMOD
                 XT_UMSLASHMOD:
0039bc 39bd          .dw PFA_UMSLASHMOD
                 PFA_UMSLASHMOD:
0039bd 017c          movw temp4, tosl
                 
0039be 9129          ld temp2, Y+
0039bf 9139          ld temp3, Y+
                   
0039c0 9109          ld temp0, Y+
0039c1 9119          ld temp1, Y+
                 
                 ;; unsigned 32/16 -> 16r16 divide
                 
                 PFA_UMSLASHMODmod:
                 
                   ; set loop counter
0039c2 e140          ldi temp6,$10
                 
                 PFA_UMSLASHMODmod_loop:
                     ; shift left, saving high bit
0039c3 2755          clr temp7
0039c4 0f00          lsl temp0
0039c5 1f11          rol temp1
0039c6 1f22          rol temp2
0039c7 1f33          rol temp3
0039c8 1f55          rol temp7
                 
                   ; try subtracting divisor
0039c9 152e          cp temp2, temp4
0039ca 053f          cpc temp3, temp5
0039cb 0552          cpc temp7,zerol
                 
0039cc f018          brcs PFA_UMSLASHMODmod_loop_control
                 
                 PFA_UMSLASHMODmod_subtract:
                     ; dividend is large enough
                     ; do the subtraction for real
                     ; and set lowest bit
0039cd 9503          inc temp0
0039ce 192e          sub temp2, temp4
0039cf 093f          sbc temp3, temp5
                 
                 PFA_UMSLASHMODmod_loop_control:
0039d0 954a          dec  temp6
0039d1 f789          brne PFA_UMSLASHMODmod_loop
                 
                 PFA_UMSLASHMODmod_done:
                     ; put remainder on stack
0039d2 933a          st -Y,temp3
0039d3 932a          st -Y,temp2
                 
                     ; put quotient on stack
0039d4 01c8          movw tosl, temp0
0039d5 ce2e          jmp_ DO_NEXT
                 .include "words/umstar.asm"
                 
                 ; Arithmetics
                 ; multiply 2 unsigned cells to a double cell
                 VE_UMSTAR:
0039d6 ff03          .dw $ff03
0039d7 6d75
0039d8 002a          .db "um*",0
0039d9 39b7          .dw VE_HEAD
                     .set VE_HEAD = VE_UMSTAR
                 XT_UMSTAR:
0039da 39db          .dw PFA_UMSTAR
                 PFA_UMSTAR:
0039db 018c          movw temp0, tosl
0039dc 9189
0039dd 9199          loadtos
                     ; result: (temp3*temp1)* 65536 + (temp3*temp0 + temp1*temp2) * 256 + (temp0 * temp2)
                     ; low bytes
0039de 9f80          mul tosl,temp0
0039df 01f0          movw zl, r0
0039e0 2722          clr temp2
0039e1 2733          clr temp3
                     ; middle bytes
0039e2 9f90          mul tosh, temp0
0039e3 0df0          add zh, r0
0039e4 1d21          adc temp2, r1
0039e5 1d33          adc temp3, zeroh
                         
0039e6 9f81          mul tosl, temp1
0039e7 0df0          add zh, r0
0039e8 1d21          adc temp2, r1
0039e9 1d33          adc temp3, zeroh
                     
0039ea 9f91          mul tosh, temp1
0039eb 0d20          add temp2, r0
0039ec 1d31          adc temp3, r1
0039ed 01cf          movw tosl, zl
0039ee 939a
0039ef 938a          savetos
0039f0 01c9          movw tosl, temp2
0039f1 ce12          jmp_ DO_NEXT
                 
                 .include "words/invert.asm"
                 
                 ; Arithmetics
                 ; 1-complement of TOS
                 VE_INVERT:
0039f2 ff06          .dw $ff06
0039f3 6e69
0039f4 6576
0039f5 7472          .db "invert"
0039f6 39d6          .dw VE_HEAD
                     .set VE_HEAD = VE_INVERT
                 XT_INVERT:
0039f7 39f8          .dw PFA_INVERT
                 PFA_INVERT:
0039f8 9580          com tosl
0039f9 9590          com tosh
0039fa ce09          jmp_ DO_NEXT
                 .include "words/2slash.asm"
                 
                 ; Arithmetics
                 ; arithmetic shift right
                 VE_2SLASH:
0039fb ff02          .dw $ff02
0039fc 2f32          .db "2/"
0039fd 39f2          .dw VE_HEAD
                     .set VE_HEAD = VE_2SLASH
                 XT_2SLASH:
0039fe 39ff          .dw PFA_2SLASH
                 PFA_2SLASH:
0039ff 9595          asr tosh
003a00 9587          ror tosl
003a01 ce02          jmp_ DO_NEXT
                 .include "words/2star.asm"
                 
                 ; Arithmetics
                 ; arithmetic shift left, filling with zero
                 VE_2STAR:
003a02 ff02          .dw $ff02
003a03 2a32          .db "2*"
003a04 39fb          .dw VE_HEAD
                     .set VE_HEAD = VE_2STAR
                 XT_2STAR:
003a05 3a06          .dw PFA_2STAR
                 PFA_2STAR:
003a06 0f88          lsl tosl
003a07 1f99          rol tosh
003a08 cdfb          jmp_ DO_NEXT
                 .include "words/and.asm"
                 
                 ; Logic
                 ; bitwise and
                 VE_AND:
003a09 ff03          .dw $ff03
003a0a 6e61
003a0b 0064          .db "and",0
003a0c 3a02          .dw VE_HEAD
                     .set VE_HEAD = VE_AND
                 XT_AND:
003a0d 3a0e          .dw PFA_AND
                 PFA_AND:
003a0e 9109          ld temp0, Y+
003a0f 9119          ld temp1, Y+
003a10 2380          and tosl, temp0
003a11 2391          and tosh, temp1
003a12 cdf1          jmp_ DO_NEXT
                 .include "words/or.asm"
                 
                 ; Logic
                 ; logical or
                 VE_OR:
003a13 ff02          .dw $ff02
003a14 726f          .db "or"
003a15 3a09          .dw VE_HEAD
                     .set VE_HEAD = VE_OR
                 XT_OR:
003a16 3a17          .dw PFA_OR
                 PFA_OR:
003a17 9109          ld temp0, Y+
003a18 9119          ld temp1, Y+
003a19 2b80          or tosl, temp0
003a1a 2b91          or tosh, temp1
003a1b cde8          jmp_ DO_NEXT
                 
                 .include "words/xor.asm"
                 
                 ; Logic
                 ; exclusive or
                 VE_XOR:
003a1c ff03          .dw $ff03
003a1d 6f78
003a1e 0072          .db "xor",0
003a1f 3a13          .dw VE_HEAD
                     .set VE_HEAD = VE_XOR
                 XT_XOR:
003a20 3a21          .dw PFA_XOR
                 PFA_XOR:
003a21 9109          ld temp0, Y+
003a22 9119          ld temp1, Y+
003a23 2780          eor tosl, temp0
003a24 2791          eor tosh, temp1
003a25 cdde          jmp_ DO_NEXT
                 
                 .include "words/1plus.asm"
                 
                 ; Arithmetics
                 ; optimized increment
                 VE_1PLUS:
003a26 ff02          .dw $ff02
003a27 2b31          .db "1+"
003a28 3a1c          .dw VE_HEAD
                     .set VE_HEAD = VE_1PLUS
                 XT_1PLUS:
003a29 3a2a          .dw PFA_1PLUS
                 PFA_1PLUS:
003a2a 9601          adiw tosl,1
003a2b cdd8          jmp_ DO_NEXT
                 .include "words/1minus.asm"
                 
                 ; Arithmetics
                 ; optimized decrement
                 VE_1MINUS:
003a2c ff02          .dw $ff02 
003a2d 2d31          .db "1-"
003a2e 3a26          .dw VE_HEAD
                     .set VE_HEAD = VE_1MINUS
                 XT_1MINUS:
003a2f 3a30          .dw PFA_1MINUS
                 PFA_1MINUS:
003a30 9701          sbiw tosl, 1
003a31 cdd2          jmp_ DO_NEXT
                 .include "words/lshift.asm"
                 
                 ; Arithmetics
                 ; logically shift n1 left n2 times
                 VE_LSHIFT:
003a32 ff06          .dw $ff06
003a33 736c
003a34 6968
003a35 7466          .db "lshift"
003a36 3a2c          .dw VE_HEAD
                     .set VE_HEAD = VE_LSHIFT
                 XT_LSHIFT:
003a37 3a38          .dw PFA_LSHIFT
                 PFA_LSHIFT:
003a38 01fc          movw zl, tosl
003a39 9189
003a3a 9199          loadtos
                 PFA_LSHIFT1:
003a3b 9731          sbiw zl, 1
003a3c f01a          brmi PFA_LSHIFT2
003a3d 0f88          lsl tosl
003a3e 1f99          rol tosh
003a3f cffb          rjmp PFA_LSHIFT1
                 PFA_LSHIFT2:
003a40 cdc3          jmp_ DO_NEXT
                 
                 .include "words/rshift.asm"
                 
                 ; Arithmetics
                 ; shift n1 n2-times logically right
                 VE_RSHIFT:
003a41 ff06          .dw $ff06
003a42 7372
003a43 6968
003a44 7466          .db "rshift"
003a45 3a32          .dw VE_HEAD
                     .set VE_HEAD = VE_RSHIFT
                 XT_RSHIFT:
003a46 3a47          .dw PFA_RSHIFT
                 PFA_RSHIFT:
003a47 01fc          movw zl, tosl
003a48 9189
003a49 9199          loadtos
                 PFA_RSHIFT1:
003a4a 9731          sbiw zl, 1
003a4b f01a          brmi PFA_RSHIFT2
003a4c 9596          lsr tosh
003a4d 9587          ror tosl
003a4e cffb          rjmp PFA_RSHIFT1
                 PFA_RSHIFT2:
003a4f cdb4          jmp_ DO_NEXT
                 
                 .include "words/plusstore.asm"
                 
                 ; Arithmetics
                 ; add n to content of RAM address a-addr
                 VE_PLUSSTORE:
003a50 ff02          .dw $ff02
003a51 212b          .db "+!"
003a52 3a41          .dw VE_HEAD
                     .set VE_HEAD = VE_PLUSSTORE
                 XT_PLUSSTORE:
003a53 3a54          .dw PFA_PLUSSTORE
                 PFA_PLUSSTORE:
003a54 01fc          movw zl, tosl
003a55 9189
003a56 9199          loadtos
003a57 8120          ldd temp2, Z+0
003a58 8131          ldd temp3, Z+1
003a59 0f82          add tosl, temp2
003a5a 1f93          adc tosh, temp3
003a5b 8380          std Z+0, tosl
003a5c 8391          std Z+1, tosh
003a5d 9189
003a5e 9199          loadtos
003a5f cda4          jmp_ DO_NEXT
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/rpfetch.asm"
                 
                 ; Stack
                 ; current return stack pointer address
                 VE_RP_FETCH:
003a60 ff03          .dw $ff03
003a61 7072
003a62 0040          .db "rp@",0
003a63 3a50          .dw VE_HEAD
                     .set VE_HEAD = VE_RP_FETCH
                 XT_RP_FETCH:
003a64 3a65          .dw PFA_RP_FETCH
                 PFA_RP_FETCH:
003a65 939a
003a66 938a          savetos
003a67 b78d          in tosl, SPL
003a68 b79e          in tosh, SPH
003a69 cd9a          jmp_ DO_NEXT
                 .include "words/rpstore.asm"
                 
                 ; Stack
                 ; set return stack pointer
                 VE_RP_STORE:
003a6a ff03          .dw $ff03
003a6b 7072
003a6c 0021          .db "rp!",0
003a6d 3a60          .dw VE_HEAD
                     .set VE_HEAD = VE_RP_STORE
                 XT_RP_STORE:
003a6e 3a6f          .dw PFA_RP_STORE
                 PFA_RP_STORE:
003a6f b72f          in temp2, SREG
003a70 94f8          cli
003a71 bf8d          out SPL, tosl
003a72 bf9e          out SPH, tosh
003a73 bf2f          out SREG, temp2
003a74 9189
003a75 9199          loadtos
003a76 cd8d          jmp_ DO_NEXT
                 .include "words/spfetch.asm"
                 
                 ; Stack
                 ; current data stack pointer
                 VE_SP_FETCH:
003a77 ff03          .dw $ff03
003a78 7073
003a79 0040          .db "sp@",0
003a7a 3a6a          .dw VE_HEAD
                     .set VE_HEAD = VE_SP_FETCH
                 XT_SP_FETCH:
003a7b 3a7c          .dw PFA_SP_FETCH
                 PFA_SP_FETCH:
003a7c 939a
003a7d 938a          savetos
003a7e 01ce          movw tosl, yl
003a7f cd84          jmp_ DO_NEXT
                 .include "words/spstore.asm"
                 
                 ; Stack
                 ; set data stack pointer to addr
                 VE_SP_STORE:
003a80 ff03          .dw $ff03
003a81 7073
003a82 0021          .db "sp!",0
003a83 3a77          .dw VE_HEAD
                     .set VE_HEAD = VE_SP_STORE
                 XT_SP_STORE:
003a84 3a85          .dw PFA_SP_STORE
                 PFA_SP_STORE:
003a85 01ec          movw yl, tosl
003a86 9189
003a87 9199          loadtos
003a88 cd7b          jmp_ DO_NEXT
                 
                 .include "words/dodo.asm"
                 
                 ; System
                 ; runtime of do
                 ;VE_DODO:
                 ;    .dw $ff04
                 ;    .db "(do)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DODO
                 XT_DODO:
003a89 3a8a          .dw PFA_DODO
                 PFA_DODO:
003a8a 9129          ld temp2, Y+
003a8b 9139          ld temp3, Y+  ; limit
                 PFA_DODO1:
003a8c e8e0          ldi zl, $80
003a8d 0f3e          add temp3, zl
003a8e 1b82          sub  tosl, temp2
003a8f 0b93          sbc  tosh, temp3
                 
003a90 933f          push temp3
003a91 932f          push temp2    ; limit  ( --> limit + $8000)
003a92 939f          push tosh
003a93 938f          push tosl     ; start -> index ( --> index - (limit - $8000)
003a94 9189
003a95 9199          loadtos
003a96 cd6d          jmp_ DO_NEXT
                 .include "words/i.asm"
                 
                 ; Compiler
                 ; current loop counter
                 VE_I:
003a97 ff01          .dw $FF01
003a98 0069          .db "i",0
003a99 3a80          .dw VE_HEAD
                     .set VE_HEAD = VE_I
                 XT_I:
003a9a 3a9b          .dw PFA_I
                 PFA_I:
003a9b 939a
003a9c 938a          savetos
003a9d 918f          pop tosl
003a9e 919f          pop tosh  ; index
003a9f 91ef          pop zl
003aa0 91ff          pop zh    ; limit
003aa1 93ff          push zh
003aa2 93ef          push zl
003aa3 939f          push tosh
003aa4 938f          push tosl
003aa5 0f8e          add tosl, zl
003aa6 1f9f          adc tosh, zh
003aa7 cd5c          jmp_ DO_NEXT
                 .include "words/doplusloop.asm"
                 
                 ; System
                 ; runtime of +loop
                 ;VE_DOPLUSLOOP:
                 ;    .dw $ff07
                 ;    .db "(+loop)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOPLUSLOOP
                 XT_DOPLUSLOOP:
003aa8 3aa9          .dw PFA_DOPLUSLOOP
                 PFA_DOPLUSLOOP:
003aa9 91ef          pop zl
003aaa 91ff          pop zh
003aab 0fe8          add zl, tosl
003aac 1ff9          adc zh, tosh
003aad 9189
003aae 9199          loadtos
003aaf f01b          brvs PFA_DOPLUSLOOP_LEAVE
                     ; next cycle
                 PFA_DOPLUSLOOP_NEXT:
                     ; next iteration
003ab0 93ff          push zh
003ab1 93ef          push zl
003ab2 cd77          rjmp PFA_DOBRANCH ; read next cell from dictionary and jump to its destination
                 PFA_DOPLUSLOOP_LEAVE:
003ab3 910f          pop  temp0
003ab4 911f          pop  temp1  ; remove limit
003ab5 9611          adiw xl, 1  ; skip branch-back address
003ab6 cd4d          jmp_ DO_NEXT
                 .include "words/doloop.asm"
                 
                 ; System
                 ; runtime of loop
                 ;VE_DOLOOP:
                 ;    .dw $ff06
                 ;    .db "(loop)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOLOOP
                 XT_DOLOOP:
003ab7 3ab8          .dw PFA_DOLOOP
                 PFA_DOLOOP:
003ab8 91ef          pop zl
003ab9 91ff          pop zh
003aba 9631          adiw zl,1
003abb f3bb          brvs PFA_DOPLUSLOOP_LEAVE
003abc cff3          jmp_ PFA_DOPLUSLOOP_NEXT
                 .include "words/unloop.asm"
                 
                 ; Compiler
                 ; remove loop-sys, exit the loop and continue execution after it
                 VE_UNLOOP:
003abd ff06          .dw $ff06
003abe 6e75
003abf 6f6c
003ac0 706f          .db "unloop"
003ac1 3a97          .dw VE_HEAD
                     .set VE_HEAD = VE_UNLOOP
                 XT_UNLOOP:
003ac2 3ac3          .dw PFA_UNLOOP
                 PFA_UNLOOP:
003ac3 911f          pop temp1
003ac4 910f          pop temp0
003ac5 911f          pop temp1
003ac6 910f          pop temp0
003ac7 cd3c          jmp_ DO_NEXT
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 
                 .include "words/cmove_g.asm"
                 
                 ; Memory
                 ; copy data in RAM from higher to lower addresses.
                 VE_CMOVE_G:
003ac8 ff06          .dw $ff06
003ac9 6d63
003aca 766f
003acb 3e65          .db "cmove>"
003acc 3abd          .dw VE_HEAD
                     .set VE_HEAD  = VE_CMOVE_G
                 XT_CMOVE_G:
003acd 3ace          .dw PFA_CMOVE_G
                 PFA_CMOVE_G:
003ace 93bf          push xh
003acf 93af          push xl
003ad0 91e9          ld zl, Y+
003ad1 91f9          ld zh, Y+ ; addr-to
003ad2 91a9          ld xl, Y+
003ad3 91b9          ld xh, Y+ ; addr-from
003ad4 2f09          mov temp0, tosh
003ad5 2b08          or temp0, tosl
003ad6 f041          brbs 1, PFA_CMOVE_G1
003ad7 0fe8          add zl, tosl
003ad8 1ff9          adc zh, tosh
003ad9 0fa8          add xl, tosl
003ada 1fb9          adc xh, tosh
                 PFA_CMOVE_G2:
003adb 911e          ld temp1, -X
003adc 9312          st -Z, temp1
003add 9701          sbiw tosl, 1
003ade f7e1          brbc 1, PFA_CMOVE_G2
                 PFA_CMOVE_G1:
003adf 91af          pop xl
003ae0 91bf          pop xh
003ae1 9189
003ae2 9199          loadtos
003ae3 cd20          jmp_ DO_NEXT
                 .include "words/byteswap.asm"
                 
                 ; Arithmetics
                 ; exchange the bytes of the TOS
                 VE_BYTESWAP:
003ae4 ff02          .dw $ff02
003ae5 3c3e          .db "><"
003ae6 3ac8          .dw VE_HEAD
                     .set VE_HEAD = VE_BYTESWAP
                 XT_BYTESWAP:
003ae7 3ae8          .dw PFA_BYTESWAP
                 PFA_BYTESWAP:
003ae8 2f09          mov temp0, tosh
003ae9 2f98          mov tosh, tosl
003aea 2f80          mov tosl, temp0
003aeb cd18          jmp_ DO_NEXT
                 .include "words/up.asm"
                 
                 ; System Variable
                 ; get user area pointer
                 VE_UP_FETCH:
003aec ff03          .dw $ff03
003aed 7075
003aee 0040          .db "up@",0
003aef 3ae4          .dw VE_HEAD
                     .set VE_HEAD = VE_UP_FETCH
                 XT_UP_FETCH:
003af0 3af1          .dw PFA_UP_FETCH
                 PFA_UP_FETCH:
003af1 939a
003af2 938a          savetos
003af3 01c2          movw tosl, upl
003af4 cd0f          jmp_ DO_NEXT
                 
                 ; ( addr -- ) 
                 ; System Variable
                 ; set user area pointer
                 VE_UP_STORE:
003af5 ff03          .dw $ff03
003af6 7075
003af7 0021          .db "up!",0
003af8 3aec          .dw VE_HEAD
                     .set VE_HEAD = VE_UP_STORE
                 XT_UP_STORE:
003af9 3afa          .dw PFA_UP_STORE
                 PFA_UP_STORE:
003afa 012c          movw upl, tosl
003afb 9189
003afc 9199          loadtos
003afd cd06          jmp_ DO_NEXT
                 .include "words/1ms.asm"
                 
                 ; Time
                 ; busy waits (almost) exactly 1 millisecond
                 VE_1MS:
003afe ff03          .dw $ff03
003aff 6d31
003b00 0073          .db "1ms",0
003b01 3af5          .dw VE_HEAD
                     .set VE_HEAD = VE_1MS
                 XT_1MS:
003b02 3b03          .dw PFA_1MS
                 PFA_1MS:
003b03 eae0
003b04 e0ff
003b05 9731
003b06 f7f1          delay 1000
003b07 ccfc          jmp_ DO_NEXT
                 .include "words/2to_r.asm"
                 
                 ; Stack
                 ; move DTOS to TOR
                 VE_2TO_R:
003b08 ff03          .dw $ff03
003b09 3e32
003b0a 0072          .db "2>r",0
003b0b 3afe          .dw VE_HEAD
                     .set VE_HEAD = VE_2TO_R
                 XT_2TO_R:
003b0c 3b0d          .dw PFA_2TO_R
                 PFA_2TO_R:
003b0d 01fc          movw zl, tosl
003b0e 9189
003b0f 9199          loadtos
003b10 939f          push tosh
003b11 938f          push tosl
003b12 93ff          push zh
003b13 93ef          push zl
003b14 9189
003b15 9199          loadtos
003b16 cced          jmp_ DO_NEXT
                 .include "words/2r_from.asm"
                 
                 ; Stack
                 ; move DTOR to TOS
                 VE_2R_FROM:
003b17 ff03          .dw $ff03
003b18 7232
003b19 003e          .db "2r>",0
003b1a 3b08          .dw VE_HEAD
                     .set VE_HEAD = VE_2R_FROM
                 XT_2R_FROM:
003b1b 3b1c          .dw PFA_2R_FROM
                 PFA_2R_FROM:
003b1c 939a
003b1d 938a          savetos
003b1e 91ef          pop zl
003b1f 91ff          pop zh
003b20 918f          pop tosl
003b21 919f          pop tosh
003b22 939a
003b23 938a          savetos
003b24 01cf          movw tosl, zl
003b25 ccde          jmp_ DO_NEXT
                 
                 .include "words/store-e.asm"
                 
                 ; Memory
                 ; write n (2bytes) to eeprom address
                 VE_STOREE:
003b26 ff02          .dw $ff02
003b27 6521          .db "!e"
003b28 3b17          .dw VE_HEAD
                     .set VE_HEAD = VE_STOREE
                 XT_STOREE:
003b29 3b2a          .dw PFA_STOREE
                 PFA_STOREE:
                 .if WANT_UNIFIED == 1
                 .endif
                 PFA_STOREE0:
003b2a 01fc          movw zl, tosl
003b2b 9189
003b2c 9199          loadtos
003b2d b72f          in_ temp2, SREG
003b2e 94f8          cli
003b2f d028          rcall PFA_FETCHE2
003b30 b500          in_  temp0, EEDR
003b31 1708          cp temp0,tosl
003b32 f009          breq PFA_STOREE3
003b33 d00b          rcall PFA_STOREE1
                 PFA_STOREE3:
003b34 9631          adiw zl,1
003b35 d022          rcall PFA_FETCHE2
003b36 b500          in_  temp0, EEDR
003b37 1709          cp temp0,tosh
003b38 f011          breq PFA_STOREE4
003b39 2f89          mov tosl, tosh
003b3a d004          rcall PFA_STOREE1
                 PFA_STOREE4:
003b3b bf2f          out_ SREG, temp2
003b3c 9189
003b3d 9199          loadtos
003b3e ccc5          jmp_ DO_NEXT
                     
                 PFA_STOREE1:
003b3f 99f9          sbic EECR, EEPE
003b40 cffe          rjmp PFA_STOREE1
                 
                 PFA_STOREE2: ; estore_wait_low_spm:
003b41 b707          in_ temp0, SPMCSR
003b42 fd00          sbrc temp0,SPMEN
003b43 cffd          rjmp PFA_STOREE2
                 
003b44 bdf2          out_ EEARH,zh
003b45 bde1          out_ EEARL,zl
003b46 bd80          out_ EEDR, tosl
003b47 9afa          sbi EECR,EEMPE
003b48 9af9          sbi EECR,EEPE
                 
003b49 9508          ret
                 .if WANT_UNIFIED == 1
                 .endif
                 .include "words/fetch-e.asm"
                 
                 ; Memory
                 ; read 1 cell from eeprom
                 VE_FETCHE:
003b4a ff02          .dw $ff02
003b4b 6540          .db "@e"
003b4c 3b26          .dw VE_HEAD
                     .set VE_HEAD = VE_FETCHE
                 XT_FETCHE:
003b4d 3b4e          .dw PFA_FETCHE
                 PFA_FETCHE:
                 .if WANT_UNIFIED == 1
                 .endif
                 PFA_FETCHE1:
003b4e b72f          in_ temp2, SREG
003b4f 94f8          cli
003b50 01fc          movw zl, tosl
003b51 d006          rcall PFA_FETCHE2
003b52 b580          in_ tosl, EEDR
                 
003b53 9631          adiw zl,1
                 
003b54 d003          rcall PFA_FETCHE2
003b55 b590          in_  tosh, EEDR
003b56 bf2f          out_ SREG, temp2
003b57 ccac          jmp_ DO_NEXT
                 
                 PFA_FETCHE2:
003b58 99f9          sbic EECR, EEPE
003b59 cffe          rjmp PFA_FETCHE2
                 
003b5a bdf2          out_ EEARH,zh
003b5b bde1          out_ EEARL,zl
                 
003b5c 9af8          sbi EECR,EERE
003b5d 9508          ret
                 
                 .if WANT_UNIFIED == 1
                 .endif
                 .include "words/store-i.asm"
                 
                 ; System Value
                 ; Deferred action to write a single 16bit cell to flash
                 VE_STOREI:
003b5e ff02          .dw $ff02
003b5f 6921          .db "!i"
003b60 3b4a          .dw VE_HEAD
                     .set VE_HEAD = VE_STOREI
                 XT_STOREI:
003b61 3dd8          .dw PFA_DODEFER1
                 PFA_STOREI:
003b62 003e          .dw EE_STOREI
003b63 3d7a          .dw XT_EDEFERFETCH
003b64 3d84          .dw XT_EDEFERSTORE
                 .if FLASHEND > $10000
                 .else
                   .include "words/store-i_nrww.asm"
                 
                 ; Memory
                 ; writes n to flash memory using assembly code (code to be placed in boot loader section)
                 VE_DO_STOREI_NRWW:
003b65 ff09          .dw $ff09
003b66 2128
003b67 2d69
003b68 726e
003b69 7777
003b6a 0029          .db "(!i-nrww)",0
003b6b 3b5e          .dw VE_HEAD
                     .set VE_HEAD = VE_DO_STOREI_NRWW
                 XT_DO_STOREI:
003b6c 3b6d          .dw PFA_DO_STOREI_NRWW
                 PFA_DO_STOREI_NRWW:
                   ; store status register
003b6d b71f        in temp1,SREG
003b6e 931f        push temp1
003b6f 94f8        cli
                 
003b70 019c        movw temp2, tosl ; save the (word) address
003b71 9189
003b72 9199        loadtos          ; get the new value for the flash cell
003b73 93af        push xl
003b74 93bf        push xh
003b75 93cf        push yl
003b76 93df        push yh
003b77 d009        rcall DO_STOREI_atmega
003b78 91df        pop yh
003b79 91cf        pop yl
003b7a 91bf        pop xh
003b7b 91af        pop xl
                   ; finally clear the stack
003b7c 9189
003b7d 9199        loadtos
003b7e 911f        pop temp1
                   ; restore status register (and interrupt enable flag)
003b7f bf1f        out SREG,temp1
                 
003b80 cc83        jmp_ DO_NEXT
                 
                 ; 
                 DO_STOREI_atmega:
                   ; write data to temp page buffer
                   ; use the values in tosl/tosh at the
                   ; appropiate place
003b81 d011        rcall pageload
                 
                   ; erase page if needed
                   ; it is needed if a bit goes from 0 to 1
003b82 94e0        com temp4
003b83 94f0        com temp5
003b84 218e        and tosl, temp4
003b85 219f        and tosh, temp5
003b86 2b98        or tosh, tosl
003b87 f021        breq DO_STOREI_writepage 
003b88 94b3          inc erase_counter
003b89 01f9          movw zl, temp2
003b8a e002          ldi temp0,(1<<PGERS)
003b8b d020          rcall dospm
                 
                 DO_STOREI_writepage:
                   ; write page
003b8c 01f9        movw zl, temp2
003b8d e004        ldi temp0,(1<<PGWRT)
003b8e d01d        rcall dospm
                 
                   ; reenable RWW section
003b8f 01f9        movw zl, temp2
003b90 e100        ldi temp0,(1<<RWWSRE)
003b91 d01a        rcall dospm
003b92 9508        ret
                 
                 ; load the desired page
                 .equ pagemask = ~ ( PAGESIZE - 1 )
                 pageload:
003b93 01f9        movw zl, temp2
                   ; get the beginning of page
003b94 7ce0        andi zl,low(pagemask)
003b95 7fff        andi zh,high(pagemask)
003b96 01ef        movw y, z
                   ; loop counter (in words)
003b97 e4a0        ldi xl,low(pagesize)
003b98 e0b0        ldi xh,high(pagesize)
                 pageload_loop:
                   ; we need the current flash value anyways
003b99 01fe        movw z, y
003b9a 0fee
003b9b 1fff
003b9c 9145
003b9d 9155        readflashcell temp6, temp7 ; destroys Z
                   ; now check: if Z points to the same cell as temp2/3, we want the new data
003b9e 01fe        movw z, y
003b9f 17e2        cp zl, temp2
003ba0 07f3        cpc zh, temp3
003ba1 f011        breq pageload_newdata
003ba2 010a          movw r0, temp6
003ba3 c002          rjmp pageload_cont
                 pageload_newdata:
003ba4 017a          movw temp4, temp6
003ba5 010c          movw r0, tosl
                 pageload_cont:
003ba6 2700        clr temp0
003ba7 d004        rcall dospm
003ba8 9621        adiw y, 1
003ba9 9711        sbiw x, 1
003baa f771        brne pageload_loop
                 
                 pageload_done:
003bab 9508        ret
                 
                 
                 ;; dospm
                 ;;
                 ;; execute spm instruction
                 ;;   temp0 holds the value for SPMCR
                 
                 dospm:
                 dospm_wait_ee:
003bac 99f9        sbic EECR, EEPE
003bad cffe        rjmp dospm_wait_ee
                 dospm_wait_spm:
003bae b717        in_  temp1, SPMCSR
003baf fd10        sbrc temp1, SPMEN
003bb0 cffd        rjmp dospm_wait_spm
                 
                   ; turn the word addres into a byte address
003bb1 0fee
003bb2 1fff        writeflashcell
                   ; execute spm
003bb3 6001        ori temp0, (1<<SPMEN)
003bb4 bf07        out_ SPMCSR,temp0
003bb5 95e8        spm
003bb6 9508        ret
                 .endif
                 .include "words/fetch-i.asm"
                 
                 ; Memory
                 ; read 1 cell from flash
                 VE_FETCHI:
003bb7 ff02          .dw $ff02
003bb8 6940          .db "@i"
003bb9 3b65          .dw VE_HEAD
                     .set VE_HEAD = VE_FETCHI
                 XT_FETCHI:
003bba 3bbb          .dw PFA_FETCHI
                 PFA_FETCHI:
003bbb 01fc          movw zl, tosl
003bbc 0fee
003bbd 1fff
003bbe 9185
003bbf 9195          readflashcell tosl,tosh
003bc0 cc43          jmp_ DO_NEXT
                 
                 .if AMFORTH_NRWW_SIZE>8000
                 .elif AMFORTH_NRWW_SIZE>4000
                 .include "dict/core_4k.inc"
                 
                 ; in a short distance to DO_NEXT
                 .include "words/n_to_r.asm"
                 
                 ; Stack
                 ; move n items from data stack to return stack
                 VE_N_TO_R:
003bc1 ff03          .dw $ff03
003bc2 3e6e
003bc3 0072          .db "n>r",0
003bc4 3bb7          .dw VE_HEAD
                     .set VE_HEAD = VE_N_TO_R
                 XT_N_TO_R:
003bc5 3bc6          .dw PFA_N_TO_R
                 PFA_N_TO_R:
003bc6 01fc          movw zl, tosl
003bc7 2f08          mov  temp0, tosl
                 PFA_N_TO_R1:
003bc8 9189
003bc9 9199          loadtos
003bca 939f          push tosh
003bcb 938f          push tosl
003bcc 950a          dec temp0
003bcd f7d1          brne PFA_N_TO_R1
003bce 93ef          push zl
003bcf 93ff          push zh
003bd0 9189
003bd1 9199          loadtos
003bd2 cc31          jmp_ DO_NEXT
                 .include "words/n_r_from.asm"
                 
                 ; Stack
                 ; move n items from return stack to data stack
                 VE_N_R_FROM:
003bd3 ff03          .dw $ff03
003bd4 726e
003bd5 003e          .db "nr>",0
003bd6 3bc1          .dw VE_HEAD
                     .set VE_HEAD = VE_N_R_FROM
                 XT_N_R_FROM:
003bd7 3bd8          .dw PFA_N_R_FROM
                 PFA_N_R_FROM:
003bd8 939a
003bd9 938a          savetos
003bda 91ff          pop zh
003bdb 91ef          pop zl
003bdc 2f0e          mov  temp0, zl
                 PFA_N_R_FROM1:
003bdd 918f          pop tosl
003bde 919f          pop tosh
003bdf 939a
003be0 938a          savetos
003be1 950a          dec temp0
003be2 f7d1          brne PFA_N_R_FROM1
003be3 01cf          movw tosl, zl
003be4 cc1f          jmp_ DO_NEXT
                 .include "words/d-2star.asm"
                 
                 ; Arithmetics
                 ; shift a double cell left
                 VE_D2STAR:
003be5 ff03          .dw $ff03
003be6 3264
003be7 002a          .db "d2*",0
003be8 3bd3          .dw VE_HEAD
                     .set VE_HEAD = VE_D2STAR
                 XT_D2STAR:
003be9 3bea          .dw PFA_D2STAR
                 PFA_D2STAR:
003bea 9109          ld temp0, Y+
003beb 9119          ld temp1, Y+
003bec 0f00          lsl temp0
003bed 1f11          rol temp1
003bee 1f88          rol tosl
003bef 1f99          rol tosh
003bf0 931a          st -Y, temp1
003bf1 930a          st -Y, temp0
003bf2 cc11          jmp_ DO_NEXT
                 .include "words/d-2slash.asm"
                 
                 ; Arithmetics
                 ; shift a double cell value right
                 VE_D2SLASH:
003bf3 ff03          .dw $ff03
003bf4 3264
003bf5 002f          .db "d2/",0
003bf6 3be5          .dw VE_HEAD
                     .set VE_HEAD = VE_D2SLASH
                 XT_D2SLASH:
003bf7 3bf8          .dw PFA_D2SLASH
                 PFA_D2SLASH:
003bf8 9109          ld temp0, Y+
003bf9 9119          ld temp1, Y+
003bfa 9595          asr tosh
003bfb 9587          ror tosl
003bfc 9517          ror temp1
003bfd 9507          ror temp0
003bfe 931a          st -Y, temp1
003bff 930a          st -Y, temp0
003c00 cc03          jmp_ DO_NEXT
                 .include "words/d-plus.asm"
                 
                 ; Arithmetics
                 ; add 2 double cell values
                 VE_DPLUS:
003c01 ff02          .dw $ff02
003c02 2b64          .db "d+"
003c03 3bf3          .dw VE_HEAD
                     .set VE_HEAD = VE_DPLUS
                 XT_DPLUS:
003c04 3c05          .dw PFA_DPLUS
                 PFA_DPLUS:
003c05 9129          ld temp2, Y+
003c06 9139          ld temp3, Y+
                 
003c07 90e9          ld temp4, Y+
003c08 90f9          ld temp5, Y+
003c09 9149          ld temp6, Y+
003c0a 9159          ld temp7, Y+
                 
003c0b 0f24          add temp2, temp6
003c0c 1f35          adc temp3, temp7
003c0d 1d8e          adc tosl, temp4
003c0e 1d9f          adc tosh, temp5
                     
003c0f 933a          st -Y, temp3
003c10 932a          st -Y, temp2
003c11 cbf2          jmp_ DO_NEXT
                 .include "words/d-minus.asm"
                 
                 ; Arithmetics
                 ; subtract d2 from d1 
                 VE_DMINUS:
003c12 ff02          .dw $ff02
003c13 2d64          .db "d-"
003c14 3c01          .dw VE_HEAD
                     .set VE_HEAD = VE_DMINUS
                 XT_DMINUS:
003c15 3c16          .dw PFA_DMINUS
                 PFA_DMINUS:
003c16 9129          ld temp2, Y+
003c17 9139          ld temp3, Y+
                 
003c18 90e9          ld temp4, Y+
003c19 90f9          ld temp5, Y+
003c1a 9149          ld temp6, Y+
003c1b 9159          ld temp7, Y+
                 
003c1c 1b42          sub temp6, temp2
003c1d 0b53          sbc temp7, temp3
003c1e 0ae8          sbc temp4, tosl
003c1f 0af9          sbc temp5, tosh
                 
003c20 935a          st -Y, temp7
003c21 934a          st -Y, temp6
003c22 01c7          movw tosl, temp4
003c23 cbe0          jmp_ DO_NEXT
                 .include "words/d-invert.asm"
                 
                 ; Arithmetics
                 ; invert all bits in the double cell value
                 VE_DINVERT:
003c24 ff07          .dw $ff07
003c25 6964
003c26 766e
003c27 7265
003c28 0074          .db "dinvert",0
003c29 3c12          .dw VE_HEAD
                     .set VE_HEAD = VE_DINVERT
                 XT_DINVERT:
003c2a 3c2b          .dw PFA_DINVERT
                 PFA_DINVERT:
003c2b 9109          ld temp0, Y+
003c2c 9119          ld temp1, Y+
003c2d 9580          com tosl
003c2e 9590          com tosh
003c2f 9500          com temp0
003c30 9510          com temp1
003c31 931a          st -Y, temp1
003c32 930a          st -Y, temp0
003c33 cbd0          jmp_ DO_NEXT
                 .include "words/slashmod.asm"
                 
                 ; Arithmetics
                 ; signed division n1/n2 with remainder and quotient
                 VE_SLASHMOD:
003c34 ff04          .dw $ff04
003c35 6d2f
003c36 646f          .db "/mod"
003c37 3c24          .dw VE_HEAD
                     .set VE_HEAD = VE_SLASHMOD
                 XT_SLASHMOD:
003c38 3c39          .dw PFA_SLASHMOD
                 PFA_SLASHMOD:
003c39 019c          movw temp2, tosl
                     
003c3a 9109          ld temp0, Y+
003c3b 9119          ld temp1, Y+
                 
003c3c 2f41          mov	temp6,temp1	;move dividend High to sign register
003c3d 2743          eor	temp6,temp3	;xor divisor High with sign register
003c3e ff17          sbrs	temp1,7	;if MSB in dividend set
003c3f c004          rjmp	PFA_SLASHMOD_1
003c40 9510          com	temp1		;    change sign of dividend
003c41 9500          com	temp0		
003c42 5f0f          subi	temp0,low(-1)
003c43 4f1f          sbci	temp1,high(-1)
                 PFA_SLASHMOD_1:	
003c44 ff37          sbrs	temp3,7	;if MSB in divisor set
003c45 c004          rjmp	PFA_SLASHMOD_2
003c46 9530          com	temp3		;    change sign of divisor
003c47 9520          com	temp2		
003c48 5f2f          subi	temp2,low(-1)
003c49 4f3f          sbci	temp3,high(-1)
003c4a 24ee      PFA_SLASHMOD_2:	clr	temp4	;clear remainder Low byte
003c4b 18ff          sub	temp5,temp5;clear remainder High byte and carry
003c4c e151          ldi	temp7,17	;init loop counter
                 
003c4d 1f00      PFA_SLASHMOD_3:	rol	temp0		;shift left dividend
003c4e 1f11          rol	temp1
003c4f 955a          dec	temp7		;decrement counter
003c50 f439          brne	PFA_SLASHMOD_5		;if done
003c51 ff47          sbrs	temp6,7		;    if MSB in sign register set
003c52 c004          rjmp	PFA_SLASHMOD_4
003c53 9510          com	temp1	;        change sign of result
003c54 9500          com	temp0
003c55 5f0f          subi	temp0,low(-1)
003c56 4f1f          sbci	temp1,high(-1)
003c57 c00b      PFA_SLASHMOD_4:	rjmp PFA_SLASHMODmod_done			;    return
003c58 1cee      PFA_SLASHMOD_5:	rol	temp4	;shift dividend into remainder
003c59 1cff          rol	temp5
003c5a 1ae2          sub	temp4,temp2	;remainder = remainder - divisor
003c5b 0af3          sbc	temp5,temp3	;
003c5c f420          brcc	PFA_SLASHMOD_6		;if result negative
003c5d 0ee2          add	temp4,temp2	;    restore remainder
003c5e 1ef3          adc	temp5,temp3
003c5f 9488          clc			;    clear carry to be shifted into result
003c60 cfec          rjmp	PFA_SLASHMOD_3		;else
003c61 9408      PFA_SLASHMOD_6:	sec			;    set carry to be shifted into result
003c62 cfea          rjmp	PFA_SLASHMOD_3
                 
                 PFA_SLASHMODmod_done:
                     ; put remainder on stack
003c63 92fa          st -Y,temp5
003c64 92ea          st -Y,temp4
                 
                     ; put quotient on stack
003c65 01c8          movw tosl, temp0
003c66 cb9d          jmp_ DO_NEXT
                 .include "words/abs.asm"
                 
                 ; Arithmetics
                 ; get the absolute value
                 VE_ABS:
003c67 ff03          .dw $ff03
003c68 6261
003c69 0073          .db "abs",0
003c6a 3c34          .dw VE_HEAD
                     .set VE_HEAD = VE_ABS
                 XT_ABS:
003c6b 3c6c          .dw PFA_ABS
                 PFA_ABS:
003c6c 2399          tst tosh
003c6d f41a          brpl PFA_ABS1
003c6e 9580          com tosl
003c6f 9590          com tosh
003c70 9601          adiw tosl, 1
                 PFA_ABS1:
003c71 cb92          jmp_ do_next
                 .include "words/pick.asm"
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_PICK:
003c72 ff04          .dw $ff04
003c73 6970
003c74 6b63          .db "pick"
003c75 3c67          .dw VE_HEAD
                     .set VE_HEAD = VE_PICK
                 XT_PICK:
003c76 3800          .dw DO_COLON
                 PFA_PICK:
                 .endif
003c77 3a29          .dw XT_1PLUS
003c78 3ea5          .dw XT_CELLS
003c79 3a7b          .dw XT_SP_FETCH
003c7a 3997          .dw XT_PLUS
003c7b 3873          .dw XT_FETCH
003c7c 381a          .dw XT_EXIT
                 .include "words/cellplus.asm"
                 
                 ; Arithmetics
                 ; add the size of an address-unit to a-addr1
                 VE_CELLPLUS:
003c7d ff05          .dw $ff05
003c7e 6563
003c7f 6c6c
003c80 002b          .db "cell+",0
003c81 3c72          .dw VE_HEAD
                     .set VE_HEAD = VE_CELLPLUS
                 XT_CELLPLUS:
003c82 3c83          .dw PFA_CELLPLUS
                 PFA_CELLPLUS:
003c83 9602          adiw tosl, CELLSIZE
003c84 cb7f          jmp_ DO_NEXT
                 .include "dict/interrupt.inc"
                 
                 .include "words/int-on.asm"
                 
                 ; Interrupt
                 ; turns on all interrupts
                 VE_INTON:
003c85 ff04          .dw $ff04
003c86 692b
003c87 746e          .db "+int"
003c88 3c7d          .dw VE_HEAD
                     .set VE_HEAD = VE_INTON
                 XT_INTON:
003c89 3c8a          .dw PFA_INTON
                 PFA_INTON:
003c8a 9478          sei
003c8b cb78          jmp_ DO_NEXT
                 .include "words/int-off.asm"
                 
                 ; Interrupt
                 ; turns off all interrupts 
                 VE_INTOFF:
003c8c ff04          .dw $ff04
003c8d 692d
003c8e 746e          .db "-int"
003c8f 3c85          .dw VE_HEAD
                     .set VE_HEAD = VE_INTOFF
                 XT_INTOFF:
003c90 3c91          .dw PFA_INTOFF
                 PFA_INTOFF:
003c91 94f8          cli
003c92 cb71          jmp_ DO_NEXT
                 .include "words/int-store.asm"
                 
                 ; Interrupt
                 ; stores XT as interrupt vector i
                 VE_INTSTORE:
003c93 ff04          .dw $ff04
003c94 6e69
003c95 2174          .db "int!"
003c96 3c8c          .dw VE_HEAD
                     .set VE_HEAD = VE_INTSTORE
                 XT_INTSTORE:
003c97 3800          .dw DO_COLON
                 PFA_INTSTORE:
003c98 3837          .dw XT_DOLITERAL
003c99 0000          .dw intvec
003c9a 3997          .dw XT_PLUS
003c9b 3b29          .dw XT_STOREE
003c9c 381a          .dw XT_EXIT
                 .include "words/int-fetch.asm"
                 
                 ; Interrupt
                 ; fetches XT from interrupt vector i
                 VE_INTFETCH:
003c9d ff04          .dw $ff04
003c9e 6e69
003c9f 4074          .db "int@"
003ca0 3c93          .dw VE_HEAD
                     .set VE_HEAD = VE_INTFETCH
                 XT_INTFETCH:
003ca1 3800          .dw DO_COLON
                 PFA_INTFETCH:
003ca2 3837          .dw XT_DOLITERAL
003ca3 0000          .dw intvec
003ca4 3997          .dw XT_PLUS
003ca5 3b4d          .dw XT_FETCHE
003ca6 381a          .dw XT_EXIT
                 .include "words/int-trap.asm"
                 
                 ; Interrupt
                 ; trigger an interrupt
                 VE_INTTRAP:
003ca7 ff08          .dw $ff08
003ca8 6e69
003ca9 2d74
003caa 7274
003cab 7061          .db "int-trap"
003cac 3c9d          .dw VE_HEAD
                     .set VE_HEAD = VE_INTTRAP
                 XT_INTTRAP:
003cad 3cae          .dw PFA_INTTRAP
                 PFA_INTTRAP:
003cae 9380 0116     sts intcur, tosl
003cb0 9189
003cb1 9199          loadtos
003cb2 9468          set ; set the interrupt flag for the inner interpreter
003cb3 cb50          jmp_ DO_NEXT
                 
                 .include "words/isr-exec.asm"
                 
                 ; Interrupt
                 ; executes an interrupt service routine
                 ;VE_ISREXEC:
                 ;    .dw $ff08
                 ;    .db "isr-exec"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_ISREXEC
                 XT_ISREXEC:
003cb4 3800          .dw DO_COLON
                 PFA_ISREXEC:
003cb5 3837          .dw XT_DOLITERAL
003cb6 0116          .dw intcur
003cb7 3892          .dw XT_CFETCH
003cb8 3837          .dw XT_DOLITERAL
003cb9 0000          .dw intvec
003cba 3997          .dw XT_PLUS
003cbb 3b4d          .dw XT_FETCHE
003cbc 3824          .dw XT_EXECUTE
003cbd 3cbf          .dw XT_ISREND
003cbe 381a          .dw XT_EXIT
                 .include "words/isr-end.asm"
                 
                 ; Interrupt
                 ; re-enables interrupts in an ISR
                 ;VE_ISREND:
                 ;    .dw $ff07
                 ;    .db "isr-end",0
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_ISREND
                 XT_ISREND:
003cbf 3cc0          .dw PFA_ISREND
                 PFA_ISREND:
003cc0 d001          rcall PFA_ISREND1 ; clear the interrupt flag for the controller
003cc1 cb42          jmp_ DO_NEXT
                 PFA_ISREND1:
003cc2 9518          reti
                 
                 ; now the relocatable colon words
                 .include "words/prompt-ok.asm"
                 
                 ; System
                 ; send the READY prompt to the command line
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 ;VE_PROMPTOK:
                 ;    .dw $ff02
                 ;    .db "ok"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_PROMPTOK
                 XT_PROMPTOK:
003cc3 3800          .dw DO_COLON
                 PFA_PROMPTOK:
003cc4 03a9          .dw XT_DOSLITERAL
003cc5 0003          .dw 3
003cc6 6f20
003cc7 006b          .db " ok",0
                 .endif
003cc8 03dc          .dw XT_ITYPE
003cc9 381a          .dw XT_EXIT
                 .include "words/prompt-ready.asm"
                 
                 ; System
                 ; process the error prompt
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 ;VE_PROMPTRDY:
                 ;    .dw $ff04
                 ;    .db "p_er"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_PROMPTRDY
                 XT_PROMPTREADY:
003cca 3800          .dw DO_COLON
                 PFA_PROMPTREADY:
003ccb 03a9          .dw XT_DOSLITERAL
003ccc 0002          .dw 2
003ccd 203e          .db "> "
                 .endif
003cce 3f89          .dw XT_CR
003ccf 03dc          .dw XT_ITYPE
003cd0 381a          .dw XT_EXIT
                 .include "words/prompt-error.asm"
                 
                 ; System
                 ; process the error prompt
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 ;VE_PROMPTERROR:
                 ;    .dw $ff04
                 ;    .db "p_er"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_PROMPTERROR
                 XT_PROMPTERROR:
003cd1 3800          .dw DO_COLON
                 PFA_PROMPTERROR:
003cd2 03a9      	.dw XT_DOSLITERAL
003cd3 0004          .dw 4
003cd4 3f20
003cd5 203f          .db " ?? "
                 .endif
003cd6 03dc          .dw XT_ITYPE
003cd7 3e9e          .dw XT_BASE
003cd8 3873          .dw XT_FETCH
003cd9 38f9          .dw XT_TO_R
003cda 3f29          .dw XT_DECIMAL
003cdb 035e          .dw XT_DOT
003cdc 3ec3          .dw XT_TO_IN
003cdd 3873          .dw XT_FETCH
003cde 035e          .dw XT_DOT
003cdf 38f0          .dw XT_R_FROM
003ce0 3e9e          .dw XT_BASE
003ce1 387b          .dw XT_STORE
003ce2 381a          .dw XT_EXIT
                 
                 .include "words/quit.asm"
                 
                 ; System
                 ; main loop of amforth. accept - interpret in an endless loop
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_QUIT:
003ce3 ff04          .dw $ff04
003ce4 7571
003ce5 7469          .db "quit"
003ce6 3ca7          .dw VE_HEAD
                     .set VE_HEAD = VE_QUIT
                 XT_QUIT:
003ce7 3800          .dw DO_COLON
                 PFA_QUIT:
                 .endif
                 PFA_QUIT1:
003ce8 0830
003ce9 0837
003cea 387b          .dw XT_LP0,XT_LP,XT_STORE
003ceb 05a5          .dw XT_SP0
003cec 3a84          .dw XT_SP_STORE
003ced 05b2          .dw XT_RP0
003cee 3a6e          .dw XT_RP_STORE
003cef 08d2          .dw XT_LBRACKET
                 
                 PFA_QUIT2:
003cf0 3e98          .dw XT_STATE
003cf1 3873          .dw XT_FETCH
003cf2 3914          .dw XT_ZEROEQUAL
003cf3 3830          .dw XT_DOCONDBRANCH
003cf4 3cf6          DEST(PFA_QUIT4)
003cf5 3cca          .dw XT_PROMPTREADY
                 PFA_QUIT4:
003cf6 04b2          .dw XT_REFILL
003cf7 3830          .dw XT_DOCONDBRANCH
003cf8 3cf0          DEST(PFA_QUIT2)
003cf9 3837          .dw XT_DOLITERAL
003cfa 05f5          .dw XT_INTERPRET
003cfb 3d4a          .dw XT_CATCH
003cfc 38b3          .dw XT_QDUP
003cfd 3830          .dw XT_DOCONDBRANCH
003cfe 3d08          DEST(PFA_QUIT3)
003cff 38ab      	.dw XT_DUP
003d00 3837      	.dw XT_DOLITERAL
003d01 fffe      	.dw -2
003d02 3968      	.dw XT_LESS
003d03 3830      	.dw XT_DOCONDBRANCH
003d04 3d06      	DEST(PFA_QUIT5)
003d05 3cd1      	.dw XT_PROMPTERROR
                 PFA_QUIT5:
003d06 3829      	.dw XT_DOBRANCH
003d07 3ce8      	DEST(PFA_QUIT1)
                 PFA_QUIT3:
003d08 3cc3          .dw XT_PROMPTOK
003d09 3829          .dw XT_DOBRANCH
003d0a 3cf0          DEST(PFA_QUIT2)
003d0b 381a          .dw XT_EXIT ; never reached
                 
                 .include "words/pause.asm"
                 
                 ; Multitasking
                 ; Fetch pause vector and execute it. may make a context/task switch
                 VE_PAUSE:
003d0c ff05          .dw $ff05
003d0d 6170
003d0e 7375
003d0f 0065          .db "pause",0
003d10 3ce3          .dw VE_HEAD
                     .set VE_HEAD = VE_PAUSE
                 XT_PAUSE:
003d11 3dd8          .dw PFA_DODEFER1
                 PFA_PAUSE:
003d12 017b          .dw ram_pause
003d13 3d8e          .dw XT_RDEFERFETCH
003d14 3d98          .dw XT_RDEFERSTORE
                 
                 .dseg
00017b           ram_pause: .byte 2
                 .cseg
                 .include "words/cold.asm"
                 
                 ; System
                 ; start up amforth.
                 VE_COLD:
003d15 ff04          .dw $ff04
003d16 6f63
003d17 646c          .db "cold"
003d18 3d0c          .dw VE_HEAD
                     .set VE_HEAD = VE_COLD
                 XT_COLD:
003d19 3d1a          .dw PFA_COLD
                 PFA_COLD:
003d1a b6a4          in_ mcu_boot, MCUSR
003d1b 2422          clr zerol
003d1c 2433          clr zeroh
003d1d be24          out_ MCUSR, zerol
                     ; init first user data area
                     ; allocate space for User Area
                 .dseg
00017d           ram_user1: .byte SYSUSERSIZE + APPUSERSIZE
                 .cseg
003d1e e7ed          ldi zl, low(ram_user1)
003d1f e0f1          ldi zh, high(ram_user1)
003d20 012f          movw upl, zl
                     ; init return stack pointer
003d21 ef0f          ldi temp0,low(rstackstart)
003d22 bf0d          out_ SPL,temp0
003d23 8304          std Z+4, temp0
003d24 e018          ldi temp1,high(rstackstart)
003d25 bf1e          out_ SPH,temp1
003d26 8315          std Z+5, temp1
                 
                     ; init parameter stack pointer
003d27 eacf          ldi yl,low(stackstart)
003d28 83c6          std Z+6, yl
003d29 e0d8          ldi yh,high(stackstart)
003d2a 83d7          std Z+7, yh
                 
                     ; load Forth IP with starting word
003d2b e3a3          ldi XL, low(PFA_WARM)
003d2c e3bd          ldi XH, high(PFA_WARM)
                     ; its a far jump...
003d2d cad6          jmp_ DO_NEXT
                 .include "words/warm.asm"
                 
                 ; System
                 ; initialize amforth further. executes turnkey operation and go to quit
                 VE_WARM:
003d2e ff04          .dw $ff04
003d2f 6177
003d30 6d72          .db "warm"
003d31 3d15          .dw VE_HEAD
                     .set VE_HEAD = VE_WARM
                 XT_WARM:
003d32 3800          .dw DO_COLON
                 PFA_WARM:
003d33 027b          .dw XT_INITUSER
003d34 3837          .dw XT_DOLITERAL
003d35 018a          .dw XT_NOOP
003d36 3837          .dw XT_DOLITERAL
003d37 3d11          .dw XT_PAUSE
003d38 3db9          .dw XT_DEFERSTORE
003d39 08d2          .dw XT_LBRACKET
003d3a 3f44          .dw XT_TURNKEY
003d3b 3ce7          .dw XT_QUIT
003d3c 381a          .dw XT_EXIT
                 
                 .include "words/handler.asm"
                 
                 ; Exceptions
                 ; USER variable used by catch/throw
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_HANDLER:
003d3d ff07          .dw $ff07
003d3e 6168
003d3f 646e
003d40 656c
003d41 0072          .db "handler",0
003d42 3d2e          .dw VE_HEAD
                     .set VE_HEAD = VE_HANDLER
                 XT_HANDLER:
003d43 3852          .dw PFA_DOUSER
                 PFA_HANDLER:
                 .endif
003d44 000a          .dw USER_HANDLER
                 .include "words/catch.asm"
                 
                 ; Exceptions
                 ; execute XT and check for exceptions.
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_CATCH:
003d45 ff05          .dw $ff05
003d46 6163
003d47 6374
003d48 0068          .db "catch",0
003d49 3d3d          .dw VE_HEAD
                     .set VE_HEAD = VE_CATCH
                 XT_CATCH:
003d4a 3800          .dw DO_COLON
                 PFA_CATCH:
                 .endif
                 
                     ; sp@ >r
003d4b 3a7b          .dw XT_SP_FETCH
003d4c 38f9          .dw XT_TO_R
                     ; handler @ >r
003d4d 3d43          .dw XT_HANDLER
003d4e 3873          .dw XT_FETCH
003d4f 38f9          .dw XT_TO_R
                     ; rp@ handler !
003d50 3a64          .dw XT_RP_FETCH
003d51 3d43          .dw XT_HANDLER
003d52 387b          .dw XT_STORE
003d53 3824          .dw XT_EXECUTE
                     ; r> handler !
003d54 38f0          .dw XT_R_FROM
003d55 3d43          .dw XT_HANDLER
003d56 387b          .dw XT_STORE
003d57 38f0          .dw XT_R_FROM
003d58 38d3          .dw XT_DROP
003d59 394e          .dw XT_ZERO
003d5a 381a          .dw XT_EXIT
                 .include "words/throw.asm"
                 
                 ; Exceptions
                 ; throw an exception
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_THROW:
003d5b ff05          .dw $ff05
003d5c 6874
003d5d 6f72
003d5e 0077          .db "throw",0
003d5f 3d45          .dw VE_HEAD
                     .set VE_HEAD = VE_THROW
                 XT_THROW:
003d60 3800          .dw DO_COLON
                 PFA_THROW:
                 .endif
003d61 38ab          .dw XT_DUP
003d62 3914          .dw XT_ZEROEQUAL
003d63 3830          .dw XT_DOCONDBRANCH
003d64 3d67          DEST(PFA_THROW1)
003d65 38d3      	.dw XT_DROP
003d66 381a      	.dw XT_EXIT
                 PFA_THROW1:
003d67 3d43          .dw XT_HANDLER
003d68 3873          .dw XT_FETCH
003d69 3a6e          .dw XT_RP_STORE
003d6a 38f0          .dw XT_R_FROM
003d6b 3d43          .dw XT_HANDLER
003d6c 387b          .dw XT_STORE
003d6d 38f0          .dw XT_R_FROM
003d6e 38be          .dw XT_SWAP
003d6f 38f9          .dw XT_TO_R
003d70 3a84          .dw XT_SP_STORE
003d71 38d3          .dw XT_DROP
003d72 38f0          .dw XT_R_FROM    
003d73 381a          .dw XT_EXIT
                 
                 
                 
                 .include "words/edefer-fetch.asm"
                 
                 ; System
                 ; does the real defer@ for eeprom defers
                 VE_EDEFERFETCH:
003d74 ff07          .dw $ff07
003d75 6445
003d76 6665
003d77 7265
003d78 0040          .db "Edefer@",0
003d79 3d5b          .dw VE_HEAD
                     .set VE_HEAD = VE_EDEFERFETCH
                 XT_EDEFERFETCH:
003d7a 3800          .dw DO_COLON
                 PFA_EDEFERFETCH:
003d7b 3bba          .dw XT_FETCHI
003d7c 3b4d          .dw XT_FETCHE
003d7d 381a          .dw XT_EXIT
                 .include "words/edefer-store.asm"
                 
                 ; System
                 ; does the real defer! for eeprom defers
                 VE_EDEFERSTORE:
003d7e ff07          .dw $ff07
003d7f 6445
003d80 6665
003d81 7265
003d82 0021          .db "Edefer!",0
003d83 3d74          .dw VE_HEAD
                     .set VE_HEAD = VE_EDEFERSTORE
                 XT_EDEFERSTORE:
003d84 3800          .dw DO_COLON
                 PFA_EDEFERSTORE:
003d85 3bba          .dw XT_FETCHI
003d86 3b29          .dw XT_STOREE
003d87 381a          .dw XT_EXIT
                 .include "words/rdefer-fetch.asm"
                 
                 ; System
                 ; The defer@ for ram defers
                 VE_RDEFERFETCH:
003d88 ff07          .dw $ff07
003d89 6452
003d8a 6665
003d8b 7265
003d8c 0040          .db "Rdefer@",0
003d8d 3d7e          .dw VE_HEAD
                     .set VE_HEAD = VE_RDEFERFETCH
                 XT_RDEFERFETCH:
003d8e 3800          .dw DO_COLON
                 PFA_RDEFERFETCH:
003d8f 3bba          .dw XT_FETCHI
003d90 3873          .dw XT_FETCH
003d91 381a          .dw XT_EXIT
                 .include "words/rdefer-store.asm"
                 
                 ; System
                 ; The defer! for ram defers
                 VE_RDEFERSTORE:
003d92 ff07          .dw $ff07
003d93 6452
003d94 6665
003d95 7265
003d96 0021          .db "Rdefer!",0
003d97 3d88          .dw VE_HEAD
                     .set VE_HEAD = VE_RDEFERSTORE
                 XT_RDEFERSTORE:
003d98 3800          .dw DO_COLON
                 PFA_RDEFERSTORE:
003d99 3bba          .dw XT_FETCHI
003d9a 387b          .dw XT_STORE
003d9b 381a          .dw XT_EXIT
                 
                 .include "words/udefer-fetch.asm"
                 
                 ; System
                 ; does the real defer@ for user based defers
                 VE_UDEFERFETCH:
003d9c ff07          .dw $ff07
003d9d 6455
003d9e 6665
003d9f 7265
003da0 0040          .db "Udefer@",0
003da1 3d92          .dw VE_HEAD
                     .set VE_HEAD = VE_UDEFERFETCH
                 XT_UDEFERFETCH:
003da2 3800          .dw DO_COLON
                 PFA_UDEFERFETCH:
003da3 3bba          .dw XT_FETCHI
003da4 3af0          .dw XT_UP_FETCH
003da5 3997          .dw XT_PLUS
003da6 3873          .dw XT_FETCH
003da7 381a          .dw XT_EXIT
                 .include "words/udefer-store.asm"
                 
                 ; System
                 ; does the real defer! for user based defers
                 VE_UDEFERSTORE:
003da8 ff07          .dw $ff07
003da9 6455
003daa 6665
003dab 7265
003dac 0021          .db "Udefer!",0
003dad 3d9c          .dw VE_HEAD
                     .set VE_HEAD = VE_UDEFERSTORE
                 XT_UDEFERSTORE:
003dae 3800          .dw DO_COLON
                 PFA_UDEFERSTORE:
003daf 3bba          .dw XT_FETCHI
003db0 3af0          .dw XT_UP_FETCH
003db1 3997          .dw XT_PLUS
003db2 387b          .dw XT_STORE
003db3 381a          .dw XT_EXIT
                 
                 .include "words/defer-store.asm"
                 
                 ; System
                 ; stores xt1 as the xt to be executed when xt2 is called
                 VE_DEFERSTORE:
003db4 ff06          .dw $ff06
003db5 6564
003db6 6566
003db7 2172          .db "defer!"
003db8 3da8          .dw VE_HEAD
                     .set VE_HEAD = VE_DEFERSTORE
                 XT_DEFERSTORE:
003db9 3800          .dw DO_COLON
                 PFA_DEFERSTORE:
003dba 3a29          .dw XT_1PLUS
003dbb 38ab          .dw XT_DUP
003dbc 3c82          .dw XT_CELLPLUS ; 2+
003dbd 3bba          .dw XT_FETCHI
003dbe 3824          .dw XT_EXECUTE
003dbf 381a          .dw XT_EXIT
                 
                 .include "words/defer-fetch.asm"
                 
                 ; System
                 ; returns the XT associated with the given XT
                 VE_DEFERFETCH:
003dc0 ff06          .dw $ff06
003dc1 6564
003dc2 6566
003dc3 4072          .db "defer@"
003dc4 3db4          .dw VE_HEAD
                     .set VE_HEAD = VE_DEFERFETCH
                 XT_DEFERFETCH:
003dc5 3800          .dw DO_COLON
                 PFA_DEFERFETCH:
003dc6 3a29          .dw XT_1PLUS ; >body
003dc7 38ab          .dw XT_DUP
003dc8 3a29          .dw XT_1PLUS 
003dc9 3bba          .dw XT_FETCHI
003dca 3824          .dw XT_EXECUTE
003dcb 381a          .dw XT_EXIT
                 .include "words/do-defer.asm"
                 
                 ; System
                 ; runtime of defer
                 VE_DODEFER:
003dcc ff07          .dw $ff07
003dcd 6428
003dce 6665
003dcf 7265
003dd0 0029          .db "(defer)", 0
003dd1 3dc0          .dw VE_HEAD
                     .set VE_HEAD = VE_DODEFER
                 XT_DODEFER:
003dd2 3800          .dw DO_COLON
                 PFA_DODEFER:
003dd3 0703          .dw XT_DOCREATE
003dd4 086d          .dw XT_REVEAL
003dd5 0729          .dw XT_COMPILE
003dd6 3dd8          .dw PFA_DODEFER1
003dd7 381a          .dw XT_EXIT
                 PFA_DODEFER1:
003dd8 940e 0891     call_ DO_DODOES
003dda 38ab          .dw XT_DUP
003ddb 3a29          .dw XT_1PLUS
003ddc 3bba          .dw XT_FETCHI
003ddd 3824          .dw XT_EXECUTE 
003dde 3824          .dw XT_EXECUTE
003ddf 381a          .dw XT_EXIT
                 
                 .include "words/d-equal.asm"
                 
                 ; Compare
                 ; compares two double cell values
                 VE_DEQUAL:
003de0 ff02          .dw $ff02
003de1 3d64          .db "d="
003de2 3dcc          .dw VE_HEAD
                     .set VE_HEAD = VE_DEQUAL
                 XT_DEQUAL:
003de3 3800          .dw DO_COLON
                 PFA_DEQUAL:
003de4 3c15          .dw XT_DMINUS
003de5 3a16          .dw XT_OR
003de6 3914          .dw XT_ZEROEQUAL
003de7 381a          .dw XT_EXIT
                 .include "words/u-dot.asm"
                 
                 ; Numeric IO
                 ; unsigned PNO with single cell numbers
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_UDOT:
003de8 ff02          .dw $ff02
003de9 2e75          .db "u."
003dea 3de0          .dw VE_HEAD
                     .set VE_HEAD = VE_UDOT
                 XT_UDOT:
003deb 3800          .dw DO_COLON
                 PFA_UDOT:
                 .endif
003dec 394e          .dw XT_ZERO
003ded 0366          .dw XT_UDDOT
003dee 381a          .dw XT_EXIT
                 ; : u.        ( us -- )    0 ud. ;
                 .include "words/u-dot-r.asm"
                 
                 ; Numeric IO
                 ; unsigned PNO with single cells numbers, right aligned in width w
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 
                 VE_UDOTR:
003def ff03          .dw $ff03
003df0 2e75
003df1 0072          .db "u.r",0
003df2 3de8          .dw VE_HEAD
                     .set VE_HEAD = VE_UDOTR
                 XT_UDOTR:
003df3 3800          .dw DO_COLON
                 PFA_UDOTR:
                 .endif
003df4 394e          .dw XT_ZERO
003df5 38be          .dw XT_SWAP
003df6 036f          .dw XT_UDDOTR
003df7 381a          .dw XT_EXIT
                 ; : u.r       ( s n -- )   0 swap ud.r ;
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/uslashmod.asm"
                 
                 ; Arithmetics
                 ; unsigned division with remainder
                 VE_USLASHMOD:
003df8 ff05          .dw $ff05
003df9 2f75
003dfa 6f6d
003dfb 0064          .db "u/mod",0
003dfc 3def          .dw VE_HEAD
                     .set VE_HEAD = VE_USLASHMOD
                 XT_USLASHMOD:
003dfd 3800          .dw DO_COLON
                 PFA_USLASHMOD:
003dfe 38f9          .dw XT_TO_R
003dff 394e          .dw XT_ZERO
003e00 38f0          .dw XT_R_FROM
003e01 39bc          .dw XT_UMSLASHMOD
003e02 381a          .dw XT_EXIT
                 .include "words/negate.asm"
                 
                 ; Logic
                 ; 2-complement
                 VE_NEGATE:
003e03 ff06          .dw $ff06
003e04 656e
003e05 6167
003e06 6574          .db "negate"
003e07 3df8          .dw VE_HEAD
                     .set VE_HEAD = VE_NEGATE
                 XT_NEGATE:
003e08 3800          .dw DO_COLON
                 PFA_NEGATE:
003e09 39f7          .dw XT_INVERT
003e0a 3a29          .dw XT_1PLUS
003e0b 381a          .dw XT_EXIT
                 .include "words/slash.asm"
                 
                 ; Arithmetics
                 ; divide n1 by n2. giving the quotient
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 
                 VE_SLASH:
003e0c ff01          .dw $ff01
003e0d 002f          .db "/",0
003e0e 3e03          .dw VE_HEAD
                     .set VE_HEAD = VE_SLASH
                 XT_SLASH:
003e0f 3800          .dw DO_COLON
                 PFA_SLASH:
                 .endif
003e10 3c38          .dw XT_SLASHMOD
003e11 38ea          .dw XT_NIP
003e12 381a          .dw XT_EXIT
                 
                 .include "words/mod.asm"
                 
                 ; Arithmetics
                 ; divide n1 by n2 giving the remainder n3
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 
                 VE_MOD:
003e13 ff03          .dw $ff03
003e14 6f6d
003e15 0064          .db "mod",0
003e16 3e0c          .dw VE_HEAD
                     .set VE_HEAD = VE_MOD
                 XT_MOD:
003e17 3800          .dw DO_COLON
                 PFA_MOD:
                 .endif
003e18 3c38          .dw XT_SLASHMOD
003e19 38d3          .dw XT_DROP
003e1a 381a          .dw XT_EXIT
                 
                 .include "words/min.asm"
                 
                 ; Compare
                 ; compare two values leave the smaller one
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 
                 VE_MIN:
003e1b ff03          .dw $ff03
003e1c 696d
003e1d 006e          .db "min",0
003e1e 3e13          .dw VE_HEAD
                     .set VE_HEAD = VE_MIN
                 XT_MIN:
003e1f 3800          .dw DO_COLON
                 PFA_MIN:
                 .endif
003e20 3eaa          .dw XT_2DUP
003e21 3972          .dw XT_GREATER
003e22 3830          .dw XT_DOCONDBRANCH
003e23 3e25          DEST(PFA_MIN1)
003e24 38be          .dw XT_SWAP
                 PFA_MIN1:
003e25 38d3          .dw XT_DROP
003e26 381a          .dw XT_EXIT
                 .include "words/max.asm"
                 
                 ; Compare
                 ; compare two values, leave the bigger one
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_MAX:
003e27 ff03          .dw $ff03
003e28 616d
003e29 0078          .db "max",0
003e2a 3e1b          .dw VE_HEAD
                     .set VE_HEAD = VE_MAX
                 XT_MAX:
003e2b 3800          .dw DO_COLON
                 PFA_MAX:
                 
                 .endif
003e2c 3eaa          .dw XT_2DUP
003e2d 3968          .dw XT_LESS
003e2e 3830          .dw XT_DOCONDBRANCH
003e2f 3e31          DEST(PFA_MAX1)
003e30 38be          .dw XT_SWAP
                 PFA_MAX1:
003e31 38d3          .dw XT_DROP
003e32 381a          .dw XT_EXIT
                 .include "words/within.asm"
                 
                 ; Compare
                 ; check if n is within min..max
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_WITHIN:
003e33 ff06          .dw $ff06
003e34 6977
003e35 6874
003e36 6e69          .db "within"
003e37 3e27          .dw VE_HEAD
                     .set VE_HEAD = VE_WITHIN
                 XT_WITHIN:
003e38 3800          .dw DO_COLON
                 PFA_WITHIN:
                 .endif
003e39 38c9          .dw XT_OVER
003e3a 398d          .dw XT_MINUS
003e3b 38f9          .dw XT_TO_R
003e3c 398d          .dw XT_MINUS
003e3d 38f0          .dw XT_R_FROM
003e3e 3956          .dw XT_ULESS
003e3f 381a          .dw XT_EXIT
                 
                 .include "words/show-wordlist.asm"
                 
                 ; Tools
                 ; prints the name of the words in a wordlist
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SHOWWORDLIST:
003e40 ff0d          .dw $ff0d
003e41 6873
003e42 776f
003e43 772d
003e44 726f
003e45 6c64
003e46 7369
003e47 0074          .db "show-wordlist",0
003e48 3e33          .dw VE_HEAD
                     .set VE_HEAD = VE_SHOWWORDLIST
                 XT_SHOWWORDLIST:
003e49 3800          .dw DO_COLON
                 PFA_SHOWWORDLIST:
                 .endif
003e4a 3837          .dw XT_DOLITERAL
003e4b 3e4f          .dw XT_SHOWWORD
003e4c 38be          .dw XT_SWAP
003e4d 06b1          .dw XT_TRAVERSEWORDLIST
003e4e 381a          .dw XT_EXIT
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 XT_SHOWWORD:
003e4f 3800          .dw DO_COLON
                 PFA_SHOWWORD:
                 .endif
003e50 06cc          .dw XT_NAME2STRING
003e51 03dc          .dw XT_ITYPE
003e52 3f96          .dw XT_SPACE         ; ( -- addr n)
003e53 3945          .dw XT_TRUE
003e54 381a          .dw XT_EXIT
                 .include "words/words.asm"
                 
                 ; Tools
                 ; prints a list of all (visible) words in the dictionary
                 VE_WORDS:
003e55 ff05          .dw $ff05
003e56 6f77
003e57 6472
003e58 0073          .db "words",0
003e59 3e40          .dw VE_HEAD
                     .set VE_HEAD = VE_WORDS
                 XT_WORDS:
003e5a 3800          .dw DO_COLON
                 PFA_WORDS:
003e5b 3837          .dw XT_DOLITERAL
003e5c 004a          .dw CFG_ORDERLIST
003e5d 3b4d          .dw XT_FETCHE
003e5e 3e49          .dw XT_SHOWWORDLIST
003e5f 381a          .dw XT_EXIT
                 
                 .include "words/dot-quote.asm"
                 
                 ; Compiler
                 ; compiles string into dictionary to be printed at runtime
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 
                 VE_DOTSTRING:
003e60 0002          .dw $0002
003e61 222e          .db ".",$22
003e62 3e55          .dw VE_HEAD
                     .set VE_HEAD = VE_DOTSTRING
                 XT_DOTSTRING:
003e63 3800          .dw DO_COLON
                 PFA_DOTSTRING:
                 .endif
003e64 3e6b          .dw XT_SQUOTE
003e65 0729          .dw XT_COMPILE
003e66 03dc          .dw XT_ITYPE
003e67 381a          .dw XT_EXIT
                 .include "words/squote.asm"
                 
                 ; Compiler
                 ; compiles a string to flash, at runtime leaves ( -- flash-addr count) on stack
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SQUOTE:
003e68 0002        .dw $0002
003e69 2273        .db "s",$22
003e6a 3e60        .dw VE_HEAD
                   .set VE_HEAD = VE_SQUOTE
                 XT_SQUOTE:
003e6b 3800          .dw DO_COLON
                 PFA_SQUOTE:
                 .endif
003e6c 3837          .dw XT_DOLITERAL
003e6d 0022          .dw 34   ; 0x22 
003e6e 055d          .dw XT_PARSE       ; ( -- addr n)
003e6f 3e98          .dw XT_STATE
003e70 3873          .dw XT_FETCH
003e71 3830          .dw XT_DOCONDBRANCH
003e72 3e74          DEST(PFA_SQUOTE1)
003e73 075b            .dw XT_SLITERAL
                 PFA_SQUOTE1:
003e74 381a          .dw XT_EXIT
                 .include "words/fill.asm"
                 
                 ; Memory
                 ; fill u bytes memory beginning at a-addr with character c
                 VE_FILL:
003e75 ff04          .dw $ff04
003e76 6966
003e77 6c6c          .db "fill"
003e78 3e68          .dw VE_HEAD
                     .set VE_HEAD = VE_FILL
                 XT_FILL:
003e79 3800          .dw DO_COLON
                 PFA_FILL:
003e7a 38db          .dw XT_ROT
003e7b 38db          .dw XT_ROT
003e7c 38b3
003e7d 3830          .dw XT_QDUP,XT_DOCONDBRANCH
003e7e 3e86          DEST(PFA_FILL2)
003e7f 3f81          .dw XT_BOUNDS
003e80 3a89          .dw XT_DODO
                 PFA_FILL1:
003e81 38ab          .dw XT_DUP
003e82 3a9a          .dw XT_I
003e83 3887          .dw XT_CSTORE  ; ( -- c c-addr)
003e84 3ab7          .dw XT_DOLOOP
003e85 3e81          .dw PFA_FILL1
                 PFA_FILL2:
003e86 38d3          .dw XT_DROP
003e87 381a          .dw XT_EXIT
                 
                 .include "words/f_cpu.asm"
                 
                 ; System
                 ; put the cpu frequency in Hz on stack
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_F_CPU:
003e88 ff05          .dw $ff05
003e89 5f66
003e8a 7063
003e8b 0075          .db "f_cpu",0
003e8c 3e75          .dw VE_HEAD
                     .set VE_HEAD = VE_F_CPU
                 XT_F_CPU:
003e8d 3800          .dw DO_COLON
                 PFA_F_CPU:
                 .endif
003e8e 3837          .dw XT_DOLITERAL
003e8f 2400          .dw (F_CPU % 65536)
003e90 3837          .dw XT_DOLITERAL
003e91 00f4          .dw (F_CPU / 65536)
003e92 381a          .dw XT_EXIT
                 .include "words/state.asm"
                 
                 ; System Variable
                 ; system state
                 VE_STATE:
003e93 ff05          .dw $ff05
003e94 7473
003e95 7461
003e96 0065          .db "state",0
003e97 3e88          .dw VE_HEAD
                     .set VE_HEAD = VE_STATE
                 XT_STATE:
003e98 3842          .dw PFA_DOVARIABLE
                 PFA_STATE:
003e99 01a3          .dw ram_state
                 
                 .dseg
0001a3           ram_state: .byte 2
                 .include "words/base.asm"
                 
                 ; Numeric IO
                 ; location of the cell containing the number conversion radix
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_BASE:
003e9a ff04          .dw $ff04
003e9b 6162
003e9c 6573          .db "base"
003e9d 3e93          .dw VE_HEAD
                     .set VE_HEAD = VE_BASE
                 XT_BASE:
003e9e 3852          .dw PFA_DOUSER
                 PFA_BASE:
                 .endif
003e9f 000c          .dw USER_BASE
                 
                 .include "words/cells.asm"
                 
                 ; Arithmetics
                 ; n2 is the size in address units of n1 cells
                 VE_CELLS:
003ea0 ff05          .dw $ff05
003ea1 6563
003ea2 6c6c
003ea3 0073          .db "cells",0
003ea4 3e9a          .dw VE_HEAD
                     .set VE_HEAD = VE_CELLS
                 XT_CELLS:
003ea5 3a06          .dw PFA_2STAR
                 
                 .include "words/2dup.asm"
                 
                 ; Stack
                 ; Duplicate the 2 top elements
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_2DUP:
003ea6 ff04          .dw $ff04
003ea7 6432
003ea8 7075          .db "2dup"
003ea9 3ea0          .dw VE_HEAD
                     .set VE_HEAD = VE_2DUP
                 XT_2DUP:
003eaa 3800          .dw DO_COLON
                 PFA_2DUP:
                 .endif
                 
003eab 38c9          .dw XT_OVER
003eac 38c9          .dw XT_OVER
003ead 381a          .dw XT_EXIT
                 .include "words/2drop.asm"
                 
                 ; Stack
                 ; Remove the 2 top elements
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_2DROP:
003eae ff05          .dw $ff05
003eaf 6432
003eb0 6f72
003eb1 0070          .db "2drop",0
003eb2 3ea6          .dw VE_HEAD
                     .set VE_HEAD = VE_2DROP
                 XT_2DROP:
003eb3 3800          .dw DO_COLON
                 PFA_2DROP:
                 .endif
003eb4 38d3          .dw XT_DROP
003eb5 38d3          .dw XT_DROP
003eb6 381a          .dw XT_EXIT
                 .include "words/tuck.asm"
                 
                 ; Stack
                 ; Copy the first (top) stack item below the second stack item. 
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_TUCK:
003eb7 ff04          .dw $ff04
003eb8 7574
003eb9 6b63          .db "tuck"
003eba 3eae          .dw VE_HEAD
                     .set VE_HEAD = VE_TUCK
                 XT_TUCK:
003ebb 3800          .dw DO_COLON
                 PFA_TUCK:
                 .endif
003ebc 38be          .dw XT_SWAP
003ebd 38c9          .dw XT_OVER
003ebe 381a          .dw XT_EXIT
                 
                 .include "words/to-in.asm"
                 
                 ; System Variable
                 ; pointer to current read position in input buffer
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_TO_IN:
003ebf ff03          .dw $ff03
003ec0 693e
003ec1 006e          .db ">in",0
003ec2 3eb7          .dw VE_HEAD
                     .set VE_HEAD = VE_TO_IN
                 XT_TO_IN:
003ec3 3852          .dw PFA_DOUSER
                 PFA_TO_IN:
                 .endif
003ec4 0018          .dw USER_TO_IN
                 .include "words/sharptib.asm"
                 
                 ; System Variable
                 ; variable holding the number of characters in TIB
                 VE_NUMBERTIB:
003ec5 ff04          .dw $ff04
003ec6 7423
003ec7 6269          .db "#tib"
003ec8 3ebf          .dw VE_HEAD
                     .set VE_HEAD  = VE_NUMBERTIB
                 XT_NUMBERTIB:
003ec9 3842          .dw PFA_DOVARIABLE
                 PFA_NUMBERTIB:
003eca 01a5          .dw ram_sharptib
                 
                 .dseg
0001a5           ram_sharptib: .byte 2
                 .cseg
                  
                 .include "words/pad.asm"
                 
                 ; System Variable
                 ; Address of the temporary scratch buffer.
                 VE_PAD:
003ecb ff03          .dw $ff03
003ecc 6170
003ecd 0064          .db "pad",0
003ece 3ec5          .dw VE_HEAD
                     .set VE_HEAD = VE_PAD
                 XT_PAD:
003ecf 3800          .dw DO_COLON
                 PFA_PAD:
003ed0 3f0a          .dw XT_HERE
003ed1 3837          .dw XT_DOLITERAL
003ed2 0064          .dw 100
003ed3 3997          .dw XT_PLUS
003ed4 381a          .dw XT_EXIT
                 .include "words/emit.asm"
                 
                 ; Character IO
                 ; fetch the emit vector and execute it. should emit a character from TOS
                 VE_EMIT:
003ed5 ff04          .dw $ff04
003ed6 6d65
003ed7 7469          .db "emit"
003ed8 3ecb          .dw VE_HEAD
                     .set VE_HEAD = VE_EMIT
                 XT_EMIT:
003ed9 3dd8          .dw PFA_DODEFER1
                 PFA_EMIT:
003eda 000e          .dw USER_EMIT
003edb 3da2          .dw XT_UDEFERFETCH
003edc 3dae          .dw XT_UDEFERSTORE
                 .include "words/emitq.asm"
                 
                 ; Character IO
                 ; fetch emit? vector and execute it. should return the ready-to-send condition
                 VE_EMITQ:
003edd ff05          .dw $ff05
003ede 6d65
003edf 7469
003ee0 003f          .db "emit?",0
003ee1 3ed5          .dw VE_HEAD
                     .set VE_HEAD = VE_EMITQ
                 XT_EMITQ:
003ee2 3dd8          .dw PFA_DODEFER1
                 PFA_EMITQ:
003ee3 0010          .dw USER_EMITQ
003ee4 3da2          .dw XT_UDEFERFETCH
003ee5 3dae          .dw XT_UDEFERSTORE
                 .include "words/key.asm"
                 
                 ; Character IO
                 ; fetch key vector and execute it, should leave a single character on TOS
                 VE_KEY:
003ee6 ff03          .dw $ff03
003ee7 656b
003ee8 0079          .db "key",0
003ee9 3edd          .dw VE_HEAD
                     .set VE_HEAD = VE_KEY
                 XT_KEY:
003eea 3dd8          .dw PFA_DODEFER1
                 PFA_KEY:
003eeb 0012          .dw USER_KEY
003eec 3da2          .dw XT_UDEFERFETCH
003eed 3dae          .dw XT_UDEFERSTORE
                 .include "words/keyq.asm"
                 
                 ; Character IO
                 ; fetch key? vector and execute it. should turn on key sender, if it is disabled/stopped
                 VE_KEYQ:
003eee ff04          .dw $ff04
003eef 656b
003ef0 3f79          .db "key?"
003ef1 3ee6          .dw VE_HEAD
                     .set VE_HEAD = VE_KEYQ
                 XT_KEYQ:
003ef2 3dd8          .dw PFA_DODEFER1
                 PFA_KEYQ:
003ef3 0014          .dw USER_KEYQ
003ef4 3da2          .dw XT_UDEFERFETCH
003ef5 3dae          .dw XT_UDEFERSTORE
                 
                 .include "words/dp.asm"
                 
                 ; System Value
                 ; address of the next free dictionary cell
                 VE_DP:
003ef6 ff02          .dw $ff02
003ef7 7064          .db "dp"
003ef8 3eee          .dw VE_HEAD
                     .set VE_HEAD = VE_DP
                 XT_DP:
003ef9 3869          .dw PFA_DOVALUE1
                 PFA_DP:
003efa 0036          .dw EE_DP
003efb 3d7a          .dw XT_EDEFERFETCH
003efc 3d84          .dw XT_EDEFERSTORE
                 .include "words/ehere.asm"
                 
                 ; System Value
                 ; address of the next free address in eeprom
                 VE_EHERE:
003efd ff05          .dw $ff05
003efe 6865
003eff 7265
003f00 0065          .db "ehere",0
003f01 3ef6          .dw VE_HEAD
                     .set VE_HEAD = VE_EHERE
                 XT_EHERE:
003f02 3869          .dw PFA_DOVALUE1
                 PFA_EHERE:
003f03 003a          .dw EE_EHERE
003f04 3d7a          .dw XT_EDEFERFETCH
003f05 3d84          .dw XT_EDEFERSTORE
                 .include "words/here.asm"
                 
                 ; System Value
                 ; address of the next free data space (RAM) cell
                 VE_HERE:
003f06 ff04          .dw $ff04
003f07 6568
003f08 6572          .db "here"
003f09 3efd          .dw VE_HEAD
                     .set VE_HEAD = VE_HERE
                 XT_HERE:
003f0a 3869          .dw PFA_DOVALUE1
                 PFA_HERE:
003f0b 0038          .dw EE_HERE
003f0c 3d7a          .dw XT_EDEFERFETCH
003f0d 3d84          .dw XT_EDEFERSTORE
                 .include "words/allot.asm"
                 
                 ; System
                 ; allocate or release memory in RAM
                 VE_ALLOT:
003f0e ff05          .dw $ff05
003f0f 6c61
003f10 6f6c
003f11 0074          .db "allot",0
003f12 3f06          .dw VE_HEAD
                     .set VE_HEAD = VE_ALLOT
                 XT_ALLOT:
003f13 3800          .dw DO_COLON
                 PFA_ALLOT:
003f14 3f0a          .dw XT_HERE
003f15 3997          .dw XT_PLUS
003f16 01a5          .dw XT_DOTO
003f17 3f0b          .dw PFA_HERE
003f18 381a          .dw XT_EXIT
                 
                 .include "words/bin.asm"
                 
                 ; Numeric IO
                 ; set base for numeric conversion to 10
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_BIN:
003f19 ff03          .dw $ff03
003f1a 6962
003f1b 006e          .db "bin",0
003f1c 3f0e          .dw VE_HEAD
                     .set VE_HEAD = VE_BIN
                 XT_BIN:
003f1d 3800          .dw DO_COLON
                 PFA_BIN:
                 .endif
003f1e 3837          .dw XT_DOLITERAL
003f1f 0002          .dw 2
003f20 3e9e          .dw XT_BASE
003f21 387b          .dw XT_STORE
003f22 381a          .dw XT_EXIT
                 .include "words/decimal.asm"
                 
                 ; Numeric IO
                 ; set base for numeric conversion to 10
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DECIMAL:
003f23 ff07          .dw $ff07
003f24 6564
003f25 6963
003f26 616d
003f27 006c          .db "decimal",0
003f28 3f19          .dw VE_HEAD
                     .set VE_HEAD = VE_DECIMAL
                 XT_DECIMAL:
003f29 3800          .dw DO_COLON
                 PFA_DECIMAL:
                 .endif
003f2a 3837          .dw XT_DOLITERAL
003f2b 000a          .dw 10
003f2c 3e9e          .dw XT_BASE
003f2d 387b          .dw XT_STORE
003f2e 381a          .dw XT_EXIT
                 .include "words/hex.asm"
                 
                 ; Numeric IO
                 ; set base for numeric conversion to 10
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_HEX:
003f2f ff03          .dw $ff03
003f30 6568
003f31 0078          .db "hex",0
003f32 3f23          .dw VE_HEAD
                     .set VE_HEAD = VE_HEX
                 XT_HEX:
003f33 3800          .dw DO_COLON
                 PFA_HEX:
                 .endif
003f34 3837          .dw XT_DOLITERAL
003f35 0010          .dw 16
003f36 3e9e          .dw XT_BASE
003f37 387b          .dw XT_STORE
003f38 381a          .dw XT_EXIT
                 .include "words/bl.asm"
                 
                 ; Character IO
                 ; put ascii code of the blank to the stack
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_BL:
003f39 ff02          .dw $ff02
003f3a 6c62          .db "bl"
003f3b 3f2f          .dw VE_HEAD
                     .set VE_HEAD = VE_BL
                 XT_BL:
003f3c 3842          .dw PFA_DOVARIABLE
                 PFA_BL:
                 .endif
003f3d 0020          .dw 32
                 
                 .include "words/turnkey.asm"
                 
                 ; System Value
                 ; Deferred action during startup/reset
                 VE_TURNKEY:
003f3e ff07          .dw $ff07
003f3f 7574
003f40 6e72
003f41 656b
003f42 0079          .db "turnkey",0
003f43 3f39          .dw VE_HEAD
                     .set VE_HEAD = VE_TURNKEY
                 XT_TURNKEY:
003f44 3dd8          .dw PFA_DODEFER1
                 PFA_TURNKEY:
003f45 003c          .dw EE_TURNKEY
003f46 3d7a          .dw XT_EDEFERFETCH
003f47 3d84          .dw XT_EDEFERSTORE
                 .include "words/to-upper.asm"
                 
                 ; String
                 ; if c is a lowercase letter convert it to uppercase
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_TOUPPER:
003f48 ff07          .dw $ff07 
003f49 6f74
003f4a 7075
003f4b 6570
003f4c 0072          .db "toupper",0
003f4d 3f3e          .dw VE_HEAD
                     .set VE_HEAD = VE_TOUPPER
                 XT_TOUPPER:
003f4e 3800          .dw DO_COLON 
                 PFA_TOUPPER:
                 .endif
003f4f 38ab          .dw XT_DUP 
003f50 3837          .dw XT_DOLITERAL 
003f51 0061          .dw 'a' 
003f52 3837          .dw XT_DOLITERAL 
003f53 007b          .dw 'z'+1
003f54 3e38          .dw XT_WITHIN 
003f55 3830          .dw XT_DOCONDBRANCH
003f56 3f5a          DEST(PFA_TOUPPER0)
003f57 3837          .dw XT_DOLITERAL
003f58 00df          .dw 223 ; inverse of 0x20: 0xdf
003f59 3a0d          .dw XT_AND 
                 PFA_TOUPPER0:
003f5a 381a          .dw XT_EXIT 
                 .include "words/to-lower.asm"
                 
                 ; String
                 ; if C is an uppercase letter convert it to lowercase
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 
                 VE_TOLOWER:
003f5b ff07          .dw $ff07
003f5c 6f74
003f5d 6f6c
003f5e 6577
003f5f 0072          .db "tolower",0
003f60 3f48          .dw VE_HEAD
                     .set VE_HEAD = VE_TOLOWER
                 XT_TOLOWER:
003f61 3800          .dw DO_COLON
                 PFA_TOLOWER:
                 .endif
003f62 38ab          .dw XT_DUP
003f63 3837          .dw XT_DOLITERAL
003f64 0041          .dw 'A'
003f65 3837          .dw XT_DOLITERAL
003f66 005b          .dw 'Z'+1
003f67 3e38          .dw XT_WITHIN
003f68 3830          .dw XT_DOCONDBRANCH
003f69 3f6d          DEST(PFA_TOLOWER0)
003f6a 3837          .dw XT_DOLITERAL
003f6b 0020          .dw 32
003f6c 3a16          .dw XT_OR 
                 PFA_TOLOWER0:
003f6d 381a          .dw XT_EXIT 
                 
                 .include "words/q-stack.asm"
                 
                 ; Tools
                 ; check data stack depth and exit to quit if underrun
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_QSTACK:
003f6e ff06          .dw $ff06
003f6f 733f
003f70 6174
003f71 6b63          .db "?stack"
003f72 3f5b          .dw VE_HEAD
                     .set VE_HEAD = VE_QSTACK
                 XT_QSTACK:
003f73 3800          .dw DO_COLON
                 PFA_QSTACK:
                 .endif
003f74 05bd          .dw XT_DEPTH
003f75 391b          .dw XT_ZEROLESS
003f76 3830          .dw XT_DOCONDBRANCH
003f77 3f7b          DEST(PFA_QSTACK1)
003f78 3837            .dw XT_DOLITERAL
003f79 fffc            .dw -4
003f7a 3d60            .dw XT_THROW
                 PFA_QSTACK1:
003f7b 381a          .dw XT_EXIT
                 .include "words/bounds.asm"
                 
                 ; Tools
                 ; convert a string to an address range
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_BOUNDS:
003f7c ff06          .dw $ff06
003f7d 6f62
003f7e 6e75
003f7f 7364          .db "bounds"
003f80 3f6e          .dw VE_HEAD
                     .set VE_HEAD = VE_BOUNDS
                 XT_BOUNDS:
003f81 3800          .dw DO_COLON
                 PFA_BOUNDS:
                 .endif
003f82 38c9          .dw XT_OVER
003f83 3997          .dw XT_PLUS
003f84 38be          .dw XT_SWAP
003f85 381a          .dw XT_EXIT
                 .include "words/cr.asm"
                 
                 ; Character IO
                 ; cause subsequent output appear at the beginning of the next line
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_CR:
003f86 ff02          .dw 0xff02
003f87 7263          .db "cr"
003f88 3f7c          .dw VE_HEAD
                     .set VE_HEAD = VE_CR
                 XT_CR:
003f89 3800          .dw DO_COLON
                 PFA_CR:
                 .endif
                 
003f8a 3837          .dw XT_DOLITERAL
003f8b 000d          .dw 13
003f8c 3ed9          .dw XT_EMIT
003f8d 3837          .dw XT_DOLITERAL
003f8e 000a          .dw 10
003f8f 3ed9          .dw XT_EMIT
003f90 381a          .dw XT_EXIT
                 .include "words/space.asm"
                 
                 ; Character IO
                 ; emits a space (bl)
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SPACE:
003f91 ff05          .dw $ff05
003f92 7073
003f93 6361
003f94 0065          .db "space",0
003f95 3f86          .dw VE_HEAD
                     .set VE_HEAD = VE_SPACE
                 XT_SPACE:
003f96 3800          .dw DO_COLON
                 PFA_SPACE:
                 .endif
003f97 3f3c          .dw XT_BL
003f98 3ed9          .dw XT_EMIT
003f99 381a          .dw XT_EXIT
                 .include "words/spaces.asm"
                 
                 ; Character IO
                 ; emits n space(s) (bl)
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SPACES:
003f9a ff06          .dw $ff06
003f9b 7073
003f9c 6361
003f9d 7365          .db "spaces"
003f9e 3f91          .dw VE_HEAD
                     .set VE_HEAD = VE_SPACES
                 XT_SPACES:
003f9f 3800          .dw DO_COLON
                 PFA_SPACES:
                 
                 .endif
                 ;C SPACES   n --            output n spaces
                 ;   BEGIN DUP 0> WHILE SPACE 1- REPEAT DROP ;
003fa0 394e
003fa1 3e2b      	.DW XT_ZERO, XT_MAX
003fa2 38ab
003fa3 3830      SPCS1:  .DW XT_DUP,XT_DOCONDBRANCH
003fa4 3fa9              DEST(SPCS2)
003fa5 3f96
003fa6 3a2f
003fa7 3829              .DW XT_SPACE,XT_1MINUS,XT_DOBRANCH
003fa8 3fa2              DEST(SPCS1)
003fa9 38d3
003faa 381a      SPCS2:  .DW XT_DROP,XT_EXIT
                 .include "words/s-to-d.asm"
                 
                 ; Conversion
                 ; extend (signed) single cell value to double cell
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_S2D:
003fab ff03          .dw $ff03
003fac 3e73
003fad 0064          .db "s>d",0
003fae 3f9a          .dw VE_HEAD
                     .set VE_HEAD = VE_S2D
                 XT_S2D:
003faf 3800          .dw DO_COLON
                 PFA_S2D:
                 .endif
003fb0 38ab          .dw XT_DUP
003fb1 391b          .dw XT_ZEROLESS
003fb2 381a          .dw XT_EXIT
                 .elif AMFORTH_NRWW_SIZE>2000
                 .else
                 .endif
                 ; now colon words
                 ;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/2literal.asm"
                 
                 ; Compiler
                 ; compile a cell pair literal in colon definitions
                 VE_2LITERAL:
003fb3 0008          .dw $0008
003fb4 6c32
003fb5 7469
003fb6 7265
003fb7 6c61          .db "2literal"
003fb8 3fab          .dw VE_HEAD
                     .set VE_HEAD = VE_2LITERAL
                 XT_2LITERAL:
003fb9 3800          .dw DO_COLON
                 PFA_2LITERAL:
003fba 38be          .dw XT_SWAP
003fbb 0729          .dw XT_COMPILE
003fbc 3837          .dw XT_DOLITERAL
003fbd 0734          .dw XT_COMMA
003fbe 0729          .dw XT_COMPILE
003fbf 3837          .dw XT_DOLITERAL
003fc0 0734          .dw XT_COMMA
                     
003fc1 381a          .dw XT_EXIT
                 .include "words/equal.asm"
                 
                 ; Compare
                 ; compares two values for equality
                 VE_EQUAL:
003fc2 ff01          .dw $ff01
003fc3 003d          .db "=",0
003fc4 3fb3          .dw VE_HEAD
                     .set VE_HEAD = VE_EQUAL
                 XT_EQUAL:
003fc5 3800          .dw DO_COLON
                 PFA_EQUAL:
003fc6 398d          .dw XT_MINUS
003fc7 3914          .dw XT_ZEROEQUAL
003fc8 381a          .dw XT_EXIT
                 .include "words/num-constants.asm"
                 
                 .endif
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_ONE:
003fc9 ff01          .dw $ff01
003fca 0031          .db "1",0
003fcb 3fc2          .dw VE_HEAD
                     .set VE_HEAD = VE_ONE
                 XT_ONE:
003fcc 3842          .dw PFA_DOVARIABLE
                 PFA_ONE:
                 .endif
003fcd 0001              .DW 1
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_TWO:
003fce ff01          .dw $ff01
003fcf 0032          .db "2",0
003fd0 3fc9          .dw VE_HEAD
                     .set VE_HEAD = VE_TWO
                 XT_TWO:
003fd1 3842          .dw PFA_DOVARIABLE
                 PFA_TWO:
                 .endif
003fd2 0002              .DW 2
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_MINUSONE:
003fd3 ff02          .dw $ff02
003fd4 312d          .db "-1"
003fd5 3fce          .dw VE_HEAD
                     .set VE_HEAD = VE_MINUSONE
                 XT_MINUSONE:
003fd6 3842          .dw PFA_DOVARIABLE
                 PFA_MINUSONE:
                 .endif
003fd7 ffff              .DW -1
                 .include "dict_appl_core.inc"
                 
                 ; do not delete it!
                 
                 .set flashlast = pc
                 .if (pc>FLASHEND)
                 .endif
                 
                 .dseg
                 ; define a label for the 1st free ram address
                 HERESTART:
                 .eseg
                 .include "amforth-eeprom.inc"
000034 ff ff     
                 EE_DP:
000036 9d 0a         .dw DPSTART      ; Dictionary Pointer
                 EE_HERE:
000038 a7 01         .dw HERESTART    ; Memory Allocation
                 EE_EHERE:
00003a 88 00         .dw EHERESTART     ; EEProm Memory Allocation
                 EE_TURNKEY:
00003c 8f 0a         .dw XT_APPLTURNKEY  ; TURNKEY
                 EE_STOREI:
00003e 6c 3b         .dw XT_DO_STOREI  ; Store a cell into flash
                 
                 EE_ENVIRONMENT:
000040 d8 02         .dw VE_ENVHEAD   ; environmental queries
                 EE_WL_FORTH:
000042 46 00         .dw EE_FORTHWORDLIST; forth-wordlist
                 EE_CURRENT:
000044 46 00         .dw EE_FORTHWORDLIST
                 EE_FORTHWORDLIST:
000046 d3 3f         .dw VE_HEAD      ; pre-defined (compiled in) wordlist
                 CFG_ORDERLISTLEN:
000048 01 00         .dw 1
                 CFG_ORDERLIST: ; list of wordlist id, exactly numwordlist entries
00004a 46 00         .dw EE_FORTHWORDLIST      ; get/set-order
00004c               .byte  (NUMWORDLISTS-1)*CELLSIZE ; one slot is already used
                 CFG_RECOGNIZERLISTLEN:
00005a 02 00         .dw 2
                 CFG_RECOGNIZERLIST:
00005c 40 06         .dw XT_REC_WORD
00005e 2b 06         .dw XT_REC_NUM
000060               .byte  (NUMRECOGNIZERS-2)*CELLSIZE ; two slots are already used
                 
                 EE_WLSCOPE:
000064 ab 09         .dw XT_GET_CURRENT  ; default wordlist scope
                 
                 ; LEAVE stack is between data stack and return stack.
                 EE_LP0:
000066 b0 08         .dw stackstart+1
                 
                 ; MARKER saves everything up to here. Nothing beyond gets saved
                 EE_MARKER:
000068 68 00         .dw EE_MARKER
                 
                 ; default user area
                 EE_INITUSER:
00006a 00 00         .dw 0  ; USER_STATE
00006c 00 00         .dw 0  ; USER_FOLLOWER
00006e ff 08         .dw rstackstart  ; USER_RP
000070 af 08         .dw stackstart   ; USER_SP0
000072 af 08         .dw stackstart   ; USER_SP
                     
000074 00 00         .dw 0  ; USER_HANDLER
000076 0a 00         .dw 10 ; USER_BASE
                     
000078 90 00         .dw XT_TX  ; USER_EMIT
00007a 9e 00         .dw XT_TXQ ; USER_EMITQ
00007c 66 00         .dw XT_RX  ; USER_KEY
00007e 80 00         .dw XT_RXQ ; USER_KEYQ
000080 5b 02         .dw XT_SOURCETIB ; USER_SKEY
000082 00 00         .dw 0            ; USER_G_IN
000084 48 02         .dw XT_REFILLTIB ; USER_REFILL  
                 
                 ; calculate baud rate error
                 .equ UBRR_VAL   = ((F_CPU+BAUD*8)/(BAUD*16)-1)  ; smart round
                 .equ BAUD_REAL  = (F_CPU/(16*(UBRR_VAL+1)))     ; effective baud rate
                 .equ BAUD_ERROR = ((BAUD_REAL*1000)/BAUD-1000)  ; error in pro mille
                 
                 .if ((BAUD_ERROR>BAUD_MAXERROR) || (BAUD_ERROR<-BAUD_MAXERROR))       
                 .endif
                 EE_UBRRVAL:
000086 19 00         .dw UBRR_VAL     ; BAUDRATE
                 ; 1st free address in EEPROM.
                 EHERESTART:
                 .cseg


RESOURCE USE INFORMATION
------------------------

Notice:
The register and instruction counts are symbol table hit counts,
and hence implicitly used resources are not counted, eg, the
'lpm' instruction without operands implicitly uses r0 and z,
none of which are counted.

x,y,z are separate entities in the symbol table and are
counted separately from r26..r31 here.

.dseg memory usage only counts static data declared with .byte

"ATmega328P" register use summary:
r0 :  20 r1 :   5 r2 :   7 r3 :  11 r4 :   4 r5 :   1 r6 :   0 r7 :   0 
r8 :   0 r9 :   0 r10:   1 r11:   1 r12:   0 r13:   0 r14:  22 r15:  20 
r16:  78 r17:  56 r18:  52 r19:  37 r20:  13 r21:  11 r22:  11 r23:   3 
r24: 191 r25: 136 r26:  39 r27:  21 r28:   7 r29:   4 r30:  81 r31:  43 
x  :   4 y  : 201 z  :  45 
Registers used: 29 out of 35 (82.9%)

"ATmega328P" instruction use summary:
.lds  :   0 .sts  :   0 adc   :  21 add   :  16 adiw  :  18 and   :   4 
andi  :   3 asr   :   2 bclr  :   0 bld   :   0 brbc  :   2 brbs  :   7 
brcc  :   3 brcs  :   1 break :   0 breq  :   6 brge  :   1 brhc  :   0 
brhs  :   0 brid  :   0 brie  :   0 brlo  :   1 brlt  :   3 brmi  :   3 
brne  :  17 brpl  :   1 brsh  :   0 brtc  :   0 brts  :   1 brvc  :   0 
brvs  :   2 bset  :   0 bst   :   0 call  :   2 cbi   :   7 cbr   :   0 
clc   :   2 clh   :   0 cli   :   7 cln   :   0 clr   :  11 cls   :   0 
clt   :   1 clv   :   0 clz   :   0 com   :  16 cp    :  10 cpc   :  10 
cpi   :   0 cpse  :   0 dec   :  10 eor   :   3 fmul  :   0 fmuls :   0 
fmulsu:   0 icall :   0 ijmp  :   1 in    :  19 inc   :   3 jmp   :   9 
ld    : 133 ldd   :   4 ldi   :  37 lds   :   2 lpm   :  16 lsl   :  14 
lsr   :   1 mov   :  12 movw  :  65 mul   :   5 muls  :   1 mulsu :   2 
neg   :   0 nop   :   0 or    :   9 ori   :   2 out   :  19 pop   :  48 
push  :  42 rcall :  38 ret   :   6 reti  :   2 rjmp  : 105 rol   :  23 
ror   :   6 sbc   :   9 sbci  :   3 sbi   :   8 sbic  :   3 sbis  :   0 
sbiw  :  14 sbr   :   0 sbrc  :   5 sbrs  :   4 sec   :   1 seh   :   0 
sei   :   1 sen   :   0 ser   :   4 ses   :   0 set   :   2 sev   :   0 
sez   :   0 sleep :   0 spm   :   2 st    :  72 std   :   8 sts   :   3 
sub   :   6 subi  :   3 swap  :   0 tst   :   1 wdr   :   0 
Instructions used: 75 out of 113 (66.4%)

"ATmega328P" memory use summary [bytes]:
Segment   Begin    End      Code   Data   Used    Size   Use%
---------------------------------------------------------------
[.cseg] 0x000000 0x007fb0   1958  11462  13420   32768  41.0%
[.dseg] 0x000100 0x0001a7      0    167    167    2048   8.2%
[.eseg] 0x000000 0x000088      0    136    136    1024  13.3%

Assembly complete, 0 errors, 5 warnings
