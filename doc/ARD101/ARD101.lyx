#LyX 2.1 created this file. For more info see http://www.lyx.org/
\lyxformat 474
\begin_document
\begin_header
\textclass article
\begin_preamble
\input{ConfigARD101.tex}
\end_preamble
\use_default_options true
\begin_modules
noweb
customHeadersFooters
\end_modules
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding iso8859-1
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_math auto
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100
\graphics dvips
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize 10
\spacing single
\use_hyperref true
\pdf_bookmarks true
\pdf_bookmarksnumbered false
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 1
\pdf_breaklinks false
\pdf_pdfborder false
\pdf_colorlinks false
\pdf_backref false
\pdf_pdfusetitle true
\papersize default
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 0
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 2cm
\rightmargin 2cm
\secnumdepth 3
\tocdepth 3
\paragraph_separation skip
\defskip smallskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle fancy
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title

\series bold
ARD101 Tutorial Conversion
\end_layout

\begin_layout Standard
\noindent
\align center
Public Domain
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="2">
<features rotate="0" islongtable="true" longtabularalignment="center">
<column alignment="none" valignment="top">
<column alignment="none" valignment="top">
<row>
<cell multicolumn="1" alignment="none" valignment="top" topline="true" usebox="none" special="c">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Software Version
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Date
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="none" valignment="top" bottomline="true" usebox="none" special="c">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
projectVersion
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
projectDate
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Make sure the ConfigARD101.tex file is setup properly before exporting to
 PDF.
\end_layout

\end_inset


\end_layout

\begin_layout Section
OSEPP 101 Arduino Basics Starter Kitz
\end_layout

\begin_layout Standard
This 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
projectName
\end_layout

\end_inset


\begin_inset space \space{}
\end_inset

project started when Fry's put this kit on sale for $35.99.
\end_layout

\begin_layout Standard
\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://osepp.com/products/kits/101-arduino-basic-starter-kit/
\end_layout

\end_inset


\end_layout

\begin_layout Standard
It contains an UNO R3 Plus processor, which is compatible with, at least,
 Dr.
 Ting's 328eForth for Arduino.
\end_layout

\begin_layout Standard
\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://www.offete.com/328eForth.html
\end_layout

\end_inset


\end_layout

\begin_layout Standard
It is also compatible with SwiftX AVR and probably with amForth, but I haven't
 gotten the latter working yet.
\end_layout

\begin_layout Standard
\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://www.forth.com/downloads/SwiftX-Eval-AVR-3.7.1-f4qbm8hnnrg5r42ko.exe
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://amforth.sourceforge.net/
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The Kit also contains all the parts needed to complete 7 different tutorials
 involving flashing LEDs, playing tones and reading voltages and GPIOs,
 which can provide a very basic comparison between the C and Forth programming
 languages.
 Unfortunately, while the Kit is complete for programming in C, you still
 need an additional AVR ISP programmer to work with Forth.
 While Atmel does sell one that is very mature, I decided to try to find
 one that was a little smaller.
 After a couple of misfires, I went back to the one recommended by Leon
 Wagner from Forth, Inc.
 at the February 2011 SVFIG meeting:
\end_layout

\begin_layout Standard
\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://www.forth.org/svfig/kk/02-2011.html
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://www.pololu.com/product/1300/
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
arduino-ble-dev-kit
\end_layout

\begin_layout Standard
And now, in the pursuit of the Internet of Things (IoT), I am moving this
 to Bluetooth LE:
\end_layout

\begin_layout Standard
\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://blog.onlycoin.com/posts/?category=Open+Source
\end_layout

\end_inset


\end_layout

\begin_layout Standard
They did not pre-burn the boot loaders or software with the boards produced
 in a 2nd run, as this service was not offered by their contract manufacturer
 in China.
 However, do not fear! They have a very simple fix that has taken most people
 10 minutes or less to get you up and programming with your awesome dev
 kit, just follow these steps...
\end_layout

\begin_layout Standard
\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://ross-arduinoprojects.blogspot.com/2014/04/setting-up-coin-ble-dev-kit.html
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Well, any implication that this would be an easy transition has proven to
 be misleading, but I did finally get the SwiftX distress sample to run
 last night.
 The Pololu Programmer doesn't work, because this is a 3.3 volt system running
 at 8 MHz.
 So, I have had to get the Atmel AVRISP mkII and the TI CC-DEBUGGER for
 the Bluetooth module.
 The 
\family typewriter
\series bold
CPUCLOCK
\family default
\series default
 change in SwiftX AVR was pretty easy to figure out, but I still haven't
 figured out what's needed in eForth.
 I changed the baud rate value in 
\family typewriter
\series bold
STOIO
\family default
\series default
, but I still don't get any output.
 I guess I should take another stab at amForth.
\end_layout

\begin_layout Standard
The AVRISP mkII proved to be problematic too.
 Atmel switched to a Jungo interface in their Studio 5, but I had installed
 the 
\family typewriter
\series bold
avrispmkii libusb win32 1.2.1.0
\family default
\series default
 which prevented the Jungo interface from attaching to the mkII.
 Installing Atmel Studio 6.2.1153 .net fixed that problem and using it to recompile
 eForth fixed that too.
 I had a point in time that I had amForth working, but that proved to be
 fleeting and doesn't work today.
 They appear to have issues with uploading code that I haven't figure out
 yet too (See section 3.7.1 of the AmForth Documentation, Release 5.3).
\end_layout

\begin_layout Subsubsection
BLE Sample
\end_layout

\begin_layout Standard
There are many Bluetooth Low Energy (BLE) samples around right now.
 It's the latest fad for the IoT and Texas Instruments CC2540 is one of
 the more popular chips supporting the protocol.
 The CC2540 combines an excellent RF transceiver with an industry-standard
 enhanced 8051 MCU.
 In 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:BLE Sample"

\end_inset

 you can see that the chip is alive and transmitting, but I still have to
 figure out how to use it.
 Until then, I just leave this running on 3 AAA batteries to see if I can
 even make a dent in the battery voltage.
 Coin predicts a couple of years for their product, so I may have to wait
 a very long time before I see any change.
 We'll see!
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:BLE Sample"

\end_inset


\begin_inset Graphics
	filename BLE_Sample.png
	height 70theight%

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Atmel Studio 6
\end_layout

\begin_layout Standard
The Kit does require it's own software.
 ARDUINO 1.0.5-r2 - 2014.01.08 is the latest version, but I ended up using ARDUINO
 1.5.5-r2 BETA 2014.01.10 to support my Windows 8.1 computer.
 Now, I see that they are up to version 1.6.3, which also works.
\end_layout

\begin_layout Standard
\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://arduino.cc/en/Main/Software
\end_layout

\end_inset


\end_layout

\begin_layout Standard
While SwiftX is self contained, amForth and eForth require a separate assembler
 and compiler system.
 The most recent is Atmel's Studio 6 (Version 6.1.2730 - Service Pack 2).
\end_layout

\begin_layout Standard
\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://www.atmel.com/tools/ATMELSTUDIO.aspx
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Getting all of this setup is a much more significant part of the problem
 than it needs to be, but then again, supporting all of the updates of all
 of the pieces is certainly an expensive proposition.
 I just wish more vendors considered it to be a priority.
 OSEPP is doing a better job than most, but even they are at the mercy of
 the Arduino open-source community, and Win8.1 is causing most companies
 issues with their driver security requirements.
\end_layout

\begin_layout Standard
\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://preview.tinyurl.com/krnp7nv
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Atmel has also gone through many variations to its compiler suite, and with
 this latest version, they chose to use Microsoft's Visual Studio as the
 IDE for their compiler.
 They are still stuck in the VS2010 version, but at least they have a reasonable
 update mechanism and they do provide the older version for the less adventurous.
 I personally believe in continuous integration, so I still am struggling
 to figure out how to get amForth to work.
 Dr.
 Ting's eForth was not too difficult, but the Pololu programmer instructions
 have not been updated to the latest menus in Studio 6.
 The instructions that say to 
\begin_inset Quotes eld
\end_inset

select Add STK500… from the Tools menu
\begin_inset Quotes erd
\end_inset

 should actually be to select Add target...
 and Select the STK500 tool.
 A minor but frustratingly significant difference.
\end_layout

\begin_layout Standard
After having to rebuild my computer and do a quick contract between jobs,
 I've gotten this setup again, and found the command line syntax to flash
 without loading the entire IDE.
 It is:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

atprogram -t stk500 -c 6 -i ISP -d ATmega328P -v program -f target.hex
\end_layout

\end_inset


\end_layout

\begin_layout Standard
You may need to adjust some of the parameters for your environment.
\end_layout

\begin_layout Standard
Also after an even longer hiatus, an item that I had to go find again, was
 how to connect the AVRISP MkII to the arduino-ble-dev-kit.
 I found:
\end_layout

\begin_layout Standard
\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://www.atmel.com/webdoc/avrispmkii/avrispmkii.section.zgf_vsd_lc.html
\end_layout

\end_inset

 and
\end_layout

\begin_layout Standard
\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://img.onlycoin.com/arduino-ble-dev-kit/pinout.png
\end_layout

\end_inset

 which solved that dilemma.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset Graphics
	filename coin.jpg
	lyxscale 30
	width 70text%

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
328eForth v2.20
\end_layout

\begin_layout Standard
Once I finally got everything setup properly, I was able to backup the existing
 flash image, which is essential if you want to return to the Kit's original
 Tutorials.
 However, I lost that backup when I had to rebuild my computer, so I had
 to find out where the 
\begin_inset Quotes eld
\end_inset

official
\begin_inset Quotes erd
\end_inset

 image is called 
\family typewriter
\series bold
\size small
ATmegaBOOT_168_atmega328_pro_8MHz.hex
\family default
\series default
\size default
 and was at:
\end_layout

\begin_layout Standard

\family typewriter
\series bold
\size small
C:
\backslash
Arduino
\backslash
arduino-1.5.5-r2
\backslash
hardware
\backslash
arduino
\backslash
avr
\backslash
bootloaders
\backslash
atmega
\backslash

\end_layout

\begin_layout Standard
Dr.
 Ting's instructions also say to set the High Fuse byte to 0xD8, which I
 have so far, found to be unnecessary and the original setting of 0xDE (BOOTSZ
 = 256W_3F00) works the same.
 Once I flashed the 
\family typewriter
\series bold
328eforth.hex
\family default
\series default
 and connected the serial port to PuTTY, I got the following:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

328eForth v2.20
\end_layout

\begin_layout Plain Layout

ok
\end_layout

\begin_layout Plain Layout

words
\end_layout

\begin_layout Plain Layout

 VARIABLE CONSTANT CREATE IMMEDIATE : ] ; OVERT ." $" ABORT" WHILE ELSE AFT
 THEN 
\end_layout

\begin_layout Plain Layout

REPEAT IF AGAIN UNTIL NEXT FOR BEGIN LITERAL COMPILE [COMPILE] , IALLOT
 ALLOT 
\end_layout

\begin_layout Plain Layout

D- D+ D> > 2- 2+ 1- 1+ READ WRITE ERASE COLD WORDS .S IDUMP DUMP ' QUIT EVAL
 [ 
\end_layout

\begin_layout Plain Layout

QUERY EXPECT NAME> WORD CHAR 
\backslash
 ( .( ? .
 U.
 U.R .R CR ITYPE TYPE SPACES SPACE KEY 
\end_layout

\begin_layout Plain Layout

NUMBER? DECIMAL HEX #> SIGN #S # HOLD <# FILL CMOVE @EXECUTE TIB PAD HERE
 ICOUNT 
\end_layout

\begin_layout Plain Layout

COUNT +! PICK DEPTH */ */MOD M* * UM* / MOD /MOD M/MOD UM/MOD WITHIN MIN
 MAX < 
\end_layout

\begin_layout Plain Layout

U< = ABS - DNEGATE NEGATE INVERT + 2DUP 2DROP ROT ?DUP BL 2/ 2* LAST DP
 CP 
\end_layout

\begin_layout Plain Layout

CONTEXT HLD 'EVAL 'TIB #TIB >IN SPAN TMP BASE 'BOOT UM+ XOR OR AND 0< OVER
 
\end_layout

\begin_layout Plain Layout

SWAP DUP DROP >R R@ R> C@ C! FLUSH I! IC@ I@ @ ! EXIT EXECUTE EMIT ?KEYok
 
\end_layout

\begin_layout Plain Layout

ok
\end_layout

\end_inset


\end_layout

\begin_layout Standard
So now, I can start translating the tutorials.
\end_layout

\begin_layout Subsubsection
amforth 5.8 ATmega328P Forthduino
\end_layout

\begin_layout Standard
I have a 
\family typewriter
\series bold
C:
\backslash
amforth
\family default
\series default
 folder with versions 5.1, 5.3, 5.4, and now 5.8 in it, so I have been trying
 to do this for a while now.
 I finally noticed:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

.equ F_CPU = 16000000 -> 8000000
\end_layout

\end_inset


\end_layout

\begin_layout Standard
and:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

.set BAUD = 38400 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
and thought I might try PuTTY at 19200 baud and pressed the reset button
 multiple times, until I got:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

amforth 5.8 ATmega328P Forthduino
\end_layout

\begin_layout Plain Layout

> 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Not rocket science, and doesn't work or always take keyboard input, but
 encouraging.
 On the other hand:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Assembly failed, 39 errors, 44 warnings
\end_layout

\end_inset


\end_layout

\begin_layout Standard
And how to make:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Atmel Studio 6 (Version: 6.2.1563 - Service Pack 2) © 2014 Atmel Corp.
 All rights reserved.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Find the source files...
\end_layout

\begin_layout Standard
In the Project -> Properties -> Toolchain -> General, check Generate EEP
 file and
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Include Paths (-I)
\end_layout

\begin_layout Plain Layout

../../amforth-5.8/common
\end_layout

\begin_layout Plain Layout

../../amforth-5.8/avr8
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Other optimization flags:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

-v0
\end_layout

\end_inset


\end_layout

\begin_layout Standard
and finally!
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

------ Build started: Project: coinForth, Configuration: Debug AVR ------
\end_layout

\begin_layout Plain Layout

Build started.
\end_layout

\begin_layout Plain Layout

Project "coinForth.asmproj" (default targets):
\end_layout

\begin_layout Plain Layout

Target "PreBuildEvent" skipped, due to false condition;
\end_layout

\begin_layout Plain Layout

('$(PreBuildEvent)'!='') was evaluated as (''!='').
\end_layout

\begin_layout Plain Layout

Target "CoreBuild" in file "C:
\backslash
Program Files (x86)
\backslash
Atmel
\backslash
Atmel Studio 6.2
\backslash
Vs
\backslash
Assembler.targets"
\end_layout

\begin_layout Plain Layout

from project "C:
\backslash
Users
\backslash
Dennis
\backslash
Documents
\backslash
Atmel Studio
\backslash
6.2
\backslash
coinForth
\backslash
coinForth
\backslash
coinForth.asmproj"
\end_layout

\begin_layout Plain Layout

(target "Build" depends on it):
\end_layout

\begin_layout Plain Layout

	Task "RunAssemblerTask"
\end_layout

\begin_layout Plain Layout

C:
\backslash
Program Files (x86)
\backslash
Atmel
\backslash
Atmel Toolchain
\backslash
AVR Assembler
\backslash
Native
\backslash
2.1.1175
\backslash
avrassembler
\backslash
avrasm2.exe
\end_layout

\begin_layout Plain Layout

 -fI -o "coinForth.hex"  -m "coinForth.map"  -l "coinForth.lss"  -S "coinForth.tmp"
\end_layout

\begin_layout Plain Layout

 -W+ie -I"../../amforth-5.8/common" -I"../../amforth-5.8/avr8"  -e uno.eep -v0 -im328Pdef.in
c
\end_layout

\begin_layout Plain Layout

 -d "C:
\backslash
Users
\backslash
Dennis
\backslash
Documents
\backslash
Atmel Studio
\backslash
6.2
\backslash
coinForth
\backslash
coinForth
\backslash
Debug/coinForth.obj"
\end_layout

\begin_layout Plain Layout

 "C:
\backslash
Users
\backslash
Dennis
\backslash
Documents
\backslash
Atmel Studio
\backslash
6.2
\backslash
coinForth
\backslash
coinForth
\backslash
coinForth.asm"
\end_layout

\begin_layout Plain Layout

 -I "C:
\backslash
Program Files (x86)
\backslash
Atmel
\backslash
Atmel Toolchain
\backslash
AVR Assembler
\backslash
Native
\backslash
2.1.1175
\backslash
avrassembler
\backslash
Include"
\end_layout

\begin_layout Plain Layout

 	Done executing task "RunAssemblerTask".
\end_layout

\begin_layout Plain Layout

Done building target "CoreBuild" in project "coinForth.asmproj".
\end_layout

\begin_layout Plain Layout

Target "PostBuildEvent" skipped, due to false condition;
\end_layout

\begin_layout Plain Layout

('$(PostBuildEvent)' != '') was evaluated as ('' != '').
\end_layout

\begin_layout Plain Layout

Target "Build" in file "C:
\backslash
Program Files (x86)
\backslash
Atmel
\backslash
Atmel Studio 6.2
\backslash
Vs
\backslash
Avr.common.targets"
\end_layout

\begin_layout Plain Layout

from project "C:
\backslash
Users
\backslash
Dennis
\backslash
Documents
\backslash
Atmel Studio
\backslash
6.2
\backslash
coinForth
\backslash
coinForth
\backslash
coinForth.asmproj"
\end_layout

\begin_layout Plain Layout

(entry point):
\end_layout

\begin_layout Plain Layout

Done building target "Build" in project "coinForth.asmproj".
\end_layout

\begin_layout Plain Layout

Done building project "coinForth.asmproj".
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Build succeeded.
\end_layout

\begin_layout Plain Layout

========== Build: 1 succeeded or up-to-date, 0 failed, 0 skipped ==========
 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
I had to change the project name from my_amforth to coinForth because amforth.asm
 opened my_amforth.asm, which makes the build fail.
\end_layout

\begin_layout Standard
I also had to turn off the 
\family typewriter
\series bold
EESAVE
\family default
\series default
 and 
\family typewriter
\series bold
BOOTRST
\family default
\series default
 fuses and change the 
\family typewriter
\series bold
BOOSTSZ
\family default
\series default
 fuse from 
\family typewriter
\series bold
1024W_3C00
\family default
\series default
 to 
\family typewriter
\series bold
2048W_3800
\family default
\series default
.
 (E.g.
 HIGH = 0xD9).
\end_layout

\begin_layout Standard
I found that amForth can not handle direct file input, but the 
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

C:
\backslash
Users
\backslash
Dennis
\backslash
Documents
\backslash
Atmel Studio
\backslash
6.2
\backslash
coinForth
\backslash
amforth-5.8
\backslash
tools>python amforth-shell.py
\end_layout

\begin_layout Plain Layout

|I=appl_defs: 0 loaded 
\end_layout

\begin_layout Plain Layout

|I=Entering amforth interactive interpreter 
\end_layout

\begin_layout Plain Layout

|I=getting MCU name..
 
\end_layout

\begin_layout Plain Layout

|I=successfully loaded register definitions for atmega328p 
\end_layout

\begin_layout Plain Layout

|I=getting filenames on the host 
\end_layout

\begin_layout Plain Layout

|I=  Reading C:
\backslash
Users
\backslash
Dennis
\backslash
Documents
\backslash
Atmel Studio
\backslash
6.2
\backslash
coinForth
\backslash
amforth-5.8
\backslash
avr8
\backslash
devices
\backslash
atmega328p
\end_layout

\begin_layout Plain Layout

|I=  Reading C:
\backslash
Users
\backslash
Dennis
\backslash
Documents
\backslash
Atmel Studio
\backslash
6.2
\backslash
coinForth
\backslash
amforth-5.8
\backslash
avr8
\backslash
lib 
\end_layout

\begin_layout Plain Layout

|I=  Reading .
 
\end_layout

\begin_layout Plain Layout

|I=getting filenames from the controller 
\end_layout

\begin_layout Plain Layout

(ATmega328P)> 5 .
\end_layout

\begin_layout Plain Layout

5  ok 
\end_layout

\begin_layout Plain Layout

(ATmega328P)> words 
\end_layout

\begin_layout Plain Layout

-1 2 1 = 2literal s>d spaces space cr bounds ?stack tolower toupper turnkey
 bl hex decimal bin allot here ehere dp key? key emit? emit pad #tib >in
 tuck 2drop 2 dup cells base state f_cpu fill s" ." words show-wordlist within
 max min mod / negate u/mod u.r u.
 d= (defer) defer@ defer! Udefer! Udefer@ Rdefer! Rdefer@ Edefer! Edefer@
 throw catch handler warm cold pause quit int-trap int@ int! -int +in t
 cell+ pick abs /mod dinvert d- d+ d2/ d2* nr> n>r @i (!i-nrww) !i @e !e
 2r> 2> r 1ms up! up@ >< cmove> unloop i sp! sp@ rp! rp@ +! rshift lshift
 1- 1+ xor or and 2* 2/ invert um* um/mod m* + - log2 > < u> u< 0 true d0<
 d0> 0> 0< 0= <> r@ >r r> nip rot drop over swap ?dup dup !u @u c@ c! !
 @ (value) execute exit applturnkey i-cell+ postpone (marker) end-code code
 get-recognizers set-recognizers set-order forth-wordlist only wordlist
 set-current nfa>lfa compare get-order get-current map-stack set-stack get-stack
 ?abort abort abort" [char] immediate recurse user constant variable [ ]
 ; :noname : does> latest reveal wlscope header create lp lp0 >l l> endloop
 ?do leave +loop loop do again until repeat while begin then else if ahead
 sliteral literal ['] , compile ( 
\backslash
 (create) find-name nfa>cfa name>string traverse-wordlist search-wordlist
 r:fail r:word rec:word rec:num r:dnum r:num interpret do-recognizer depth
 rp0 sp sp0 parse-name /string source parse >number number char refill accept
 cscan cskip ' type icount itype s, digit? u d/mod ud.r ud.
 .
 d.
 .r d.r sign #> #s # <# hold hld environment init-user ee>ram source-tib refill-ti
b tib 2swap cmove dnegate dabs j * icompare to unused noop ver name>flags
 umin umax ud* m+ 1w.slot 1w.reset +usart ubrr tx?-poll tx-poll rx?-isr rx-isr
  ok 
\end_layout

\begin_layout Plain Layout

(ATmega328P)>
\end_layout

\end_inset


\end_layout

\begin_layout Standard
I haven't had a reason to use PowerShell yet, but this might be the time
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset Graphics
	filename PowerShell.png
	width 70text%

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://druffer.github.io/coinForth/
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
SwiftX for AVR
\end_layout

\begin_layout Standard
\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://www.forth.com/embedded/eval-upgrade.html?MCU=AVR
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Initially, I was stuck in the SwiftX AVR Target Reference Manual, Appendix
 A.1.1 Uno Board Overview.
 I was trying to get the RELOAD! command to work, but it would not work
 with the Pololu USB AVR Programmer.
 Once I got it working as an STK500 in Atmel Studio, and read further in
 Appendix D: Atmel STK500, I saw that this is the 
\begin_inset Quotes eld
\end_inset

normal
\begin_inset Quotes erd
\end_inset

 way to use this interface.
 So, now I can start including that system in the translation too.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

SwiftX Evaluation AVR 3.7.0 01-Jan-2014
\end_layout

\begin_layout Plain Layout

INCLUDE DEBUG
\end_layout

\begin_layout Plain Layout

   Start      End      Size     Used   Unused    Type   Name
\end_layout

\begin_layout Plain Layout

    0000     7FFF     32768     7308    25460    CDATA  FLASH
\end_layout

\begin_layout Plain Layout

    0100     01FF       256       29      227    IDATA  IRAM
\end_layout

\begin_layout Plain Layout

    0200     08FF      1792      421     1371    UDATA  URAM
\end_layout

\begin_layout Plain Layout

TARGET READY
\end_layout

\begin_layout Plain Layout

SwiftX/AVR Arduino Uno SOS Demo  ok
\end_layout

\begin_layout Plain Layout

2 6 + .
 8  ok
\end_layout

\begin_layout Plain Layout

go
\end_layout

\begin_layout Plain Layout

TARGET READY  ok
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Unfortunately, my latest attempt is giving me this:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

C:
\backslash
ForthInc
\backslash
Projects
\backslash
ARD101>atprogram -t stk500 -c 11 -i ISP -d ATmega328P -v program -f target.hex
\end_layout

\begin_layout Plain Layout

[DEBUG] Starting execution of "program"
\end_layout

\begin_layout Plain Layout

[DEBUG] Starting process 'C:
\backslash
Program Files (x86)
\backslash
Atmel
\backslash
Atmel Studio 6.2
\backslash
atbackend
\backslash
atbackend.exe'
\end_layout

\begin_layout Plain Layout

[DEBUG] Connecting to TCP:127.0.0.1:53208
\end_layout

\begin_layout Plain Layout

[WARNING] Could not establish communication with the tool.
 (TCF Error code: 1)
\end_layout

\begin_layout Plain Layout

[WARNING] Could not create tool context.
 Retrying, 3 more attempts...
\end_layout

\begin_layout Plain Layout

[WARNING] Failed to open 
\backslash

\backslash
.
\backslash
COM11.
 Error 0x5.
 (TCF Error code: 1)
\end_layout

\begin_layout Plain Layout

[WARNING] Could not create tool context.
 Retrying, 2 more attempts...
\end_layout

\begin_layout Plain Layout

[WARNING] Failed to open 
\backslash

\backslash
.
\backslash
COM11.
 Error 0x5.
 (TCF Error code: 1)
\end_layout

\begin_layout Plain Layout

[WARNING] Could not create tool context.
 Retrying, 1 more attempts...
\end_layout

\begin_layout Plain Layout

[ERROR] Could not establish communication with the tool.
 (TCF Error code: 1) 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Still trying to figure that issue out.
\end_layout

\begin_layout Section
Tutorials
\end_layout

\begin_layout Standard
Starting from OSEPP's learning center, I have shortened the URL for each
 of the subsections below to fit on a printed page.
\end_layout

\begin_layout Standard
\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://osepp.com/learning-centre/start-here/101-basic-starter-kit/
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://tinyurl.com/megobz3
\end_layout

\end_inset


\end_layout

\begin_layout Standard
I have also setup the hardware interfaces so that all 7 of the tutorials
 are connected at the same time.
 The only overlap that this creates is with the 7 segment LED.
 This just means that the speaker clicks during the LED tutorial, but otherwise,
 all of the I/O used in the tutorials functions properly
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset Graphics
	filename ARD101.jpg
	lyxscale 30
	width 70text%

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Tutorial 1: Loading the First Sketch
\end_layout

\begin_layout Standard
\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://tinyurl.com/megobz3/tutorial-1-loading-the-first-sketch/
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This tutorial looks to be well represented in the 
\family typewriter
\series bold
flasher.txt
\family default
\series default
 sample that is included with eForth.
 However, 1st you need to have a terminal emulator that can send text files
 with a 900 ms delay in between lines.
 900 ms is probably way too slow, but the system can not handle no delay
 between lines.
 200 ms seems about right.
 Unfortunately, PuTTY can not do this.
 Realterm is a reasonable substitute, but scrollback is an issue.
\end_layout

\begin_layout Standard
\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://realterm.sourceforge.net/
\end_layout

\end_inset


\end_layout

\begin_layout Standard
I've always preferred the capabilities of HyperACCESS, which is the parent
 of Windows old HyperTerminal.
 It's expensive, but I've seen issues with just about any other terminal
 program and I don't recall ever finding an issue with HyerACCESS.
 They also still sell the original HyperTerminal Private Edition if you
 want something less expensive.
\end_layout

\begin_layout Standard
\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://www.hilgraeve.com/hyperaccess-trial/
\end_layout

\end_inset


\end_layout

\begin_layout Standard
With decent scroll back capabilities, I was able to see that 
\family typewriter
\series bold
flasher.txt
\family default
\series default
 required 
\family typewriter
\series bold
io-core.txt
\family default
\series default
 which was not loading properly.
 Eventually, I figured out that I needed to load 
\family typewriter
\series bold
marker.txt
\family default
\series default
 1st.
 Even Dr.
 Ting's documentation has a mistake there in that 
\family typewriter
\series bold
hello-world.txt
\family default
\series default
 also requires 
\family typewriter
\series bold
marker.txt
\family default
\series default
, but in the end, the system can finally be considered to be functional.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

1000 3 manyok
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Note that the 
\begin_inset Quotes eld
\end_inset

ok
\begin_inset Quotes erd
\end_inset

 doesn't output a space first, so the acknowledgment can be a little confusing.
\end_layout

\begin_layout Subsubsection
Tutorial1
\end_layout

\begin_layout Standard
\begin_inset Flex Chunk
status open

\begin_layout Plain Layout

\begin_inset Argument 1
status open

\begin_layout Plain Layout
Tutorial1.ino
\end_layout

\end_inset

/* Tutorial 1
\end_layout

\begin_layout Plain Layout

Blink
\end_layout

\begin_layout Plain Layout

Turns on an LED on for one second, then off for one second, repeatedly.
\end_layout

\begin_layout Plain Layout

This example code is in the public domain.
\end_layout

\begin_layout Plain Layout

*/
\end_layout

\begin_layout Plain Layout

// Pin 13 has an LED connected on most Arduino boards.
\end_layout

\begin_layout Plain Layout

// give it a name:
\end_layout

\begin_layout Plain Layout

int led = 13;
\end_layout

\begin_layout Plain Layout

// the setup routine runs once when you press reset:
\end_layout

\begin_layout Plain Layout

void setup() {              
\end_layout

\begin_layout Plain Layout

// initialize the digital pin as an output.
\end_layout

\begin_layout Plain Layout

pinMode(led, OUTPUT);    
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

// the loop routine runs over and over again forever:
\end_layout

\begin_layout Plain Layout

void loop() {
\end_layout

\begin_layout Plain Layout

digitalWrite(led, HIGH);   // turn the LED on (HIGH is the voltage level)
\end_layout

\begin_layout Plain Layout

delay(1000);               // wait for a second
\end_layout

\begin_layout Plain Layout

digitalWrite(led, LOW);    // turn the LED off by making the voltage LOW
\end_layout

\begin_layout Plain Layout

delay(1000);               // wait for a second
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
flasher.txt
\end_layout

\begin_layout Standard
William F.
 Ragsdale had written these demo applications for Arduino with AmForth.
 Dr.
 Ting modified them so that they work properly under 328eForth.
\begin_inset Index idx
status open

\begin_layout Plain Layout
flasher.txt
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex Chunk
status open

\begin_layout Plain Layout

\begin_inset Argument 1
status open

\begin_layout Plain Layout
flasher.txt
\end_layout

\end_inset


\backslash
 FLASHER.txt to Demo LED control              WFR 2011-01-27 
\end_layout

\begin_layout Plain Layout

( must have io-core.txt installed )
\end_layout

\begin_layout Plain Layout

chop-flasher
\end_layout

\begin_layout Plain Layout

marker chop-flasher  ( a forget point)
\end_layout

\begin_layout Plain Layout

$23 value PortB  $26 value PortC  $29 value PortD
\end_layout

\begin_layout Plain Layout

  5 value LED
\end_layout

\begin_layout Plain Layout

: 1-cycle  ( ms_delay ---   flash LED on then off )
\end_layout

\begin_layout Plain Layout

    PortB LED PoBiHi   dup ms   PortB LED PoBiLo   ms ;
\end_layout

\begin_layout Plain Layout

: many  ( on_time flashes ---   produce controlled LED flashes)
\end_layout

\begin_layout Plain Layout

    PortB LED PoBiOut ( set LED pin as output)
\end_layout

\begin_layout Plain Layout

    for aft  dup 1-cycle then next drop ;
\end_layout

\begin_layout Plain Layout

( use 'many' leading with on-time and # of flashes )
\end_layout

\begin_layout Plain Layout

( end of flasher.txt )
\end_layout

\begin_layout Plain Layout

flush
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Note that in both C and Forth, there are many support routines that are
 not always listed.
 Knowing the environment is always key to your productivity and you can
 usually learn a lot by examining the sample source listings.
 You should also notice that the 
\family typewriter
\series bold
setup
\family default
\series default
 and 
\family typewriter
\series bold
loop
\family default
\series default
 functions need to be done explicitly in Forth.
 You can always assume that you need to do those steps, but how often and
 in what order is typically, an application specific requirement.
 Thus the use of parameters is more typical in Forth than infinite loops.
\end_layout

\begin_layout Standard
You should also notice that while the C routines deal with sequential pins
 which span multiple ports, the Forth routines deal with the port bits directly.
 The onboard LED is on pin 13, but it can also be referenced as bit 5 on
 Port B.
 The lower 8 pins are on Port D.
\end_layout

\begin_layout Subsubsection
flasher.frt
\end_layout

\begin_layout Standard
In amforth-5.8, the original flasher that was mentioned above is no longer
 found, so I need to create it.
\end_layout

\begin_layout Standard
\begin_inset Flex Chunk
status open

\begin_layout Plain Layout

\begin_inset Argument 1
status open

\begin_layout Plain Layout
flasher.frt
\end_layout

\end_inset


\backslash
 flasher.frt to Demo LED control
\end_layout

\begin_layout Plain Layout

0 constant false  #include io-core.f
\end_layout

\begin_layout Plain Layout


\backslash
 requires: in application master file
\end_layout

\begin_layout Plain Layout

   .set WANT_PORTB = 1
\end_layout

\begin_layout Plain Layout

   .set WANT_PORTC = 1
\end_layout

\begin_layout Plain Layout

   .set WANT_PORTD = 1
\end_layout

\begin_layout Plain Layout

   .set WANT_TIMER_COUNTER_0 = 1
\end_layout

\begin_layout Plain Layout

   .set WANT_SPI = 1
\end_layout

\begin_layout Plain Layout

#include timer0.frt  #include timer.frt
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

$23 value PortB  $26 value PortC  $29 value PortD
\end_layout

\begin_layout Plain Layout

  5 value LED
\end_layout

\begin_layout Plain Layout

: 1-cycle  ( ms_delay ---   flash LED on then off )
\end_layout

\begin_layout Plain Layout

    PortB LED PoBiHi   dup ms   PortB LED PoBiLo   ms ;
\end_layout

\begin_layout Plain Layout

: many  ( on_time flashes ---   produce controlled LED flashes)
\end_layout

\begin_layout Plain Layout

    PortB LED PoBiOut ( set LED pin as output)
\end_layout

\begin_layout Plain Layout

    for aft  dup 1-cycle then next drop ;
\end_layout

\begin_layout Plain Layout

( use 'many' leading with on-time and # of flashes )
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
distress.f
\end_layout

\begin_layout Standard
An onboard LED example is also included in SwiftX AVR, but it is listed
 as Copyright 2001-2007 FORTH, Inc.
 You should look at it and execute it to make sure everything is working
 properly.
 However, I will not list it here to avoid any copyright infringement.
 It is interesting to note that this example puts the 
\family typewriter
\series bold
SOS
\family default
\series default
 distress code into a background 
\family typewriter
\series bold
BEACON
\family default
\series default
 task, which allows it to continue running while you continue to exercise
 the tether interface.
 This is extremely useful, but for compatibility, I will not use it for
 the rest of these tutorials.
 Instead, I will attempt to use the same code on all of the Forth systems.
\end_layout

\begin_layout Standard
However, there will be some differences, and I will need a modified version
 of the io-core.f support from eForth:
\begin_inset Index idx
status open

\begin_layout Plain Layout
io-core.f
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex Chunk
status open

\begin_layout Plain Layout

\begin_inset Argument 1
status open

\begin_layout Plain Layout
io-core.f
\end_layout

\end_inset


\backslash
 Port Input Output for AmForth                  DaR 28Mar14
\end_layout

\begin_layout Plain Layout


\backslash
 loaded as  io-core.f
\end_layout

\begin_layout Plain Layout


\backslash
 Modified for 328eForth, 23mar11cht
\end_layout

\begin_layout Plain Layout


\backslash
 Modified for SwiftX, daruffer@gmail.com
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
 manually begin with chop-io entered
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

: mask ( bit# --- port_mask  convert bit to 8 bit mask)
\end_layout

\begin_layout Plain Layout

     1 swap lshift  ;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

: DDR  
\backslash
 port --- port' adjust input port# to DDR
\end_layout

\begin_layout Plain Layout

    1- ;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

: Input 
\backslash
 port --- port adjust input port# to output
\end_layout

\begin_layout Plain Layout

    2 - ;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

: RegFrom 
\backslash
 Reg mask --- value  read masked bits from register
\end_layout

\begin_layout Plain Layout

        
\backslash
 To read all bits:  PortB true RegFrom -> value
\end_layout

\begin_layout Plain Layout

     swap c@  and ;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

: RegTo 
\backslash
 Reg mask new ---  write masked new into register
\end_layout

\begin_layout Plain Layout

     over and >r   invert over c@ and   r> or  swap c! ;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

: PoBiI/O  
\backslash
 port bit direction --- configure bit in/out
\end_layout

\begin_layout Plain Layout

    rot DDR   rot mask   rot RegTo 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

: PoBiOut  
\backslash
 port bit --- configure as output
\end_layout

\begin_layout Plain Layout

    true  PoBiI/O ;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

: PoBiRead  
\backslash
 port bit --- value  read bit value from port
\end_layout

\begin_layout Plain Layout

     swap Input swap mask RegFrom ;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

: PoBiHi  
\backslash
 port bit --- set port bit 0..7 high
\end_layout

\begin_layout Plain Layout

     mask true  RegTo ;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

: PoBiLo   
\backslash
 port bit --- clear port bit 0..7 low
\end_layout

\begin_layout Plain Layout

     mask false RegTo ;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

: PoBiIn   
\backslash
 port bit --- configure as input,  no pull-up
\end_layout

\begin_layout Plain Layout

    2dup false PoBiI/O   PoBiLo ( pullup inactive) ;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

: PoBiInPu 
\backslash
 port bit --- configure as input with pull-up
\end_layout

\begin_layout Plain Layout

    2dup false PoBiI/O   PoBiHi ( pullup active) ;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
 read bits from register  Reg#         select      RegFrom
\end_layout

\begin_layout Plain Layout


\backslash
 write bits to register   Reg#         select bits RegTo
\end_layout

\begin_layout Plain Layout


\backslash
 write 1-bit to register  Reg#   5 mask true       RegTo
\end_layout

\begin_layout Plain Layout


\backslash
 write 0-bit to register  Reg#   5 mask false      RegTo
\end_layout

\begin_layout Plain Layout


\backslash
 configure bits as output PortB DDR    select True RegTo
\end_layout

\begin_layout Plain Layout


\backslash
 write bits to output     PortB Output select bits RegTo
\end_layout

\begin_layout Plain Layout


\backslash
 configure bit as output  PortB     LED            PoBiOut
\end_layout

\begin_layout Plain Layout


\backslash
 bit as input with pullup PortB     Switch3        PoBiInPu
\end_layout

\begin_layout Plain Layout


\backslash
 read bit from port       PortB     Switch3        PoBiRead
\end_layout

\begin_layout Plain Layout


\backslash
 write 1-bit to port      PortB     LED            PoBiHi
\end_layout

\begin_layout Plain Layout


\backslash
 write 0-bit to port      PortB     LED            PoBiLo
\end_layout

\begin_layout Plain Layout


\backslash
 Note, when initializing a 16 bit register, TCNT1 etc.
 it
\end_layout

\begin_layout Plain Layout


\backslash
  must be written directly hi/lo not using RegTo.
\end_layout

\begin_layout Plain Layout


\backslash
  The proper form to clear is:    TCNT1hi false c!
\end_layout

\begin_layout Plain Layout


\backslash
                         then:    TCNT1lo false c!
\end_layout

\begin_layout Plain Layout


\backslash
                                  
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
 end of io-core.txt
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Note that the differences are:
\end_layout

\begin_layout Enumerate
The 
\family typewriter
\series bold
marker
\family default
\series default
 concepts don't really apply here.
\end_layout

\begin_layout Enumerate
The port names refer to the output port, rather than the input port.
 Thus, the adjustments are reversed.
\end_layout

\begin_layout Enumerate
The 
\family typewriter
\series bold
flush
\family default
\series default
 concept used by eForth also doesn't apply here.
\end_layout

\begin_layout Subsection
Tutorial 2: Controlling Digital Outputs
\end_layout

\begin_layout Standard
\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://tinyurl.com/megobz3/tutorial-2-controlling-digital-outputs/
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

500 3 cyclesok
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Tutorial2
\end_layout

\begin_layout Standard
\begin_inset Flex Chunk
status open

\begin_layout Plain Layout

\begin_inset Argument 1
status open

\begin_layout Plain Layout
Tutorial2.ino
\end_layout

\end_inset

/*
\end_layout

\begin_layout Plain Layout

Tutorial 2 Digital Output
\end_layout

\begin_layout Plain Layout

*/
\end_layout

\begin_layout Plain Layout

int LED0  = 2;     // Use digital pin 2 to drive the white LED
\end_layout

\begin_layout Plain Layout

int LED1  = 3;     // Use digital pin 3 to drive the yellow LED
\end_layout

\begin_layout Plain Layout

int LED2  = 4;     // Use digital pin 4 to drive the green LED
\end_layout

\begin_layout Plain Layout

int LED3  = 5;     // Use digital pin 5 to drive the red LED
\end_layout

\begin_layout Plain Layout

void setup() {
\end_layout

\begin_layout Plain Layout

  // initialize digital pin 2 to 5 as output:
\end_layout

\begin_layout Plain Layout

  pinMode(LED0, OUTPUT);  
\end_layout

\begin_layout Plain Layout

  pinMode(LED1, OUTPUT);  
\end_layout

\begin_layout Plain Layout

  pinMode(LED2, OUTPUT);  
\end_layout

\begin_layout Plain Layout

  pinMode(LED3, OUTPUT);  
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

void loop(){
\end_layout

\begin_layout Plain Layout

  // Toggle each LED at a time with a 500ms delay
\end_layout

\begin_layout Plain Layout

  digitalWrite(LED0, HIGH);
\end_layout

\begin_layout Plain Layout

  delay(500);
\end_layout

\begin_layout Plain Layout

  digitalWrite(LED0, LOW);
\end_layout

\begin_layout Plain Layout

  delay(500);
\end_layout

\begin_layout Plain Layout

  digitalWrite(LED1, HIGH);
\end_layout

\begin_layout Plain Layout

  delay(500);
\end_layout

\begin_layout Plain Layout

  digitalWrite(LED1, LOW);
\end_layout

\begin_layout Plain Layout

  delay(500); 
\end_layout

\begin_layout Plain Layout

  digitalWrite(LED2, HIGH);
\end_layout

\begin_layout Plain Layout

  delay(500);
\end_layout

\begin_layout Plain Layout

  digitalWrite(LED2, LOW);
\end_layout

\begin_layout Plain Layout

  delay(500); 
\end_layout

\begin_layout Plain Layout

  digitalWrite(LED3, HIGH);
\end_layout

\begin_layout Plain Layout

  delay(500);
\end_layout

\begin_layout Plain Layout

  digitalWrite(LED3, LOW);
\end_layout

\begin_layout Plain Layout

  delay(500); 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
cycle.txt
\begin_inset Index idx
status open

\begin_layout Plain Layout
cycle.txt
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex Chunk
status open

\begin_layout Plain Layout

\begin_inset Argument 1
status open

\begin_layout Plain Layout
cycle.txt
\end_layout

\end_inset


\backslash
 cycle.txt to Demo multiple LED control      DaR 2014-02-16
\end_layout

\begin_layout Plain Layout

chop-cycle
\end_layout

\begin_layout Plain Layout

marker chop-cycle
\end_layout

\begin_layout Plain Layout


\backslash
 Define LED port bits and flashing order
\end_layout

\begin_layout Plain Layout

CREATE LEDS   4 2* 1 + allot 
\backslash
 Number of LEDS, then order
\end_layout

\begin_layout Plain Layout

: 
\backslash
LEDS ( --- Initialize the RAM array )   4 LEDS C!
\end_layout

\begin_layout Plain Layout

   LEDS count 2* PortD fill 
\backslash
 Overfill the Port addresses to save code
\end_layout

\begin_layout Plain Layout

   2 LEDS 1 + C!  3 LEDS 3 + C!  4 LEDS 5 + C!  5 LEDS 7 + C! ;
\end_layout

\begin_layout Plain Layout

: cycle ( time port bit --- flash LED on then off )
\end_layout

\begin_layout Plain Layout

   2dup PoBiHi  rot dup ms  rot rot PoBiLo  ms ;
\end_layout

\begin_layout Plain Layout

: cycles ( time cycles --- produce cycles of LED flashes )   
\backslash
LEDS
\end_layout

\begin_layout Plain Layout

   LEDS count for aft  count >r count r> PoBiOut  then next drop
\end_layout

\begin_layout Plain Layout

   for aft  LEDS count for aft  count >r count >r over r> r>
\end_layout

\begin_layout Plain Layout

         cycle  then next  drop  then next  drop ;
\end_layout

\begin_layout Plain Layout

flush
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Note a few principles here:
\end_layout

\begin_layout Enumerate
Look for patterns of doing things 3 or more times and factory them out.
 Each LED name was used 3 times, which leads to putting them into an array,
 which only needs to be referenced twice.
 This also allows a significant reduction in code size.
\end_layout

\begin_layout Enumerate
Be careful where things are compiled when systems have multiple address
 spaces.
 I had thought that 
\family typewriter
\series bold
,
\family default
\series default
 would work to create the table, but no, I had to resort to a much less
 elegant solution.
\end_layout

\begin_layout Enumerate
Still, the lack of elegance is at compile time and does not effect the run
 time behavior.
 That makes it much less objectionable.
\end_layout

\begin_layout Enumerate
Last minute uglyness is the requirement for a 
\family typewriter
\series bold
flush
\family default
\series default
 before 
\family typewriter
\series bold
LEDS
\family default
\series default
 can be referenced.
 Otherwise, the system would reboot while compiling this code.
 That's the risk for compile time initialization and thus, why it is now
 in a definition and called everytime 
\family typewriter
\series bold
cycles
\family default
\series default
 starts up.
 This gives it some runtime overhead, but saves compatibility issues with
 other systems.
\end_layout

\begin_layout Enumerate
Don't be afraid of passing multiple parameters.
 Up to 3 parameters are easily handled in Forth and even more can be handled
 with minimal difficulties.
 Watch for literals or fixed values that might change over time, like the
 LED parameters here in the 
\family typewriter
\series bold
cycle
\family default
\series default
 routine.
 The original 
\family typewriter
\series bold
1-cycle
\family default
\series default
 routine could have been written this way with some forethought.
\end_layout

\begin_layout Enumerate
Know when to stop factoring things out.
 I could have broken 
\family typewriter
\series bold
cycles
\family default
\series default
 down into, at least, 2 other words.
 However, again you should remember the rule of 3.
 I might use a similar pattern 1 more time in the next tutorial, but as
 with most test code, a 3rd time is unlikely.
\end_layout

\begin_layout Subsubsection
cycle.f
\begin_inset Index idx
status open

\begin_layout Plain Layout
cycle.f
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex Chunk
status open

\begin_layout Plain Layout

\begin_inset Argument 1
status open

\begin_layout Plain Layout
cycle.f
\end_layout

\end_inset


\backslash
 cycle.f to Demo multiple LED control      DaR 2014-03-29
\end_layout

\begin_layout Plain Layout


\backslash
 Define LED port bits and flashing order
\end_layout

\begin_layout Plain Layout

CREATE LEDS   4 2* 1 + allot 
\backslash
 Number of LEDS, then order
\end_layout

\begin_layout Plain Layout

: 
\backslash
LEDS ( --- Initialize the RAM array )   4 LEDS C!
\end_layout

\begin_layout Plain Layout

   LEDS count 2* PortD fill 
\backslash
 Overfill the Port addresses to save code
\end_layout

\begin_layout Plain Layout

   2 LEDS 1 + C!  3 LEDS 3 + C!  4 LEDS 5 + C!  5 LEDS 7 + C! ;
\end_layout

\begin_layout Plain Layout

: cycle ( time port bit --- flash LED on then off )
\end_layout

\begin_layout Plain Layout

   2dup PoBiHi  rot dup ms  rot rot PoBiLo  ms ;
\end_layout

\begin_layout Plain Layout

: cycles ( time cycles --- produce cycles of LED flashes )   
\backslash
LEDS
\end_layout

\begin_layout Plain Layout

   LEDS count 0 do  count >r count r> PoBiOut  loop  drop
\end_layout

\begin_layout Plain Layout

   0 do  LEDS count 0 do  count >r count >r over r> r>
\end_layout

\begin_layout Plain Layout

         cycle  loop  drop  loop  drop ;
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Note that the differences are:
\end_layout

\begin_layout Enumerate
The 
\family typewriter
\series bold
marker
\family default
\series default
 and 
\family typewriter
\series bold
flush
\family default
\series default
 concepts don't really apply here.
\end_layout

\begin_layout Enumerate
The 
\family typewriter
\series bold
for aft ...
 then next
\family default
\series default
 structure is directly replaced with the more standard 
\family typewriter
\series bold
0 do ...
 loop
\family default
\series default
 structure.
\end_layout

\begin_layout Subsection
Tutorial 3: Using Digital Input
\end_layout

\begin_layout Standard
\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://tinyurl.com/megobz3/tutorial-3-using-digital-input/
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Tutorial3
\end_layout

\begin_layout Standard
\begin_inset Flex Chunk
status open

\begin_layout Plain Layout

\begin_inset Argument 1
status open

\begin_layout Plain Layout
Tutorial3.ino
\end_layout

\end_inset

/*
\end_layout

\begin_layout Plain Layout

Tutorial 3 Digital Input
\end_layout

\begin_layout Plain Layout

*/
\end_layout

\begin_layout Plain Layout

const int buttonPin = 12;     // Use digital pin 12 for the button pin
\end_layout

\begin_layout Plain Layout

int buttonState = 0;          // variable for storing the button status
\end_layout

\begin_layout Plain Layout

void setup() {
\end_layout

\begin_layout Plain Layout

  // initialize the pushbutton pin as an input:
\end_layout

\begin_layout Plain Layout

  pinMode(buttonPin, INPUT);
\end_layout

\begin_layout Plain Layout

  // initialize the serial port;
\end_layout

\begin_layout Plain Layout

  Serial.begin(9600);  // start serial for output 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

void loop(){
\end_layout

\begin_layout Plain Layout

  // read the state of the pushbutton value:
\end_layout

\begin_layout Plain Layout

  buttonState = digitalRead(buttonPin);
\end_layout

\begin_layout Plain Layout

  // Output button state
\end_layout

\begin_layout Plain Layout

  Serial.print("The button state is ");
\end_layout

\begin_layout Plain Layout

  Serial.println(buttonState);
\end_layout

\begin_layout Plain Layout

  // Delay 1000ms
\end_layout

\begin_layout Plain Layout

  delay(1000);
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
button.txt
\begin_inset Index idx
status open

\begin_layout Plain Layout
button.txt
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex Chunk
status open

\begin_layout Plain Layout

\begin_inset Argument 1
status open

\begin_layout Plain Layout
button.txt
\end_layout

\end_inset


\backslash
 button.txt to Demo Digital input      DaR 2014-02-17
\end_layout

\begin_layout Plain Layout

chop-button
\end_layout

\begin_layout Plain Layout

marker chop-button
\end_layout

\begin_layout Plain Layout

4 value buttonPin 
\backslash
 Use digital pin 12 for the button pin
\end_layout

\begin_layout Plain Layout

: states ( --- read state of button )
\end_layout

\begin_layout Plain Layout

   PortB buttonPin 2dup PoBiIn  PoBiRead
\end_layout

\begin_layout Plain Layout

   begin  PortB buttonPin PoBiRead  2dup - if
\end_layout

\begin_layout Plain Layout

         cr ." The button state is "  dup .
 swap
\end_layout

\begin_layout Plain Layout

   then  drop  ?key until  drop ;
\end_layout

\begin_layout Plain Layout

flush
\end_layout

\end_inset


\end_layout

\begin_layout Standard
A few more principles:
\end_layout

\begin_layout Enumerate
For testing words, like these, it is often convenient to just wait for a
 key press to terminate the loop.
 You have an interactive terminal loop running anyway.
 You might just as well use it.
 However, be warned that eForth appears to have a bug with 
\family typewriter
\series bold
until
\family default
\series default
.
 The 
\family typewriter
\series bold
drop
\family default
\series default
, or anything else after 
\family typewriter
\series bold
until
\family default
\series default
, never executes.
 Not a big problem here, and I have reported it.
\end_layout

\begin_layout Enumerate
We also don't need to initialize the serial port because it is the terminal
 loop.
 I suspect that this may not always be the case.
\end_layout

\begin_layout Enumerate
Don't add things that you don't use.
 Note that 
\family typewriter
\series bold
buttonState
\family default
\series default
 is not needed in Forth, when the stack can hold the state.
\end_layout

\begin_layout Enumerate
Don't time a polled event if you don't need to.
 There's no need to report the state unless it changes.
\end_layout

\begin_layout Subsubsection
button.f
\begin_inset Index idx
status open

\begin_layout Plain Layout
button.f
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex Chunk
status open

\begin_layout Plain Layout

\begin_inset Argument 1
status open

\begin_layout Plain Layout
button.f
\end_layout

\end_inset


\backslash
 button.f to Demo Digital input      DaR 2014-03-29
\end_layout

\begin_layout Plain Layout

4 value buttonPin 
\backslash
 Use digital pin 12 for the button pin
\end_layout

\begin_layout Plain Layout

: states ( --- read state of button )
\end_layout

\begin_layout Plain Layout

   PortB buttonPin 2dup PoBiIn  PoBiRead
\end_layout

\begin_layout Plain Layout

   begin  PortB buttonPin PoBiRead
\end_layout

\begin_layout Plain Layout

      2dup = while  nip  repeat
\end_layout

\begin_layout Plain Layout

   cr ." The button state is " .
 drop ;
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Note that the differences are:
\end_layout

\begin_layout Enumerate
The 
\family typewriter
\series bold
marker
\family default
\series default
 and 
\family typewriter
\series bold
flush
\family default
\series default
 concepts don't really apply here.
\end_layout

\begin_layout Enumerate
Since I don't have serial port support in SwiftX, I only loop until the
 button state changes.
\end_layout

\begin_layout Subsection
Tutorial 4: An LED Game
\end_layout

\begin_layout Standard
\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://tinyurl.com/megobz3/tutorial-4-an-led-game/
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Tutorial4
\end_layout

\begin_layout Standard
\begin_inset Flex Chunk
status open

\begin_layout Plain Layout

\begin_inset Argument 1
status open

\begin_layout Plain Layout
Tutorial4.ino
\end_layout

\end_inset

/*
\end_layout

\begin_layout Plain Layout

  Tutorial 4 Digital Input and Output Game
\end_layout

\begin_layout Plain Layout

  In this game, the LED will loop from white, yellow, green, red
\end_layout

\begin_layout Plain Layout

  then back to white.
  The goal is to press the push button at the exact
\end_layout

\begin_layout Plain Layout

  moment when the green LED is ON.
 Each time you got it right, the LED
\end_layout

\begin_layout Plain Layout

  will speed up and the difficulty will increase.
\end_layout

\begin_layout Plain Layout

*/
\end_layout

\begin_layout Plain Layout

int currentLED = 2;
\end_layout

\begin_layout Plain Layout

int delayValue = 200;
\end_layout

\begin_layout Plain Layout

void setup() {
\end_layout

\begin_layout Plain Layout

  // initialize digital pin 12 as input;
\end_layout

\begin_layout Plain Layout

  pinMode(12, INPUT);   // button input
\end_layout

\begin_layout Plain Layout

  // initialize digital pin 2 to 5 as output:
\end_layout

\begin_layout Plain Layout

  pinMode(2, OUTPUT);   // white LED
\end_layout

\begin_layout Plain Layout

  pinMode(3, OUTPUT);   // yellow LED
\end_layout

\begin_layout Plain Layout

  pinMode(4, OUTPUT);   // green LED
\end_layout

\begin_layout Plain Layout

  pinMode(5, OUTPUT);   // red LED
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

int checkInput() { 
\end_layout

\begin_layout Plain Layout

  if (digitalRead(12) == 0) {
\end_layout

\begin_layout Plain Layout

    return 1;
\end_layout

\begin_layout Plain Layout

  } else {
\end_layout

\begin_layout Plain Layout

    return 0;
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

void loop(){
\end_layout

\begin_layout Plain Layout

  // Check if the button is press at the right moment
\end_layout

\begin_layout Plain Layout

  if (digitalRead(12) == 0) {
\end_layout

\begin_layout Plain Layout

    if (currentLED == 4) {
\end_layout

\begin_layout Plain Layout

       // Blink the correct (green) LED
\end_layout

\begin_layout Plain Layout

       digitalWrite(4, HIGH);
\end_layout

\begin_layout Plain Layout

       delay(200);
\end_layout

\begin_layout Plain Layout

       digitalWrite(4, LOW);
\end_layout

\begin_layout Plain Layout

       delay(200);
\end_layout

\begin_layout Plain Layout

       digitalWrite(4, HIGH);
\end_layout

\begin_layout Plain Layout

       delay(200);
\end_layout

\begin_layout Plain Layout

       digitalWrite(4, LOW);
\end_layout

\begin_layout Plain Layout

       delay(200);
\end_layout

\begin_layout Plain Layout

       // Speed up the LEDs
\end_layout

\begin_layout Plain Layout

       delayValue = delayValue - 20; 
\end_layout

\begin_layout Plain Layout

    } else {
\end_layout

\begin_layout Plain Layout

       // Blink the wrong LED
\end_layout

\begin_layout Plain Layout

       digitalWrite(currentLED, HIGH);
\end_layout

\begin_layout Plain Layout

       delay(200);
\end_layout

\begin_layout Plain Layout

       digitalWrite(currentLED, LOW);
\end_layout

\begin_layout Plain Layout

       delay(200);
\end_layout

\begin_layout Plain Layout

       digitalWrite(currentLED, HIGH);
\end_layout

\begin_layout Plain Layout

       delay(200);
\end_layout

\begin_layout Plain Layout

       digitalWrite(currentLED, LOW);
\end_layout

\begin_layout Plain Layout

       delay(200);
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  // Loop LED from white > yellow > green > red
\end_layout

\begin_layout Plain Layout

  digitalWrite(currentLED, HIGH);
\end_layout

\begin_layout Plain Layout

  delay(delayValue);
\end_layout

\begin_layout Plain Layout

  digitalWrite(currentLED, LOW);
\end_layout

\begin_layout Plain Layout

  delay(delayValue);
\end_layout

\begin_layout Plain Layout

  currentLED = currentLED + 1;
\end_layout

\begin_layout Plain Layout

  if (currentLED > 5) {
\end_layout

\begin_layout Plain Layout

     currentLED = 2;
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
game.txt
\begin_inset Index idx
status open

\begin_layout Plain Layout
game.txt
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex Chunk
status open

\begin_layout Plain Layout

\begin_inset Argument 1
status open

\begin_layout Plain Layout
game.txt
\end_layout

\end_inset


\backslash
 game.txt Digital Input and Output Game      DaR 2014-02-20
\end_layout

\begin_layout Plain Layout

chop-game
\end_layout

\begin_layout Plain Layout

marker chop-game
\end_layout

\begin_layout Plain Layout

variable delayValue
\end_layout

\begin_layout Plain Layout

: game ( --- cycles LEDs and check button presses )   
\backslash
LEDS
\end_layout

\begin_layout Plain Layout

   LEDS count for aft  count >r count r> PoBiOut  then next drop
\end_layout

\begin_layout Plain Layout

   PortB buttonPin PoBiIn  200 delayValue !
\end_layout

\begin_layout Plain Layout

   begin  LEDS count for aft  count >r count r>
\end_layout

\begin_layout Plain Layout

         2dup delayValue @ rot rot cycle
\end_layout

\begin_layout Plain Layout

         PortB buttonPin PoBiRead 0 = if
\end_layout

\begin_layout Plain Layout

            rot dup LEDS count 1 - 2* + = if
\end_layout

\begin_layout Plain Layout

               delayValue @ 20 - dup 0 = if
\end_layout

\begin_layout Plain Layout

                  ." You win!" 2drop drop exit
\end_layout

\begin_layout Plain Layout

               then  delayValue !
\end_layout

\begin_layout Plain Layout

            then  rot rot
\end_layout

\begin_layout Plain Layout

            2dup 200 rot rot cycle
\end_layout

\begin_layout Plain Layout

            2dup 200 rot rot cycle
\end_layout

\begin_layout Plain Layout

         then
\end_layout

\begin_layout Plain Layout

         2drop  ?key if
\end_layout

\begin_layout Plain Layout

            drop exit
\end_layout

\begin_layout Plain Layout

         then
\end_layout

\begin_layout Plain Layout

   then next  drop  again ;
\end_layout

\begin_layout Plain Layout

flush 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Things to note here:
\end_layout

\begin_layout Enumerate
A pointer can easily serve as an index.
 You just have to use something a little less opaque than a number for compariso
n.
 Typically, that comparison value can be computed, which is certainly a
 requirement for using this technique.
\end_layout

\begin_layout Enumerate
The use of multiple 
\family typewriter
\series bold
exit
\family default
\series default
s with an endless 
\family typewriter
\series bold
again
\family default
\series default
 loop is common in Forth and not something that should be frowned upon as
 it is with other languages.
\end_layout

\begin_layout Enumerate
Unfortunately, this technique appears to also have an issue, like 
\family typewriter
\series bold
until
\family default
\series default
 does, as was discussed earlier.
 In this case, the chip reboots as soon as a key is pressed, or when you
 win.
 In the later case, the message doesn't even get a chance to finish.
\end_layout

\begin_layout Subsubsection
game.f
\begin_inset Index idx
status open

\begin_layout Plain Layout
game.f
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex Chunk
status open

\begin_layout Plain Layout

\begin_inset Argument 1
status open

\begin_layout Plain Layout
game.f
\end_layout

\end_inset


\backslash
 game.f Digital Input and Output Game      DaR 2014-03-29
\end_layout

\begin_layout Plain Layout

variable delayValue
\end_layout

\begin_layout Plain Layout

: game ( --- cycles LEDs and check button presses )   
\backslash
LEDS
\end_layout

\begin_layout Plain Layout

   LEDS count 0 do  count >r count r> PoBiOut  loop  drop
\end_layout

\begin_layout Plain Layout

   PortB buttonPin PoBiIn  200 delayValue !
\end_layout

\begin_layout Plain Layout

   begin  LEDS count 0 do  count >r count r>
\end_layout

\begin_layout Plain Layout

         2dup delayValue @ rot rot cycle
\end_layout

\begin_layout Plain Layout

         PortB buttonPin PoBiRead 0 = if
\end_layout

\begin_layout Plain Layout

            rot dup LEDS count 1 - 2* + = if
\end_layout

\begin_layout Plain Layout

               delayValue @ 20 - dup 0 = if
\end_layout

\begin_layout Plain Layout

                  ." You win!" 2drop drop exit
\end_layout

\begin_layout Plain Layout

               then  delayValue !
\end_layout

\begin_layout Plain Layout

            then  rot rot
\end_layout

\begin_layout Plain Layout

            2dup 200 rot rot cycle
\end_layout

\begin_layout Plain Layout

            2dup 200 rot rot cycle
\end_layout

\begin_layout Plain Layout

         then  2drop
\end_layout

\begin_layout Plain Layout

      loop  drop
\end_layout

\begin_layout Plain Layout

   again ;
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Note that the differences are:
\end_layout

\begin_layout Enumerate
The 
\family typewriter
\series bold
marker
\family default
\series default
 and 
\family typewriter
\series bold
flush
\family default
\series default
 concepts don't really apply here.
\end_layout

\begin_layout Enumerate
The 
\family typewriter
\series bold
for aft ...
 then next
\family default
\series default
 structure is directly replaced with the more standard 
\family typewriter
\series bold
0 do ...
 loop
\family default
\series default
 structure.
\end_layout

\begin_layout Enumerate
Since I don't have serial port support in SwiftX, I loop until the CPU is
 reset.
\end_layout

\begin_layout Enumerate
It appears that the eForth reboot also effects this system, but I'm not
 sure how pervasive it is yet.
\end_layout

\begin_layout Subsection
Tutorial 5: Building Voltage Meter
\end_layout

\begin_layout Standard
\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://tinyurl.com/megobz3/tutorial-5-building-voltage-meter/
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Tutorial5
\end_layout

\begin_layout Standard
\begin_inset Flex Chunk
status open

\begin_layout Plain Layout

\begin_inset Argument 1
status open

\begin_layout Plain Layout
Tutorial5.ino
\end_layout

\end_inset

/*
\end_layout

\begin_layout Plain Layout

  Tutorial 5: Volt Meter
\end_layout

\begin_layout Plain Layout

*/
\end_layout

\begin_layout Plain Layout

int sensorPin = A0;    // select the analog input pin
\end_layout

\begin_layout Plain Layout

int sensorValue = 0;   // variable to store the value coming from the sensor
\end_layout

\begin_layout Plain Layout

float sensorVoltage = 0; // variable to store the voltage coming from the
 sensor
\end_layout

\begin_layout Plain Layout

void setup() {
\end_layout

\begin_layout Plain Layout

  Serial.begin(9600);  // start serial for output
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

void loop() {
\end_layout

\begin_layout Plain Layout

  // Read the value from the analog input pin
\end_layout

\begin_layout Plain Layout

  // A value of 1023 = 5V, a value of 0 = 0V
\end_layout

\begin_layout Plain Layout

  int sensorValue = analogRead(sensorPin);
\end_layout

\begin_layout Plain Layout

  // Convert sensor value to voltage
\end_layout

\begin_layout Plain Layout

  float sensorVoltage= sensorValue*(5.0/1023.0);
\end_layout

\begin_layout Plain Layout

  // print sensor value
\end_layout

\begin_layout Plain Layout

  Serial.print("The voltage is ");
\end_layout

\begin_layout Plain Layout

  Serial.println(sensorVoltage);
\end_layout

\begin_layout Plain Layout

  // delay by 1000 milliseconds:
\end_layout

\begin_layout Plain Layout

  delay(1000);                 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
volts.f
\begin_inset Index idx
status open

\begin_layout Plain Layout
volts.f
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex Chunk
status open

\begin_layout Plain Layout

\begin_inset Argument 1
status open

\begin_layout Plain Layout
volts.f
\end_layout

\end_inset


\backslash
 volts.f to Demo Analog input      DaR 2014-03-29
\end_layout

\begin_layout Plain Layout

0 value analogPin 
\backslash
 Use analog pin 0 for the voltage pin
\end_layout

\begin_layout Plain Layout

: volts ( --- read state of pot )
\end_layout

\begin_layout Plain Layout

   PortC analogPin PoBiInPu
\end_layout

\begin_layout Plain Layout

   $40 ADMux c!  $C3 ADCSra c!  ADCL @
\end_layout

\begin_layout Plain Layout

   cr ." The voltage is "  500 1023 */
\end_layout

\begin_layout Plain Layout

   0 <# # # $2E hold # #> type space ;
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Notes for the SwiftX version only:
\end_layout

\begin_layout Enumerate
Although the eForth manual does have a section regarding analog inputs,
 I chose to use the SwiftX model after losing my work in a computer rebuild.
\end_layout

\begin_layout Enumerate
While the C version used floating point operators, this is often overkill
 for embedded systems.
 Fixed point math allows you to use the faster integer math operators and
 you simply need to keep track of where the decimal point is.
 Typically, the only place where this information is needed is when the
 value is displayed (see the 
\family typewriter
\series bold
$2E hold
\family default
\series default
 above).
 You do need to be concerned with the range of the value, which is why the
 */ operator uses a double-cell intermediate result.
\end_layout

\begin_layout Enumerate
Typically, you also would want to separate the voltage conversion from the
 display output, but for simplicity, I did not do that here.
\end_layout

\begin_layout Subsection
Tutorial 6: Using Buzzer to Play a Melody
\end_layout

\begin_layout Standard
\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://tinyurl.com/megobz3/tutorial-6-using-buzzer-to-play-a-melody/
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Tutorial6a
\end_layout

\begin_layout Standard
\begin_inset Flex Chunk
status open

\begin_layout Plain Layout

\begin_inset Argument 1
status open

\begin_layout Plain Layout
Tutorial6a.ino
\end_layout

\end_inset

/*   Tutorial 6a: Simple Scale Sweep */
\end_layout

\begin_layout Plain Layout

int buzzerPin = 8;    // Using digital pin 8
\end_layout

\begin_layout Plain Layout

#define NOTE_C6  1047
\end_layout

\begin_layout Plain Layout

#define NOTE_D6  1175
\end_layout

\begin_layout Plain Layout

#define NOTE_E6  1319
\end_layout

\begin_layout Plain Layout

#define NOTE_F6  1397
\end_layout

\begin_layout Plain Layout

#define NOTE_G6  1568
\end_layout

\begin_layout Plain Layout

#define NOTE_A6  1760
\end_layout

\begin_layout Plain Layout

#define NOTE_B6  1976
\end_layout

\begin_layout Plain Layout

#define NOTE_C7  2093
\end_layout

\begin_layout Plain Layout

void setup() {
\end_layout

\begin_layout Plain Layout

  // nothing to setup
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

void loop() {
\end_layout

\begin_layout Plain Layout

  //tone(pin, frequency, duration)
\end_layout

\begin_layout Plain Layout

  tone(buzzerPin, NOTE_C6, 500);
\end_layout

\begin_layout Plain Layout

  delay(500);
\end_layout

\begin_layout Plain Layout

  tone(buzzerPin, NOTE_D6, 500);
\end_layout

\begin_layout Plain Layout

  delay(500);
\end_layout

\begin_layout Plain Layout

  tone(buzzerPin, NOTE_E6, 500);
\end_layout

\begin_layout Plain Layout

  delay(500);
\end_layout

\begin_layout Plain Layout

  tone(buzzerPin, NOTE_F6, 500);
\end_layout

\begin_layout Plain Layout

  delay(500);
\end_layout

\begin_layout Plain Layout

  tone(buzzerPin, NOTE_G6, 500);
\end_layout

\begin_layout Plain Layout

  delay(500);
\end_layout

\begin_layout Plain Layout

  tone(buzzerPin, NOTE_A6, 500);
\end_layout

\begin_layout Plain Layout

  delay(500);
\end_layout

\begin_layout Plain Layout

  tone(buzzerPin, NOTE_B6, 500);
\end_layout

\begin_layout Plain Layout

  delay(500);
\end_layout

\begin_layout Plain Layout

  tone(buzzerPin, NOTE_C7, 500);
\end_layout

\begin_layout Plain Layout

  delay(500);
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
tone.f
\begin_inset Index idx
status open

\begin_layout Plain Layout
tone.f
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The eForth system ha this tone generation code, which uses pin 6 on PortD,
 rather than pin 0 on PortB.
 So far, I have not figured out how to generate a tone on PortB, so I have
 simply switched the buzzer over to the bit used by eForth.
 This really is so much easier than figuring out the code.
\end_layout

\begin_layout Standard
\begin_inset Flex Chunk
status open

\begin_layout Plain Layout

\begin_inset Argument 1
status open

\begin_layout Plain Layout
tone.f
\end_layout

\end_inset


\backslash
 Audio tone generator                      30Mar14
\end_layout

\begin_layout Plain Layout


\backslash
 Modified for 328eForth, 23mar11cht
\end_layout

\begin_layout Plain Layout


\backslash
 Modified for SwiftX by daruffer@gmail.com
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
 Must have io-core.f installed
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

6 value Tone-out 
\backslash
 PortD bit 6
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

binary
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

: setup-osc 
\backslash
 prescale limit  ---  limit 1..255, prescale 1..5
\end_layout

\begin_layout Plain Layout

   PortD   Tone-out                  PoBiOut 
\backslash
 setup output pin
\end_layout

\begin_layout Plain Layout

   OCR0A   true      rot ( limit   ) RegTo
\end_layout

\begin_layout Plain Layout

   TCCR0A  11000011  01000010        RegTo   
\backslash
 CTC mode
\end_layout

\begin_layout Plain Layout

           00000101  min    0  max    
\backslash
 form TCCR0B prescale
\end_layout

\begin_layout Plain Layout

   TCCR0B  00001111 rot ( prescale ) RegTo ;  
\backslash
 and tone on
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

: tone-off 
\backslash
  ---  end output tone setting prescale to zeros
\end_layout

\begin_layout Plain Layout

   TCCR0B  00000111  false RegTo ;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

decimal
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

78 value Limit   4 value Prescale  
\backslash
 400 Hz tone parameters
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

: ud/mod ( ud1 n -- rem ud2 ) >R 0 R@ UM/MOD R> SWAP >R UM/MOD R> ;
\end_layout

\begin_layout Plain Layout

: Hertz   
\backslash
 frequency --- load Limit and Prescale
\end_layout

\begin_layout Plain Layout

    $1200 $7A ( 8000000.
 ) rot ud/mod  
\backslash
 total scale as rem double-quot
\end_layout

\begin_layout Plain Layout

    dup            if ( >16 bits)  1024  5 else
\end_layout

\begin_layout Plain Layout

    over $C000 and if ( >14 bits)   256  4 else
\end_layout

\begin_layout Plain Layout

    over $F800 and if ( >10 bits)    64  3 else
\end_layout

\begin_layout Plain Layout

    over $FF00 and if ( > 8 bits)     8  2 else   1  1
\end_layout

\begin_layout Plain Layout

                      then then then then
\end_layout

\begin_layout Plain Layout

      to Prescale   um/mod to Limit  drop drop ( two remainders ) ;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

: tone-on   
\backslash
 ---  begin tone from fixed presets
\end_layout

\begin_layout Plain Layout

     Prescale  Limit  setup-osc ;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

: note  
\backslash
 duration ---    generate timed tone for duration msec.
\end_layout

\begin_layout Plain Layout

     tone-on  ms  tone-off ;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
 End of tone.f
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Notes for the SwiftX version only:
\end_layout

\begin_layout Enumerate
The 
\family typewriter
\series bold
marker
\family default
\series default
 and 
\family typewriter
\series bold
flush
\family default
\series default
 concepts don't really apply here.
\end_layout

\begin_layout Enumerate
The SwiftX system defines all of the ports as compile time 
\family typewriter
\series bold
EQU
\family default
\series default
 constants, so I do not need to define them here.
\end_layout

\begin_layout Enumerate
I have not defined a way to compile the musical notes yet, but the Ring
 Tone Text Transfer Language looks interesting.
\begin_inset Newline newline
\end_inset

See: 
\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://www.srtware.com/index.php?/ringtones/rtttlformat.php
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
scale.f
\begin_inset Index idx
status open

\begin_layout Plain Layout
scale.f
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex Chunk
status open

\begin_layout Plain Layout

\begin_inset Argument 1
status open

\begin_layout Plain Layout
scale.f
\end_layout

\end_inset


\backslash
 Play musical scale                      13Apr14
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

CREATE scale 
\backslash
 sequence of notes, pauses and times
\end_layout

\begin_layout Plain Layout

   1047 , 500 , 0 , 500 , 1175 , 500 , 0 , 500 ,
\end_layout

\begin_layout Plain Layout

   1319 , 500 , 0 , 500 , 1397 , 500 , 0 , 500 ,
\end_layout

\begin_layout Plain Layout

   1568 , 500 , 0 , 500 , 1760 , 500 , 0 , 500 ,
\end_layout

\begin_layout Plain Layout

   1976 , 500 , 0 , 500 , 2093 , 500 , 0 , 500 ,
\end_layout

\begin_layout Plain Layout

      0 ,   0 ,  
\backslash
 Null terminators
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

: notes ( a -- ) 
\backslash
 Play sequence of notes, pauses and times
\end_layout

\begin_layout Plain Layout

   begin  dup 2@  2dup or while  ?dup if
\end_layout

\begin_layout Plain Layout

         Hertz note  else  ms
\end_layout

\begin_layout Plain Layout

      then  2 cells +
\end_layout

\begin_layout Plain Layout

   repeat  drop ;
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Notes for the SwiftX version only:
\end_layout

\begin_layout Enumerate
The only purpose here is to define 
\family typewriter
\series bold
notes
\family default
\series default
 to process the sequence of notes.
 The sequences of notes are not things that need to be created within the
 target.
 Thus, even define tables are pretty much pointless.
\end_layout

\begin_layout Enumerate
However, this did reveal that SwiftX is using timer 0 to support the 
\family typewriter
\series bold
ms
\family default
\series default
 and 
\family typewriter
\series bold
counter ...
 timer
\family default
\series default
 routines.
 Once 
\family typewriter
\series bold
tone-on
\family default
\series default
 is executed 
\family typewriter
\series bold
counter
\family default
\series default
 no longer changes and 
\family typewriter
\series bold
ms
\family default
\series default
 hangs until the board is reset.
\end_layout

\begin_layout Subsubsection
scale.txt
\begin_inset Index idx
status open

\begin_layout Plain Layout
scale.txt
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex Chunk
status open

\begin_layout Plain Layout

\begin_inset Argument 1
status open

\begin_layout Plain Layout
scale.txt
\end_layout

\end_inset


\backslash
 Play musical scale                      14Apr14
\end_layout

\begin_layout Plain Layout

chop-scale
\end_layout

\begin_layout Plain Layout

marker chop-scale
\end_layout

\begin_layout Plain Layout

CP @  
\backslash
 sequence of notes, pauses and times
\end_layout

\begin_layout Plain Layout

   1047 , 500 , 0 , 500 , 1175 , 500 , 0 , 500 ,
\end_layout

\begin_layout Plain Layout

   1319 , 500 , 0 , 500 , 1397 , 500 , 0 , 500 ,
\end_layout

\begin_layout Plain Layout

   1568 , 500 , 0 , 500 , 1760 , 500 , 0 , 500 ,
\end_layout

\begin_layout Plain Layout

   1976 , 500 , 0 , 500 , 2093 , 500 , 0 , 500 ,
\end_layout

\begin_layout Plain Layout

      0 ,   0 ,  
\backslash
 Null terminators
\end_layout

\begin_layout Plain Layout

CONSTANT scale
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

: notes ( a -- ) 
\backslash
 Play sequence of notes, pauses and times
\end_layout

\begin_layout Plain Layout

   begin  dup I@ >r  2 + dup I@ >r  2+
\end_layout

\begin_layout Plain Layout

      r> r> 2dup or while  ?dup if
\end_layout

\begin_layout Plain Layout

         Hertz note  else  ms
\end_layout

\begin_layout Plain Layout

      then  repeat  drop ;
\end_layout

\begin_layout Plain Layout

flush
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Notes for the eForth version only:
\end_layout

\begin_layout Enumerate
Since 
\family typewriter
\series bold
ms
\family default
\series default
 does not use timer 0 in eForth, I just need to get the table into eForth
 properly.
 It's not portable, but it does work.
\end_layout

\begin_layout Subsubsection
Tutorial6b
\end_layout

\begin_layout Standard
\begin_inset Flex Chunk
status open

\begin_layout Plain Layout

\begin_inset Argument 1
status open

\begin_layout Plain Layout
pitches.h
\end_layout

\end_inset

/*************************************************
\end_layout

\begin_layout Plain Layout

 * Public Constants
\end_layout

\begin_layout Plain Layout

 *************************************************/
\end_layout

\begin_layout Plain Layout

#define NOTE_B0  31
\end_layout

\begin_layout Plain Layout

#define NOTE_C1  33
\end_layout

\begin_layout Plain Layout

#define NOTE_CS1 35
\end_layout

\begin_layout Plain Layout

#define NOTE_D1  37
\end_layout

\begin_layout Plain Layout

#define NOTE_DS1 39
\end_layout

\begin_layout Plain Layout

#define NOTE_E1  41
\end_layout

\begin_layout Plain Layout

#define NOTE_F1  44
\end_layout

\begin_layout Plain Layout

#define NOTE_FS1 46
\end_layout

\begin_layout Plain Layout

#define NOTE_G1  49
\end_layout

\begin_layout Plain Layout

#define NOTE_GS1 52
\end_layout

\begin_layout Plain Layout

#define NOTE_A1  55
\end_layout

\begin_layout Plain Layout

#define NOTE_AS1 58
\end_layout

\begin_layout Plain Layout

#define NOTE_B1  62
\end_layout

\begin_layout Plain Layout

#define NOTE_C2  65
\end_layout

\begin_layout Plain Layout

#define NOTE_CS2 69
\end_layout

\begin_layout Plain Layout

#define NOTE_D2  73
\end_layout

\begin_layout Plain Layout

#define NOTE_DS2 78
\end_layout

\begin_layout Plain Layout

#define NOTE_E2  82
\end_layout

\begin_layout Plain Layout

#define NOTE_F2  87
\end_layout

\begin_layout Plain Layout

#define NOTE_FS2 93
\end_layout

\begin_layout Plain Layout

#define NOTE_G2  98
\end_layout

\begin_layout Plain Layout

#define NOTE_GS2 104
\end_layout

\begin_layout Plain Layout

#define NOTE_A2  110
\end_layout

\begin_layout Plain Layout

#define NOTE_AS2 117
\end_layout

\begin_layout Plain Layout

#define NOTE_B2  123
\end_layout

\begin_layout Plain Layout

#define NOTE_C3  131
\end_layout

\begin_layout Plain Layout

#define NOTE_CS3 139
\end_layout

\begin_layout Plain Layout

#define NOTE_D3  147
\end_layout

\begin_layout Plain Layout

#define NOTE_DS3 156
\end_layout

\begin_layout Plain Layout

#define NOTE_E3  165
\end_layout

\begin_layout Plain Layout

#define NOTE_F3  175
\end_layout

\begin_layout Plain Layout

#define NOTE_FS3 185
\end_layout

\begin_layout Plain Layout

#define NOTE_G3  196
\end_layout

\begin_layout Plain Layout

#define NOTE_GS3 208
\end_layout

\begin_layout Plain Layout

#define NOTE_A3  220
\end_layout

\begin_layout Plain Layout

#define NOTE_AS3 233
\end_layout

\begin_layout Plain Layout

#define NOTE_B3  247
\end_layout

\begin_layout Plain Layout

#define NOTE_C4  262
\end_layout

\begin_layout Plain Layout

#define NOTE_CS4 277
\end_layout

\begin_layout Plain Layout

#define NOTE_D4  294
\end_layout

\begin_layout Plain Layout

#define NOTE_DS4 311
\end_layout

\begin_layout Plain Layout

#define NOTE_E4  330
\end_layout

\begin_layout Plain Layout

#define NOTE_F4  349
\end_layout

\begin_layout Plain Layout

#define NOTE_FS4 370
\end_layout

\begin_layout Plain Layout

#define NOTE_G4  392
\end_layout

\begin_layout Plain Layout

#define NOTE_GS4 415
\end_layout

\begin_layout Plain Layout

#define NOTE_A4  440
\end_layout

\begin_layout Plain Layout

#define NOTE_AS4 466
\end_layout

\begin_layout Plain Layout

#define NOTE_B4  494
\end_layout

\begin_layout Plain Layout

#define NOTE_C5  523
\end_layout

\begin_layout Plain Layout

#define NOTE_CS5 554
\end_layout

\begin_layout Plain Layout

#define NOTE_D5  587
\end_layout

\begin_layout Plain Layout

#define NOTE_DS5 622
\end_layout

\begin_layout Plain Layout

#define NOTE_E5  659
\end_layout

\begin_layout Plain Layout

#define NOTE_F5  698
\end_layout

\begin_layout Plain Layout

#define NOTE_FS5 740
\end_layout

\begin_layout Plain Layout

#define NOTE_G5  784
\end_layout

\begin_layout Plain Layout

#define NOTE_GS5 831
\end_layout

\begin_layout Plain Layout

#define NOTE_A5  880
\end_layout

\begin_layout Plain Layout

#define NOTE_AS5 932
\end_layout

\begin_layout Plain Layout

#define NOTE_B5  988
\end_layout

\begin_layout Plain Layout

#define NOTE_C6  1047
\end_layout

\begin_layout Plain Layout

#define NOTE_CS6 1109
\end_layout

\begin_layout Plain Layout

#define NOTE_D6  1175
\end_layout

\begin_layout Plain Layout

#define NOTE_DS6 1245
\end_layout

\begin_layout Plain Layout

#define NOTE_E6  1319
\end_layout

\begin_layout Plain Layout

#define NOTE_F6  1397
\end_layout

\begin_layout Plain Layout

#define NOTE_FS6 1480
\end_layout

\begin_layout Plain Layout

#define NOTE_G6  1568
\end_layout

\begin_layout Plain Layout

#define NOTE_GS6 1661
\end_layout

\begin_layout Plain Layout

#define NOTE_A6  1760
\end_layout

\begin_layout Plain Layout

#define NOTE_AS6 1865
\end_layout

\begin_layout Plain Layout

#define NOTE_B6  1976
\end_layout

\begin_layout Plain Layout

#define NOTE_C7  2093
\end_layout

\begin_layout Plain Layout

#define NOTE_CS7 2217
\end_layout

\begin_layout Plain Layout

#define NOTE_D7  2349
\end_layout

\begin_layout Plain Layout

#define NOTE_DS7 2489
\end_layout

\begin_layout Plain Layout

#define NOTE_E7  2637
\end_layout

\begin_layout Plain Layout

#define NOTE_F7  2794
\end_layout

\begin_layout Plain Layout

#define NOTE_FS7 2960
\end_layout

\begin_layout Plain Layout

#define NOTE_G7  3136
\end_layout

\begin_layout Plain Layout

#define NOTE_GS7 3322
\end_layout

\begin_layout Plain Layout

#define NOTE_A7  3520
\end_layout

\begin_layout Plain Layout

#define NOTE_AS7 3729
\end_layout

\begin_layout Plain Layout

#define NOTE_B7  3951
\end_layout

\begin_layout Plain Layout

#define NOTE_C8  4186
\end_layout

\begin_layout Plain Layout

#define NOTE_CS8 4435
\end_layout

\begin_layout Plain Layout

#define NOTE_D8  4699
\end_layout

\begin_layout Plain Layout

#define NOTE_DS8 4978
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex Chunk
status open

\begin_layout Plain Layout

\begin_inset Argument 1
status open

\begin_layout Plain Layout
Tutorial6b.ino
\end_layout

\end_inset

/* Tutorial 6b: Playing an Melody */
\end_layout

\begin_layout Plain Layout

#include "pitches.h"
\end_layout

\begin_layout Plain Layout

// notes in the melody:
\end_layout

\begin_layout Plain Layout

int melody[] = {    NOTE_C4, NOTE_G3,NOTE_G3, NOTE_A3, NOTE_G3,0, NOTE_B3,
 NOTE_C4};
\end_layout

\begin_layout Plain Layout

// note durations: 4 = quarter note, 8 = eighth note, etc.:
\end_layout

\begin_layout Plain Layout

int noteDurations[] = {4, 8, 8, 4,4,4,4,4 };
\end_layout

\begin_layout Plain Layout

void setup() {
\end_layout

\begin_layout Plain Layout

  // iterate over the notes of the melody:
\end_layout

\begin_layout Plain Layout

  for (int thisNote = 0; thisNote < 8; thisNote++) {
\end_layout

\begin_layout Plain Layout

    // to calculate the note duration, take one second
\end_layout

\begin_layout Plain Layout

    // divided by the note type.
\end_layout

\begin_layout Plain Layout

    //e.g.
 quarter note = 1000 / 4, eighth note = 1000/8, etc.
\end_layout

\begin_layout Plain Layout

    int noteDuration = 1000/noteDurations[thisNote];
\end_layout

\begin_layout Plain Layout

    tone(8, melody[thisNote],noteDuration);
\end_layout

\begin_layout Plain Layout

    // to distinguish the notes, set a minimum time between them.
\end_layout

\begin_layout Plain Layout

    // the note's duration + 30% seems to work well:
\end_layout

\begin_layout Plain Layout

    int pauseBetweenNotes = noteDuration * 1.30;
\end_layout

\begin_layout Plain Layout

    delay(pauseBetweenNotes);
\end_layout

\begin_layout Plain Layout

    // stop the tone playing:
\end_layout

\begin_layout Plain Layout

    noTone(8);
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

void loop() {
\end_layout

\begin_layout Plain Layout

  // no need to repeat the melody.
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
pitches.txt
\begin_inset Index idx
status open

\begin_layout Plain Layout
pitches.txt
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex Chunk
status open

\begin_layout Plain Layout

\begin_inset Argument 1
status open

\begin_layout Plain Layout
pitches.txt
\end_layout

\end_inset


\backslash
 pitches.txt to Demo Musical notes      DaR 2014-04-14
\end_layout

\begin_layout Plain Layout


\backslash
 See: http://www.phy.mtu.edu/~suits/notefreqs.html
\end_layout

\begin_layout Plain Layout

chop-pitches
\end_layout

\begin_layout Plain Layout

marker chop-pitches
\end_layout

\begin_layout Plain Layout

CP @ 
\backslash
 3 dimentional array of note frequencies
\end_layout

\begin_layout Plain Layout

(        C      D      E      F      G      A      B )
\end_layout

\begin_layout Plain Layout

( 0 )   16 ,   18 ,   21 ,   22 ,   24 ,   27 ,   31 ,
\end_layout

\begin_layout Plain Layout

( # )   17 ,   19 ,    0 ,   23 ,   26 ,   29 ,    0 ,
\end_layout

\begin_layout Plain Layout

( 1 )   33 ,   37 ,   41 ,   44 ,   49 ,   55 ,   62 ,
\end_layout

\begin_layout Plain Layout

( # )   35 ,   39 ,    0 ,   46 ,   52 ,   58 ,    0 ,
\end_layout

\begin_layout Plain Layout

( 2 )   65 ,   73 ,   82 ,   87 ,   98 ,  110 ,  123 ,
\end_layout

\begin_layout Plain Layout

( # )   69 ,   78 ,    0 ,   93 ,  104 ,  117 ,    0 ,
\end_layout

\begin_layout Plain Layout

( 3 )  131 ,  147 ,  165 ,  175 ,  196 ,  220 ,  247 ,
\end_layout

\begin_layout Plain Layout

( # )  139 ,  156 ,    0 ,  185 ,  208 ,  233 ,    0 ,
\end_layout

\begin_layout Plain Layout

( 4 )  262 ,  294 ,  330 ,  349 ,  392 ,  440 ,  494 ,
\end_layout

\begin_layout Plain Layout

( # )  277 ,  311 ,    0 ,  370 ,  415 ,  466 ,    0 ,
\end_layout

\begin_layout Plain Layout

( 5 )  523 ,  587 ,  659 ,  698 ,  784 ,  880 ,  988 ,
\end_layout

\begin_layout Plain Layout

( # )  554 ,  622 ,    0 ,  740 ,  831 ,  932 ,    0 ,
\end_layout

\begin_layout Plain Layout

( 6 ) 1047 , 1175 , 1319 , 1397 , 1568 , 1760 , 1976 ,
\end_layout

\begin_layout Plain Layout

( # ) 1109 , 1245 ,    0 , 1480 , 1661 , 1865 ,    0 ,
\end_layout

\begin_layout Plain Layout

( 7 ) 2093 , 2349 , 2637 , 2794 , 3136 , 3520 , 3951 ,
\end_layout

\begin_layout Plain Layout

( # ) 2217 , 2489 ,    0 , 2960 , 3322 , 3729 ,    0 ,
\end_layout

\begin_layout Plain Layout

( 8 ) 4186 , 4699 , 5274 , 5588 , 6272 ,    0 ,    0 ,
\end_layout

\begin_layout Plain Layout

( # ) 4435 , 4978 ,    0 , 5920 ,    0 ,    0 ,    0 ,
\end_layout

\begin_layout Plain Layout

CONSTANT pitches
\end_layout

\begin_layout Plain Layout

flush
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Notes for the eForth version only:
\end_layout

\begin_layout Enumerate
There's no reason to name every note, even with defines, because we are
 going to parse a Ring Tone Text Transfer Language string.
\end_layout

\begin_layout Enumerate
Once again, this is not portable and the equivalent version will not even
 compile in the SwiftX evaluation version due to its size.
\end_layout

\begin_layout Enumerate
The 0 values in this 3-dimensional (note, sharp, octave) table are invalid
 notes, so some error handling must be provided.
\end_layout

\begin_layout Enumerate
A sharp is the same as a flat of the next note, so only one is needed, but
 the other must be calculated.
\end_layout

\begin_layout Subsection
Tutorial 7: Counting Down with a 7 Segment LED
\end_layout

\begin_layout Standard
\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://tinyurl.com/megobz3/tutorial-7-counting-down-with-a-7-segment-led/
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Tutorial7
\end_layout

\begin_layout Standard
\begin_inset Flex Chunk
status open

\begin_layout Plain Layout

\begin_inset Argument 1
status open

\begin_layout Plain Layout
Tutorial7.ino
\end_layout

\end_inset

//  Tutorial 7: 7 Segment LED
\end_layout

\begin_layout Plain Layout

//
\end_layout

\begin_layout Plain Layout

// Define the LED digit patterns, from 0 - 9
\end_layout

\begin_layout Plain Layout

// Note that these patterns are for common anode displays
\end_layout

\begin_layout Plain Layout

// 0 = LED on, 1 = LED off:
\end_layout

\begin_layout Plain Layout

// Digital pin: 2,3,4,5,6,7,8
\end_layout

\begin_layout Plain Layout

//              a,b,c,d,e,f,g
\end_layout

\begin_layout Plain Layout

byte seven_seg_digits[10][7] = { { 0,0,0,0,0,0,1 },  // = 0
\end_layout

\begin_layout Plain Layout

                                 { 1,0,0,1,1,1,1 },  // = 1
\end_layout

\begin_layout Plain Layout

                                 { 0,0,1,0,0,1,0 },  // = 2
\end_layout

\begin_layout Plain Layout

                                 { 0,0,0,0,1,1,0 },  // = 3
\end_layout

\begin_layout Plain Layout

                                 { 1,0,0,1,1,0,0 },  // = 4
\end_layout

\begin_layout Plain Layout

                                 { 0,1,0,0,1,0,0 },  // = 5
\end_layout

\begin_layout Plain Layout

                                 { 0,1,0,0,0,0,0 },  // = 6
\end_layout

\begin_layout Plain Layout

                                 { 0,0,0,1,1,1,1 },  // = 7
\end_layout

\begin_layout Plain Layout

                                 { 0,0,0,0,0,0,0 },  // = 8
\end_layout

\begin_layout Plain Layout

                                 { 0,0,0,1,1,0,0 }   // = 9
\end_layout

\begin_layout Plain Layout

                               };
\end_layout

\begin_layout Plain Layout

void setup() {
\end_layout

\begin_layout Plain Layout

  pinMode(2, OUTPUT);
\end_layout

\begin_layout Plain Layout

  pinMode(3, OUTPUT);
\end_layout

\begin_layout Plain Layout

  pinMode(4, OUTPUT);
\end_layout

\begin_layout Plain Layout

  pinMode(5, OUTPUT);
\end_layout

\begin_layout Plain Layout

  pinMode(6, OUTPUT);
\end_layout

\begin_layout Plain Layout

  pinMode(7, OUTPUT);
\end_layout

\begin_layout Plain Layout

  pinMode(8, OUTPUT); }
\end_layout

\begin_layout Plain Layout

void sevenSegWrite(byte digit) {
\end_layout

\begin_layout Plain Layout

  byte pin = 2;
\end_layout

\begin_layout Plain Layout

  for (byte segCount = 0; segCount < 7; ++segCount) {
\end_layout

\begin_layout Plain Layout

    digitalWrite(pin, seven_seg_digits[digit][segCount]);
\end_layout

\begin_layout Plain Layout

    ++pin;
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

void loop() {
\end_layout

\begin_layout Plain Layout

  for (byte count = 10; count > 0; --count) {
\end_layout

\begin_layout Plain Layout

   delay(1000);
\end_layout

\begin_layout Plain Layout

   sevenSegWrite(count - 1);
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  delay(3000);
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
count.f
\begin_inset Index idx
status open

\begin_layout Plain Layout
count.f
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex Chunk
status open

\begin_layout Plain Layout

\begin_inset Argument 1
status open

\begin_layout Plain Layout
count.f
\end_layout

\end_inset


\backslash
 count.f to Demo 7-segment LED control      DaR 2014-04-08
\end_layout

\begin_layout Plain Layout


\backslash
 Define LED segment port bits and segment order
\end_layout

\begin_layout Plain Layout

CREATE LEDS   7 2* 1 + allot 
\backslash
 Number of segments, then order
\end_layout

\begin_layout Plain Layout

: 
\backslash
LEDS ( --- Initialize the RAM array )   7 LEDS C!
\end_layout

\begin_layout Plain Layout

   LEDS count 2* PortD fill 
\backslash
 Overfill the Port addresses to save code
\end_layout

\begin_layout Plain Layout

   2 LEDS 1 + C!  3 LEDS 3 + C!  4 LEDS 5 + C!  5 LEDS 7 + C!
\end_layout

\begin_layout Plain Layout

   6 LEDS 9 + C!  7 LEDS 11 + C!  0 LEDS 13 + C!
\end_layout

\begin_layout Plain Layout

   PortB LEDS 14 + C! ; 
\backslash
 Last segment on PortB
\end_layout

\begin_layout Plain Layout

CREATE SEGS 
\backslash
 Try flash based array on SwiftX
\end_layout

\begin_layout Plain Layout

   0 c, 0 c, 0 c, 0 c, 0 c, 0 c, 1 c, 
\backslash
 = 0
\end_layout

\begin_layout Plain Layout

   1 c, 0 c, 0 c, 1 c, 1 c, 1 c, 1 c, 
\backslash
 = 1
\end_layout

\begin_layout Plain Layout

   0 c, 0 c, 1 c, 0 c, 0 c, 1 c, 0 c, 
\backslash
 = 2
\end_layout

\begin_layout Plain Layout

   0 c, 0 c, 0 c, 0 c, 1 c, 1 c, 0 c, 
\backslash
 = 3
\end_layout

\begin_layout Plain Layout

   1 c, 0 c, 0 c, 1 c, 1 c, 0 c, 0 c, 
\backslash
 = 4
\end_layout

\begin_layout Plain Layout

   0 c, 1 c, 0 c, 0 c, 1 c, 0 c, 0 c, 
\backslash
 = 5
\end_layout

\begin_layout Plain Layout

   0 c, 1 c, 0 c, 0 c, 0 c, 0 c, 0 c, 
\backslash
 = 6
\end_layout

\begin_layout Plain Layout

   0 c, 0 c, 0 c, 1 c, 1 c, 1 c, 1 c, 
\backslash
 = 7
\end_layout

\begin_layout Plain Layout

   0 c, 0 c, 0 c, 0 c, 0 c, 0 c, 0 c, 
\backslash
 = 8
\end_layout

\begin_layout Plain Layout

   0 c, 0 c, 0 c, 1 c, 1 c, 0 c, 0 c, 
\backslash
 = 9
\end_layout

\begin_layout Plain Layout

: sevenSegWrite ( digit --- turn on the segments for the given digit )
\end_layout

\begin_layout Plain Layout

   LEDS count  rot over * SEGS +  -rot 0 do
\end_layout

\begin_layout Plain Layout

      swap count >r  swap count >r count r>  r> if
\end_layout

\begin_layout Plain Layout

         PoBiHi  else  PoBiLo
\end_layout

\begin_layout Plain Layout

      then
\end_layout

\begin_layout Plain Layout

   loop  2drop ;
\end_layout

\begin_layout Plain Layout

: counts ( time cycles --- produce cycles of digits )   
\backslash
LEDS
\end_layout

\begin_layout Plain Layout

   LEDS count 0 do  count >r count r> PoBiOut  loop  drop
\end_layout

\begin_layout Plain Layout

   0 do  10 dup 0 do  dup i - 1- sevenSegWrite  over ms
\end_layout

\begin_layout Plain Layout

   loop  drop  loop  drop ;
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Notes for the SwiftX version only:
\end_layout

\begin_layout Enumerate
Although I used the same RAM based array as I did in the 
\family typewriter
\series bold
cycle
\family default
\series default
 tutorial, I was able to use a 
\begin_inset Quotes eld
\end_inset

proper
\begin_inset Quotes erd
\end_inset

 flash based array in SwiftX.
\end_layout

\begin_layout Section
Document Processing
\end_layout

\begin_layout Standard
A script for converting this document to PDF form:
\begin_inset Index idx
status open

\begin_layout Plain Layout
final
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex Chunk
status open

\begin_layout Plain Layout

\begin_inset Argument 1
status open

\begin_layout Plain Layout
final
\end_layout

\end_inset

lyx -e latex $1.lyx
\end_layout

\begin_layout Plain Layout

if [ $? == 0 ]; then
\end_layout

\begin_layout Plain Layout

   lyx -e pdf $1.lyx
\end_layout

\begin_layout Plain Layout

else # noweb conversion can't be called in cygwin
\end_layout

\begin_layout Plain Layout

   lyx -e literate $1.lyx
\end_layout

\begin_layout Plain Layout

   noweave -delay -index "$1.nw" > "$1.tex"
\end_layout

\begin_layout Plain Layout

   pdflatex $1 latex=pdflatex fi
\end_layout

\end_inset


\end_layout

\begin_layout Standard
For marking the output with a PRELIMINARY watermark:
\begin_inset Index idx
status open

\begin_layout Plain Layout
preliminary
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex Chunk
status open

\begin_layout Plain Layout

\begin_inset Argument 1
status open

\begin_layout Plain Layout
preliminary
\end_layout

\end_inset

echo "Make $1 PDF release notes..."
\end_layout

\begin_layout Plain Layout

./final $1
\end_layout

\begin_layout Plain Layout

pdftk $1.pdf stamp Preliminary.pdf output out.pdf
\end_layout

\begin_layout Plain Layout

rm $1.pdf
\end_layout

\begin_layout Plain Layout

mv out.pdf $1.pdf
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Each of these scripts can be pulled out manually given the default * script
 defined below.
\end_layout

\begin_layout Standard
\begin_inset Flex Chunk
status open

\begin_layout Plain Layout

\begin_inset Argument 1
status open

\begin_layout Plain Layout
*
\end_layout

\end_inset

echo "Extract script $2 from $1.lyx..."
\end_layout

\begin_layout Plain Layout

rm -f $1.nw
\end_layout

\begin_layout Plain Layout

lyx -e literate $1.lyx
\end_layout

\begin_layout Plain Layout

notangle -t4 -R$2 $1.nw > $2
\end_layout

\begin_layout Plain Layout

chmod a+x $2
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Once that script is pulled out and named extract, the following script can
 pull out all of the other scripts:
\begin_inset Index idx
status open

\begin_layout Plain Layout
extract-all
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex Chunk
status open

\begin_layout Plain Layout

\begin_inset Argument 1
status open

\begin_layout Plain Layout
extract-all
\end_layout

\end_inset

echo "Extract all scripts..."
\end_layout

\begin_layout Plain Layout

sedArgs="s/
\backslash
(.*
\backslash
)
\backslash
.idx:.*entry{
\backslash
(.*
\backslash
)|hyper.*/
\backslash
1 
\backslash
2/g"
\end_layout

\begin_layout Plain Layout

find .
 -type f -name 
\backslash
*idx |
\backslash

\end_layout

\begin_layout Plain Layout

xargs grep "indexentry" |
\backslash

\end_layout

\begin_layout Plain Layout

sed -e "$sedArgs" |
\backslash

\end_layout

\begin_layout Plain Layout

xargs -n 2 ./extract
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset index_print
LatexCommand printindex
type "idx"

\end_inset


\end_layout

\end_body
\end_document
