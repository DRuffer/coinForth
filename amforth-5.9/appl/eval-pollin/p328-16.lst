
AVRASM ver. 2.1.52  p328-16.asm Fri Jul 10 18:43:16 2015

p328-16.asm(5): Including file '../../avr8\preamble.inc'
../../avr8\preamble.inc(2): Including file '../../avr8\macros.asm'
../../avr8\macros.asm(6): Including file '../../avr8\user.inc'
../../avr8\preamble.inc(6): Including file '../../avr8/devices/atmega328p\device.asm'
../../avr8/devices/atmega328p\device.asm(5): Including file '../../avr8/Atmel/Appnotes2\m328Pdef.inc'
p328-16.asm(14): Including file '../../avr8\drivers/usart_0.asm'
../../avr8\drivers/usart_0.asm(32): Including file '../../avr8\drivers/usart_common.asm'
../../avr8\drivers/usart_common.asm(5): Including file '../../avr8\drivers/usart-isr-rx.asm'
../../avr8\drivers/usart_common.asm(17): Including file '../../avr8\words/usart-tx-poll.asm'
../../avr8\drivers/usart_common.asm(22): Including file '../../avr8\words/ubrr.asm'
../../avr8\drivers/usart_common.asm(23): Including file '../../avr8\words/usart.asm'
p328-16.asm(19): Including file '../../avr8\drivers/1wire.asm'
p328-16.asm(21): Including file '../../avr8\amforth.asm'
../../avr8\amforth.asm(12): Including file '../../avr8\drivers/generic-isr.asm'
../../avr8\amforth.asm(14): Including file '../../avr8\dict/rww.inc'
../../avr8\dict/rww.inc(1): Including file '../../avr8\words/mplus.asm'
../../avr8\dict/rww.inc(2): Including file '../../common\words/ud-star.asm'
../../avr8\dict/rww.inc(3): Including file '../../common\words/umax.asm'
../../avr8\dict/rww.inc(4): Including file '../../common\words/umin.asm'
../../avr8\dict/rww.inc(5): Including file '../../avr8\words/immediate-q.asm'
../../avr8\dict/rww.inc(6): Including file '../../avr8\words/name2flags.asm'
../../avr8\dict/rww.inc(7): Including file '../../common\words/name2interpret.asm'
../../avr8\dict/rww.inc(8): Including file '../../common\words/name2compile.asm'
../../avr8\dict/rww.inc(13): Including file '../../avr8\dict/appl_4k.inc'
../../avr8\dict/appl_4k.inc(1): Including file '../../common\words/ver.asm'
../../avr8\dict/appl_4k.inc(4): Including file '../../avr8\words/noop.asm'
../../avr8\dict/appl_4k.inc(5): Including file '../../avr8\words/unused.asm'
../../avr8\dict/appl_4k.inc(6): Including file '../../common\words/to.asm'
../../avr8\dict/appl_4k.inc(7): Including file '../../avr8\words/i-cellplus.asm'
../../avr8\dict/appl_4k.inc(8): Including file '../../avr8\words/icompare.asm'
../../avr8\dict/appl_4k.inc(9): Including file '../../common\words/star.asm'
../../avr8\dict/appl_4k.inc(10): Including file '../../avr8\words/j.asm'
../../avr8\dict/appl_4k.inc(11): Including file '../../avr8\words/dabs.asm'
../../avr8\dict/appl_4k.inc(12): Including file '../../avr8\words/dnegate.asm'
../../avr8\dict/appl_4k.inc(13): Including file '../../avr8\words/cmove.asm'
../../avr8\dict/appl_4k.inc(14): Including file '../../common\words/2swap.asm'
../../avr8\dict/appl_4k.inc(15): Including file '../../avr8\words/tib.asm'
../../avr8\dict/appl_4k.inc(16): Including file '../../avr8\words/init-user.asm'
../../avr8\dict/appl_4k.inc(20): Including file '../../avr8\words/environment.asm'
../../avr8\dict/appl_4k.inc(21): Including file '../../avr8\words/env-wordlists.asm'
../../avr8\dict/appl_4k.inc(22): Including file '../../avr8\words/env-slashpad.asm'
../../avr8\dict/appl_4k.inc(23): Including file '../../avr8\words/env-slashhold.asm'
../../avr8\dict/appl_4k.inc(24): Including file '../../common\words/env-forthname.asm'
../../avr8\dict/appl_4k.inc(25): Including file '../../common\words/env-forthversion.asm'
../../avr8\dict/appl_4k.inc(26): Including file '../../common\words/env-cpu.asm'
../../avr8\dict/appl_4k.inc(27): Including file '../../avr8\words/env-mcuinfo.asm'
../../avr8\dict/appl_4k.inc(28): Including file '../../avr8\words/env-usersize.asm'
../../avr8\dict/appl_4k.inc(30): Including file '../../avr8\words/hld.asm'
../../avr8\dict/appl_4k.inc(31): Including file '../../common\words/hold.asm'
../../avr8\dict/appl_4k.inc(32): Including file '../../common\words/less-sharp.asm'
../../avr8\dict/appl_4k.inc(33): Including file '../../common\words/sharp.asm'
../../avr8\dict/appl_4k.inc(34): Including file '../../common\words/sharp-s.asm'
../../avr8\dict/appl_4k.inc(35): Including file '../../common\words/sharp-greater.asm'
../../avr8\dict/appl_4k.inc(36): Including file '../../common\words/sign.asm'
../../avr8\dict/appl_4k.inc(37): Including file '../../common\words/d-dot-r.asm'
../../avr8\dict/appl_4k.inc(38): Including file '../../common\words/dot-r.asm'
../../avr8\dict/appl_4k.inc(39): Including file '../../common\words/d-dot.asm'
../../avr8\dict/appl_4k.inc(40): Including file '../../common\words/dot.asm'
../../avr8\dict/appl_4k.inc(41): Including file '../../common\words/ud-dot.asm'
../../avr8\dict/appl_4k.inc(42): Including file '../../common\words/ud-dot-r.asm'
../../avr8\dict/appl_4k.inc(43): Including file '../../common\words/ud-slash-mod.asm'
../../avr8\dict/appl_4k.inc(44): Including file '../../common\words/digit-q.asm'
../../avr8\dict/appl_4k.inc(46): Including file '../../avr8\words/do-sliteral.asm'
../../avr8\dict/appl_4k.inc(47): Including file '../../avr8\words/scomma.asm'
../../avr8\dict/appl_4k.inc(48): Including file '../../avr8\words/itype.asm'
../../avr8\dict/appl_4k.inc(49): Including file '../../avr8\words/icount.asm'
../../avr8\dict/appl_4k.inc(50): Including file '../../common\words/type.asm'
../../avr8\dict/appl_4k.inc(51): Including file '../../common\words/tick.asm'
../../avr8\dict/appl_4k.inc(53): Including file '../../common\words/cskip.asm'
../../avr8\dict/appl_4k.inc(54): Including file '../../common\words/cscan.asm'
../../avr8\dict/appl_4k.inc(55): Including file '../../common\words/accept.asm'
../../avr8\dict/appl_4k.inc(56): Including file '../../avr8\words/refill.asm'
../../avr8\dict/appl_4k.inc(57): Including file '../../common\words/char.asm'
../../avr8\dict/appl_4k.inc(58): Including file '../../common\words/number.asm'
../../avr8\dict/appl_4k.inc(59): Including file '../../common\words/q-sign.asm'
../../avr8\dict/appl_4k.inc(60): Including file '../../common\words/set-base.asm'
../../avr8\dict/appl_4k.inc(61): Including file '../../common\words/to-number.asm'
../../avr8\dict/appl_4k.inc(62): Including file '../../common\words/parse.asm'
../../avr8\dict/appl_4k.inc(63): Including file '../../avr8\words/source.asm'
../../avr8\dict/appl_4k.inc(64): Including file '../../common\words/slash-string.asm'
../../avr8\dict/appl_4k.inc(65): Including file '../../common\words/parse-name.asm'
../../avr8\dict/appl_4k.inc(66): Including file '../../avr8\words/sp0.asm'
../../avr8\dict/appl_4k.inc(67): Including file '../../avr8\words/rp0.asm'
../../avr8\dict/appl_4k.inc(68): Including file '../../common\words/depth.asm'
../../avr8\dict/appl_4k.inc(69): Including file '../../common\words/do-recognizer.asm'
../../avr8\dict/appl_4k.inc(70): Including file '../../common\words/interpret.asm'
../../avr8\dict/appl_4k.inc(71): Including file '../../common\words/r-intnumber.asm'
../../avr8\dict/appl_4k.inc(72): Including file '../../common\words/r-word.asm'
../../avr8\dict/appl_4k.inc(73): Including file '../../common\words/r-fail.asm'
../../avr8\dict/appl_4k.inc(74): Including file '../../common\words/search-wordlist.asm'
../../avr8\dict/appl_4k.inc(75): Including file '../../common\words/traverse-wordlist.asm'
../../avr8\dict/appl_4k.inc(76): Including file '../../common\words/name2string.asm'
../../avr8\dict/appl_4k.inc(77): Including file '../../avr8\words/nfa2cfa.asm'
../../avr8\dict/appl_4k.inc(78): Including file '../../common\words/find-name.asm'
../../avr8\dict/appl_4k.inc(80): Including file '../../avr8\dict/compiler1.inc'
../../avr8\dict/compiler1.inc(2): Including file '../../avr8\words/docreate.asm'
../../avr8\dict/compiler1.inc(3): Including file '../../common\words/backslash.asm'
../../avr8\dict/compiler1.inc(4): Including file '../../common\words/l-paren.asm'
../../avr8\dict/compiler1.inc(6): Including file '../../common\words/compile.asm'
../../avr8\dict/compiler1.inc(7): Including file '../../avr8\words/comma.asm'
../../avr8\dict/compiler1.inc(8): Including file '../../common\words/brackettick.asm'
../../avr8\dict/compiler1.inc(11): Including file '../../common\words/literal.asm'
../../avr8\dict/compiler1.inc(12): Including file '../../common\words/sliteral.asm'
../../avr8\dict/compiler1.inc(13): Including file '../../avr8\words/g-mark.asm'
../../avr8\dict/compiler1.inc(14): Including file '../../avr8\words/g-resolve.asm'
../../avr8\dict/compiler1.inc(15): Including file '../../avr8\words/l_mark.asm'
../../avr8\dict/compiler1.inc(16): Including file '../../avr8\words/l_resolve.asm'
../../avr8\dict/compiler1.inc(18): Including file '../../common\words/ahead.asm'
../../avr8\dict/compiler1.inc(19): Including file '../../common\words/if.asm'
../../avr8\dict/compiler1.inc(20): Including file '../../common\words/else.asm'
../../avr8\dict/compiler1.inc(21): Including file '../../common\words/then.asm'
../../avr8\dict/compiler1.inc(22): Including file '../../common\words/begin.asm'
../../avr8\dict/compiler1.inc(23): Including file '../../common\words/while.asm'
../../avr8\dict/compiler1.inc(24): Including file '../../common\words/repeat.asm'
../../avr8\dict/compiler1.inc(25): Including file '../../common\words/until.asm'
../../avr8\dict/compiler1.inc(26): Including file '../../common\words/again.asm'
../../avr8\dict/compiler1.inc(27): Including file '../../common\words/do.asm'
../../avr8\dict/compiler1.inc(28): Including file '../../common\words/loop.asm'
../../avr8\dict/compiler1.inc(29): Including file '../../common\words/plusloop.asm'
../../avr8\dict/compiler1.inc(30): Including file '../../common\words/leave.asm'
../../avr8\dict/compiler1.inc(31): Including file '../../common\words/qdo.asm'
../../avr8\dict/compiler1.inc(32): Including file '../../common\words/endloop.asm'
../../avr8\dict/compiler1.inc(34): Including file '../../common\words/l-from.asm'
../../avr8\dict/compiler1.inc(35): Including file '../../common\words/to-l.asm'
../../avr8\dict/compiler1.inc(36): Including file '../../avr8\words/lp0.asm'
../../avr8\dict/compiler1.inc(37): Including file '../../avr8\words/lp.asm'
../../avr8\dict/compiler1.inc(39): Including file '../../avr8\words/create.asm'
../../avr8\dict/compiler1.inc(40): Including file '../../avr8\words/header.asm'
../../avr8\dict/compiler1.inc(41): Including file '../../avr8\words/wlscope.asm'
../../avr8\dict/compiler1.inc(42): Including file '../../avr8\words/reveal.asm'
../../avr8\dict/compiler1.inc(43): Including file '../../avr8\words/latest.asm'
../../avr8\dict/compiler1.inc(44): Including file '../../avr8\words/does.asm'
../../avr8\dict/compiler1.inc(45): Including file '../../common\words/colon.asm'
../../avr8\dict/compiler1.inc(46): Including file '../../avr8\words/colon-noname.asm'
../../avr8\dict/compiler1.inc(47): Including file '../../common\words/semicolon.asm'
../../avr8\dict/compiler1.inc(48): Including file '../../common\words/right-bracket.asm'
../../avr8\dict/compiler1.inc(49): Including file '../../common\words/left-bracket.asm'
../../avr8\dict/compiler1.inc(50): Including file '../../common\words/variable.asm'
../../avr8\dict/compiler1.inc(51): Including file '../../common\words/constant.asm'
../../avr8\dict/compiler1.inc(52): Including file '../../avr8\words/user.asm'
../../avr8\dict/compiler1.inc(54): Including file '../../avr8\words/recurse.asm'
../../avr8\dict/compiler1.inc(55): Including file '../../avr8\words/immediate.asm'
../../avr8\dict/compiler1.inc(57): Including file '../../common\words/bracketchar.asm'
../../avr8\dict/compiler1.inc(58): Including file '../../common\words/abort-string.asm'
../../avr8\dict/compiler1.inc(59): Including file '../../common\words/abort.asm'
../../avr8\dict/compiler1.inc(60): Including file '../../common\words/q-abort.asm'
../../avr8\dict/compiler1.inc(62): Including file '../../common\words/get-stack.asm'
../../avr8\dict/compiler1.inc(63): Including file '../../common\words/set-stack.asm'
../../avr8\dict/compiler1.inc(64): Including file '../../common\words/map-stack.asm'
../../avr8\dict/compiler1.inc(65): Including file '../../avr8\words/get-current.asm'
../../avr8\dict/compiler1.inc(66): Including file '../../common\words/get-order.asm'
../../avr8\dict/compiler1.inc(68): Including file '../../avr8\words/compare.asm'
../../avr8\dict/compiler1.inc(69): Including file '../../avr8\words/nfa2lfa.asm'
../../avr8\amforth.asm(15): Including file 'dict_appl.inc'
dict_appl.inc(3): Including file '../../common\words/dot-s.asm'
dict_appl.inc(4): Including file '../../avr8\words/spirw.asm'
dict_appl.inc(5): Including file '../../avr8\words/n-spi.asm'
dict_appl.inc(6): Including file 'words/applturnkey.asm'
dict_appl.inc(7): Including file '../../avr8\dict/compiler2.inc'
../../avr8\dict/compiler2.inc(8): Including file '../../avr8\words/set-current.asm'
../../avr8\dict/compiler2.inc(9): Including file '../../avr8\words/wordlist.asm'
../../avr8\dict/compiler2.inc(11): Including file '../../avr8\words/only.asm'
../../avr8\dict/compiler2.inc(12): Including file '../../avr8\words/forth-wordlist.asm'
../../avr8\dict/compiler2.inc(13): Including file '../../common\words/set-order.asm'
../../avr8\dict/compiler2.inc(14): Including file '../../common\words/set-recognizer.asm'
../../avr8\dict/compiler2.inc(15): Including file '../../common\words/get-recognizer.asm'
../../avr8\dict/compiler2.inc(16): Including file '../../avr8\words/code.asm'
../../avr8\dict/compiler2.inc(17): Including file '../../avr8\words/end-code.asm'
../../avr8\dict/compiler2.inc(18): Including file '../../avr8\words/marker.asm'
../../avr8\dict/compiler2.inc(19): Including file '../../common\words/postpone.asm'
dict_appl.inc(8): Including file '../../avr8\words/2r_fetch.asm'
../../avr8\amforth.asm(23): Including file '../../avr8\amforth-interpreter.asm'
../../avr8\amforth.asm(24): Including file '../../avr8\dict/nrww.inc'
../../avr8\dict/nrww.inc(4): Including file '../../avr8\words/exit.asm'
../../avr8\dict/nrww.inc(5): Including file '../../avr8\words/execute.asm'
../../avr8\dict/nrww.inc(6): Including file '../../avr8\words/dobranch.asm'
../../avr8\dict/nrww.inc(7): Including file '../../avr8\words/docondbranch.asm'
../../avr8\dict/nrww.inc(10): Including file '../../avr8\words/doliteral.asm'
../../avr8\dict/nrww.inc(11): Including file '../../avr8\words/dovariable.asm'
../../avr8\dict/nrww.inc(12): Including file '../../avr8\words/doconstant.asm'
../../avr8\dict/nrww.inc(13): Including file '../../avr8\words/douser.asm'
../../avr8\dict/nrww.inc(14): Including file '../../avr8\words/do-value.asm'
../../avr8\dict/nrww.inc(15): Including file '../../avr8\words/fetch.asm'
../../avr8\dict/nrww.inc(16): Including file '../../avr8\words/store.asm'
../../avr8\dict/nrww.inc(17): Including file '../../avr8\words/cstore.asm'
../../avr8\dict/nrww.inc(18): Including file '../../avr8\words/cfetch.asm'
../../avr8\dict/nrww.inc(19): Including file '../../avr8\words/fetch-u.asm'
../../avr8\dict/nrww.inc(20): Including file '../../avr8\words/store-u.asm'
../../avr8\dict/nrww.inc(23): Including file '../../avr8\words/dup.asm'
../../avr8\dict/nrww.inc(24): Including file '../../avr8\words/qdup.asm'
../../avr8\dict/nrww.inc(25): Including file '../../avr8\words/swap.asm'
../../avr8\dict/nrww.inc(26): Including file '../../avr8\words/over.asm'
../../avr8\dict/nrww.inc(27): Including file '../../avr8\words/drop.asm'
../../avr8\dict/nrww.inc(28): Including file '../../avr8\words/rot.asm'
../../avr8\dict/nrww.inc(29): Including file '../../avr8\words/nip.asm'
../../avr8\dict/nrww.inc(31): Including file '../../avr8\words/r_from.asm'
../../avr8\dict/nrww.inc(32): Including file '../../avr8\words/to_r.asm'
../../avr8\dict/nrww.inc(33): Including file '../../avr8\words/r_fetch.asm'
../../avr8\dict/nrww.inc(36): Including file '../../common\words/not-equal.asm'
../../avr8\dict/nrww.inc(37): Including file '../../avr8\words/equalzero.asm'
../../avr8\dict/nrww.inc(38): Including file '../../avr8\words/lesszero.asm'
../../avr8\dict/nrww.inc(39): Including file '../../avr8\words/greaterzero.asm'
../../avr8\dict/nrww.inc(40): Including file '../../avr8\words/d-greaterzero.asm'
../../avr8\dict/nrww.inc(41): Including file '../../avr8\words/d-lesszero.asm'
../../avr8\dict/nrww.inc(43): Including file '../../avr8\words/true.asm'
../../avr8\dict/nrww.inc(44): Including file '../../avr8\words/zero.asm'
../../avr8\dict/nrww.inc(45): Including file '../../avr8\words/uless.asm'
../../avr8\dict/nrww.inc(46): Including file '../../common\words/u-greater.asm'
../../avr8\dict/nrww.inc(47): Including file '../../avr8\words/less.asm'
../../avr8\dict/nrww.inc(48): Including file '../../avr8\words/greater.asm'
../../avr8\dict/nrww.inc(50): Including file '../../avr8\words/log2.asm'
../../avr8\dict/nrww.inc(51): Including file '../../avr8\words/minus.asm'
../../avr8\dict/nrww.inc(52): Including file '../../avr8\words/plus.asm'
../../avr8\dict/nrww.inc(53): Including file '../../avr8\words/mstar.asm'
../../avr8\dict/nrww.inc(54): Including file '../../avr8\words/umslashmod.asm'
../../avr8\dict/nrww.inc(55): Including file '../../avr8\words/umstar.asm'
../../avr8\dict/nrww.inc(57): Including file '../../avr8\words/invert.asm'
../../avr8\dict/nrww.inc(58): Including file '../../avr8\words/2slash.asm'
../../avr8\dict/nrww.inc(59): Including file '../../avr8\words/2star.asm'
../../avr8\dict/nrww.inc(60): Including file '../../avr8\words/and.asm'
../../avr8\dict/nrww.inc(61): Including file '../../avr8\words/or.asm'
../../avr8\dict/nrww.inc(62): Including file '../../avr8\words/xor.asm'
../../avr8\dict/nrww.inc(64): Including file '../../avr8\words/1plus.asm'
../../avr8\dict/nrww.inc(65): Including file '../../avr8\words/1minus.asm'
../../avr8\dict/nrww.inc(66): Including file '../../avr8\words/lshift.asm'
../../avr8\dict/nrww.inc(67): Including file '../../avr8\words/rshift.asm'
../../avr8\dict/nrww.inc(68): Including file '../../avr8\words/plusstore.asm'
../../avr8\dict/nrww.inc(70): Including file '../../avr8\words/rpfetch.asm'
../../avr8\dict/nrww.inc(71): Including file '../../avr8\words/rpstore.asm'
../../avr8\dict/nrww.inc(72): Including file '../../avr8\words/spfetch.asm'
../../avr8\dict/nrww.inc(73): Including file '../../avr8\words/spstore.asm'
../../avr8\dict/nrww.inc(75): Including file '../../avr8\words/dodo.asm'
../../avr8\dict/nrww.inc(76): Including file '../../avr8\words/i.asm'
../../avr8\dict/nrww.inc(77): Including file '../../avr8\words/doplusloop.asm'
../../avr8\dict/nrww.inc(78): Including file '../../avr8\words/doloop.asm'
../../avr8\dict/nrww.inc(79): Including file '../../avr8\words/unloop.asm'
../../avr8\dict/nrww.inc(83): Including file '../../avr8\words/cmove_g.asm'
../../avr8\dict/nrww.inc(84): Including file '../../avr8\words/byteswap.asm'
../../avr8\dict/nrww.inc(85): Including file '../../avr8\words/up.asm'
../../avr8\dict/nrww.inc(86): Including file '../../avr8\words/1ms.asm'
../../avr8\dict/nrww.inc(87): Including file '../../avr8\words/2to_r.asm'
../../avr8\dict/nrww.inc(88): Including file '../../avr8\words/2r_from.asm'
../../avr8\dict/nrww.inc(90): Including file '../../avr8\words/store-e.asm'
../../avr8\dict/nrww.inc(91): Including file '../../avr8\words/fetch-e.asm'
../../avr8\dict/nrww.inc(92): Including file '../../avr8\words/store-i.asm'
../../avr8\dict/nrww.inc(96): Including file '../../avr8\words/store-i_nrww.asm'
../../avr8\dict/nrww.inc(98): Including file '../../avr8\words/fetch-i.asm'
../../avr8\dict/nrww.inc(103): Including file '../../avr8\dict/core_4k.inc'
../../avr8\dict/core_4k.inc(3): Including file '../../avr8\words/n_to_r.asm'
../../avr8\dict/core_4k.inc(4): Including file '../../avr8\words/n_r_from.asm'
../../avr8\dict/core_4k.inc(5): Including file '../../avr8\words/d-2star.asm'
../../avr8\dict/core_4k.inc(6): Including file '../../avr8\words/d-2slash.asm'
../../avr8\dict/core_4k.inc(7): Including file '../../avr8\words/d-plus.asm'
../../avr8\dict/core_4k.inc(8): Including file '../../avr8\words/d-minus.asm'
../../avr8\dict/core_4k.inc(9): Including file '../../avr8\words/d-invert.asm'
../../avr8\dict/core_4k.inc(10): Including file '../../avr8\words/slashmod.asm'
../../avr8\dict/core_4k.inc(11): Including file '../../avr8\words/abs.asm'
../../avr8\dict/core_4k.inc(12): Including file '../../common\words/pick.asm'
../../avr8\dict/core_4k.inc(13): Including file '../../avr8\words/cellplus.asm'
../../avr8\dict/core_4k.inc(14): Including file '../../avr8\dict/interrupt.inc'
../../avr8\dict/interrupt.inc(2): Including file '../../avr8\words/int-on.asm'
../../avr8\dict/interrupt.inc(3): Including file '../../avr8\words/int-off.asm'
../../avr8\dict/interrupt.inc(4): Including file '../../avr8\words/int-store.asm'
../../avr8\dict/interrupt.inc(5): Including file '../../avr8\words/int-fetch.asm'
../../avr8\dict/interrupt.inc(6): Including file '../../avr8\words/int-trap.asm'
../../avr8\dict/interrupt.inc(8): Including file '../../avr8\words/isr-exec.asm'
../../avr8\dict/interrupt.inc(9): Including file '../../avr8\words/isr-end.asm'
../../avr8\dict/core_4k.inc(17): Including file '../../common\words/prompt-ok.asm'
../../avr8\dict/core_4k.inc(18): Including file '../../common\words/prompt-ready.asm'
../../avr8\dict/core_4k.inc(19): Including file '../../common\words/prompt-error.asm'
../../avr8\dict/core_4k.inc(21): Including file '../../common\words/quit.asm'
../../avr8\dict/core_4k.inc(22): Including file '../../avr8\words/pause.asm'
../../avr8\dict/core_4k.inc(23): Including file '../../avr8\words/cold.asm'
../../avr8\dict/core_4k.inc(24): Including file '../../avr8\words/warm.asm'
../../avr8\dict/core_4k.inc(26): Including file '../../common\words/handler.asm'
../../avr8\dict/core_4k.inc(27): Including file '../../common\words/catch.asm'
../../avr8\dict/core_4k.inc(28): Including file '../../common\words/throw.asm'
../../avr8\dict/core_4k.inc(31): Including file '../../avr8\words/edefer-fetch.asm'
../../avr8\dict/core_4k.inc(32): Including file '../../avr8\words/edefer-store.asm'
../../avr8\dict/core_4k.inc(33): Including file '../../common\words/rdefer-fetch.asm'
../../avr8\dict/core_4k.inc(34): Including file '../../common\words/rdefer-store.asm'
../../avr8\dict/core_4k.inc(35): Including file '../../common\words/udefer-fetch.asm'
../../avr8\dict/core_4k.inc(36): Including file '../../common\words/udefer-store.asm'
../../avr8\dict/core_4k.inc(37): Including file '../../common\words/defer-store.asm'
../../avr8\dict/core_4k.inc(38): Including file '../../common\words/defer-fetch.asm'
../../avr8\dict/core_4k.inc(39): Including file '../../avr8\words/do-defer.asm'
../../avr8\dict/core_4k.inc(41): Including file '../../avr8\words/d-equal.asm'
../../avr8\dict/core_4k.inc(42): Including file '../../common\words/u-dot.asm'
../../avr8\dict/core_4k.inc(43): Including file '../../common\words/u-dot-r.asm'
../../avr8\dict/core_4k.inc(46): Including file '../../avr8\words/uslashmod.asm'
../../avr8\dict/core_4k.inc(47): Including file '../../avr8\words/negate.asm'
../../avr8\dict/core_4k.inc(48): Including file '../../common\words/slash.asm'
../../avr8\dict/core_4k.inc(49): Including file '../../common\words/mod.asm'
../../avr8\dict/core_4k.inc(51): Including file '../../common\words/min.asm'
../../avr8\dict/core_4k.inc(52): Including file '../../common\words/max.asm'
../../avr8\dict/core_4k.inc(53): Including file '../../common\words/within.asm'
../../avr8\dict/core_4k.inc(55): Including file '../../common\words/show-wordlist.asm'
../../avr8\dict/core_4k.inc(56): Including file '../../avr8\words/words.asm'
../../avr8\dict/core_4k.inc(58): Including file '../../common\words/dot-quote.asm'
../../avr8\dict/core_4k.inc(59): Including file '../../common\words/squote.asm'
../../avr8\dict/core_4k.inc(60): Including file '../../avr8\words/fill.asm'
../../avr8\dict/core_4k.inc(62): Including file '../../common\words/f_cpu.asm'
../../avr8\dict/core_4k.inc(63): Including file '../../avr8\words/state.asm'
../../avr8\dict/core_4k.inc(64): Including file '../../common\words/base.asm'
../../avr8\dict/core_4k.inc(66): Including file '../../avr8\words/cells.asm'
../../avr8\dict/core_4k.inc(68): Including file '../../common\words/2dup.asm'
../../avr8\dict/core_4k.inc(69): Including file '../../common\words/2drop.asm'
../../avr8\dict/core_4k.inc(70): Including file '../../common\words/tuck.asm'
../../avr8\dict/core_4k.inc(72): Including file '../../common\words/to-in.asm'
../../avr8\dict/core_4k.inc(73): Including file '../../avr8\words/sharptib.asm'
../../avr8\dict/core_4k.inc(74): Including file '../../avr8\words/pad.asm'
../../avr8\dict/core_4k.inc(75): Including file '../../avr8\words/emit.asm'
../../avr8\dict/core_4k.inc(76): Including file '../../avr8\words/emitq.asm'
../../avr8\dict/core_4k.inc(77): Including file '../../avr8\words/key.asm'
../../avr8\dict/core_4k.inc(78): Including file '../../avr8\words/keyq.asm'
../../avr8\dict/core_4k.inc(80): Including file '../../avr8\words/dp.asm'
../../avr8\dict/core_4k.inc(81): Including file '../../avr8\words/ehere.asm'
../../avr8\dict/core_4k.inc(82): Including file '../../avr8\words/here.asm'
../../avr8\dict/core_4k.inc(83): Including file '../../avr8\words/allot.asm'
../../avr8\dict/core_4k.inc(85): Including file '../../common\words/bin.asm'
../../avr8\dict/core_4k.inc(86): Including file '../../common\words/decimal.asm'
../../avr8\dict/core_4k.inc(87): Including file '../../common\words/hex.asm'
../../avr8\dict/core_4k.inc(88): Including file '../../common\words/bl.asm'
../../avr8\dict/core_4k.inc(90): Including file '../../avr8\words/turnkey.asm'
../../avr8\dict/core_4k.inc(91): Including file '../../common\words/to-upper.asm'
../../avr8\dict/core_4k.inc(92): Including file '../../common\words/to-lower.asm'
../../avr8\dict/core_4k.inc(94): Including file '../../common\words/q-stack.asm'
../../avr8\dict/core_4k.inc(95): Including file '../../common\words/bounds.asm'
../../avr8\dict/core_4k.inc(96): Including file '../../common\words/cr.asm'
../../avr8\dict/core_4k.inc(97): Including file '../../common\words/space.asm'
../../avr8\dict/core_4k.inc(98): Including file '../../common\words/spaces.asm'
../../avr8\dict/core_4k.inc(99): Including file '../../common\words/s-to-d.asm'
../../avr8\dict/core_4k.inc(100): Including file '../../avr8\words/to-body.asm'
../../avr8\dict/nrww.inc(111): Including file '../../avr8\words/2literal.asm'
../../avr8\dict/nrww.inc(112): Including file '../../avr8\words/equal.asm'
../../avr8\dict/nrww.inc(113): Including file '../../common\words/num-constants.asm'
../../avr8\amforth.asm(25): Including file 'dict_appl_core.inc'
../../avr8\amforth.asm(36): Including file '../../avr8\amforth-eeprom.inc'
                 
                 
                 ; file see ../template/template.asm. You may want to
                 ; copy that file to this one and edit it afterwards.
                 
                 .include "preamble.inc"
                 
                 .include "macros.asm"
                 
                 .set DICT_COMPILER2 = 0 ;
                 .set cpu_msp430 = 0
                 .set cpu_avr8   = 1
                 
                 .include "user.inc"
                 
                 ; 
                 
                 ; used by the multitasker
                 .set USER_STATE    = 0
                 .set USER_FOLLOWER = 2
                 
                 ; stackpointer, used by mulitasker
                 .set USER_RP      = 4
                 .set USER_SP0     = 6
                 .set USER_SP      = 8
                 
                 ; excpection handling
                 .set USER_HANDLER = 10
                 
                 ; numeric IO
                 .set USER_BASE  = 12
                 
                 ; character IO 
                 .set USER_EMIT  = 14
                 .set USER_EMITQ = 16
                 .set USER_KEY   = 18
                 .set USER_KEYQ  = 20
                 
                 .set USER_SOURCE  = 22
                 .set USER_TO_IN   = 24
                 .set USER_REFILL  = 26
                 
                 .set SYSUSERSIZE = 28
                 ; 
                 
                   .def zerol = r2
                   .def zeroh = r3
                   .def upl = r4
                   .def uph = r5
                 
                   .def al  = r6
                   .def ah  = r7
                   .def bl  = r8
                   .def bh  = r9
                 
                 ; internal
                   .def mcu_boot      = r10
                   .def erase_counter = r11
                 
                   .def temp4 = r14
                   .def temp5 = r15
                 
                   .def temp0 = r16
                   .def temp1 = r17
                   .def temp2 = r18
                   .def temp3 = r19
                 
                   .def temp6 = r20
                   .def temp7 = r21
                 
                   .def tosl = r24
                   .def tosh = r25
                 
                   .def wl = r22
                   .def wh = r23
                 
                 .macro loadtos
                     ld tosl, Y+
                     ld tosh, Y+
                 .endmacro
                 
                 .macro savetos
                     st -Y, tosh
                     st -Y, tosl
                 .endmacro
                 
                 .macro in_
                 .if (@1 < $40)
                   in @0,@1
                 .else
                   lds @0,@1
                 .endif
                 .endmacro
                 
                 .macro out_
                 .if (@0 < $40)
                   out @0,@1
                 .else
                   sts @0,@1
                 .endif
                 .endmacro
                 
                 .macro sbi_
                 .if (@0 < $40)
                   sbi @0,@1
                 .else
                   in_ @2,@0
                   ori @2,exp2(@1)
                   out_ @0,@2
                 .endif
                 .endmacro
                 
                 .macro cbi_
                 .if (@0 < $40)
                   cbi @0,@1
                 .else
                   in_ @2,@0
                   andi @2,~(exp2(@1))
                   out_ @0,@2
                 .endif
                 .endmacro
                 
                 .macro jmp_
                 	; a more flexible macro
                     .ifdef @0
                     .if (@0-pc > 2040) || (pc-@0>2040)
                 	jmp @0
                 	.else
                 	rjmp @0
                 	.endif
                 	.else
                 	jmp @0
                 	.endif
                 .endmacro
                 .macro call_
                 	; a more flexible macro
                     .ifdef @0
                     .if (@0-pc > 2040) || (pc-@0>2040)
                 	call @0
                 	.else
                 	rcall @0
                 	.endif
                 	.else
                 	call @0
                 	.endif
                 .endmacro
                 
                 ;               F_CPU
                 ;    µsec   16000000   14745600    8000000  1000000
                 ;    1            16      14,74          8        1
                 ;    10          160     147,45         80       10
                 ;    100        1600    1474,56        800      100
                 ;    1000      16000   14745,6        8000     1000
                 ;
                 ; cycles = µsec * f_cpu / 1e6
                 ; n_loops=cycles/5
                 ;
                 ;     cycles already used will be subtracted from the delay
                 ;     the waittime resolution is 1 cycle (delay from exact to +1 cycle)
                 ;     the maximum delay at 20MHz (50ns/clock) is 38350ns
                 ;     waitcount register must specify an immediate register
                 ;
                 ; busy waits a specfied amount of microseconds
                 .macro   delay
                       .set cycles = ( ( @0 * F_CPU ) / 1000000 )
                       .if (cycles > ( 256 * 255 * 4 + 2))
                         .error "MACRO delay - too many cycles to burn"
                       .else
                         .if (cycles > 6)
                           .set  loop_cycles = (cycles / 4)      
                           ldi   zl,low(loop_cycles)
                           ldi   zh,high(loop_cycles)
                           sbiw  Z, 1
                           brne  pc-1
                           .set  cycles = (cycles - (loop_cycles * 4))
                         .endif
                         .if (cycles > 0)
                           .if   (cycles & 4)
                             rjmp  pc+1
                             rjmp  pc+1
                           .endif
                           .if   (cycles & 2)
                             rjmp  pc+1
                           .endif
                           .if   (cycles & 1)
                             nop
                           .endif
                         .endif
                       .endif
                 .endmacro
                 
                 ; portability macros, they come from the msp430 branches
                 
                 .macro DEST
                     .dw @0
                 .endm
                 
                 ; controller specific file selected via include
                 ; directory definition when calling the assembler (-I)
                 .include "device.asm"
                 
                 ; generated automatically, do not edit
                 
                 .list
                 
                 .equ ramstart =  256
                 .equ CELLSIZE = 2
                 .macro readflashcell
                 	lsl zl
                 	rol zh
                 	lpm @0, Z+
                 	lpm @1, Z+
                 .endmacro
                 .macro writeflashcell
                 	lsl zl
                 	rol zh
                 .endmacro
                 .set WANT_USART0 = 0
                 .set WANT_TWI = 0
                 .set WANT_TIMER_COUNTER_1 = 0
                 .set WANT_TIMER_COUNTER_2 = 0
                 .set WANT_AD_CONVERTER = 0
                 .set WANT_ANALOG_COMPARATOR = 0
                 .set WANT_PORTB = 0
                 .set WANT_PORTC = 0
                 .set WANT_PORTD = 0
                 .set WANT_TIMER_COUNTER_0 = 0
                 .set WANT_EXTERNAL_INTERRUPT = 0
                 .set WANT_SPI = 0
                 .set WANT_WATCHDOG = 0
                 .set WANT_CPU = 0
                 .set WANT_EEPROM = 0
                 .equ intvecsize = 2 ; please verify; flash size: 32768 bytes
                 .equ pclen = 2 ; please verify
                 .overlap
                 .org 2
000002 d114      	 rcall isr ; External Interrupt Request 0
                 .org 4
000004 d112      	 rcall isr ; External Interrupt Request 1
                 .org 6
000006 d110      	 rcall isr ; Pin Change Interrupt Request 0
                 .org 8
000008 d10e      	 rcall isr ; Pin Change Interrupt Request 0
                 .org 10
00000a d10c      	 rcall isr ; Pin Change Interrupt Request 1
                 .org 12
00000c d10a      	 rcall isr ; Watchdog Time-out Interrupt
                 .org 14
00000e d108      	 rcall isr ; Timer/Counter2 Compare Match A
                 .org 16
000010 d106      	 rcall isr ; Timer/Counter2 Compare Match A
                 .org 18
000012 d104      	 rcall isr ; Timer/Counter2 Overflow
                 .org 20
000014 d102      	 rcall isr ; Timer/Counter1 Capture Event
                 .org 22
000016 d100      	 rcall isr ; Timer/Counter1 Compare Match A
                 .org 24
000018 d0fe      	 rcall isr ; Timer/Counter1 Compare Match B
                 .org 26
00001a d0fc      	 rcall isr ; Timer/Counter1 Overflow
                 .org 28
00001c d0fa      	 rcall isr ; TimerCounter0 Compare Match A
                 .org 30
00001e d0f8      	 rcall isr ; TimerCounter0 Compare Match B
                 .org 32
000020 d0f6      	 rcall isr ; Timer/Couner0 Overflow
                 .org 34
000022 d0f4      	 rcall isr ; SPI Serial Transfer Complete
                 .org 36
000024 d0f2      	 rcall isr ; USART Rx Complete
                 .org 38
000026 d0f0      	 rcall isr ; USART, Data Register Empty
                 .org 40
000028 d0ee      	 rcall isr ; USART Tx Complete
                 .org 42
00002a d0ec      	 rcall isr ; ADC Conversion Complete
                 .org 44
00002c d0ea      	 rcall isr ; EEPROM Ready
                 .org 46
00002e d0e8      	 rcall isr ; Analog Comparator
                 .org 48
000030 d0e6      	 rcall isr ; Two-wire Serial Interface
                 .org 50
000032 d0e4      	 rcall isr ; Store Program Memory Read
                 .equ INTVECTORS = 26
                 .nooverlap
                 
                 ; compatability layer (maybe empty)
                 .equ SPMEN = SELFPRGEN
                 
                 ; controller data area, environment query mcu-info
                 mcu_info:
                 mcu_ramsize:
000033 0800      	.dw 2048
                 mcu_eepromsize:
000034 0400      	.dw 1024
                 mcu_maxdp:
000035 7000      	.dw 28672 
                 mcu_numints:
000036 001a      	.dw 26
                 mcu_name:
000037 000a      	.dw 10
000038 5441
000039 656d
00003a 6167
00003b 3233
00003c 5038      	.db "ATmega328P"
                 .set codestart=pc
                 
                 ; some defaults, change them in your application master file
                 ; see template.asm for an example
                 
                 .set AMFORTH_RO_SEG = NRWW_START_ADDR
                 
                 ; receiving is asynchron, so an interrupt queue is useful.
                 .set WANT_ISR_RX = 1
                 
                 ; case insensitve dictionary lookup.
                 .set WANT_IGNORECASE = 0
                 
                 ; map all memories to one address space. Details in the
                 ; technical guide
                 .set WANT_UNIFIED = 0
                 
                 ; terminal input buffer
                 .set TIBSIZE  = 90    ; ANS94 needs at least 80 characters per line
                 
                 ; USER variables *in addition* to system ones
                 .set APPUSERSIZE = 10  ; size of application specific user area in bytes
                 
                 ; addresses of various data segments
                 .set rstackstart = RAMEND      ; start address of return stack, grows downward
                 .set stackstart  = RAMEND - 80 ; start address of data stack, grows downward
                 ; change only if you know what to you do
                 .set NUMWORDLISTS = 8 ; number of word lists in the searh order, at least 8
                 .set NUMRECOGNIZERS = 4 ; total number of recognizers, two are always used.
                 
                 ; 10 per mille (1 per cent) is ok.
                 .set BAUD = 38400
                 .set BAUD_MAXERROR = 10
                 
                 ; Dictionary setup
                 .set VE_HEAD = $0000
                 .set VE_ENVHEAD = $0000
                 
                 
                 .set AMFORTH_RO_SEG = NRWW_START_ADDR+1
                 
                 ; cpu clock in hertz
                 .equ F_CPU = 16000000
                 .set BAUD_MAXERROR = 30
                 .equ TIMER_INT = OVF2addr
                 
                 .include "drivers/usart_0.asm"
                 
                   .equ BAUDRATE_HIGH = UBRR0H
                   .equ USART_C = UCSR0C
                   .equ USART_B = UCSR0B
                   .equ USART_A = UCSR0A
                   .equ USART_DATA = UDR0
                   .ifndef URXCaddr
                   .endif
                 
                 .equ bm_USART_RXRD = 1 << RXC0
                 .equ bm_USART_TXRD = 1 << UDRE0
                 .equ bm_ENABLE_TX  = 1 << TXEN0
                 .equ bm_ENABLE_RX  = 1 << RXEN0
                 .equ bm_ENABLE_INT_RX = 1<<RXCIE0
                 .equ bm_ENABLE_INT_TX = 1<<UDRIE0
                 
                 .equ bm_USARTC_en   = 0
                 .equ bm_ASYNC       = 0 << 6
                 .equ bm_SYNC        = 1 << 6
                 .equ bm_NO_PARITY   = 0 << 4
                 .equ bm_EVEN_PARITY = 2 << 4
                 .equ bm_ODD_PARITY  = 3 << 4
                 .equ bm_1STOPBIT    = 0 << 3
                 .equ bm_2STOPBIT    = 1 << 3
                 .equ bm_5BIT        = 0 << 1
                 .equ bm_6BIT        = 1 << 1
                 .equ bm_7BIT        = 2 << 1
                 .equ bm_8BIT        = 3 << 1
                 
                 .include "drivers/usart_common.asm"
                 
                 .set USART_C_VALUE = bm_ASYNC | bm_NO_PARITY | bm_1STOPBIT | bm_8BIT
                 .if WANT_ISR_RX == 1
                   .set USART_B_VALUE = bm_ENABLE_TX | bm_ENABLE_RX | bm_ENABLE_INT_RX
                   .include "drivers/usart-isr-rx.asm"
                 
                 
                 ; sizes have to be powers of 2!
                 .equ usart_rx_size = $10
                 .equ usart_rx_mask = usart_rx_size - 1
                 .dseg
000100           usart_rx_data: .byte usart_rx_size+2
000112           usart_rx_in: .byte 2
000114           usart_rx_out: .byte 2
                 
                 .cseg
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 ; forth code:
                 ; : rx-isr USART_DATA c@
                 ;    usart_rx_data usart_rx_in c@ dup >r
                 ;    + !
                 ;    r> 1+ usart_rx_mask and usart_rx_in c!
                 ; ;
                 ; setup with
                 ; ' rx-isr URXCaddr int!
                 usart_rx_isr:
00003d 93af        push xl
00003e b7af        in xl, SREG
00003f 93af        push xl
000040 93bf        push xh
000041 93ef        push zl
000042 93ff        push zh
                 
000043 91b0 00c6   lds xh, USART_DATA
                 usart_rx_store:
000045 91a0 0112   lds xl, usart_rx_in
000047 e0e0        ldi zl, low(usart_rx_data)
000048 e0f1        ldi zh, high(usart_rx_data)
000049 0fea        add zl, xl
00004a 1df3        adc zh, zeroh
00004b 83b0        st Z, xh
                 
00004c 95a3        inc xl
00004d 70af        andi xl,usart_rx_mask
                 
00004e 93a0 0112   sts usart_rx_in, xl
                 
                 usart_rx_isr_finish:
000050 91ff        pop zh
000051 91ef        pop zl
000052 91bf        pop xh
000053 91af        pop xl
000054 bfaf        out SREG, xl
000055 91af        pop xl
000056 9518        reti
                 
                 .set usartpc = pc
                 .org URXCaddr
000024 c018        jmp_ usart_rx_isr
                 .org usartpc
                 
                 
                 ; ( -- ) Hardware Access
                 ; R( --)
                 ; initialize usart
                 ;VE_USART_INIT_RX:
                 ;  .dw $ff06
                 ;  .db "+usart"
                 ;  .dw VE_HEAD
                 ;  .set VE_HEAD = VE_USART_INIT_RX
                 XT_USART_INIT_RX_ISR:
000057 3801        .dw DO_COLON
                 PFA_USART_INIT_RX_ISR:          ; ( -- )
000058 394f        .dw XT_ZERO
000059 3838        .dw XT_DOLITERAL
00005a 0112        .dw usart_rx_in
00005b 3888        .dw XT_CSTORE
00005c 394f        .dw XT_ZERO
00005d 3838        .dw XT_DOLITERAL
00005e 0114        .dw usart_rx_out
00005f 3888        .dw XT_CSTORE
                 
000060 381b        .dw XT_EXIT
                 
                 ; ( -- c)
                 ; MCU
                 ; get 1 character from input queue, wait if needed using interrupt driver
                 VE_RX_ISR:
000061 ff06          .dw $ff06
000062 7872
000063 692d
000064 7273          .db "rx-isr"
000065 0000          .dw VE_HEAD
                     .set VE_HEAD = VE_RX_ISR
                 XT_RX_ISR:
000066 3801          .dw DO_COLON
                 PFA_RX_ISR:
000067 0080        .dw XT_RXQ_ISR
000068 3831        .dw XT_DOCONDBRANCH
000069 0067        .dw PFA_RX_ISR
00006a 3838        .dw XT_DOLITERAL
00006b 0114        .dw usart_rx_out
00006c 3893        .dw XT_CFETCH
00006d 38ac        .dw XT_DUP
00006e 3a2a        .dw XT_1PLUS
00006f 3838        .dw XT_DOLITERAL
000070 000f        .dw usart_rx_mask
000071 3a0e        .dw XT_AND
000072 3838        .dw XT_DOLITERAL
000073 0114        .dw usart_rx_out
000074 3888        .dw XT_CSTORE
000075 3838        .dw XT_DOLITERAL
000076 0100        .dw usart_rx_data
000077 3998        .dw XT_PLUS
000078 3893        .dw XT_CFETCH
000079 381b        .dw XT_EXIT
                 
                 ; ( -- f)  
                 ; MCU
                 ; check if unread characters are in the input queue using interrupt driver
                 VE_RXQ_ISR:
00007a ff07          .dw $ff07
00007b 7872
00007c 2d3f
00007d 7369
00007e 0072          .db "rx?-isr",0
00007f 0061          .dw VE_HEAD
                     .set VE_HEAD = VE_RXQ_ISR
                 XT_RXQ_ISR:
000080 3801          .dw DO_COLON
                 PFA_RXQ_ISR:
000081 3d12        .dw XT_PAUSE
000082 3838        .dw XT_DOLITERAL
000083 0114        .dw usart_rx_out
000084 3893        .dw XT_CFETCH
000085 3838        .dw XT_DOLITERAL
000086 0112        .dw usart_rx_in
000087 3893        .dw XT_CFETCH
000088 390e        .dw XT_NOTEQUAL
000089 381b        .dw XT_EXIT
                   .set XT_RX  = XT_RX_ISR
                   .set XT_RXQ = XT_RXQ_ISR
                   .set XT_USART_INIT_RX = XT_USART_INIT_RX_ISR
                 .else
                 .endif
                 
                 .include "words/usart-tx-poll.asm"
                 
                 ; MCU
                 ; check availability and send one character to the terminal using register poll
                 VE_TX_POLL:
00008a ff07          .dw $ff07
00008b 7874
00008c 702d
00008d 6c6f
00008e 006c          .db "tx-poll",0
00008f 007a          .dw VE_HEAD
                     .set VE_HEAD = VE_TX_POLL
                 XT_TX_POLL:
000090 3801          .dw DO_COLON
                 PFA_TX_POLL:
                   ; wait for data ready
000091 009e        .dw XT_TXQ_POLL
000092 3831        .dw XT_DOCONDBRANCH
000093 0091        .dw PFA_TX_POLL
                   ; send to usart
000094 3838        .dw XT_DOLITERAL
000095 00c6        .dw USART_DATA
000096 3888        .dw XT_CSTORE
000097 381b        .dw XT_EXIT
                 
                 ; ( -- f) MCU
                 ; MCU
                 ; check if a character can be send using register poll
                 VE_TXQ_POLL:
000098 ff08          .dw $ff08
000099 7874
00009a 2d3f
00009b 6f70
00009c 6c6c          .db "tx?-poll"
00009d 008a          .dw VE_HEAD
                     .set VE_HEAD = VE_TXQ_POLL
                 XT_TXQ_POLL:
00009e 3801          .dw DO_COLON
                 PFA_TXQ_POLL:
00009f 3d12        .dw XT_PAUSE
0000a0 3838        .dw XT_DOLITERAL
0000a1 00c0        .dw USART_A
0000a2 3893        .dw XT_CFETCH
0000a3 3838        .dw XT_DOLITERAL
0000a4 0020        .dw bm_USART_TXRD
0000a5 3a0e        .dw XT_AND
0000a6 381b        .dw XT_EXIT
                 .set XT_TX  = XT_TX_POLL
                 .set XT_TXQ = XT_TXQ_POLL
                 .set XT_USART_INIT_TX = 0
                 
                 .include "words/ubrr.asm"
                 
                 ; MCU
                 ; returns usart UBRR settings
                 VE_UBRR:
0000a7 ff04        .dw $ff04
0000a8 6275
0000a9 7272        .db "ubrr"
0000aa 0098        .dw VE_HEAD
                   .set VE_HEAD = VE_UBRR
                 XT_UBRR:
0000ab 386a        .dw PFA_DOVALUE1
                 PFA_UBRR:          ; ( -- )
0000ac 0086        .dw EE_UBRRVAL
0000ad 3d82        .dw XT_EDEFERFETCH
0000ae 3d8c        .dw XT_EDEFERSTORE
                 .include "words/usart.asm"
                 
                 ; MCU
                 ; initialize usart
                 VE_USART:
0000af ff06        .dw $ff06
0000b0 752b
0000b1 6173
0000b2 7472        .db "+usart"
0000b3 00a7        .dw VE_HEAD
                   .set VE_HEAD = VE_USART
                 XT_USART:
0000b4 3801        .dw DO_COLON
                 PFA_USART:          ; ( -- )
                 
0000b5 3838        .dw XT_DOLITERAL
0000b6 0098        .dw USART_B_VALUE
0000b7 3838        .dw XT_DOLITERAL
0000b8 00c1        .dw USART_B
0000b9 3888        .dw XT_CSTORE
                 
0000ba 3838        .dw XT_DOLITERAL
0000bb 0006        .dw USART_C_VALUE
0000bc 3838        .dw XT_DOLITERAL
0000bd 00c2        .dw USART_C | bm_USARTC_en
0000be 3888        .dw XT_CSTORE
                 
0000bf 00ab        .dw XT_UBRR
0000c0 38ac        .dw XT_DUP
0000c1 3ae8        .dw XT_BYTESWAP
0000c2 3838        .dw XT_DOLITERAL
0000c3 00c5        .dw BAUDRATE_HIGH
0000c4 3888        .dw XT_CSTORE
0000c5 3838        .dw XT_DOLITERAL
0000c6 00c4        .dw BAUDRATE_LOW
0000c7 3888        .dw XT_CSTORE
                 .if XT_USART_INIT_RX!=0
0000c8 0057        .dw XT_USART_INIT_RX
                 .endif
                 .if XT_USART_INIT_TX!=0
                 .endif
                 
0000c9 381b        .dw XT_EXIT
                 
                 ; settings for 1wire interface
                 .equ OW_PORT=PORTB
                 .EQU OW_BIT=4
                 .include "drivers/1wire.asm"
                 
                 ;   B. J. Rodriguez (MSP 430)
                 ;   Matthias Trute (AVR Atmega)
                 ; COPYRIGHT
                 ;   (c) 2012 Bradford J. Rodriguez for the 430 code and API
                 
                 ;  adapted 430 assembly code to AVR
                 ;  wishlist: 
                 ;     use a configurable pin at runtime, compatible with bitnames.frt
                 ;     no external pull up, no external power supply for devices
                 ;     ???
                 ;
                 ;.EQU OW_BIT=4
                 ;.equ OW_PORT=PORTE
                 .set OW_DDR=(OW_PORT-1)
                 .set OW_PIN=(OW_DDR-1)
                 
                 ;****f* 1W.RESET
                 ; NAME
                 ;   1W.RESET
                 ; SYNOPSIS
                 ;   1W.RESET ( -- f )  Initialize 1-wire devices; return true if present
                 ; DESCRIPTION
                 ;   This configures the port pin used by the 1-wire interface, and then
                 ;   sends an "initialize" sequence to the 1-wire devices.  If any device
                 ;   is present, it will be detected.
                 ;
                 ;   Timing, per DS18B20 data sheet:
                 ;   a) Output "0" (drive output low) for >480 usec.
                 ;   b) Output "1" (let output float).
                 ;   c) After 15 to 60 usec, device will drive pin low for 60 to 240 usec.
                 ;      So, wait 75 usec and sample input.
                 ;   d) Leave output high (floating) for at least 480 usec.
                 ;******
                 ; ( -- f )
                 ; Hardware
                 ; Initialize 1-wire devices; return true if present
                 VE_OW_RESET:
0000ca ff08          .dw $ff08
0000cb 7731
0000cc 722e
0000cd 7365
0000ce 7465          .db "1w.reset"
0000cf 00af          .dw VE_HEAD
                     .set VE_HEAD = VE_OW_RESET
                 XT_OW_RESET:
0000d0 00d1          .dw PFA_OW_RESET
                 PFA_OW_RESET:
0000d1 939a
0000d2 938a          savetos
0000d3 2799          clr tosh
                     ; setup to output
0000d4 9a24          sbi OW_DDR, OW_BIT
                     ; Pull output low
0000d5 982c          cbi OW_PORT, OW_BIT
                     ; Delay >480 usec        
0000d6 e8e0
0000d7 e0f7
0000d8 9731
0000d9 f7f1          DELAY   480
                     ; Critical timing period, disable interrupts.
0000da b71f          in temp1, SREG
0000db 94f8          cli
                     ; Pull output high
0000dc 9a2c          sbi OW_PORT, OW_BIT
                     ; make pin input, sends "1"
0000dd 9824          cbi OW_DDR, OW_BIT 
0000de e0e0
0000df e0f1
0000e0 9731
0000e1 f7f1          DELAY   64 ; delayB
                     ; Sample input pin, set TOS if input is zero
0000e2 b183          in tosl, OW_PIN
0000e3 ff84          sbrs tosl, OW_BIT
0000e4 ef9f          ser  tosh
                     ; End critical timing period, enable interrupts
0000e5 bf1f          out SREG, temp1
                     ; release bus
0000e6 9824          cbi OW_DDR, OW_BIT
0000e7 982c          cbi OW_PORT, OW_BIT
                 
                     ; Delay rest of 480 usec 
0000e8 e8e0
0000e9 e0f6
0000ea 9731
0000eb f7f1          DELAY   416
                     ; we now have the result flag in TOS        
0000ec 2f89          mov tosl, tosh
0000ed 940c 3805     jmp_ DO_NEXT
                     
                 ;****f* 1W.SLOT
                 ; NAME
                 ;   1W.SLOT
                 ; SYNOPSIS
                 ;   1W.SLOT ( c -- c' ) Write and read one bit to/from 1-wire.
                 ; DESCRIPTION
                 ;   The "touch byte" function is described in Dallas App Note 74.
                 ;   It outputs a byte to the 1-wire pin, LSB first, and reads back
                 ;   the state of the 1-wire pin after a suitable delay.
                 ;   To read a byte, output $FF and read the reply data.
                 ;   To write a byte, output that byte and discard the reply.
                 ;
                 ;   This function performs one bit of the "touch" operation --
                 ;   one read/write "slot" in Dallas jargon.  Perform this eight
                 ;   times in a row to get the "touch byte" function.
                 ;
                 ; PARAMETERS
                 ;   The input parameter is xxxxxxxxbbbbbbbo where
                 ;   'xxxxxxxx' are don't cares,
                 ;   'bbbbbbb' are bits to be shifted down, and
                 ;   'o' is the bit to be output in the slot.  This must be 1
                 ;   to create a read slot.
                 ;
                 ;   The returned value is xxxxxxxxibbbbbbb where
                 ;   'xxxxxxxx' are not known (the input shifted down 1 position),
                 ;   'i' is the bit read during the slot.  This has no meaning
                 ;   if it was a write slot.
                 ;   'bbbbbbb' are the 7 input bits, shifted down one position.
                 ;
                 ;   This peculiar parameter usage allows OWTOUCH to be written as
                 ;     OWSLOT OWSLOT OWSLOT OWSLOT OWSLOT OWSLOT OWSLOT OWSLOT 
                 ;
                 ; NOTES 
                 ;   Interrupts are disabled during each bit.
                 
                 ;   Timing, per DS18B20 data sheet:
                 ;   a) Output "0" for start period.  (> 1 us, < 15 us, typ. 6 us*)
                 ;   b) Output data bit (0 or 1), open drain 
                 ;   c) After MS from start of cycle, sample input (15 to 60 us, typ. 25 us*)
                 ;   d) After write-0 period from start of cycle, output "1" (>60 us)
                 ;   e) After recovery period, loop or return. (> 1 us)
                 ;   For writes, DS18B20 samples input 15 to 60 usec from start of cycle.
                 ;   * "Typical" values are per App Note 132 for a 300m cable length.
                 
                 ;   ---------        -------------------------------
                 ;            \      /                        /
                 ;             ------------------------------- 
                 ;            a      b          c             d     e
                 ;            |  6us |   19us   |    35us     | 2us |
                 ;******
                 ; ( c -- c' )
                 ; Hardware
                 ; Write and read one bit to/from 1-wire.
                 VE_OW_SLOT:
0000ef ff07          .dw $ff07
0000f0 7731
0000f1 732e
0000f2 6f6c
0000f3 0074          .db "1w.slot",0
0000f4 00ca          .dw VE_HEAD
                     .set VE_HEAD = VE_OW_SLOT
                 XT_OW_SLOT:
0000f5 00f6          .dw PFA_OW_SLOT
                 PFA_OW_SLOT:
                     ; pull low
0000f6 9a24          sbi OW_DDR, OW_BIT
0000f7 982c          cbi OW_PORT, OW_BIT
                     ; disable interrupts
0000f8 b71f          in temp1, SREG
0000f9 94f8          cli
0000fa e1e8
0000fb e0f0
0000fc 9731
0000fd f7f1          DELAY   6 ; DELAY A
                     ; check bit
0000fe 9488          clc
0000ff 9587          ror tosl
000100 f410          brcc PFA_OW_SLOT0 ; a 0 keeps the bus low
                       ; release bus, a 1 is written
000101 9824            cbi OW_DDR, OW_BIT
000102 9a2c            sbi OW_PORT, OW_BIT
                 PFA_OW_SLOT0:
                     ; sample the input (no action required if zero)
000103 e2e4
000104 e0f0
000105 9731
000106 f7f1          DELAY 9   ; wait DELAY E to sample
000107 b103          in temp0, OW_PIN
000108 fd04          sbrc temp0, OW_BIT
000109 6880          ori tosl, $80
                 
00010a ecec
00010b e0f0
00010c 9731
00010d f7f1          DELAY   51 ; DELAY B
00010e 9824          cbi OW_DDR, OW_BIT
00010f 9a2c          sbi OW_PORT, OW_BIT ; release bus
000110 e0e8
000111 e0f0
000112 9731
000113 f7f1          delay 2
                     ; re-enable interrupts
000114 bf1f          out SREG, temp1
000115 940c 3805     jmp_ DO_NEXT
                 
                 .include "amforth.asm"
                 
                 ;;;;
                 ;;;; GPL V2 (only)
                 
                 .set AMFORTH_NRWW_SIZE=(FLASHEND-AMFORTH_RO_SEG)*2
                 
                 .set corepc = pc
                 .org $0000
000000 940c 3d1b   jmp_ PFA_COLD
                 
                 .org corepc
                 .include "drivers/generic-isr.asm"
                 
                 .dseg
000116           intcur: .byte 1
                 .eseg
000000           intvec: .byte INTVECTORS * CELLSIZE
                 .cseg
                 
                 ; interrupt routine gets called (again) by rcall! This gives the
                 ; address of the int-vector on the stack.
                 isr:
000117 920a          st -Y, r0
000118 b60f          in r0, SREG
000119 920a          st -Y, r0
                 .if (pclen==3)
                 .endif
00011a 900f          pop r0
00011b 900f          pop r0          ; = intnum * intvectorsize + 1 (address following the rcall)
00011c 940a          dec r0
                 .if intvecsize == 1 ;
                 .endif
00011d 9200 0116     sts intcur, r0
00011f 9009          ld r0, Y+
000120 be0f          out SREG, r0
000121 9009          ld r0, Y+
000122 9468          set ; set the interrupt flag for the inner interpreter
000123 9508          ret ; returns the interrupt, the rcall stack frame is removed!
                 
                 ; lower part of the dictionary
                 .include "dict/rww.inc"
                 
                 
                 ; Arithmetics
                 ; add a number to a double cell
                 VE_MPLUS:
000124 ff02          .dw $ff02
000125 2b6d          .db "m+"
000126 00ef          .dw VE_HEAD
                     .set VE_HEAD = VE_MPLUS
                 XT_MPLUS:
000127 3801          .dw DO_COLON
                 PFA_MPLUS:
000128 3fb8          .dw XT_S2D
000129 3c05          .dw XT_DPLUS
00012a 381b          .dw XT_EXIT
                 .include "words/ud-star.asm"
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_UDSTAR:
00012b ff03          .dw $ff03
00012c 6475
../../common\words/ud-star.asm(9): warning: .cseg .db misalignment - padding zero byte
00012d 002a          .db "ud*"
00012e 0124          .dw VE_HEAD
                     .set VE_HEAD = VE_UDSTAR
                 XT_UDSTAR:
00012f 3801          .dw DO_COLON
                 PFA_UDSTAR:
                 
                 .endif
                 ;Z UD*      ud1 d2 -- ud3      32*16->32 multiply
                 ;   XT_DUP >R UM* DROP  XT_SWAP R> UM* ROT + ;
                 
000130 38ac
000131 38fa
000132 39db
000133 38d4              .DW XT_DUP,XT_TO_R,XT_UMSTAR,XT_DROP
000134 38bf
000135 38f1
000136 39db
000137 38dc
000138 3998
000139 381b              .DW XT_SWAP,XT_R_FROM,XT_UMSTAR,XT_ROT,XT_PLUS,XT_EXIT
                 .include "words/umax.asm"
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_UMAX:
00013a ff04          .dw $ff04
00013b 6d75
00013c 7861          .db "umax"
00013d 012b          .dw VE_HEAD
                     .set VE_HEAD = VE_UMAX
                 XT_UMAX:
00013e 3801          .dw DO_COLON
                 PFA_UMAX:
                 .endif
                 
00013f 3eb3
000140 3957              .DW XT_2DUP,XT_ULESS
000141 3831      	.dw XT_DOCONDBRANCH
000142 0144      	 DEST(UMAX1)
000143 38bf              .DW XT_SWAP
000144 38d4      UMAX1:  .DW XT_DROP
000145 381b      	.dw XT_EXIT
                 .include "words/umin.asm"
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_UMIN:
000146 ff04          .dw $ff04
000147 6d75
000148 6e69          .db "umin"
000149 013a          .dw VE_HEAD
                     .set VE_HEAD = VE_UMIN
                 XT_UMIN:
00014a 3801          .dw DO_COLON
                 PFA_UMIN:
                 .endif
00014b 3eb3
00014c 3962              .DW XT_2DUP,XT_UGREATER
00014d 3831      	.dw XT_DOCONDBRANCH
00014e 0150      	DEST(UMIN1)
00014f 38bf              .DW XT_SWAP
000150 38d4      UMIN1:  .DW XT_DROP
000151 381b      	.dw XT_EXIT
                 .include "words/immediate-q.asm"
                 
                 ; Tools
                 ; get count information out of a counted string in flash
                 ;VE_IMMEDIATEQ:
                 ;    .dw $ff06
                 ;    .db "immediate?"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_IMMEDIATEQ
                 XT_IMMEDIATEQ:
000152 3801          .dw DO_COLON
                 PFA_IMMEDIATEQ:
000153 3838          .dw XT_DOLITERAL
000154 8000          .dw $8000
000155 3a0e          .dw XT_AND
000156 3915          .dw XT_ZEROEQUAL
000157 3831          .dw XT_DOCONDBRANCH
000158 015c          DEST(IMMEDIATEQ1)
000159 3838           .dw XT_DOLITERAL
00015a 0001           .dw 1
00015b 381b           .dw XT_EXIT
                 IMMEDIATEQ1:
                     ; not immediate
00015c 3946          .dw XT_TRUE
00015d 381b          .dw XT_EXIT
                 .include "words/name2flags.asm"
                 
                 ; Tools
                 ; get the flags from a name token
                 VE_NAME2FLAGS:
00015e ff0a          .dw $ff0a
00015f 616e
000160 656d
000161 663e
000162 616c
000163 7367          .db "name>flags"
000164 0146          .dw VE_HEAD
                     .set VE_HEAD = VE_NAME2FLAGS
                 XT_NAME2FLAGS:
000165 3801          .dw DO_COLON
                 PFA_NAME2FLAGS:
000166 3bbb          .dw XT_FETCHI ; skip to link field
000167 3838          .dw XT_DOLITERAL
000168 ff00          .dw $ff00
000169 3a0e          .dw XT_AND
00016a 381b          .dw XT_EXIT
                 .include "words/name2interpret.asm"
                 
                 ; Tools (ext)
                 ; get the execution token from the name token
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_NAME2INTERPRET:
00016b ff0e          .dw $ff0e
00016c 616e
00016d 656d
00016e 693e
00016f 746e
000170 7265
000171 7270
000172 7465          .db "name>interpret"
000173 015e          .dw VE_HEAD
                     .set VE_HEAD = VE_NAME2INTERPRET
                 XT_NAME2INTERPRET:
000174 3801          .dw DO_COLON
                 PFA_NAME2INTERPRET:
                 .endif
000175 0705          .dw XT_NFA2CFA
000176 381b          .dw XT_EXIT
                 .include "words/name2compile.asm"
                 
                 ; Tools (ext)
                 ; get the execution token from the name token in compile state
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_NAME2COMPILE:
000177 ff0c          .dw $ff0c
000178 616e
000179 656d
00017a 633e
00017b 6d6f
00017c 6970
00017d 656c          .db "name>compile"
00017e 016b          .dw VE_HEAD
                     .set VE_HEAD = VE_NAME2COMPILE
                 XT_NAME2COMPILE:
00017f 3801          .dw DO_COLON
                 PFA_NAME2COMPILE:
                 .endif
000180 38ac          .dw XT_DUP
000181 0705          .dw XT_NFA2CFA
000182 38bf          .dw XT_SWAP
000183 0165          .dw XT_NAME2FLAGS
000184 0152          .dw XT_IMMEDIATEQ
000185 3831          .dw XT_DOCONDBRANCH
000186 018a          DEST(NAME2COMPILE1)
000187 3838      	.dw XT_DOLITERAL
000188 0761      	.dw XT_COMMA
000189 381b      	.dw XT_EXIT
                 NAME2COMPILE1:
00018a 3838      	.dw XT_DOLITERAL
00018b 3825      	.dw XT_EXECUTE
00018c 381b          .dw XT_EXIT
                 
                 .if AMFORTH_NRWW_SIZE > 8000
                 .elif AMFORTH_NRWW_SIZE > 4000
                 .include "dict/appl_4k.inc"
                 
                 
                 ; Tools
                 ; print the version string
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DOT_VER:
00018d ff03          .dw $ff03
00018e 6576
../../common\words/ver.asm(12): warning: .cseg .db misalignment - padding zero byte
00018f 0072          .db "ver"
000190 0177          .dw VE_HEAD
                     .set VE_HEAD = VE_DOT_VER
                 XT_DOT_VER:
000191 3801          .dw DO_COLON
                 PFA_DOT_VER:
                 .endif
000192 02de          .dw XT_ENV_FORTHNAME
000193 0407          .dw XT_ITYPE
000194 3f9f          .dw XT_SPACE
000195 3ea7          .dw XT_BASE
000196 3874          .dw XT_FETCH
                 
000197 02ec          .dw XT_ENV_FORTHVERSION
000198 3f32          .dw XT_DECIMAL
000199 3fb8          .dw XT_S2D
00019a 0325          .dw XT_L_SHARP
00019b 032d          .dw XT_SHARP
00019c 3838          .dw XT_DOLITERAL
00019d 002e          .dw '.'
00019e 0316          .dw XT_HOLD
00019f 0343          .dw XT_SHARP_S
0001a0 034e          .dw XT_SHARP_G
0001a1 043d          .dw XT_TYPE
0001a2 3ea7          .dw XT_BASE
0001a3 387c          .dw XT_STORE
0001a4 3f9f          .dw XT_SPACE
0001a5 02f4          .dw XT_ENV_CPU
0001a6 0407          .dw XT_ITYPE
                 
0001a7 381b          .dw XT_EXIT
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/noop.asm"
                 
                 ; Tools
                 ; do nothing
                 VE_NOOP:
0001a8 ff04          .dw $ff04
0001a9 6f6e
0001aa 706f          .db "noop"
0001ab 018d          .dw VE_HEAD
                     .set VE_HEAD = VE_NOOP
                 XT_NOOP:
0001ac 01ad          .dw PFA_NOOP
                 PFA_NOOP:
0001ad 940c 3805     jmp_ DO_NEXT
                 .include "words/unused.asm"
                 
                 ; Tools
                 ; Amount of available RAM (incl. PAD)
                 VE_UNUSED:
0001af ff06          .dw $ff06
0001b0 6e75
0001b1 7375
0001b2 6465          .db "unused"
0001b3 01a8          .dw VE_HEAD
                     .set VE_HEAD = VE_UNUSED
                 XT_UNUSED:
0001b4 3801          .dw DO_COLON
                 PFA_UNUSED:
0001b5 3a7c          .dw XT_SP_FETCH
0001b6 3f13          .dw XT_HERE
0001b7 398e          .dw XT_MINUS
0001b8 381b          .dw XT_EXIT
                 .include "words/to.asm"
                 
                 ; Tools
                 ; store the TOS to the named value (eeprom cell)
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_TO:
0001b9 0002          .dw $0002
0001ba 6f74          .db "to"
0001bb 01af          .dw VE_HEAD
                     .set VE_HEAD = VE_TO
                 XT_TO:
0001bc 3801          .dw DO_COLON
                 PFA_TO:
                 .endif
0001bd 044c          .dw XT_TICK
0001be 3fc1          .dw XT_TO_BODY
0001bf 3ea1          .dw XT_STATE
0001c0 3874          .dw XT_FETCH
0001c1 3831          .dw XT_DOCONDBRANCH
0001c2 01cd          DEST(PFA_TO1)
0001c3 0756          .dw XT_COMPILE
0001c4 01c7          .dw XT_DOTO
0001c5 0761          .dw XT_COMMA
0001c6 381b          .dw XT_EXIT
                 
                 ; ( n -- ) (R: IP -- IP+1)
                 ; Tools
                 ; runtime portion of to
                 ;VE_DOTO:
                 ;    .dw $ff04
                 ;    .db "(to)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOTO
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 XT_DOTO:
0001c7 3801          .dw DO_COLON
                 PFA_DOTO:
                 .endif
0001c8 38f1          .dw XT_R_FROM
0001c9 38ac          .dw XT_DUP
0001ca 01d9          .dw XT_ICELLPLUS
0001cb 38fa          .dw XT_TO_R
0001cc 3bbb          .dw XT_FETCHI
                 PFA_TO1:
0001cd 38ac          .dw XT_DUP
0001ce 01d9          .dw XT_ICELLPLUS
0001cf 01d9          .dw XT_ICELLPLUS
0001d0 3bbb          .dw XT_FETCHI
0001d1 3825          .dw XT_EXECUTE
0001d2 381b          .dw XT_EXIT
                 .include "words/i-cellplus.asm"
                 
                 ; Compiler
                 ; skip to the next cell in flash
                 VE_ICELLPLUS:
0001d3 ff07          .dw $FF07
0001d4 2d69
0001d5 6563
0001d6 6c6c
0001d7 002b          .db "i-cell+",0
0001d8 01b9          .dw VE_HEAD
                     .set VE_HEAD = VE_ICELLPLUS
                 XT_ICELLPLUS:
0001d9 3801          .dw DO_COLON
                 PFA_ICELLPLUS:
0001da 3a2a          .dw XT_1PLUS
0001db 381b          .dw XT_EXIT
                 .include "words/icompare.asm"
                 
                 ; Tools
                 ; compares string in RAM with string in flash. f is zero if equal like COMPARE
                 VE_ICOMPARE:
0001dc ff08          .dw $ff08
0001dd 6369
0001de 6d6f
0001df 6170
0001e0 6572          .db "icompare"
0001e1 01d3          .dw VE_HEAD
                     .set VE_HEAD = VE_ICOMPARE
                 XT_ICOMPARE:
0001e2 3801          .dw DO_COLON
                 PFA_ICOMPARE:
0001e3 38fa          .dw XT_TO_R    ; ( -- r-addr r-len f-addr)
0001e4 38ca          .dw XT_OVER    ; ( -- r-addr r-len f-addr r-len)
0001e5 38f1          .dw XT_R_FROM  ; ( -- r-addr r-len f-addr r-len f-len )
0001e6 390e          .dw XT_NOTEQUAL ; ( -- r-addr r-len f-addr flag )
0001e7 3831          .dw XT_DOCONDBRANCH
0001e8 01ed          .dw PFA_ICOMPARE_SAMELEN
0001e9 3ebc            .dw XT_2DROP
0001ea 38d4            .dw XT_DROP
0001eb 3946            .dw XT_TRUE
0001ec 381b            .dw XT_EXIT
                 PFA_ICOMPARE_SAMELEN:
0001ed 38bf          .dw XT_SWAP ; ( -- r-addr f-addr len )
0001ee 394f          .dw XT_ZERO
0001ef 0820          .dw XT_QDOCHECK
0001f0 3831          .dw XT_DOCONDBRANCH
0001f1 0210          .dw PFA_ICOMPARE_DONE
0001f2 3a8a          .dw XT_DODO
                 PFA_ICOMPARE_LOOP:
                     ; ( r-addr f-addr --)
0001f3 38ca          .dw XT_OVER
0001f4 3874          .dw XT_FETCH
                 .if WANT_IGNORECASE == 1
                 .endif
0001f5 38ca          .dw XT_OVER
0001f6 3bbb          .dw XT_FETCHI ; ( -- r-addr f-addr r-cc f- cc)
                 .if WANT_IGNORECASE == 1
                 .endif
                     ; flash strings are zero-padded at the last cell
                     ; that means: if the flash cell is less $0100, than mask the
                     ; high byte in the ram cell
0001f7 38ac          .dw XT_DUP
                     ;.dw XT_BYTESWAP
0001f8 3838          .dw XT_DOLITERAL
0001f9 0100          .dw $100
0001fa 3957          .dw XT_ULESS
0001fb 3831          .dw XT_DOCONDBRANCH
0001fc 0201          .dw PFA_ICOMPARE_LASTCELL
0001fd 38bf          .dw XT_SWAP
0001fe 3838          .dw XT_DOLITERAL
0001ff 00ff          .dw $00FF
000200 3a0e          .dw XT_AND  ; the final swap can be omitted
                 PFA_ICOMPARE_LASTCELL:
000201 390e          .dw XT_NOTEQUAL
000202 3831          .dw XT_DOCONDBRANCH
000203 0208          .dw PFA_ICOMPARE_NEXTLOOP
000204 3ebc          .dw XT_2DROP
000205 3946          .dw XT_TRUE
000206 3ac3          .dw XT_UNLOOP
000207 381b          .dw XT_EXIT
                 PFA_ICOMPARE_NEXTLOOP:
000208 3a2a          .dw XT_1PLUS
000209 38bf          .dw XT_SWAP
00020a 3c83          .dw XT_CELLPLUS
00020b 38bf          .dw XT_SWAP
00020c 3838          .dw XT_DOLITERAL
00020d 0002          .dw 2
00020e 3aa9          .dw XT_DOPLUSLOOP
00020f 01f3          .dw PFA_ICOMPARE_LOOP
                 PFA_ICOMPARE_DONE:
000210 3ebc          .dw XT_2DROP
000211 394f          .dw XT_ZERO
000212 381b          .dw XT_EXIT
                 
                 .if WANT_IGNORECASE == 1
                 .endif
                 .include "words/star.asm"
                 
                 ; Arithmetics
                 ; multiply routine
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_STAR:
000213 ff01          .dw $ff01
000214 002a          .db "*",0
000215 01dc          .dw VE_HEAD
                     .set VE_HEAD = VE_STAR
                 XT_STAR:
000216 3801          .dw DO_COLON
                 PFA_STAR:
                 .endif
                 
000217 39a1          .dw XT_MSTAR
000218 38d4          .dw XT_DROP
000219 381b          .dw XT_EXIT
                 .include "words/j.asm"
                 
                 ; Compiler
                 ; loop counter of outer loop
                 VE_J:
00021a ff01          .dw $FF01
00021b 006a          .db "j",0
00021c 0213          .dw VE_HEAD
                     .set VE_HEAD = VE_J
                 XT_J:
00021d 3801          .dw DO_COLON
                 PFA_J:
00021e 3a65          .dw XT_RP_FETCH
00021f 3838          .dw XT_DOLITERAL
000220 0007          .dw 7
000221 3998          .dw XT_PLUS
000222 3874          .dw XT_FETCH
000223 3a65          .dw XT_RP_FETCH
000224 3838          .dw XT_DOLITERAL
000225 0009          .dw 9
000226 3998          .dw XT_PLUS
000227 3874          .dw XT_FETCH
000228 3998          .dw XT_PLUS
000229 381b          .dw XT_EXIT
                 .include "words/dabs.asm"
                 
                 ; Arithmetics
                 ; double cell absolute value
                 VE_DABS:
00022a ff04          .dw $ff04
00022b 6164
00022c 7362          .db "dabs"
00022d 021a          .dw VE_HEAD
                     .set VE_HEAD = VE_DABS
                 XT_DABS:
00022e 3801          .dw DO_COLON
                 PFA_DABS:
00022f 38ac          .dw XT_DUP
000230 391c          .dw XT_ZEROLESS
000231 3831          .dw XT_DOCONDBRANCH
000232 0234          .dw PFA_DABS1
000233 023b          .dw XT_DNEGATE
                 PFA_DABS1:
000234 381b          .dw XT_EXIT
                 ; : dabs      ( ud1 -- +d2 ) dup 0< if dnegate then ;
                 .include "words/dnegate.asm"
                 
                 ; Arithmetics
                 ; double cell negation
                 VE_DNEGATE:
000235 ff07          .dw $ff07
000236 6e64
000237 6765
000238 7461
000239 0065          .db "dnegate",0
00023a 022a          .dw VE_HEAD
                     .set VE_HEAD = VE_DNEGATE
                 XT_DNEGATE:
00023b 3801          .dw DO_COLON
                 PFA_DNEGATE:
00023c 3c2b          .dw XT_DINVERT
00023d 3838          .dw XT_DOLITERAL
00023e 0001          .dw 1
00023f 394f          .dw XT_ZERO
000240 3c05          .dw XT_DPLUS
000241 381b          .dw XT_EXIT
                 ; : dnegate   ( ud1 -- ud2 ) dinvert 1. d+ ;
                 .include "words/cmove.asm"
                 
                 ; Memory
                 ; copy data in RAM, from lower to higher addresses
                 VE_CMOVE:
000242 ff05          .dw $ff05
000243 6d63
000244 766f
000245 0065          .db "cmove",0
000246 0235          .dw VE_HEAD
                     .set VE_HEAD  = VE_CMOVE
                 XT_CMOVE:
000247 0248          .dw PFA_CMOVE
                 PFA_CMOVE:
000248 93bf          push xh
000249 93af          push xl
00024a 91e9          ld zl, Y+
00024b 91f9          ld zh, Y+ ; addr-to
00024c 91a9          ld xl, Y+
00024d 91b9          ld xh, Y+ ; addr-from
00024e 2f09          mov temp0, tosh
00024f 2b08          or temp0, tosl
000250 f021          brbs 1, PFA_CMOVE1
                 PFA_CMOVE2:
000251 911d          ld temp1, X+
000252 9311          st Z+, temp1
000253 9701          sbiw tosl, 1
000254 f7e1          brbc 1, PFA_CMOVE2
                 PFA_CMOVE1:
000255 91af          pop xl
000256 91bf          pop xh
000257 9189
000258 9199          loadtos
000259 940c 3805     jmp_ DO_NEXT
                 .include "words/2swap.asm"
                 
                 ; Stack
                 ; Exchange the two top cell pairs
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_2SWAP:
00025b ff05          .dw $ff05
00025c 7332
00025d 6177
00025e 0070          .db "2swap",0
00025f 0242          .dw VE_HEAD
                     .set VE_HEAD = VE_2SWAP
                 XT_2SWAP:
000260 3801          .dw DO_COLON
                 PFA_2SWAP:
                 
                 .endif
000261 38dc          .dw XT_ROT
000262 38fa          .dw XT_TO_R
000263 38dc          .dw XT_ROT
000264 38f1          .dw XT_R_FROM
000265 381b          .dw XT_EXIT
                 .include "words/tib.asm"
                 
                 ; System Variable
                 ; terminal input buffer address
                 VE_TIB:
000266 ff03          .dw $ff03
000267 6974
000268 0062          .db "tib",0
000269 025b          .dw VE_HEAD
                     .set VE_HEAD = VE_TIB
                 XT_TIB:
00026a 3843          .dw PFA_DOVARIABLE
                 PFA_TIB:
00026b 0117          .dw ram_tib
                     
                 .dseg
000117           ram_tib: .byte TIBSIZE
                 .cseg
                 ; ( -- f ) 
                 ; System
                 ; refills the input buffer
                 VE_REFILLTIB:
00026c ff0a          .dw $ff0a
00026d 6572
00026e 6966
00026f 6c6c
000270 742d
000271 6269          .db "refill-tib"
000272 0266          .dw VE_HEAD
                     .set VE_HEAD = VE_REFILLTIB
                 XT_REFILLTIB:
000273 3801          .dw DO_COLON
                 PFA_REFILLTIB:
000274 026a          .dw XT_TIB
000275 3838          .dw XT_DOLITERAL
000276 005a          .dw TIBSIZE
000277 0495          .dw XT_ACCEPT
000278 3ed2          .dw XT_NUMBERTIB
000279 387c          .dw XT_STORE
00027a 394f          .dw XT_ZERO
00027b 3ecc          .dw XT_TO_IN
00027c 387c          .dw XT_STORE
00027d 3946          .dw XT_TRUE ; -1
00027e 381b          .dw XT_EXIT
                 
                 ; ( -- addr n ) 
                 ; System
                 ; address and current length of the input buffer
                 VE_SOURCETIB:
00027f ff0a          .dw $FF0A
000280 6f73
000281 7275
000282 6563
000283 742d
000284 6269          .db "source-tib"
000285 026c          .dw VE_HEAD
                     .set VE_HEAD = VE_SOURCETIB
                 XT_SOURCETIB:
000286 3801          .dw DO_COLON
                 PFA_SOURCETIB:
000287 026a          .dw XT_TIB
000288 3ed2          .dw XT_NUMBERTIB
000289 3874          .dw XT_FETCH
00028a 381b          .dw XT_EXIT
                 .include "words/init-user.asm"
                 
                 ; Tools
                 ; copy len cells from eeprom to ram
                 VE_EE2RAM:
00028b ff06        .dw $ff06
00028c 6565
00028d 723e
00028e 6d61        .db "ee>ram"
00028f 027f        .dw VE_HEAD
                   .set VE_HEAD = VE_EE2RAM
                 XT_EE2RAM:
000290 3801        .dw DO_COLON
                 PFA_EE2RAM:          ; ( -- )
000291 394f          .dw XT_ZERO
000292 3a8a          .dw XT_DODO
                 PFA_EE2RAM_1:
                     ; ( -- e-addr r-addr )
000293 38ca          .dw XT_OVER
000294 3b4e          .dw XT_FETCHE
000295 38ca          .dw XT_OVER
000296 387c          .dw XT_STORE
000297 3c83          .dw XT_CELLPLUS
000298 38bf          .dw XT_SWAP
000299 3c83          .dw XT_CELLPLUS
00029a 38bf          .dw XT_SWAP
00029b 3ab8          .dw XT_DOLOOP
00029c 0293          .dw PFA_EE2RAM_1
                 PFA_EE2RAM_2:
00029d 3ebc          .dw XT_2DROP
00029e 381b          .dw XT_EXIT
                 
                 ; ( -- )
                 ; Tools
                 ; setup the default user area from eeprom
                 VE_INITUSER:
00029f ff09        .dw $ff09
0002a0 6e69
0002a1 7469
0002a2 752d
0002a3 6573
0002a4 0072        .db "init-user",0
0002a5 028b        .dw VE_HEAD
                   .set VE_HEAD = VE_INITUSER
                 XT_INITUSER:
0002a6 3801        .dw DO_COLON
                 PFA_INITUSER:          ; ( -- )
0002a7 3838          .dw XT_DOLITERAL
0002a8 006a          .dw EE_INITUSER
0002a9 3af1          .dw XT_UP_FETCH
0002aa 3838          .dw XT_DOLITERAL
0002ab 001c          .dw SYSUSERSIZE
0002ac 39ff          .dw XT_2SLASH
0002ad 0290          .dw XT_EE2RAM
0002ae 381b          .dw XT_EXIT
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 
                 
                 .include "words/environment.asm"
                 
                 ; System Value
                 ; word list identifier of the environmental search list
                 VE_ENVIRONMENT:
0002af ff0b          .dw $ff0b
0002b0 6e65
0002b1 6976
0002b2 6f72
0002b3 6d6e
0002b4 6e65
0002b5 0074          .db "environment",0
0002b6 029f          .dw VE_HEAD
                     .set VE_HEAD = VE_ENVIRONMENT
                 XT_ENVIRONMENT:
0002b7 3843          .dw PFA_DOVARIABLE
                 PFA_ENVIRONMENT:
0002b8 0040          .dw EE_ENVIRONMENT
                 .include "words/env-wordlists.asm"
                 
                 ; Environment
                 ; maximum number of wordlists in the dictionary search order
                 VE_ENVWORDLISTS:
0002b9 ff09          .dw $ff09
0002ba 6f77
0002bb 6472
0002bc 696c
0002bd 7473
0002be 0073          .db "wordlists",0
0002bf 0000          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENVWORDLISTS
                 XT_ENVWORDLISTS:
0002c0 3801          .dw DO_COLON
                 PFA_ENVWORDLISTS:
0002c1 3838          .dw XT_DOLITERAL
0002c2 0008          .dw NUMWORDLISTS
0002c3 381b          .dw XT_EXIT
                 .include "words/env-slashpad.asm"
                 
                 ; Environment
                 ; Size of the PAD buffer in bytes
                 VE_ENVSLASHPAD:
0002c4 ff04          .dw $ff04
0002c5 702f
0002c6 6461          .db "/pad"
0002c7 02b9          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENVSLASHPAD
                 XT_ENVSLASHPAD:
0002c8 3801          .dw DO_COLON
                 PFA_ENVSLASHPAD:
0002c9 3a7c          .dw XT_SP_FETCH
0002ca 3ed8          .dw XT_PAD
0002cb 398e          .dw XT_MINUS
0002cc 381b          .dw XT_EXIT
                 .include "words/env-slashhold.asm"
                 
                 ; Environment
                 ; size of the pictured numeric output buffer in bytes
                 VE_ENVSLASHHOLD:
0002cd ff05          .dw $ff05
0002ce 682f
0002cf 6c6f
0002d0 0064          .db "/hold",0
0002d1 02c4          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENVSLASHHOLD
                 XT_ENVSLASHHOLD:
0002d2 3801          .dw DO_COLON
                 PFA_ENVSLASHHOLD:
0002d3 3ed8          .dw XT_PAD
0002d4 3f13          .dw XT_HERE
0002d5 398e          .dw XT_MINUS
0002d6 381b          .dw XT_EXIT
                 .include "words/env-forthname.asm"
                 
                 ; Environment
                 ; flash address of the amforth name string
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_ENV_FORTHNAME:
0002d7 ff0a          .dw $ff0a
0002d8 6f66
0002d9 7472
0002da 2d68
0002db 616e
0002dc 656d          .db "forth-name"
0002dd 02cd          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENV_FORTHNAME
                 XT_ENV_FORTHNAME:
0002de 3801          .dw DO_COLON
                 PFA_EN_FORTHNAME:
0002df 03d4          .dw XT_DOSLITERAL
0002e0 0007          .dw 7
                 .endif
0002e1 6d61
0002e2 6f66
0002e3 7472
../../common\words/env-forthname.asm(22): warning: .cseg .db misalignment - padding zero byte
0002e4 0068          .db "amforth"
                 .if cpu_msp430==1
                 .endif
0002e5 381b          .dw XT_EXIT
                 .include "words/env-forthversion.asm"
                 
                 ; Environment
                 ; version number of amforth
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_ENV_FORTHVERSION:
0002e6 ff07          .dw $ff07
0002e7 6576
0002e8 7372
0002e9 6f69
0002ea 006e          .db "version",0
0002eb 02d7          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENV_FORTHVERSION
                 XT_ENV_FORTHVERSION:
0002ec 3801          .dw DO_COLON
                 PFA_EN_FORTHVERSION:
                 .endif
0002ed 3838          .dw XT_DOLITERAL
0002ee 003b          .dw 59
0002ef 381b          .dw XT_EXIT
                 .include "words/env-cpu.asm"
                 
                 ; Environment
                 ; flash address of the CPU identification string
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_ENV_CPU:
0002f0 ff03          .dw $ff03
0002f1 7063
0002f2 0075          .db "cpu",0
0002f3 02e6          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENV_CPU
                 XT_ENV_CPU:
0002f4 3801          .dw DO_COLON
                 PFA_EN_CPU:
0002f5 3838          .dw XT_DOLITERAL
0002f6 0037          .dw mcu_name
0002f7 0433          .dw XT_ICOUNT
                 .endif
0002f8 381b          .dw XT_EXIT
                 .include "words/env-mcuinfo.asm"
                 
                 ; Environment
                 ; flash address of some CPU specific parameters
                 VE_ENV_MCUINFO:
0002f9 ff08          .dw $ff08
0002fa 636d
0002fb 2d75
0002fc 6e69
0002fd 6f66          .db "mcu-info"
0002fe 02f0          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENV_MCUINFO
                 XT_ENV_MCUINFO:
0002ff 3801          .dw DO_COLON
                 PFA_EN_MCUINFO:
000300 3838          .dw XT_DOLITERAL
000301 0033          .dw mcu_info
000302 381b          .dw XT_EXIT
                 .include "words/env-usersize.asm"
                 
                 ; Environment
                 ; size of the USER area in bytes
                 VE_ENVUSERSIZE:
000303 ff05          .dw $ff05
000304 752f
000305 6573
000306 0072          .db "/user",0
000307 02f9          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENVUSERSIZE
                 XT_ENVUSERSIZE:
000308 3801          .dw DO_COLON
                 PFA_ENVUSERSIZE:
000309 3838          .dw XT_DOLITERAL
00030a 0026          .dw SYSUSERSIZE + APPUSERSIZE
00030b 381b          .dw XT_EXIT
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/hld.asm"
                 
                 ; Numeric IO
                 ; pointer to current write position in the Pictured Numeric Output buffer
                 VE_HLD:
00030c ff03          .dw $ff03
00030d 6c68
00030e 0064          .db "hld",0
00030f 02af          .dw VE_HEAD
                     .set VE_HEAD = VE_HLD
                 XT_HLD:
000310 3843          .dw PFA_DOVARIABLE
                 PFA_HLD:
000311 0171          .dw ram_hld
                 
                 .dseg
000171           ram_hld: .byte 2
                 .cseg
                 .include "words/hold.asm"
                 
                 ; Numeric IO
                 ; prepend character to pictured numeric output buffer
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_HOLD:
000312 ff04          .dw $ff04
000313 6f68
000314 646c          .db "hold"
000315 030c          .dw VE_HEAD
                     .set VE_HEAD = VE_HOLD
                 XT_HOLD:
000316 3801          .dw DO_COLON
                 PFA_HOLD:
                 .endif
000317 0310          .dw XT_HLD
000318 38ac          .dw XT_DUP
000319 3874          .dw XT_FETCH
00031a 3a30          .dw XT_1MINUS
00031b 38ac          .dw XT_DUP
00031c 38fa          .dw XT_TO_R
00031d 38bf          .dw XT_SWAP
00031e 387c          .dw XT_STORE
00031f 38f1          .dw XT_R_FROM
000320 3888          .dw XT_CSTORE
000321 381b          .dw XT_EXIT
                 .include "words/less-sharp.asm" ; <#
                 
                 ; Numeric IO
                 ; initialize the pictured numeric output conversion process
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_L_SHARP:
000322 ff02          .dw $ff02
000323 233c          .db "<#"
000324 0312          .dw VE_HEAD
                     .set VE_HEAD = VE_L_SHARP
                 XT_L_SHARP:
000325 3801          .dw DO_COLON
                 PFA_L_SHARP:
                 .endif
000326 3ed8          .dw XT_PAD
000327 0310          .dw XT_HLD
000328 387c          .dw XT_STORE
000329 381b          .dw XT_EXIT
                 .include "words/sharp.asm"
                 
                 ; Numeric IO
                 ; pictured numeric output: convert one digit
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 
                 VE_SHARP:
00032a ff01          .dw $ff01
00032b 0023          .db "#",0
00032c 0322          .dw VE_HEAD
                     .set VE_HEAD = VE_SHARP
                 XT_SHARP:
00032d 3801          .dw DO_COLON
                 PFA_SHARP:
                 .endif
00032e 3ea7          .dw XT_BASE
00032f 3874          .dw XT_FETCH
000330 03aa          .dw XT_UDSLASHMOD
000331 38dc          .dw XT_ROT
000332 3838          .dw XT_DOLITERAL
000333 0009          .dw 9
000334 38ca          .dw XT_OVER
000335 3969          .dw XT_LESS
000336 3831          .dw XT_DOCONDBRANCH
000337 033b          DEST(PFA_SHARP1)
000338 3838          .dw XT_DOLITERAL
000339 0007          .dw 7
00033a 3998          .dw XT_PLUS
                 PFA_SHARP1:
00033b 3838          .dw XT_DOLITERAL
00033c 0030          .dw 48 ; ASCII 0
00033d 3998          .dw XT_PLUS
00033e 0316          .dw XT_HOLD
00033f 381b          .dw XT_EXIT
                 ; : #    ( ud1 -- ud2 ) 
                 ;        base @ ud/mod rot 9 over < if 7 + then 30 + hold ; 
                 .include "words/sharp-s.asm"
                 
                 ; Numeric IO
                 ; pictured numeric output: convert all digits until 0 (zero) is reached
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SHARP_S:
000340 ff02          .dw $ff02
000341 7323          .db "#s"
000342 032a          .dw VE_HEAD
                     .set VE_HEAD = VE_SHARP_S
                 XT_SHARP_S:
000343 3801          .dw DO_COLON
                 PFA_SHARP_S:
                 .endif
                 NUMS1:
000344 032d          .dw XT_SHARP
000345 3eb3          .dw XT_2DUP
000346 3a17          .dw XT_OR
000347 3915          .dw XT_ZEROEQUAL
000348 3831          .dw XT_DOCONDBRANCH
000349 0344          DEST(NUMS1) ; PFA_SHARP_S
00034a 381b          .dw XT_EXIT
                 .include "words/sharp-greater.asm" ; #>
                 
                 ; Numeric IO
                 ; Pictured Numeric Output: convert PNO buffer into an string
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SHARP_G:
00034b ff02          .dw $ff02
00034c 3e23          .db "#>"
00034d 0340          .dw VE_HEAD
                     .set VE_HEAD = VE_SHARP_G
                 XT_SHARP_G:
00034e 3801          .dw DO_COLON
                 PFA_SHARP_G:
                 .endif
00034f 3ebc          .dw XT_2DROP
000350 0310          .dw XT_HLD
000351 3874          .dw XT_FETCH
000352 3ed8          .dw XT_PAD
000353 38ca          .dw XT_OVER
000354 398e          .dw XT_MINUS
000355 381b          .dw XT_EXIT
                 .include "words/sign.asm"
                 
                 ; Numeric IO
                 ; place a - in HLD if n is negative
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SIGN:
000356 ff04          .dw $ff04
000357 6973
000358 6e67          .db "sign"
000359 034b          .dw VE_HEAD
                     .set VE_HEAD = VE_SIGN
                 XT_SIGN:
00035a 3801          .dw DO_COLON
                 PFA_SIGN:
                 .endif
00035b 391c          .dw XT_ZEROLESS
00035c 3831          .dw XT_DOCONDBRANCH
00035d 0361          DEST(PFA_SIGN1)
00035e 3838          .dw XT_DOLITERAL
00035f 002d          .dw 45 ; ascii -
000360 0316          .dw XT_HOLD
                 PFA_SIGN1:
000361 381b          .dw XT_EXIT
                 .include "words/d-dot-r.asm"
                 
                 ; Numeric IO
                 ; singed PNO with double cell numbers, right aligned in width w
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DDOTR:
000362 ff03          .dw $ff03
000363 2e64
000364 0072          .db "d.r",0
000365 0356          .dw VE_HEAD
                     .set VE_HEAD = VE_DDOTR
                 XT_DDOTR:
000366 3801          .dw DO_COLON
                 PFA_DDOTR:
                 
                 .endif
000367 38fa          .dw XT_TO_R
000368 3ec4          .dw XT_TUCK
000369 022e          .dw XT_DABS
00036a 0325          .dw XT_L_SHARP
00036b 0343          .dw XT_SHARP_S
00036c 38dc          .dw XT_ROT
00036d 035a          .dw XT_SIGN
00036e 034e          .dw XT_SHARP_G
00036f 38f1          .dw XT_R_FROM
000370 38ca          .dw XT_OVER
000371 398e          .dw XT_MINUS
000372 3fa8          .dw XT_SPACES
000373 043d          .dw XT_TYPE
000374 381b          .dw XT_EXIT
                 ; : d.r       ( d n -- )
                 ;             >r swap over dabs <# #s rot sign #> r> over - spaces type ;
                 .include "words/dot-r.asm"
                 
                 ; Numeric IO
                 ; singed PNO with single cell numbers, right aligned in width w
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DOTR:
000375 ff02          .dw $ff02
000376 722e          .db ".r"
000377 0362          .dw VE_HEAD
                     .set VE_HEAD = VE_DOTR
                 XT_DOTR:
000378 3801          .dw DO_COLON
                 PFA_DOTR:
                 
                 .endif
000379 38fa          .dw XT_TO_R
00037a 3fb8          .dw XT_S2D
00037b 38f1          .dw XT_R_FROM
00037c 0366          .dw XT_DDOTR
00037d 381b          .dw XT_EXIT
                 ; : .r        ( s n -- )  >r s>d r> d.r ;
                 .include "words/d-dot.asm"
                 
                 ; Numeric IO
                 ; singed PNO with double cell numbers
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DDOT:
00037e ff02          .dw $ff02
00037f 2e64          .db "d."
000380 0375          .dw VE_HEAD
                     .set VE_HEAD = VE_DDOT
                 XT_DDOT:
000381 3801          .dw DO_COLON
                 PFA_DDOT:
                 
                 .endif
000382 394f          .dw XT_ZERO
000383 0366          .dw XT_DDOTR
000384 3f9f          .dw XT_SPACE
000385 381b          .dw XT_EXIT
                 ; : d.        ( d -- )    0 d.r space ;
                 .include "words/dot.asm"
                 
                 ; Numeric IO
                 ; singed PNO with single cell numbers
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 
                 VE_DOT:
000386 ff01          .dw $ff01
000387 002e          .db ".",0
000388 037e          .dw VE_HEAD
                     .set VE_HEAD = VE_DOT
                 XT_DOT:
000389 3801          .dw DO_COLON
                 PFA_DOT:
                 .endif
00038a 3fb8          .dw XT_S2D
00038b 0381          .dw XT_DDOT
00038c 381b          .dw XT_EXIT
                 ; : .         ( s -- )    s>d d. ; 
                 .include "words/ud-dot.asm"
                 
                 ; Numeric IO
                 ; unsigned PNO with double cell numbers
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_UDDOT:
00038d ff03          .dw $ff03
00038e 6475
00038f 002e          .db "ud.",0
000390 0386          .dw VE_HEAD
                     .set VE_HEAD = VE_UDDOT
                 XT_UDDOT:
000391 3801          .dw DO_COLON
                 PFA_UDDOT:
                 .endif
000392 394f          .dw XT_ZERO
000393 039a          .dw XT_UDDOTR
000394 3f9f          .dw XT_SPACE
000395 381b          .dw XT_EXIT
                 .include "words/ud-dot-r.asm"
                 
                 ; Numeric IO
                 ; unsigned PNO with double cell numbers, right aligned in width w
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 
                 VE_UDDOTR:
000396 ff04          .dw $ff04
000397 6475
000398 722e          .db "ud.r"
000399 038d          .dw VE_HEAD
                     .set VE_HEAD = VE_UDDOTR
                 XT_UDDOTR:
00039a 3801          .dw DO_COLON
                 PFA_UDDOTR:
                 .endif
00039b 38fa          .dw XT_TO_R
00039c 0325          .dw XT_L_SHARP
00039d 0343          .dw XT_SHARP_S
00039e 034e          .dw XT_SHARP_G
00039f 38f1          .dw XT_R_FROM
0003a0 38ca          .dw XT_OVER
0003a1 398e          .dw XT_MINUS
0003a2 3fa8          .dw XT_SPACES
0003a3 043d          .dw XT_TYPE
0003a4 381b          .dw XT_EXIT
                 .include "words/ud-slash-mod.asm"
                 
                 ; Arithmetics
                 ; unsigned double cell division with remainder
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_UDSLASHMOD:
0003a5 ff06          .dw $ff06
0003a6 6475
0003a7 6d2f
0003a8 646f          .db "ud/mod"
0003a9 0396          .dw VE_HEAD
                     .set VE_HEAD = VE_UDSLASHMOD
                 XT_UDSLASHMOD:
0003aa 3801          .dw DO_COLON
                 PFA_UDSLASHMOD:
                 .endif
0003ab 38fa          .dw XT_TO_R
0003ac 394f          .dw XT_ZERO
0003ad 3903          .dw XT_R_FETCH
0003ae 39bd          .dw XT_UMSLASHMOD
0003af 38f1          .dw XT_R_FROM
0003b0 38bf          .dw XT_SWAP
0003b1 38fa          .dw XT_TO_R
0003b2 39bd          .dw XT_UMSLASHMOD
0003b3 38f1          .dw XT_R_FROM
0003b4 381b          .dw XT_EXIT
                 .include "words/digit-q.asm"
                 
                 ; Numeric IO
                 ; tries to convert a character to a number, set flag accordingly
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DIGITQ:
0003b5 ff06          .dw $ff06 
0003b6 6964
0003b7 6967
0003b8 3f74          .db "digit?"
0003b9 03a5          .dw VE_HEAD
                     .set VE_HEAD = VE_DIGITQ
                 XT_DIGITQ:
0003ba 3801          .dw DO_COLON 
                 PFA_DIGITQ:
                 .endif
0003bb 3f57          .dw XT_TOUPPER
0003bc 38ac
0003bd 3838
0003be 0039
0003bf 3973
0003c0 3838
0003c1 0100          .DW XT_DUP,XT_DOLITERAL,57,XT_GREATER,XT_DOLITERAL,256
0003c2 3a0e
0003c3 3998
0003c4 38ac
0003c5 3838
0003c6 0140
0003c7 3973          .DW XT_AND,XT_PLUS,XT_DUP,XT_DOLITERAL,320,XT_GREATER
0003c8 3838
0003c9 0107
0003ca 3a0e
0003cb 398e
0003cc 3838
0003cd 0030          .DW XT_DOLITERAL,263,XT_AND,XT_MINUS,XT_DOLITERAL,48
0003ce 398e
0003cf 38ac
0003d0 3ea7
0003d1 3874
0003d2 3957          .DW XT_MINUS,XT_DUP,XT_BASE,XT_FETCH,XT_ULESS
0003d3 381b          .DW XT_EXIT
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/do-sliteral.asm"
                 
                 ; String
                 ; runtime portion of sliteral
                 ;VE_DOSLITERAL:
                 ;  .dw $ff0a
                 ;  .db "(sliteral)"
                 ;  .dw VE_HEAD
                 ;  .set VE_HEAD = VE_DOSLITERAL
                 XT_DOSLITERAL:
0003d4 3801        .dw DO_COLON
                 PFA_DOSLITERAL:
0003d5 3903        .dw XT_R_FETCH   ; ( -- addr )
0003d6 0433        .dw XT_ICOUNT
0003d7 38f1        .dw XT_R_FROM
0003d8 38ca        .dw XT_OVER     ; ( -- addr' n addr n)
0003d9 3a2a        .dw XT_1PLUS
0003da 39ff        .dw XT_2SLASH   ; ( -- addr' n addr k )
0003db 3998        .dw XT_PLUS     ; ( -- addr' n addr'' )
0003dc 3a2a        .dw XT_1PLUS
0003dd 38fa        .dw XT_TO_R     ; ( -- )
0003de 381b        .dw XT_EXIT
                 .include "words/scomma.asm"
                 
                 ; Compiler
                 ; compiles a string from RAM to Flash
                 VE_SCOMMA:
0003df ff02        .dw $ff02
0003e0 2c73        .db "s",$2c
0003e1 03b5        .dw VE_HEAD
                   .set VE_HEAD = VE_SCOMMA
                 XT_SCOMMA:
0003e2 3801          .dw DO_COLON
                 PFA_SCOMMA:
0003e3 38ac          .dw XT_DUP
0003e4 03e6          .dw XT_DOSCOMMA
0003e5 381b          .dw XT_EXIT
                 
                 ; ( addr len len' -- ) 
                 ; Compiler
                 ; compiles a string from RAM to Flash
                 ;VE_DOSCOMMA:
                 ;  .dw $ff04
                 ;  .db "(s",$2c,")"
                 ;  .dw VE_HEAD
                 ;  .set VE_HEAD = VE_DOSCOMMA
                 XT_DOSCOMMA:
0003e6 3801          .dw DO_COLON
                 PFA_DOSCOMMA:
0003e7 0761          .dw XT_COMMA
0003e8 38ac          .dw XT_DUP   ; ( --addr len len)
0003e9 39ff          .dw XT_2SLASH ; ( -- addr len len/2
0003ea 3ec4          .dw XT_TUCK   ; ( -- addr len/2 len len/2
0003eb 3a06          .dw XT_2STAR  ; ( -- addr len/2 len len'
0003ec 398e          .dw XT_MINUS  ; ( -- addr len/2 rem
0003ed 38fa          .dw XT_TO_R
0003ee 394f          .dw XT_ZERO
0003ef 0820          .dw XT_QDOCHECK
0003f0 3831          .dw XT_DOCONDBRANCH
0003f1 03f9          .dw PFA_SCOMMA2
0003f2 3a8a          .dw XT_DODO
                 PFA_SCOMMA1:
0003f3 38ac          .dw XT_DUP         ; ( -- addr addr )
0003f4 3874          .dw XT_FETCH       ; ( -- addr c1c2 )
0003f5 0761          .dw XT_COMMA       ; ( -- addr )
0003f6 3c83          .dw XT_CELLPLUS    ; ( -- addr+cell )
0003f7 3ab8          .dw XT_DOLOOP
0003f8 03f3          .dw PFA_SCOMMA1
                 PFA_SCOMMA2:
0003f9 38f1          .dw XT_R_FROM
0003fa 3923          .dw XT_GREATERZERO
0003fb 3831          .dw XT_DOCONDBRANCH
0003fc 0400          .dw PFA_SCOMMA3
0003fd 38ac            .dw XT_DUP     ; well, tricky
0003fe 3893            .dw XT_CFETCH
0003ff 0761            .dw XT_COMMA
                 PFA_SCOMMA3:
000400 38d4          .dw XT_DROP        ; ( -- )
000401 381b          .dw XT_EXIT
                 .include "words/itype.asm"
                 
                 ; Tools
                 ; reads string from flash and prints it
                 VE_ITYPE:
000402 ff05          .dw $ff05
000403 7469
000404 7079
000405 0065          .db "itype",0
000406 03df          .dw VE_HEAD
                     .set VE_HEAD = VE_ITYPE
                 XT_ITYPE:
000407 3801          .dw DO_COLON
                 PFA_ITYPE:
000408 38ac          .dw XT_DUP    ; ( --addr len len)
000409 39ff          .dw XT_2SLASH ; ( -- addr len len/2
00040a 3ec4          .dw XT_TUCK   ; ( -- addr len/2 len len/2
00040b 3a06          .dw XT_2STAR  ; ( -- addr len/2 len len'
00040c 398e          .dw XT_MINUS  ; ( -- addr len/2 rem
00040d 38fa          .dw XT_TO_R
00040e 394f          .dw XT_ZERO
00040f 0820          .dw XT_QDOCHECK
000410 3831          .dw XT_DOCONDBRANCH
000411 041b          .dw PFA_ITYPE2
000412 3a8a          .dw XT_DODO
                 PFA_ITYPE1:
000413 38ac          .dw XT_DUP         ; ( -- addr addr )
000414 3bbb          .dw XT_FETCHI      ; ( -- addr c1c2 )
000415 38ac          .dw XT_DUP
000416 0428          .dw XT_LOWEMIT
000417 0424          .dw XT_HIEMIT
000418 3a2a          .dw XT_1PLUS    ; ( -- addr+cell )
000419 3ab8          .dw XT_DOLOOP
00041a 0413          .dw PFA_ITYPE1
                 PFA_ITYPE2:
00041b 38f1          .dw XT_R_FROM
00041c 3923          .dw XT_GREATERZERO
00041d 3831          .dw XT_DOCONDBRANCH
00041e 0422          .dw PFA_ITYPE3
00041f 38ac            .dw XT_DUP     ; make sure the drop below has always something to do
000420 3bbb            .dw XT_FETCHI
000421 0428            .dw XT_LOWEMIT
                 PFA_ITYPE3:
000422 38d4          .dw XT_DROP
000423 381b          .dw XT_EXIT
                 
                 ; ( w -- )
                 ; R( -- )
                 ; content of cell fetched on stack.
                 ;VE_HIEMIT:
                 ;    .dw $ff06
                 ;    .db "hiemit"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_HIEMIT
                 XT_HIEMIT:
000424 3801          .dw DO_COLON
                 PFA_HIEMIT:
000425 3ae8          .dw XT_BYTESWAP
000426 0428          .dw XT_LOWEMIT
000427 381b          .dw XT_EXIT
                 
                 ; ( w -- )
                 ; R( -- )
                 ; content of cell fetched on stack.
                 ;VE_LOWEMIT:
                 ;    .dw $ff07
                 ;    .db "lowemit"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_LOWEMIT
                 XT_LOWEMIT:
000428 3801          .dw DO_COLON
                 PFA_LOWEMIT:
000429 3838          .dw XT_DOLITERAL
00042a 00ff          .dw $00ff
00042b 3a0e          .dw XT_AND
00042c 3ee2          .dw XT_EMIT
00042d 381b          .dw XT_EXIT
                 .include "words/icount.asm"
                 
                 ; Tools
                 ; get count information out of a counted string in flash
                 VE_ICOUNT:
00042e ff06          .dw $ff06
00042f 6369
000430 756f
000431 746e          .db "icount"
000432 0402          .dw VE_HEAD
                     .set VE_HEAD = VE_ICOUNT
                 XT_ICOUNT:
000433 3801          .dw DO_COLON
                 PFA_ICOUNT:
000434 38ac          .dw XT_DUP
000435 3a2a          .dw XT_1PLUS
000436 38bf          .dw XT_SWAP
000437 3bbb          .dw XT_FETCHI
000438 381b          .dw XT_EXIT
                 .include "words/type.asm"
                 
                 ; Character IO
                 ; print a RAM based string
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_TYPE:
000439 ff04          .dw $ff04
00043a 7974
00043b 6570          .db "type"
00043c 042e          .dw VE_HEAD
                     .set VE_HEAD = VE_TYPE
                 XT_TYPE:
00043d 3801          .dw DO_COLON
                 PFA_TYPE:
                 
                 .endif
00043e 3f8a          .dw XT_BOUNDS
00043f 0820          .dw XT_QDOCHECK
000440 3831          .dw XT_DOCONDBRANCH
000441 0448          DEST(PFA_TYPE2)
000442 3a8a          .dw XT_DODO
                 PFA_TYPE1:
000443 3a9b          .dw XT_I
000444 3893          .dw XT_CFETCH
000445 3ee2          .dw XT_EMIT
000446 3ab8          .dw XT_DOLOOP
000447 0443          DEST(PFA_TYPE1)
                 PFA_TYPE2:
000448 381b          .dw XT_EXIT
                 .include "words/tick.asm"
                 
                 ; Dictionary
                 ; search dictionary for name, return XT or throw an exception -13
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_TICK:
000449 ff01          .dw $ff01
00044a 0027          .db "'",0
00044b 0439          .dw VE_HEAD
                     .set VE_HEAD = VE_TICK
                 XT_TICK:
00044c 3801          .dw DO_COLON
                 PFA_TICK:
                 .endif
00044d 05b8          .dw XT_PARSENAME
00044e 05fa          .dw XT_DORECOGNIZER
00044f 067d          .dw XT_R_WORD
000450 3fd4          .dw XT_EQUAL
000451 3831          .dw XT_DOCONDBRANCH
000452 0455          DEST(PFA_TICK1)
000453 38d4          .dw XT_DROP
000454 381b          .dw XT_EXIT
                 PFA_TICK1:
000455 3838          .dw XT_DOLITERAL
000456 fff3          .dw -13
000457 3d68          .dw XT_THROW
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/cskip.asm"
                 
                 ; String
                 ; skips leading occurancies in string at addr1/n1 leaving addr2/n2 pointing to the 1st non-c character
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_CSKIP:
000458 ff05          .dw $ff05
000459 7363
00045a 696b
00045b 0070          .db "cskip",0
00045c 0449          .dw VE_HEAD
                     .set VE_HEAD = VE_CSKIP
                 XT_CSKIP:
00045d 3801          .dw DO_COLON
                 PFA_CSKIP:
                 .endif
00045e 38fa          .dw XT_TO_R           ; ( -- addr1 n1 )
                 PFA_CSKIP1:
00045f 38ac          .dw XT_DUP            ; ( -- addr' n' n' )
000460 3831          .dw XT_DOCONDBRANCH   ; ( -- addr' n')
000461 046d          DEST(PFA_CSKIP2)
000462 38ca          .dw XT_OVER           ; ( -- addr' n' addr' )
000463 3893          .dw XT_CFETCH         ; ( -- addr' n' c' )
000464 3903          .dw XT_R_FETCH        ; ( -- addr' n' c' c )
000465 3fd4          .dw XT_EQUAL          ; ( -- addr' n' f )
000466 3831          .dw XT_DOCONDBRANCH   ; ( -- addr' n')
000467 046d          DEST(PFA_CSKIP2)
000468 3838          .dw XT_DOLITERAL
000469 0001          .dw 1
00046a 05a9          .dw XT_SLASHSTRING
00046b 382a          .dw XT_DOBRANCH
00046c 045f          DEST(PFA_CSKIP1)
                 PFA_CSKIP2:
00046d 38f1          .dw XT_R_FROM
00046e 38d4          .dw XT_DROP           ; ( -- addr2 n2)
00046f 381b          .dw XT_EXIT
                 .include "words/cscan.asm"
                 
                 ; String
                 ; Scan string at addr1/n1 for the first occurance of c, leaving addr1/n2, char at n2 is first non-c character
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_CSCAN:
000470 ff05          .dw $ff05
000471 7363
000472 6163
../../common\words/cscan.asm(12): warning: .cseg .db misalignment - padding zero byte
000473 006e          .db "cscan"
000474 0458          .dw VE_HEAD
                     .set VE_HEAD = VE_CSCAN
                 XT_CSCAN:
000475 3801          .dw DO_COLON
                 PFA_CSCAN:
                 .endif
000476 38fa          .dw XT_TO_R
000477 38ca          .dw XT_OVER
                 PFA_CSCAN1:
000478 38ac          .dw XT_DUP
000479 3893          .dw XT_CFETCH
00047a 3903          .dw XT_R_FETCH
00047b 3fd4          .dw XT_EQUAL
00047c 3915          .dw XT_ZEROEQUAL
00047d 3831          .dw XT_DOCONDBRANCH
00047e 048a          DEST(PFA_CSCAN2)
00047f 38bf            .dw XT_SWAP
000480 3a30            .dw XT_1MINUS
000481 38bf            .dw XT_SWAP
000482 38ca            .dw XT_OVER
000483 391c            .dw XT_ZEROLESS ; not negative
000484 3915            .dw XT_ZEROEQUAL
000485 3831            .dw XT_DOCONDBRANCH
000486 048a            DEST(PFA_CSCAN2)
000487 3a2a              .dw XT_1PLUS
000488 382a              .dw XT_DOBRANCH
000489 0478              DEST(PFA_CSCAN1)
                 PFA_CSCAN2:
00048a 38eb          .dw XT_NIP
00048b 38ca          .dw XT_OVER
00048c 398e          .dw XT_MINUS
00048d 38f1          .dw XT_R_FROM
00048e 38d4          .dw XT_DROP
00048f 381b          .dw XT_EXIT
                 
                 ; : my-cscan ( addr len c -- addr len' )
                 ;    >r over ( -- addr len addr )
                 ;    begin
                 ;      dup c@ r@ <> while
                 ;       swap 1- swap over 0 >=  while
                 ;        1+ 
                 ;     repeat then
                 ;     nip over - r> drop 
                 ; ;
                 .include "words/accept.asm"
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_ACCEPT:
000490 ff06          .dw $ff06
000491 6361
000492 6563
000493 7470          .db "accept"
000494 0470          .dw VE_HEAD
                     .set VE_HEAD = VE_ACCEPT
                 XT_ACCEPT:
000495 3801          .dw DO_COLON
                 PFA_ACCEPT:
                 
                 .endif
000496 38ca
000497 3998
000498 3a30
000499 38ca              .DW XT_OVER,XT_PLUS,XT_1MINUS,XT_OVER
00049a 3ef3
00049b 38ac
00049c 04cf
00049d 3915
00049e 3831      ACC1:   .DW XT_KEY,XT_DUP,XT_CRLFQ,XT_ZEROEQUAL,XT_DOCONDBRANCH
00049f 04c1              DEST(ACC5)
0004a0 38ac
0004a1 3838
0004a2 0008
0004a3 3fd4
0004a4 3831              .DW XT_DUP,XT_DOLITERAL,8,XT_EQUAL,XT_DOCONDBRANCH
0004a5 04b8              DEST(ACC3)
0004a6 38d4
0004a7 38dc
0004a8 3eb3
0004a9 3973
0004aa 38fa
0004ab 38dc
0004ac 38dc
0004ad 38f1
0004ae 3831              .DW XT_DROP,XT_ROT,XT_2DUP,XT_GREATER,XT_TO_R,XT_ROT,XT_ROT,XT_R_FROM,XT_DOCONDBRANCH
0004af 04b6      	DEST(ACC6)
0004b0 04c7
0004b1 3a30
0004b2 38fa
0004b3 38ca
0004b4 38f1
0004b5 013e      	.DW XT_BS,XT_1MINUS,XT_TO_R,XT_OVER,XT_R_FROM,XT_UMAX
                 ACC6:
0004b6 382a              .DW XT_DOBRANCH
0004b7 04bf              DEST(ACC4)
0004b8 38ac
0004b9 3ee2
0004ba 38ca
0004bb 3888
0004bc 3a2a
0004bd 38ca
0004be 014a      ACC3:   .DW XT_DUP,XT_EMIT,XT_OVER,XT_CSTORE,XT_1PLUS,XT_OVER,XT_UMIN
0004bf 382a      ACC4:   .DW XT_DOBRANCH
0004c0 049a              DEST(ACC1)
0004c1 38d4
0004c2 38eb
0004c3 38bf
0004c4 398e
0004c5 3f92
0004c6 381b      ACC5:   .DW XT_DROP,XT_NIP,XT_SWAP,XT_MINUS,XT_CR,XT_EXIT
                 
                 
                 ; ( --  ) 
                 ; System
                 ; send a backspace character to overwrite the current char
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 ;VE_BS:
                 ;    .dw $ff02
                 ;    .db "bs"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_BS
                 XT_BS:
0004c7 3801          .dw DO_COLON
                 .endif
0004c8 3838          .dw XT_DOLITERAL
0004c9 0008          .dw 8
0004ca 38ac          .dw XT_DUP
0004cb 3ee2          .dw XT_EMIT
0004cc 3f9f          .dw XT_SPACE
0004cd 3ee2          .dw XT_EMIT
0004ce 381b          .dw XT_EXIT
                 
                 
                 ; ( c -- f ) 
                 ; System
                 ; is the character a line end character?
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 ;VE_CRLFQ:
                 ;    .dw $ff02
                 ;    .db "crlf?"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_CRLFQ
                 XT_CRLFQ:
0004cf 3801          .dw DO_COLON
                 .endif
0004d0 38ac          .dw XT_DUP
0004d1 3838          .dw XT_DOLITERAL
0004d2 000d          .dw 13
0004d3 3fd4          .dw XT_EQUAL
0004d4 38bf          .dw XT_SWAP
0004d5 3838          .dw XT_DOLITERAL
0004d6 000a          .dw 10
0004d7 3fd4          .dw XT_EQUAL
0004d8 3a17          .dw XT_OR
0004d9 381b          .dw XT_EXIT
                 .include "words/refill.asm"
                 
                 ; System
                 ; refills the input buffer
                 VE_REFILL:
0004da ff06          .dw $ff06
0004db 6572
0004dc 6966
0004dd 6c6c          .db "refill"
0004de 0490          .dw VE_HEAD
                     .set VE_HEAD = VE_REFILL
                 XT_REFILL:
0004df 3de1          .dw PFA_DODEFER1
                 PFA_REFILL:
0004e0 001a          .dw USER_REFILL
0004e1 3daa          .dw XT_UDEFERFETCH
0004e2 3db6          .dw XT_UDEFERSTORE
                 
                 .include "words/char.asm"
                 
                 ; Tools
                 ; copy the first character of the next word onto the stack
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_CHAR:
0004e3 ff04          .dw $ff04
0004e4 6863
0004e5 7261          .db "char"
0004e6 04da          .dw VE_HEAD
                     .set VE_HEAD = VE_CHAR
                 XT_CHAR:
0004e7 3801          .dw DO_COLON
                 PFA_CHAR:
                 .endif
0004e8 05b8          .dw XT_PARSENAME
0004e9 38d4          .dw XT_DROP
0004ea 3893          .dw XT_CFETCH
0004eb 381b          .dw XT_EXIT
                 .include "words/number.asm"
                 
                 ; Numeric IO
                 ; convert a string at addr to a number
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_NUMBER:
0004ec ff06          .dw $ff06
0004ed 756e
0004ee 626d
0004ef 7265          .db "number"
0004f0 04e3          .dw VE_HEAD
                     .set VE_HEAD = VE_NUMBER
                 XT_NUMBER:
0004f1 3801          .dw DO_COLON
                 PFA_NUMBER:
                 .endif
0004f2 3ea7          .dw XT_BASE
0004f3 3874          .dw XT_FETCH
0004f4 38fa          .dw XT_TO_R
0004f5 0538          .dw XT_QSIGN
0004f6 38fa          .dw XT_TO_R
0004f7 054c          .dw XT_SET_BASE
0004f8 0538          .dw XT_QSIGN
0004f9 38f1          .dw XT_R_FROM
0004fa 3a17          .dw XT_OR
0004fb 38fa          .dw XT_TO_R
                     ; check whether something is left
0004fc 38ac          .dw XT_DUP
0004fd 3915          .dw XT_ZEROEQUAL
0004fe 3831          .dw XT_DOCONDBRANCH
0004ff 0508          DEST(PFA_NUMBER0)
                       ; nothing is left. It cannot be a number at all
000500 3ebc            .dw XT_2DROP
000501 38f1            .dw XT_R_FROM
000502 38d4            .dw XT_DROP
000503 38f1            .dw XT_R_FROM
000504 3ea7            .dw XT_BASE
000505 387c            .dw XT_STORE
000506 394f            .dw XT_ZERO
000507 381b            .dw XT_EXIT
                 PFA_NUMBER0:
000508 3b0d          .dw XT_2TO_R
000509 394f          .dw XT_ZERO       ; starting value
00050a 394f          .dw XT_ZERO
00050b 3b1c          .dw XT_2R_FROM
00050c 056b          .dw XT_TO_NUMBER ; ( 0. addr len -- d addr' len'
                     ; check length of the remaining string.
                     ; if zero: a single cell number is entered
00050d 38b4          .dw XT_QDUP
00050e 3831          .dw XT_DOCONDBRANCH
00050f 052c          DEST(PFA_NUMBER1)
                     ; if equal 1: mayba a trailing dot? --> double cell number
000510 3838          .dw XT_DOLITERAL
000511 0001          .dw 1
000512 3fd4          .dw XT_EQUAL
000513 3831          .dw XT_DOCONDBRANCH
000514 0523          DEST(PFA_NUMBER2)
                 	; excatly one character is left
000515 3893      	.dw XT_CFETCH
000516 3838      	.dw XT_DOLITERAL
000517 002e      	.dw 46 ; .
000518 3fd4      	.dw XT_EQUAL
000519 3831      	.dw XT_DOCONDBRANCH
00051a 0524      	DEST(PFA_NUMBER6)
                 	; its a double cell number
                         ; incorporate sign into number
00051b 38f1      	.dw XT_R_FROM
00051c 3831              .dw XT_DOCONDBRANCH
00051d 051f      	DEST(PFA_NUMBER3)
00051e 023b              .dw XT_DNEGATE
                 PFA_NUMBER3:
00051f 3838      	.dw XT_DOLITERAL
000520 0002      	.dw 2
000521 382a      	.dw XT_DOBRANCH
000522 0533      	DEST(PFA_NUMBER5)
                 PFA_NUMBER2:
000523 38d4      	.dw XT_DROP
                 PFA_NUMBER6:
000524 3ebc      	.dw XT_2DROP
000525 38f1      	.dw XT_R_FROM
000526 38d4      	.dw XT_DROP
000527 38f1              .dw XT_R_FROM
000528 3ea7              .dw XT_BASE
000529 387c              .dw XT_STORE
00052a 394f      	.dw XT_ZERO
00052b 381b      	.dw XT_EXIT
                 PFA_NUMBER1:
00052c 3ebc          .dw XT_2DROP ; remove the address
                     ; incorporate sign into number
00052d 38f1          .dw XT_R_FROM
00052e 3831          .dw XT_DOCONDBRANCH
00052f 0531          DEST(PFA_NUMBER4)
000530 3e11          .dw XT_NEGATE
                 PFA_NUMBER4:
000531 3838          .dw XT_DOLITERAL
000532 0001          .dw 1
                 PFA_NUMBER5:
000533 38f1          .dw XT_R_FROM
000534 3ea7          .dw XT_BASE
000535 387c          .dw XT_STORE
000536 3946          .dw XT_TRUE
000537 381b          .dw XT_EXIT
                 .include "words/q-sign.asm"
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 XT_QSIGN:
000538 3801          .dw DO_COLON 
                 PFA_QSIGN:        ; ( c -- ) 
                 .endif
000539 38ca          .dw XT_OVER    ; ( -- addr len addr )
00053a 3893          .dw XT_CFETCH
00053b 3838          .dw XT_DOLITERAL
00053c 002d          .dw '-'
00053d 3fd4          .dw XT_EQUAL  ; ( -- addr len flag )
00053e 38ac          .dw XT_DUP
00053f 38fa          .dw XT_TO_R
000540 3831          .dw XT_DOCONDBRANCH
000541 0545          DEST(PFA_NUMBERSIGN_DONE)
000542 3838          .dw XT_DOLITERAL      ; skip sign character
000543 0001          .dw 1
000544 05a9          .dw XT_SLASHSTRING
                 PFA_NUMBERSIGN_DONE:
000545 38f1          .dw XT_R_FROM
000546 381b          .dw XT_EXIT
                 .include "words/set-base.asm"
                 
                 ; Numeric IO
                 ; skip a numeric prefix character
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 XT_BASES:
000547 384d          .dw PFA_DOCONSTANT
                 .endif
000548 000a
000549 0010
00054a 0002
00054b 000a          .dw 10,16,2,10 ; last one could a 8 instead.
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 XT_SET_BASE:
00054c 3801          .dw DO_COLON 
                 PFA_SET_BASE:        ; ( adr1 len1 -- adr2 len2 ) 
                 .endif
00054d 38ca          .dw XT_OVER
00054e 3893          .dw XT_CFETCH
00054f 3838          .dw XT_DOLITERAL
000550 0023          .dw 35
000551 398e          .dw XT_MINUS
000552 38ac          .dw XT_DUP
000553 394f          .dw XT_ZERO
000554 3838          .dw XT_DOLITERAL
000555 0004          .dw 4
000556 3e41          .dw XT_WITHIN
000557 3831          .dw XT_DOCONDBRANCH
000558 0563          DEST(SET_BASE1)
                 	.if cpu_msp430==1
                 	.endif
000559 0547      	.dw XT_BASES
00055a 3998      	.dw XT_PLUS
00055b 3bbb      	.dw XT_FETCHI
00055c 3ea7      	.dw XT_BASE
00055d 387c      	.dw XT_STORE
00055e 3838      	.dw XT_DOLITERAL
00055f 0001      	.dw 1
000560 05a9      	.dw XT_SLASHSTRING
000561 382a      	.dw XT_DOBRANCH
000562 0564      	DEST(SET_BASE2)
                 SET_BASE1:
000563 38d4      	.dw XT_DROP
                 SET_BASE2:
000564 381b          .dw XT_EXIT 
                 
                 ; create bases 10 , 16 , 2 , 8 ,
                 ; : set-base 35 - dup 0 4 within if 
                 ;    bases + @i base ! 1 /string 
                 ;   else 
                 ;    drop
                 ;   then ;
                 .include "words/to-number.asm"
                 
                 ; Numeric IO
                 ; convert a string to a number  c-addr2/u2 is the unconverted string
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_TO_NUMBER:
000565 ff07          .dw $ff07
000566 6e3e
000567 6d75
000568 6562
000569 0072          .db ">number",0
00056a 04ec          .dw VE_HEAD
                     .set VE_HEAD = VE_TO_NUMBER
                 XT_TO_NUMBER:
00056b 3801          .dw DO_COLON
                 
                 .endif
                 
00056c 38ac
00056d 3831      TONUM1: .DW XT_DUP,XT_DOCONDBRANCH
00056e 0584              DEST(TONUM3)
00056f 38ca
000570 3893
000571 03ba              .DW XT_OVER,XT_CFETCH,XT_DIGITQ
000572 3915
000573 3831              .DW XT_ZEROEQUAL,XT_DOCONDBRANCH
000574 0577              DEST(TONUM2)
000575 38d4
000576 381b              .DW XT_DROP,XT_EXIT
000577 38fa
000578 0260
000579 3ea7
00057a 3874
00057b 012f      TONUM2: .DW XT_TO_R,XT_2SWAP,XT_BASE,XT_FETCH,XT_UDSTAR
00057c 38f1
00057d 0127
00057e 0260              .DW XT_R_FROM,XT_MPLUS,XT_2SWAP
00057f 3838
000580 0001
000581 05a9
000582 382a              .DW XT_DOLITERAL,1,XT_SLASHSTRING,XT_DOBRANCH
000583 056c              DEST(TONUM1)
000584 381b      TONUM3: .DW XT_EXIT
                 
                 ;C >NUMBER  ud adr u -- ud' adr' u'
                 ;C                      convert string to number
                 ;   BEGIN
                 ;   DUP WHILE
                 ;       OVER C@ DIGIT?
                 ;       0= IF DROP EXIT THEN
                 ;       >R 2SWAP BASE @ UD*
                 ;       R> M+ 2SWAP
                 ;       1 /STRING
                 ;   REPEAT ;
                 .include "words/parse.asm"
                 
                 ; String
                 ; in input buffer parse ccc delimited string by the delimiter char.
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_PARSE:
000585 ff05          .dw $ff05
000586 6170
000587 7372
000588 0065          .db "parse",0
000589 0565          .dw VE_HEAD
                     .set VE_HEAD = VE_PARSE
                 XT_PARSE:
00058a 3801          .dw DO_COLON
                 PFA_PARSE:
                 .endif
00058b 38fa          .dw XT_TO_R     ; ( -- )
00058c 059f          .dw XT_SOURCE   ; ( -- addr len)
00058d 3ecc          .dw XT_TO_IN     ; ( -- addr len >in)
00058e 3874          .dw XT_FETCH
00058f 05a9          .dw XT_SLASHSTRING ; ( -- addr' len' )
                 
000590 38f1          .dw XT_R_FROM      ; ( -- addr' len' c)
000591 0475          .dw XT_CSCAN       ; ( -- addr' len'')
000592 38ac          .dw XT_DUP         ; ( -- addr' len'' len'')
000593 3a2a          .dw XT_1PLUS
000594 3ecc          .dw XT_TO_IN        ; ( -- addr' len'' len'' >in)
000595 3a54          .dw XT_PLUSSTORE   ; ( -- addr' len')
000596 3838          .dw XT_DOLITERAL
000597 0001          .dw 1
000598 05a9          .dw XT_SLASHSTRING
000599 381b          .dw XT_EXIT
                 .include "words/source.asm"
                 
                 ; System
                 ; address and current length of the input buffer
                 VE_SOURCE:
00059a ff06          .dw $FF06
00059b 6f73
00059c 7275
00059d 6563          .db "source"
00059e 0585          .dw VE_HEAD
                     .set VE_HEAD = VE_SOURCE
                 XT_SOURCE:
00059f 3de1          .dw PFA_DODEFER1
                 PFA_SOURCE:
0005a0 0016          .dw USER_SOURCE
0005a1 3daa          .dw XT_UDEFERFETCH
0005a2 3db6          .dw XT_UDEFERSTORE
                 
                 
                 .include "words/slash-string.asm"
                 
                 ; String
                 ; adjust string from addr1 to addr1+n, reduce length from u1 to u2 by n
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SLASHSTRING:
0005a3 ff07          .dw $ff07
0005a4 732f
0005a5 7274
0005a6 6e69
0005a7 0067          .db "/string",0
0005a8 059a          .dw VE_HEAD
                     .set VE_HEAD = VE_SLASHSTRING
                 XT_SLASHSTRING:
0005a9 3801          .dw DO_COLON
                 PFA_SLASHSTRING:
                 .endif
0005aa 38dc          .dw XT_ROT
0005ab 38ca          .dw XT_OVER
0005ac 3998          .dw XT_PLUS
0005ad 38dc          .dw XT_ROT
0005ae 38dc          .dw XT_ROT
0005af 398e          .dw XT_MINUS
0005b0 381b          .dw XT_EXIT
                 
                 .include "words/parse-name.asm"
                 
                 ; String
                 ; In the SOURCE buffer parse whitespace delimited string. Returns string address within SOURCE.
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 VE_PARSENAME:
0005b1 ff0a          .dw $FF0A 
0005b2 6170
0005b3 7372
0005b4 2d65
0005b5 616e
0005b6 656d          .db "parse-name"
0005b7 05a3          .dw VE_HEAD
                     .set VE_HEAD = VE_PARSENAME
                 XT_PARSENAME:
0005b8 3801          .dw DO_COLON 
                 PFA_PARSENAME:
                 .endif
0005b9 3f45          .dw XT_BL
0005ba 05bc          .dw XT_SKIPSCANCHAR
0005bb 381b          .dw XT_EXIT 
                 
                 ; ( c -- addr2 len2 ) 
                 ; String
                 ; skips char and scan what's left in source for char
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 ;VE_SKIPSCANCHAR:
                 ;    .dw $FF0A 
                 ;    .db "skipscanchar"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_SKIPSCANCHAR
                 XT_SKIPSCANCHAR:
0005bc 3801          .dw DO_COLON
                 PFA_SKIPSCANCHAR:
                 .endif
0005bd 38fa          .dw XT_TO_R
0005be 059f          .dw XT_SOURCE 
0005bf 3ecc          .dw XT_TO_IN 
0005c0 3874          .dw XT_FETCH 
0005c1 05a9          .dw XT_SLASHSTRING 
                 
0005c2 3903          .dw XT_R_FETCH
0005c3 045d          .dw XT_CSKIP
0005c4 38f1          .dw XT_R_FROM
0005c5 0475          .dw XT_CSCAN
                 
                     ; adjust >IN
0005c6 3eb3          .dw XT_2DUP
0005c7 3998          .dw XT_PLUS
0005c8 059f          .dw XT_SOURCE 
0005c9 38d4          .dw XT_DROP
0005ca 398e          .dw XT_MINUS
0005cb 3ecc          .dw XT_TO_IN
0005cc 387c          .dw XT_STORE
0005cd 381b          .dw XT_EXIT
                 .include "words/sp0.asm"
                 
                 ; Stack
                 ; start address of the data stack
                 VE_SP0:
0005ce ff03          .dw $ff03
0005cf 7073
0005d0 0030          .db "sp0",0
0005d1 05b1          .dw VE_HEAD
                     .set VE_HEAD = VE_SP0
                 XT_SP0:
0005d2 386a          .dw PFA_DOVALUE1
                 PFA_SP0:
0005d3 0006          .dw USER_SP0
0005d4 3daa          .dw XT_UDEFERFETCH
0005d5 3db6          .dw XT_UDEFERSTORE
                 
                 ; ( -- addr) 
                 ; Stack
                 ; address of user variable to store top-of-stack for inactive tasks
                 VE_SP:
0005d6 ff02          .dw $ff02
0005d7 7073          .db "sp"
0005d8 05ce          .dw VE_HEAD
                     .set VE_HEAD = VE_SP
                 XT_SP:
0005d9 3853          .dw PFA_DOUSER
                 PFA_SP:
0005da 0008          .dw USER_SP
                 .include "words/rp0.asm"
                 
                 ; Stack
                 ; start address of return stack
                 VE_RP0:
0005db ff03          .dw $ff03
0005dc 7072
0005dd 0030          .db "rp0",0
0005de 05d6          .dw VE_HEAD
                     .set VE_HEAD = VE_RP0
                 XT_RP0:
0005df 3801          .dw DO_COLON
                 PFA_RP0:
0005e0 05e3          .dw XT_DORP0
0005e1 3874          .dw XT_FETCH
0005e2 381b          .dw XT_EXIT
                 
                 ; ( -- addr) 
                 ; Stack
                 ; user variable of the address of the initial return stack
                 ;VE_DORP0:
                 ;    .dw $ff05
                 ;    .db "(rp0)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DORP0
                 XT_DORP0:
0005e3 3853          .dw PFA_DOUSER
                 PFA_DORP0:
0005e4 0004          .dw USER_RP
                 .include "words/depth.asm"
                 
                 ; Stack
                 ; number of single-cell values contained in the data stack before n was placed on the stack.
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DEPTH:
0005e5 ff05          .dw $ff05
0005e6 6564
0005e7 7470
0005e8 0068          .db "depth",0
0005e9 05db          .dw VE_HEAD
                     .set VE_HEAD = VE_DEPTH
                 XT_DEPTH:
0005ea 3801          .dw DO_COLON
                 PFA_DEPTH:
                 .endif
0005eb 05d2          .dw XT_SP0
0005ec 3a7c          .dw XT_SP_FETCH
0005ed 398e          .dw XT_MINUS
0005ee 39ff          .dw XT_2SLASH
0005ef 3a30          .dw XT_1MINUS
0005f0 381b          .dw XT_EXIT
                 .include "words/do-recognizer.asm"
                 
                 ; System
                 ; walk the recognizer stack
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DORECOGNIZER:
0005f1 ff0d          .dw $ff0d
0005f2 6f64
0005f3 722d
0005f4 6365
0005f5 676f
0005f6 696e
0005f7 657a
0005f8 0072          .db "do-recognizer",0
0005f9 05e5          .dw VE_HEAD
                     .set VE_HEAD = VE_DORECOGNIZER
                 XT_DORECOGNIZER:
0005fa 3801          .dw DO_COLON
                 PFA_DORECOGNIZER:
                 .endif
0005fb 3838          .dw XT_DOLITERAL
0005fc 0606          .dw XT_DORECOGNIZER_A
0005fd 3838          .dw XT_DOLITERAL
0005fe 005a          .dw CFG_RECOGNIZERLISTLEN
0005ff 09aa          .dw XT_MAPSTACK
000600 3915          .dw XT_ZEROEQUAL
000601 3831          .dw XT_DOCONDBRANCH
000602 0605          DEST(PFA_DORECOGNIZER1)
000603 3ebc            .dw XT_2DROP
000604 069a            .dw XT_R_FAIL
                 PFA_DORECOGNIZER1:
000605 381b          .dw XT_EXIT
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 ; ( addr len XT -- addr len [ r:table -1 | 0 ] )
                 XT_DORECOGNIZER_A:
000606 3801         .dw DO_COLON
                 PFA_DORECOGNIZER_A:
                 .endif
000607 38dc         .dw XT_ROT  ; -- len xt addr
000608 38dc         .dw XT_ROT  ; -- xt addr len
000609 3eb3         .dw XT_2DUP 
00060a 3b0d         .dw XT_2TO_R
00060b 38dc         .dw XT_ROT  ; -- addr len xt
00060c 3825         .dw XT_EXECUTE ; -- i*x r:foo | r:fail
00060d 3b1c         .dw XT_2R_FROM
00060e 38dc         .dw XT_ROT
00060f 38ac         .dw XT_DUP
000610 069a         .dw XT_R_FAIL
000611 3fd4         .dw XT_EQUAL
000612 3831         .dw XT_DOCONDBRANCH
000613 0617         DEST(PFA_DORECOGNIZER_A1)
000614 38d4           .dw XT_DROP
000615 394f           .dw XT_ZERO
000616 381b           .dw XT_EXIT
                 PFA_DORECOGNIZER_A1:
000617 38eb         .dw XT_NIP 
000618 38eb         .dw XT_NIP
000619 3946         .dw XT_TRUE
00061a 381b         .dw XT_EXIT
                 
                 ; : do-recognizer ( addr len -- i*x r:table|r:fail )
                 ;    \ ( addr len -- addr len 0 | i*x r:table -1 )
                 ;    [: rot rot 2dup 2>r rot execute 2r> rot 
                 ;          dup r:fail = ( -- addr len r:table f )
                 ;          if drop 0 else nip nip -1 then
                 ;    ;] 
                 ;    EE_RECOGNIZERLISTLEN map-stack ( -- i*x addr len r:table f )
                 ;    0= if \ a recognizer did the job, remove addr/len
                 ;     2drop r:fail 
                 ;    then
                 ;
                 .include "words/interpret.asm"
                 
                 ; System
                 ; Interpret SOURCE word by word.
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_INTERPRET:
00061b ff09          .dw $ff09
00061c 6e69
00061d 6574
00061e 7072
00061f 6572
000620 0074          .db "interpret",0
000621 05f1          .dw VE_HEAD
                     .set VE_HEAD = VE_INTERPRET
                 XT_INTERPRET:
000622 3801          .dw DO_COLON
                 .endif
                 PFA_INTERPRET:
000623 05b8          .dw XT_PARSENAME ; ( -- addr len )
000624 38ac          .dw XT_DUP   ; ( -- addr len flag)
000625 3831          .dw XT_DOCONDBRANCH
000626 0632          DEST(PFA_INTERPRET2)
000627 05fa            .dw XT_DORECOGNIZER
000628 3ea1            .dw XT_STATE
000629 3874            .dw XT_FETCH
00062a 3831            .dw XT_DOCONDBRANCH
00062b 062d          DEST(PFA_INTERPRET1)
00062c 01d9            .dw XT_ICELLPLUS   ; we need the compile action
                 PFA_INTERPRET1:
00062d 3bbb            .dw XT_FETCHI
00062e 3825            .dw XT_EXECUTE
00062f 3f7c            .dw XT_QSTACK
000630 382a          .dw XT_DOBRANCH
000631 0623          DEST(PFA_INTERPRET)
                 PFA_INTERPRET2:
000632 3ebc          .dw XT_2DROP
000633 381b          .dw XT_EXIT
                 .include "words/r-intnumber.asm"
                 
                 ; Interpreter
                 ; Method table for single cell integers
                 
                 
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_R_NUM:
000634 ff05          .dw $ff05
000635 3a72
000636 756e
000637 006d          .db "r:num",0
000638 061b          .dw VE_HEAD
                     .set VE_HEAD = VE_R_NUM
                 XT_R_NUM:
000639 384d          .dw PFA_DOCONSTANT
                 PFA_R_NUM:
                 .endif
00063a 01ac          .dw XT_NOOP    ; interpret
00063b 0777          .dw XT_LITERAL ; compile
00063c 0646          .dw XT_FAILNUM ; postpone
                 
                 ; ( -- addr )
                 ; Interpreter
                 ; Method table for double cell integers
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_R_DNUM:
00063d ff06          .dw $ff06
00063e 3a72
00063f 6e64
000640 6d75          .db "r:dnum"
000641 0634          .dw VE_HEAD
                     .set VE_HEAD = VE_R_DNUM
                 XT_R_DNUM:
000642 384d          .dw PFA_DOCONSTANT
                 PFA_R_DNUM:
                 .endif
000643 01ac          .dw XT_NOOP     ; interpret
000644 3fc8          .dw XT_2LITERAL ; compile
000645 064c          .dw XT_FAILDNUM ; postpone
                 
                 ; ( -- addr )
                 ; Interpreter
                 ; Method to print a number and throw exception "invalid postpone"
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 ;VE_FAILNUM:
                 ;    .dw $ff06
                 ;    .db "fail:i"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_FAILNUM
                 XT_FAILNUM:
000646 3801          .dw DO_COLON
                 PFA_FAILNUM:
                 .endif
000647 0389          .dw XT_DOT
000648 3838          .dw XT_DOLITERAL
000649 ffd0          .dw -48
00064a 3d68          .dw XT_THROW
00064b 381b          .dw XT_EXIT
                 
                 ; ( -- addr )
                 ; Interpreter
                 ; Method to print a double cell number and throw exception "invalid postpone"
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 VE_FAILDNUM:
                 ;    .dw $ff06
                 ;    .db "fail:d"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_FAILDNUM
                 XT_FAILDNUM:
00064c 3801          .dw DO_COLON
                 PFA_FAILDNUM:
                 .endif
00064d 0381          .dw XT_DDOT
00064e 3838          .dw XT_DOLITERAL
00064f ffd0          .dw -48
000650 3d68          .dw XT_THROW
000651 381b          .dw XT_EXIT
                 
                 ; ( addr len -- f )
                 ; Interpreter
                 ; recognizer for integer numbers
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 VE_REC_NUM:
000652 ff07          .dw $ff07
000653 6572
000654 3a63
000655 756e
000656 006d          .db "rec:num",0
000657 063d          .dw VE_HEAD
                     .set VE_HEAD = VE_REC_NUM
                 XT_REC_NUM:
000658 3801          .dw DO_COLON
                 PFA_REC_NUM:
                 .endif
                     ; try converting to a number
000659 04f1          .dw XT_NUMBER
00065a 3831          .dw XT_DOCONDBRANCH
00065b 0665          DEST(PFA_REC_NONUMBER)
00065c 3838          .dw XT_DOLITERAL
00065d 0001          .dw 1
00065e 3fd4          .dw XT_EQUAL
00065f 3831          .dw XT_DOCONDBRANCH
000660 0663          DEST(PFA_REC_INTNUM2)
000661 0639            .dw XT_R_NUM
000662 381b            .dw XT_EXIT
                 PFA_REC_INTNUM2:
000663 0642            .dw XT_R_DNUM
000664 381b            .dw XT_EXIT
                 PFA_REC_NONUMBER:
000665 069a          .dw XT_R_FAIL
000666 381b          .dw XT_EXIT
                 .include "words/r-word.asm"
                 
                 ; Interpreter
                 ; search for a word
                 .if cpu_msp430==1
                 .endif
                 .if cpu_avr8==1
                 VE_REC_WORD:
000667 ff08          .dw $ff08
000668 6572
000669 3a63
00066a 6f77
00066b 6472          .db "rec:word"
00066c 0652          .dw VE_HEAD
                     .set VE_HEAD = VE_REC_WORD
                 XT_REC_WORD:
00066d 3801          .dw DO_COLON
                 PFA_REC_WORD:
                 .endif
00066e 0710          .DW XT_FINDNAME
00066f 38ac          .dw XT_DUP
000670 3915          .dw XT_ZEROEQUAL
000671 3831          .dw XT_DOCONDBRANCH
000672 0676          DEST(PFA_REC_WORD_FOUND)
000673 38d4              .dw XT_DROP
000674 069a      	.dw XT_R_FAIL
000675 381b      	.dw XT_EXIT
                 PFA_REC_WORD_FOUND:
000676 067d          .dw XT_R_WORD
                 
000677 381b          .dw XT_EXIT
                 
                 ; ( -- addr )
                 ; Interpreter
                 ; actions to handle execution tokens and their flags
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_R_WORD:
000678 ff06          .dw $ff06
000679 3a72
00067a 6f77
00067b 6472          .db "r:word"
00067c 0667          .dw VE_HEAD
                     .set VE_HEAD = VE_R_WORD
                 XT_R_WORD:
00067d 384d          .dw PFA_DOCONSTANT
                 PFA_R_WORD:
                 .endif
00067e 0681          .dw XT_R_WORD_INTERPRET
00067f 0685          .dw XT_R_WORD_COMPILE
000680 068d          .dw XT_R_WORD_POSTPONE
                 
                 ; ( XT flags -- )
                 ; Interpreter
                 ; interpret method for WORD recognizer
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 XT_R_WORD_INTERPRET:
000681 3801          .dw DO_COLON
                 PFA_R_WORD_INTERPRET:
                 .endif
000682 38d4          .dw XT_DROP ; the flags are in the way
000683 3825          .dw XT_EXECUTE
000684 381b          .dw XT_EXIT
                 
                 ; ( XT flags -- )
                 ; Interpreter
                 ; Compile method for WORD recognizer
                 .if cpu_msp430==1
                 .endif
                 .if cpu_avr8==1
                 XT_R_WORD_COMPILE:
000685 3801          .dw DO_COLON
                 PFA_R_WORD_COMPILE:
                 .endif
000686 391c          .dw XT_ZEROLESS
000687 3831          .dw XT_DOCONDBRANCH
000688 068b          DEST(PFA_R_WORD_COMPILE1)
000689 0761      	.dw XT_COMMA
00068a 381b              .dw XT_EXIT
                 PFA_R_WORD_COMPILE1:
00068b 3825              .dw XT_EXECUTE
00068c 381b          .dw XT_EXIT
                 
                 ; ( XT flags -- )
                 ; Interpreter
                 ; Postpone method for WORD recognizer
                 .if cpu_msp430==1
                 .endif
                 .if cpu_avr8==1
                 XT_R_WORD_POSTPONE:
00068d 3801          .dw DO_COLON
                 PFA_R_WORD_POSTPONE:
                 .endif
00068e 391c          .dw XT_ZEROLESS
00068f 3831          .dw XT_DOCONDBRANCH
000690 0693          DEST(PFA_R_WORD_POSTPONE1)
000691 0756            .dw XT_COMPILE
000692 0756            .dw XT_COMPILE
                 PFA_R_WORD_POSTPONE1:
000693 0761          .dw XT_COMMA
000694 381b          .dw XT_EXIT
                 .include "words/r-fail.asm"
                 
                 ; Interpreter
                 ; there is no parser for this recognizer, this is the default and failsafe part
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_R_FAIL:
000695 ff06          .dw $ff06
000696 3a72
000697 6166
000698 6c69          .db "r:fail"
000699 0678          .dw VE_HEAD
                     .set VE_HEAD = VE_R_FAIL
                 XT_R_FAIL:
00069a 384d          .dw PFA_DOCONSTANT
                 PFA_R_FAIL:
                 .endif
00069b 069e          .dw XT_FAIL  ; interpret
00069c 069e          .dw XT_FAIL  ; compile
00069d 069e          .dw XT_FAIL  ; postpone
                 
                 ; ( addr len -- )
                 ; Interpreter
                 ; default failure action: throw exception -13.
                 .if cpu_msp430==1
                 .endif
                 .if cpu_avr8==1
                 ;VE_FAIL:
                 ;    .dw $ff04
                 ;    .db "fail"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_FAIL
                 XT_FAIL:
00069e 3801          .dw DO_COLON
                 PFA_FAIL:
                 .endif
00069f 3838          .dw XT_DOLITERAL
0006a0 fff3          .dw -13
0006a1 3d68          .dw XT_THROW
                 .include "words/search-wordlist.asm"
                 
                 ; Search Order
                 ; searches the word list wid for the word at c-addr/len
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SEARCH_WORDLIST:
0006a2 ff0f          .dw $ff0f
0006a3 6573
0006a4 7261
0006a5 6863
0006a6 772d
0006a7 726f
0006a8 6c64
0006a9 7369
0006aa 0074          .db "search-wordlist",0
0006ab 0695          .dw VE_HEAD
                     .set VE_HEAD = VE_SEARCH_WORDLIST
                 XT_SEARCH_WORDLIST:
0006ac 3801          .dw DO_COLON
                 PFA_SEARCH_WORDLIST:
                 .endif
0006ad 38fa          .dw XT_TO_R
0006ae 394f          .dw XT_ZERO
0006af 3838          .dw XT_DOLITERAL
0006b0 06c1          .dw XT_ISWORD
0006b1 38f1          .dw XT_R_FROM
0006b2 06de          .dw XT_TRAVERSEWORDLIST
0006b3 38ac          .dw XT_DUP
0006b4 3915          .dw XT_ZEROEQUAL
0006b5 3831          .dw XT_DOCONDBRANCH
0006b6 06bb          DEST(PFA_SEARCH_WORDLIST1)
0006b7 3ebc             .dw XT_2DROP
0006b8 38d4             .dw XT_DROP
0006b9 394f             .dw XT_ZERO
0006ba 381b             .dw XT_EXIT
                 PFA_SEARCH_WORDLIST1:
                       ; ... get the XT ...
0006bb 38ac            .dw XT_DUP
0006bc 0705            .dw XT_NFA2CFA
                       ; .. and get the header flag
0006bd 38bf            .dw XT_SWAP
0006be 0165            .dw XT_NAME2FLAGS
0006bf 0152            .dw XT_IMMEDIATEQ
0006c0 381b          .dw XT_EXIT
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 XT_ISWORD:
0006c1 3801          .dw DO_COLON
                 PFA_ISWORD:
                 .endif
                     ; ( c-addr len 0 nt -- c-addr len 0 true| nt false )
0006c2 38fa          .dw XT_TO_R
0006c3 38d4          .dw XT_DROP
0006c4 3eb3          .dw XT_2DUP
0006c5 3903          .dw XT_R_FETCH  ; -- addr len addr len nt
0006c6 06f9          .dw XT_NAME2STRING
0006c7 01e2          .dw XT_ICOMPARE      ; (-- addr len f )
0006c8 3831          .dw XT_DOCONDBRANCH
0006c9 06cf          DEST(PFA_ISWORD3)
                       ; not now
0006ca 38f1            .dw XT_R_FROM
0006cb 38d4            .dw XT_DROP
0006cc 394f            .dw XT_ZERO
0006cd 3946            .dw XT_TRUE         ; maybe next word
0006ce 381b            .dw XT_EXIT
                 PFA_ISWORD3:
                       ; we found the word, now clean up iteration data ...
0006cf 3ebc            .dw XT_2DROP
0006d0 38f1            .dw XT_R_FROM
0006d1 394f            .dw XT_ZERO       ; finish traverse-wordlist
0006d2 381b            .dw XT_EXIT
                 .include "words/traverse-wordlist.asm"
                 
                 ; Tools Ext (2012)
                 ; call the xt for every member of the wordlist wid until xt returns false
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_TRAVERSEWORDLIST:
0006d3 ff11          .dw $ff11
0006d4 7274
0006d5 7661
0006d6 7265
0006d7 6573
0006d8 772d
0006d9 726f
0006da 6c64
0006db 7369
0006dc 0074          .db "traverse-wordlist",0
0006dd 06a2          .dw VE_HEAD
                     .set VE_HEAD = VE_TRAVERSEWORDLIST
                 XT_TRAVERSEWORDLIST:
0006de 3801          .dw DO_COLON
                 PFA_TRAVERSEWORDLIST:
                 
                 .endif
0006df 3b4e          .dw XT_FETCHE
                 PFA_TRAVERSEWORDLIST1:
0006e0 38ac          .dw XT_DUP           ; ( -- xt nt nt )
0006e1 3831          .dw XT_DOCONDBRANCH  ; ( -- nt ) is nfa = counted string
0006e2 06ef          DEST(PFA_TRAVERSEWORDLIST2)
0006e3 3eb3          .dw XT_2DUP
0006e4 3b0d          .dw XT_2TO_R
0006e5 38bf          .dw XT_SWAP
0006e6 3825          .dw XT_EXECUTE
0006e7 3b1c          .dw XT_2R_FROM
0006e8 38dc          .dw XT_ROT
0006e9 3831          .dw XT_DOCONDBRANCH
0006ea 06ef          DEST(PFA_TRAVERSEWORDLIST2)
0006eb 0a11          .dw XT_NFA2LFA
0006ec 3bbb          .dw XT_FETCHI
0006ed 382a          .dw XT_DOBRANCH      ; ( -- addr )
0006ee 06e0          DEST(PFA_TRAVERSEWORDLIST1)       ; ( -- addr )
                 PFA_TRAVERSEWORDLIST2:
0006ef 3ebc          .dw XT_2DROP
0006f0 381b          .dw XT_EXIT
                 
                 ; : traverse-wordlist ( i*x xt wid -- i*x' ) 
                 ;        begin @ dup 
                 ;        while 
                 ;          2dup 2>r 
                 ;          cell + swap execute ( i*x nt -- i*x' f ) 
                 ;          2r> rot 
                 ;        while repeat then 2drop ; 
                 .include "words/name2string.asm"
                 
                 ; Tools Ext (2012)
                 ; get a (flash) string from a name token nt
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_NAME2STRING:
0006f1 ff0b          .dw $ff0b
0006f2 616e
0006f3 656d
0006f4 733e
0006f5 7274
0006f6 6e69
0006f7 0067          .db "name>string",0
0006f8 06d3          .dw VE_HEAD
                     .set VE_HEAD = VE_NAME2STRING
                 XT_NAME2STRING:
0006f9 3801          .dw DO_COLON
                 PFA_NAME2STRING:
                 
                 .endif
0006fa 0433          .dw XT_ICOUNT   ; ( -- addr n )
0006fb 3838          .dw XT_DOLITERAL
0006fc 00ff          .dw 255
0006fd 3a0e          .dw XT_AND      ; mask immediate bit
0006fe 381b          .dw XT_EXIT
                 .include "words/nfa2cfa.asm"
                 
                 ; Tools
                 ; get the XT from a name token
                 VE_NFA2CFA:
0006ff ff07          .dw $ff07
000700 666e
000701 3e61
000702 6663
../../avr8\words/nfa2cfa.asm(6): warning: .cseg .db misalignment - padding zero byte
000703 0061          .db "nfa>cfa"
000704 06f1          .dw VE_HEAD
                     .set VE_HEAD = VE_NFA2CFA
                 XT_NFA2CFA:
000705 3801          .dw DO_COLON
                 PFA_NFA2CFA:
000706 0a11          .dw XT_NFA2LFA ; skip to link field
000707 3a2a          .dw XT_1PLUS   ; next is the execution token
000708 381b          .dw XT_EXIT
                 .include "words/find-name.asm"
                 
                 ; Tools
                 ; search wordlists for an entry with the name from c-addr/len
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_FINDNAME:
000709 ff09          .dw $ff09
00070a 6966
00070b 646e
00070c 6e2d
00070d 6d61
00070e 0065          .db "find-name",0
00070f 06ff          .dw VE_HEAD
                     .set VE_HEAD = VE_FINDNAME
                 XT_FINDNAME:
000710 3801          .dw DO_COLON
                 PFA_FINDNAME:
                 .endif
000711 3838          .dw XT_DOLITERAL
000712 071c          .dw XT_FINDNAMEA
000713 3838          .dw XT_DOLITERAL
000714 0048          .dw CFG_ORDERLISTLEN
000715 09aa          .dw XT_MAPSTACK
000716 3915          .dw XT_ZEROEQUAL
000717 3831          .dw XT_DOCONDBRANCH
000718 071b          DEST(PFA_FINDNAME1)
000719 3ebc            .dw XT_2DROP
00071a 394f            .dw XT_ZERO
                 PFA_FINDNAME1:
00071b 381b          .dw XT_EXIT
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 XT_FINDNAMEA:
00071c 3801          .dw DO_COLON
                 PFA_FINDNAMEA:
                 .endif
00071d 38fa          .dw XT_TO_R
00071e 3eb3          .dw XT_2DUP
00071f 38f1          .dw XT_R_FROM
000720 06ac          .dw XT_SEARCH_WORDLIST
000721 38ac          .dw XT_DUP
000722 3831          .dw XT_DOCONDBRANCH
000723 0729          DEST(PFA_FINDNAMEA1)
000724 38fa            .dw XT_TO_R
000725 38eb            .dw XT_NIP
000726 38eb            .dw XT_NIP
000727 38f1            .dw XT_R_FROM
000728 3946            .dw XT_TRUE
                 PFA_FINDNAMEA1:
000729 381b          .dw XT_EXIT
                 
                 .include "dict/compiler1.inc"
                 
                 .include "words/docreate.asm"
                 
                 ; Compiler
                 ; parse the input and create an empty vocabulary entry without XT and data field (PF)
                 VE_DOCREATE:
00072a ff08          .dw $ff08
00072b 6328
00072c 6572
00072d 7461
00072e 2965          .db "(create)"
00072f 0709          .dw VE_HEAD
                     .set VE_HEAD = VE_DOCREATE
                 XT_DOCREATE:
000730 3801          .dw DO_COLON
                 PFA_DOCREATE:
000731 05b8          .dw XT_PARSENAME
000732 088b          .dw XT_WLSCOPE
000733 38ac          .dw XT_DUP
000734 38fa          .dw XT_TO_R
000735 0870          .dw XT_HEADER
000736 38f1          .dw XT_R_FROM
                 .dseg
000173           COLON_SMUDGE: .byte 4
                 .cseg
000737 3838          .dw XT_DOLITERAL
000738 0175          .dw COLON_SMUDGE+2
000739 387c          .dw XT_STORE		; save wid
00073a 3838          .dw XT_DOLITERAL
00073b 0173          .dw COLON_SMUDGE+0
00073c 387c          .dw XT_STORE		; save NFA
                 
00073d 381b          .dw XT_EXIT
                 .include "words/backslash.asm"
                 
                 ; Compiler
                 ; everything up to the end of the current line is a comment
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_BACKSLASH:
00073e 0001          .dw $0001
00073f 005c          .db $5c,0
000740 072a          .dw VE_HEAD
                     .set VE_HEAD = VE_BACKSLASH
                 XT_BACKSLASH:
000741 3801          .dw DO_COLON
                 PFA_BACKSLASH:
                 .endif
000742 059f          .dw XT_SOURCE
000743 38eb          .dw XT_NIP
000744 3ecc          .dw XT_TO_IN
000745 387c          .dw XT_STORE
000746 381b          .dw XT_EXIT
                 .include "words/l-paren.asm"
                 
                 ; Compiler
                 ; skip everything up to the closing bracket on the same line
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_LPAREN:
000747 0001          .dw $0001
000748 0028          .db "(" ,0
000749 073e          .dw VE_HEAD
                     .set VE_HEAD = VE_LPAREN
                 XT_LPAREN:
00074a 3801          .dw DO_COLON
                 PFA_LPAREN:
                 .endif
00074b 3838          .dw XT_DOLITERAL
00074c 0029          .dw ')'
00074d 058a          .dw XT_PARSE
00074e 3ebc          .dw XT_2DROP
00074f 381b          .dw XT_EXIT
                 
                 .include "words/compile.asm"
                 
                 ; Dictionary
                 ; read the following cell from the dictionary and append it to the current dictionary position.
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_COMPILE:
000750 ff07          .dw $ff07
000751 6f63
000752 706d
000753 6c69
000754 0065          .db "compile",0
000755 0747          .dw  VE_HEAD
                     .set VE_HEAD = VE_COMPILE
                 XT_COMPILE:
000756 3801          .dw DO_COLON
                 PFA_COMPILE:
                 .endif
000757 38f1          .dw XT_R_FROM
000758 38ac          .dw XT_DUP
000759 01d9          .dw XT_ICELLPLUS
00075a 38fa          .dw XT_TO_R
00075b 3bbb          .dw XT_FETCHI
00075c 0761          .dw XT_COMMA
00075d 381b          .dw XT_EXIT
                 .include "words/comma.asm"
                 
                 ; Dictionary
                 ; compile 16 bit into flash at DP
                 VE_COMMA:
00075e ff01          .dw $ff01
00075f 002c          .db ',',0 ; ,
000760 0750          .dw VE_HEAD
                     .set VE_HEAD = VE_COMMA
                 XT_COMMA:
000761 3801          .dw DO_COLON
                 PFA_COMMA:
000762 3f02          .dw XT_DP
000763 3b62          .dw XT_STOREI
000764 3f02          .dw XT_DP
000765 3a2a          .dw XT_1PLUS
000766 01c7          .dw XT_DOTO
000767 3f03          .dw PFA_DP
000768 381b          .dw XT_EXIT
                 .include "words/brackettick.asm"
                 
                 ; Compiler
                 ; what ' does in the interpreter mode, do in colon definitions
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_BRACKETTICK:
000769 0003          .dw $0003
00076a 275b
00076b 005d          .db "[']",0
00076c 075e          .dw VE_HEAD
                     .set VE_HEAD = VE_BRACKETTICK
                 XT_BRACKETTICK:
00076d 3801          .dw DO_COLON
                 PFA_BRACKETTICK:
                 .endif
00076e 044c          .dw XT_TICK
00076f 0777          .dw XT_LITERAL
000770 381b          .dw XT_EXIT
                 
                 
                 .include "words/literal.asm"
                 
                 ; Compiler
                 ; compile a literal in colon defintions
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_LITERAL:
000771 0007          .dw $0007
000772 696c
000773 6574
000774 6172
000775 006c          .db "literal",0
000776 0769          .dw VE_HEAD
                     .set VE_HEAD = VE_LITERAL
                 XT_LITERAL:
000777 3801          .dw DO_COLON
                 PFA_LITERAL:
                 .endif
000778 0756              .DW XT_COMPILE
000779 3838              .DW XT_DOLITERAL
00077a 0761              .DW XT_COMMA
00077b 381b              .DW XT_EXIT
                 .include "words/sliteral.asm"
                 
                 ; String
                 ; compiles a string to flash, at runtime leaves ( -- flash-addr count) on stack
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SLITERAL:
00077c 0008        .dw $0008
00077d 6c73
00077e 7469
00077f 7265
000780 6c61        .db "sliteral"
000781 0771        .dw VE_HEAD
                   .set VE_HEAD = VE_SLITERAL
                 XT_SLITERAL:
000782 3801          .dw DO_COLON
                 PFA_SLITERAL:
                 .endif
000783 0756          .dw XT_COMPILE
000784 03d4          .dw XT_DOSLITERAL    ; ( -- addr n)
000785 03e2          .dw XT_SCOMMA
000786 381b          .dw XT_EXIT
                 .include "words/g-mark.asm"
                 
                 ; Compiler
                 ; places current dictionary position for backward resolves
                 ;VE_GMARK:
                 ;    .dw $ff05
                 ;    .db ">mark"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_GMARK
                 XT_GMARK:
000787 3801          .dw DO_COLON
                 PFA_GMARK:
000788 3f02          .dw XT_DP
000789 0756          .dw XT_COMPILE
00078a ffff          .dw -1           ; ffff does not erase flash
00078b 381b          .dw XT_EXIT
                 .include "words/g-resolve.asm"
                 
                 ; Compiler
                 ; resolve backward jumps
                 ;VE_GRESOLVE:
                 ;    .dw $ff08
                 ;    .db ">resolve"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_GRESOLVE
                 XT_GRESOLVE:
00078c 3801          .dw DO_COLON
                 PFA_GRESOLVE:
00078d 3f7c          .dw XT_QSTACK
00078e 3f02          .dw XT_DP
00078f 38bf          .dw XT_SWAP
000790 3b62          .dw XT_STOREI
000791 381b          .dw XT_EXIT
                 .include "words/l_mark.asm"
                 
                 ; Compiler
                 ; place destination for backward branch
                 ;VE_LMARK:
                 ;    .dw $ff05
                 ;    .db "<mark"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_LMARK
                 XT_LMARK:
000792 3801          .dw DO_COLON
                 PFA_LMARK:
000793 3f02          .dw XT_DP
000794 381b          .dw XT_EXIT
                 .include "words/l_resolve.asm"
                 
                 ; Compiler
                 ; resolve backward branch
                 ;VE_LRESOLVE:
                 ;    .dw $ff08
                 ;    .db "<resolve"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_LRESOLVE
                 XT_LRESOLVE:
000795 3801          .dw DO_COLON
                 PFA_LRESOLVE:
000796 3f7c          .dw XT_QSTACK
000797 0761          .dw XT_COMMA
000798 381b          .dw XT_EXIT
                 
                 .include "words/ahead.asm"
                 
                 ; Compiler
                 ; do a unconditional branch
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_AHEAD:
000799 0005          .dw $0005
00079a 6861
00079b 6165
00079c 0064          .db "ahead",0
00079d 077c          .dw VE_HEAD
                     .set VE_HEAD = VE_AHEAD
                 XT_AHEAD:
00079e 3801          .dw DO_COLON
                 PFA_AHEAD:
                 .endif
00079f 0756          .dw XT_COMPILE
0007a0 382a          .dw XT_DOBRANCH
0007a1 0787          .dw XT_GMARK
0007a2 381b          .dw XT_EXIT
                 .include "words/if.asm"
                 
                 ; Compiler
                 ; start conditional branch
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_IF:
0007a3 0002          .dw $0002
0007a4 6669          .db "if"
0007a5 0799          .dw VE_HEAD
                     .set VE_HEAD = VE_IF
                 XT_IF:
0007a6 3801          .dw DO_COLON
                 PFA_IF:
                 .endif
0007a7 0756          .dw XT_COMPILE
0007a8 3831          .dw XT_DOCONDBRANCH
0007a9 0787          .dw XT_GMARK
0007aa 381b          .dw XT_EXIT
                 .include "words/else.asm"
                 
                 ; Compiler
                 ; resolve the forward reference and place a new unresolved forward reference
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_ELSE:
0007ab 0004          .dw $0004
0007ac 6c65
0007ad 6573          .db "else"
0007ae 07a3          .dw VE_HEAD
                     .set VE_HEAD = VE_ELSE
                 XT_ELSE:
0007af 3801          .dw DO_COLON
                 PFA_ELSE:
                 .endif
0007b0 0756          .dw XT_COMPILE
0007b1 382a          .dw XT_DOBRANCH
0007b2 0787          .dw XT_GMARK
0007b3 38bf          .dw XT_SWAP
0007b4 078c          .dw XT_GRESOLVE
0007b5 381b          .dw XT_EXIT
                 .include "words/then.asm"
                 
                 ; Compiler
                 ; finish if
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_THEN:
0007b6 0004          .dw $0004
0007b7 6874
0007b8 6e65          .db "then"
0007b9 07ab          .dw VE_HEAD
                     .set VE_HEAD = VE_THEN
                 XT_THEN:
0007ba 3801          .dw DO_COLON
                 PFA_THEN:
                 .endif
0007bb 078c          .dw XT_GRESOLVE
0007bc 381b          .dw XT_EXIT
                 .include "words/begin.asm"
                 
                 ; Compiler
                 ; put the next location for a transfer of control onto the control flow stack
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_BEGIN:
0007bd 0005          .dw $0005
0007be 6562
0007bf 6967
0007c0 006e          .db "begin",0
0007c1 07b6          .dw VE_HEAD
                     .set VE_HEAD = VE_BEGIN
                 XT_BEGIN:
0007c2 3801          .dw DO_COLON
                 PFA_BEGIN:
                 .endif
0007c3 0792          .dw XT_LMARK
0007c4 381b          .dw XT_EXIT
                 .include "words/while.asm"
                 
                 ; Compiler
                 ; at runtime skip until repeat if non-true
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_WHILE:
0007c5 0005          .dw $0005
0007c6 6877
0007c7 6c69
0007c8 0065          .db "while",0
0007c9 07bd          .dw VE_HEAD
                     .set VE_HEAD = VE_WHILE
                 XT_WHILE:
0007ca 3801          .dw DO_COLON
                 PFA_WHILE:
                 .endif
0007cb 07a6          .dw XT_IF
0007cc 38bf          .dw XT_SWAP
0007cd 381b          .dw XT_EXIT
                 .include "words/repeat.asm"
                 
                 ; Compiler
                 ; continue execution at dest, resolve orig
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_REPEAT:
0007ce 0006          .dw $0006
0007cf 6572
0007d0 6570
0007d1 7461          .db "repeat"
0007d2 07c5          .dw VE_HEAD
                     .set VE_HEAD = VE_REPEAT
                 XT_REPEAT:
0007d3 3801          .dw DO_COLON
                 PFA_REPEAT:
                 .endif
0007d4 07e7          .dw XT_AGAIN
0007d5 07ba          .dw XT_THEN
0007d6 381b          .dw XT_EXIT
                 .include "words/until.asm"
                 
                 ; Compiler
                 ; finish begin with conditional branch, leaves the loop if true flag at runtime
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_UNTIL:
0007d7 0005          .dw $0005
0007d8 6e75
0007d9 6974
0007da 006c          .db "until",0
0007db 07ce          .dw VE_HEAD
                     .set VE_HEAD = VE_UNTIL
                 XT_UNTIL:
0007dc 3801          .dw DO_COLON
                 PFA_UNTIL:
                 .endif
0007dd 3838          .dw XT_DOLITERAL
0007de 3831          .dw XT_DOCONDBRANCH
0007df 0761          .dw XT_COMMA
                 
0007e0 0795          .dw XT_LRESOLVE
0007e1 381b          .dw XT_EXIT
                 .include "words/again.asm"
                 
                 ; Compiler
                 ; compile a jump back to dest
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_AGAIN:
0007e2 0005          .dw $0005
0007e3 6761
0007e4 6961
0007e5 006e          .db "again",0
0007e6 07d7          .dw VE_HEAD
                     .set VE_HEAD = VE_AGAIN
                 XT_AGAIN:
0007e7 3801          .dw DO_COLON
                 PFA_AGAIN:
                 .endif
0007e8 0756          .dw XT_COMPILE
0007e9 382a          .dw XT_DOBRANCH
0007ea 0795          .dw XT_LRESOLVE
0007eb 381b          .dw XT_EXIT
                 .include "words/do.asm"
                 
                 ; Compiler
                 ; start do .. [+]loop
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DO:
0007ec 0002          .dw $0002
0007ed 6f64          .db "do"
0007ee 07e2          .dw VE_HEAD
                     .set VE_HEAD = VE_DO
                 XT_DO:
0007ef 3801          .dw DO_COLON
                 PFA_DO:
                 
                 .endif
0007f0 0756          .dw XT_COMPILE
0007f1 3a8a          .dw XT_DODO
0007f2 0792          .dw XT_LMARK
0007f3 394f          .dw XT_ZERO
0007f4 084a          .dw XT_TO_L
0007f5 381b          .dw XT_EXIT
                 .include "words/loop.asm"
                 
                 ; Compiler
                 ; compile (loop) and resolve the backward branch
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_LOOP:
0007f6 0004          .dw $0004
0007f7 6f6c
0007f8 706f          .db "loop"
0007f9 07ec          .dw VE_HEAD
                     .set VE_HEAD = VE_LOOP
                 XT_LOOP:
0007fa 3801          .dw DO_COLON
                 PFA_LOOP:
                 .endif
0007fb 0756          .dw XT_COMPILE
0007fc 3ab8          .dw XT_DOLOOP
0007fd 0831          .dw XT_ENDLOOP
0007fe 381b          .dw XT_EXIT
                 .include "words/plusloop.asm"
                 
                 ; Compiler
                 ; compile (+loop) and resolve branches
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_PLUSLOOP:
0007ff 0005          .dw $0005
000800 6c2b
000801 6f6f
000802 0070          .db "+loop",0
000803 07f6          .dw VE_HEAD
                     .set VE_HEAD = VE_PLUSLOOP
                 XT_PLUSLOOP:
000804 3801          .dw DO_COLON
                 PFA_PLUSLOOP:
                 .endif
000805 0756          .dw XT_COMPILE
000806 3aa9          .dw XT_DOPLUSLOOP
000807 0831          .dw XT_ENDLOOP
000808 381b          .dw XT_EXIT
                 .include "words/leave.asm"
                 
                 ; Compiler
                 ; immediatly leave the current DO..LOOP
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_LEAVE:
000809 0005         .dw $0005
00080a 656c
00080b 7661
00080c 0065         .db "leave",0
00080d 07ff         .dw VE_HEAD
                    .set VE_HEAD = VE_LEAVE
                 XT_LEAVE:
00080e 3801          .dw DO_COLON
                 PFA_LEAVE:
                 .endif
00080f 0756
000810 3ac3          .DW XT_COMPILE,XT_UNLOOP
000811 079e
000812 084a
000813 381b          .DW XT_AHEAD,XT_TO_L,XT_EXIT
                 .include "words/qdo.asm"
                 
                 ; Compiler
                 ; start a ?do .. [+]loop control structure
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 VE_QDO:
000814 0003          .dw $0003
000815 643f
000816 006f          .db "?do",0
000817 0809          .dw VE_HEAD
                     .set VE_HEAD = VE_QDO
                 XT_QDO:
000818 3801          .dw DO_COLON
                 PFA_QDO:
                 .endif
000819 0756          .dw XT_COMPILE
00081a 0820          .dw XT_QDOCHECK
00081b 07a6          .dw XT_IF
00081c 07ef          .dw XT_DO
00081d 38bf          .dw XT_SWAP    ; DO sets a 0 marker on the leave stack
00081e 084a          .dw XT_TO_L    ; then follows at the end.
00081f 381b          .dw XT_EXIT
                 
                 ; there is no special runtime for ?do, the do runtime
                 ; gets wrapped with the sequence
                 ; ... ?do-check if do ..... loop then
                 ; with
                 ; : ?do-check ( n1 n2 -- n1 n2 true | false )
                 ;   2dup = dup >r if 2drop then r> invert ;
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 XT_QDOCHECK:
000820 3801          .dw DO_COLON
                 PFA_QDOCHECK:
                 .endif
000821 3eb3          .dw XT_2DUP
000822 3fd4          .dw XT_EQUAL
000823 38ac          .dw XT_DUP
000824 38fa          .dw XT_TO_R
000825 3831          .dw XT_DOCONDBRANCH
000826 0828          DEST(PFA_QDOCHECK1)
000827 3ebc          .dw XT_2DROP
                 PFA_QDOCHECK1:
000828 38f1          .dw XT_R_FROM
000829 39f8          .dw XT_INVERT
00082a 381b          .dw XT_EXIT
                 .include "words/endloop.asm"
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_ENDLOOP:
00082b ff07          .dw $ff07
00082c 6e65
00082d 6c64
00082e 6f6f
00082f 0070          .db "endloop",0
000830 0814          .dw VE_HEAD
                     .set VE_HEAD = VE_ENDLOOP
                 XT_ENDLOOP:
000831 3801          .dw DO_COLON
                 PFA_ENDLOOP:
                 .endif
                 ;Z ENDLOOP   adrs xt --   L: 0 a1 a2 .. aN --
                 ;   <resolve                backward loop
                 ;   BEGIN L> ?DUP WHILE POSTPONE THEN REPEAT ;
                 ;                                 resolve LEAVEs
                 ; This is a common factor of LOOP and +LOOP.
                 
000832 0795              .DW XT_LRESOLVE
000833 083e
000834 38b4
000835 3831      LOOP1:  .DW XT_L_FROM,XT_QDUP,XT_DOCONDBRANCH
000836 083a               DEST(LOOP2)
000837 07ba              .DW XT_THEN
000838 382a      	.dw XT_DOBRANCH
000839 0833               DEST(LOOP1)
00083a 381b      LOOP2:  .DW XT_EXIT
                 ; leave address stack
                 .include "words/l-from.asm"
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_L_FROM:
00083b ff02          .dw $ff02
00083c 3e6c          .db "l>"
00083d 082b          .dw VE_HEAD
                     .set VE_HEAD = VE_L_FROM
                 XT_L_FROM:
00083e 3801          .dw DO_COLON
                 PFA_L_FROM:
                 
                 .endif
                 ;Z L>   -- x   L: x --      move from leave stack
                 ;   LP @ @  -2 LP +! ;
                 
00083f 085e          .dw XT_LP
000840 3874          .dw XT_FETCH
000841 3874          .dw XT_FETCH
000842 3838          .dw XT_DOLITERAL
000843 fffe          .dw -2
000844 085e          .dw XT_LP
000845 3a54          .dw XT_PLUSSTORE
000846 381b          .dw XT_EXIT
                 .include "words/to-l.asm"
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_TO_L:
000847 ff02          .dw $ff02
000848 6c3e          .db ">l"
000849 083b          .dw VE_HEAD
                     .set VE_HEAD = VE_TO_L
                 XT_TO_L:
00084a 3801          .dw DO_COLON
                 PFA_TO_L:
                 .endif
                 ;Z >L   x --   L: -- x        move to leave stack
                 ;   CELL LP +!  LP @ ! ;      (L stack grows up)
                 
00084b 3838              .dw XT_DOLITERAL
00084c 0002      	.dw 2
00084d 085e      	.dw XT_LP
00084e 3a54      	.dw XT_PLUSSTORE
00084f 085e      	.dw XT_LP
000850 3874      	.dw XT_FETCH
000851 387c      	.dw XT_STORE
000852 381b      	.dw XT_EXIT
                 .include "words/lp0.asm"
                 
                 ; Stack
                 ; start address of leave stack
                 VE_LP0:
000853 ff03          .dw $ff03
000854 706c
000855 0030          .db "lp0",0
000856 0847          .dw VE_HEAD
                     .set VE_HEAD = VE_LP0
                 XT_LP0:
000857 386a          .dw PFA_DOVALUE1
                 PFA_LP0:
000858 0066          .dw EE_LP0
000859 3d82          .dw XT_EDEFERFETCH
00085a 3d8c          .dw XT_EDEFERSTORE
                 .include "words/lp.asm"
                 
                 ; System Variable
                 ; leave stack pointer
                 VE_LP:
00085b ff02          .dw $ff02
00085c 706c          .db "lp"
00085d 0853          .dw VE_HEAD
                     .set VE_HEAD = VE_LP
                 XT_LP:
00085e 3843          .dw PFA_DOVARIABLE
                 PFA_LP:
00085f 0177          .dw ram_lp
                 
                 .dseg
000177           ram_lp: .byte 2
                 .cseg
                 
                 
                 .include "words/create.asm"
                 
                 ; Dictionary
                 ; create a dictionary header. XT is (constant), with the address of the data field of name
                 VE_CREATE:
000860 ff06          .dw $ff06
000861 7263
000862 6165
000863 6574          .db "create"
000864 085b          .dw VE_HEAD
                     .set VE_HEAD = VE_CREATE
                 XT_CREATE:
000865 3801          .dw DO_COLON
                 PFA_CREATE:
000866 0730          .dw XT_DOCREATE
000867 0894          .dw XT_REVEAL
000868 0756          .dw XT_COMPILE
000869 384d          .dw PFA_DOCONSTANT
00086a 381b          .dw XT_EXIT
                 .include "words/header.asm"
                 
                 ; Compiler
                 ; creates the vocabulary header without XT and data field (PF) in the wordlist wid
                 VE_HEADER:
00086b ff06          .dw $ff06
00086c 6568
00086d 6461
00086e 7265          .db "header"
00086f 0860          .dw VE_HEAD
                     .set VE_HEAD = VE_HEADER
                 XT_HEADER:
000870 3801          .dw DO_COLON
                 PFA_HEADER:
000871 3f02          .dw XT_DP           ; the new Name Field
000872 38fa          .dw XT_TO_R
000873 38fa          .dw XT_TO_R		; ( R: NFA WID )
000874 38ac          .dw XT_DUP    
000875 3923          .dw XT_GREATERZERO 
000876 3831          .dw XT_DOCONDBRANCH
000877 0882          .dw PFA_HEADER1
000878 38ac          .dw XT_DUP
000879 3838          .dw XT_DOLITERAL
00087a ff00          .dw $ff00           ; all flags are off (e.g. immediate)
00087b 3a17          .dw XT_OR
00087c 03e6          .dw XT_DOSCOMMA
                     ; make the link to the previous entry in this wordlist
00087d 38f1          .dw XT_R_FROM
00087e 3b4e          .dw XT_FETCHE
00087f 0761          .dw XT_COMMA
000880 38f1          .dw XT_R_FROM
000881 381b          .dw XT_EXIT
                 
                 PFA_HEADER1:
                     ; -16: attempt to use zero length string as a name
000882 3838          .dw XT_DOLITERAL
000883 fff0          .dw -16
000884 3d68          .dw XT_THROW
                 
                 .include "words/wlscope.asm"
                 
                 ; Compiler
                 ; dynamically place a word in a wordlist. The word name may be changed.
                 VE_WLSCOPE:
000885 ff07          .dw $ff07
000886 6c77
000887 6373
000888 706f
000889 0065          .db "wlscope",0
00088a 086b          .dw VE_HEAD
                     .set VE_HEAD = VE_WLSCOPE
                 XT_WLSCOPE:
00088b 3de1          .dw PFA_DODEFER1
                 PFA_WLSCOPE:
00088c 0064          .dw EE_WLSCOPE
00088d 3d82          .dw XT_EDEFERFETCH
00088e 3d8c          .dw XT_EDEFERSTORE
                 
                 ; wlscope, "wordlist scope" ( addr len -- addr' len' wid ), is a deferred word
                 ; which enables the AmForth application to choose the wordlist ( wid ) for the
                 ; new voc entry based on the input ( addr len ) string. The name of the new voc
                 ; entry ( addr' len' ) may be different from the input string. Note that all
                 ; created voc entry types pass through the wlscope mechanism. The default
                 ; wlscope action passes the input string to the output without modification and
                 ; uses get-current to select the wid.
                 .include "words/reveal.asm"
                 
                 ; Dictionary
                 ; makes an entry in a wordlist visible, if not already done.
                 VE_REVEAL:
00088f ff06          .dw $ff06
000890 6572
000891 6576
000892 6c61          .db "reveal"
000893 0885          .dw VE_HEAD
                     .set VE_HEAD = VE_REVEAL
                 XT_REVEAL:
000894 3801          .dw DO_COLON
                 PFA_REVEAL:
000895 3838          .dw XT_DOLITERAL
000896 0173          .dw COLON_SMUDGE+0
000897 3874          .dw XT_FETCH
000898 38b4          .dw XT_QDUP
000899 3831          .dw XT_DOCONDBRANCH
00089a 08a3          .dw PFA_REVEAL1
                 ;
00089b 3838          .dw XT_DOLITERAL
00089c 0175          .dw COLON_SMUDGE+2
00089d 3874          .dw XT_FETCH		; ( NFA WID )
00089e 3b2a          .dw XT_STOREE
                     ; prevent duplicate actions and cooperate with :noname
00089f 394f          .dw XT_ZERO
0008a0 3838          .dw XT_DOLITERAL
0008a1 0173          .dw COLON_SMUDGE+0
0008a2 387c          .dw XT_STORE
                 PFA_REVEAL1:
0008a3 381b          .dw XT_EXIT
                 .include "words/latest.asm"
                 
                 ; System Variable
                 ; system LATEST
                 VE_LATEST:
0008a4 ff06          .dw $ff06
0008a5 616c
0008a6 6574
0008a7 7473          .db "latest"
0008a8 088f          .dw VE_HEAD
                     .set VE_HEAD = VE_LATEST
                 XT_LATEST:
0008a9 3843          .dw PFA_DOVARIABLE
                 PFA_LATEST:
0008aa 0179          .dw ram_LATEST
                 
                 .dseg
000179           ram_LATEST: .byte 2
                 .cseg
                 .include "words/does.asm"
                 
                 ; Compiler
                 ; organize the XT replacement to call other colon code
                 VE_DOES:
0008ab 0005          .dw $0005
0008ac 6f64
0008ad 7365
0008ae 003e          .db "does>",0
0008af 08a4          .dw VE_HEAD
                     .set VE_HEAD = VE_DOES
                 XT_DOES:
0008b0 3801          .dw DO_COLON
                 PFA_DOES:
0008b1 0756          .dw XT_COMPILE
0008b2 08c3          .dw XT_DODOES
0008b3 0756          .dw XT_COMPILE  ; create a code snippet to be used in an embedded XT
0008b4 940e          .dw $940e       ; the address of this compiled
0008b5 0756          .dw XT_COMPILE  ; code will replace the XT of the 
0008b6 08b8          .dw DO_DODOES   ; word that CREATE created
0008b7 381b          .dw XT_EXIT     ; 
                 
                 DO_DODOES: ; ( -- PFA )
0008b8 939a
0008b9 938a          savetos
0008ba 01cb          movw tosl, wl
0008bb 9601          adiw tosl, 1
                     ; the following takes the address from a real uC-call
                 .if (pclen==3)
                 .endif
0008bc 917f          pop wh
0008bd 916f          pop wl
                 
0008be 93bf          push XH
0008bf 93af          push XL
0008c0 01db          movw XL, wl
0008c1 940c 3805     jmp_ DO_NEXT
                 
                 ; ( -- )
                 ; System
                 ; replace the XT written by CREATE to call the code that follows does>
                 ;VE_DODOES:
                 ;   .dw $ff07
                 ;   .db "(does>)"
                 ;   .set VE_HEAD = VE_DODOES
                 XT_DODOES:
0008c3 3801          .dw DO_COLON
                 PFA_DODOES:
0008c4 38f1          .dw XT_R_FROM
0008c5 3838          .dw XT_DOLITERAL
0008c6 0175          .dw COLON_SMUDGE+2
0008c7 3874          .dw XT_FETCH
0008c8 3b4e          .dw XT_FETCHE
0008c9 0a11          .dw XT_NFA2LFA
0008ca 3a2a          .dw XT_1PLUS   ; lfa>xt
                 
0008cb 3b62          .dw XT_STOREI
0008cc 381b          .dw XT_EXIT
                 .include "words/colon.asm"
                 
                 ; Compiler
                 ; create a named entry in the dictionary, XT is DO_COLON
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_COLON:
0008cd ff01          .dw $ff01
0008ce 003a          .db ":",0
0008cf 08ab          .dw VE_HEAD
                     .set VE_HEAD = VE_COLON
                 XT_COLON:
0008d0 3801          .dw DO_COLON
                 PFA_COLON:
                 .endif
0008d1 0730          .dw XT_DOCREATE
0008d2 08db          .dw XT_COLONNONAME
0008d3 38d4          .dw XT_DROP
0008d4 381b          .dw XT_EXIT
                 .include "words/colon-noname.asm"
                 
                 ; Compiler
                 ; create an unnamed entry in the dictionary, XT is DO_COLON
                 VE_COLONNONAME:
0008d5 ff07          .dw $ff07
0008d6 6e3a
0008d7 6e6f
0008d8 6d61
0008d9 0065          .db ":noname",0
0008da 08cd          .dw VE_HEAD
                     .set VE_HEAD = VE_COLONNONAME
                 XT_COLONNONAME:
0008db 3801          .dw DO_COLON
                 PFA_COLONNONAME:
0008dc 3f02          .dw XT_DP
0008dd 38ac          .dw XT_DUP
0008de 08a9          .dw XT_LATEST
0008df 387c          .dw XT_STORE
                 
0008e0 0756          .dw XT_COMPILE
0008e1 3801          .dw DO_COLON
                 
0008e2 08f0          .dw XT_RBRACKET
0008e3 381b          .dw XT_EXIT
                 .include "words/semicolon.asm"
                 
                 ; Compiler
                 ; finish colon defintion, compiles (exit) and returns to interpret state 
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 
                 VE_SEMICOLON:
0008e4 0001          .dw $0001
0008e5 003b          .db $3b,0
0008e6 08d5          .dw VE_HEAD
                     .set VE_HEAD = VE_SEMICOLON
                 XT_SEMICOLON:
0008e7 3801          .dw DO_COLON
                 PFA_SEMICOLON:
                 .endif
0008e8 0756          .dw XT_COMPILE
0008e9 381b          .dw XT_EXIT
0008ea 08f9          .dw XT_LBRACKET
0008eb 0894          .dw XT_REVEAL
0008ec 381b          .dw XT_EXIT
                 .include "words/right-bracket.asm"
                 
                 ; Compiler
                 ; enter compiler mode
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_RBRACKET:
0008ed ff01          .dw $ff01
0008ee 005d          .db "]",0
0008ef 08e4          .dw VE_HEAD
                     .set VE_HEAD = VE_RBRACKET
                 XT_RBRACKET:
0008f0 3801          .dw DO_COLON
                 PFA_RBRACKET:
                 .endif
0008f1 3838          .dw XT_DOLITERAL
0008f2 0001          .dw 1
0008f3 3ea1          .dw XT_STATE
0008f4 387c          .dw XT_STORE
0008f5 381b          .dw XT_EXIT
                 .include "words/left-bracket.asm"
                 
                 ; Compiler
                 ; enter interpreter mode
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_LBRACKET:
0008f6 0001          .dw $0001
0008f7 005b          .db "[",0
0008f8 08ed          .dw VE_HEAD
                     .set VE_HEAD = VE_LBRACKET
                 XT_LBRACKET:
0008f9 3801          .dw DO_COLON
                 PFA_LBRACKET:
                 .endif
0008fa 394f          .dw XT_ZERO
0008fb 3ea1          .dw XT_STATE
0008fc 387c          .dw XT_STORE
0008fd 381b          .dw XT_EXIT
                 .include "words/variable.asm"
                 
                 ; Compiler
                 ; create a dictionary entry for a variable and allocate 1 cell RAM
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 VE_VARIABLE:
0008fe ff08          .dw $ff08
0008ff 6176
000900 6972
000901 6261
000902 656c          .db "variable"
000903 08f6          .dw VE_HEAD
                     .set VE_HEAD = VE_VARIABLE
                 XT_VARIABLE:
000904 3801          .dw DO_COLON
                 PFA_VARIABLE:
                 .endif
000905 3f13          .dw XT_HERE
000906 0911          .dw XT_CONSTANT
000907 3838          .dw XT_DOLITERAL
000908 0002          .dw 2
000909 3f1c          .dw XT_ALLOT
00090a 381b          .dw XT_EXIT
                 .include "words/constant.asm"
                 
                 ; Compiler
                 ; create a constant in the dictionary
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 VE_CONSTANT:
00090b ff08          .dw $ff08
00090c 6f63
00090d 736e
00090e 6174
00090f 746e          .db "constant"
000910 08fe          .dw VE_HEAD
                     .set VE_HEAD = VE_CONSTANT
                 XT_CONSTANT:
000911 3801          .dw DO_COLON
                 PFA_CONSTANT:
                 .endif
000912 0730          .dw XT_DOCREATE
000913 0894          .dw XT_REVEAL
000914 0756          .dw XT_COMPILE
000915 3843          .dw PFA_DOVARIABLE
000916 0761          .dw XT_COMMA
000917 381b          .dw XT_EXIT
                 .include "words/user.asm"
                 
                 ; Compiler
                 ; create a dictionary entry for a user variable at offset n
                 VE_USER:
000918 ff04          .dw $ff04
000919 7375
00091a 7265          .db "user"
00091b 090b          .dw VE_HEAD
                     .set VE_HEAD = VE_USER
                 XT_USER:
00091c 3801          .dw DO_COLON
                 PFA_USER:
00091d 0730          .dw XT_DOCREATE
00091e 0894          .dw XT_REVEAL
                 
00091f 0756          .dw XT_COMPILE
000920 3853          .dw PFA_DOUSER
000921 0761          .dw XT_COMMA
000922 381b          .dw XT_EXIT
                 
                 .include "words/recurse.asm"
                 
                 ; Compiler
                 ; compile the XT of the word currently being defined into the dictionary
                 VE_RECURSE:
000923 0007          .dw $0007
000924 6572
000925 7563
000926 7372
000927 0065          .db "recurse",0
000928 0918          .dw VE_HEAD
                     .set VE_HEAD = VE_RECURSE
                 XT_RECURSE:
000929 3801          .dw DO_COLON
                 PFA_RECURSE:
00092a 08a9          .dw XT_LATEST
00092b 3874          .dw XT_FETCH
00092c 0761          .dw XT_COMMA
00092d 381b          .dw XT_EXIT
                 .include "words/immediate.asm"
                 
                 ; Compiler
                 ; set immediate flag for the most recent word definition
                 VE_IMMEDIATE:
00092e ff09          .dw $ff09
00092f 6d69
000930 656d
000931 6964
000932 7461
000933 0065          .db "immediate",0
000934 0923          .dw VE_HEAD
                     .set VE_HEAD = VE_IMMEDIATE
                 XT_IMMEDIATE:
000935 3801          .dw DO_COLON
                 PFA_IMMEDIATE:
000936 09d2          .dw XT_GET_CURRENT
000937 3b4e          .dw XT_FETCHE
000938 38ac          .dw XT_DUP
000939 3bbb          .dw XT_FETCHI
00093a 3838          .dw XT_DOLITERAL
00093b 7fff          .dw $7fff
00093c 3a0e          .dw XT_AND
00093d 38bf          .dw XT_SWAP
00093e 3b62          .dw XT_STOREI
00093f 381b          .dw XT_EXIT
                 
                 .include "words/bracketchar.asm"
                 
                 ; Tools
                 ; skip leading space delimites, place the first character of the word on the stack
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_BRACKETCHAR:
000940 0006          .dw $0006
000941 635b
000942 6168
000943 5d72          .db "[char]"
000944 092e          .dw VE_HEAD
                     .set VE_HEAD = VE_BRACKETCHAR
                 XT_BRACKETCHAR:
000945 3801          .dw DO_COLON
                 PFA_BRACKETCHAR:
                 .endif
000946 0756          .dw XT_COMPILE
000947 3838          .dw XT_DOLITERAL
000948 04e7          .dw XT_CHAR
000949 0761          .dw XT_COMMA
00094a 381b          .dw XT_EXIT
                 .include "words/abort-string.asm"
                 
                 ;C         i*x x1 --       R: j*x --      x1<>0
                 ;   POSTPONE IS" POSTPONE ?ABORT ; IMMEDIATE
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_ABORTQUOTE:
00094b 0006          .dw $0006
00094c 6261
00094d 726f
00094e 2274          .db "abort",'"'
00094f 0940          .dw VE_HEAD
                     .set VE_HEAD = VE_ABORTQUOTE
                 XT_ABORTQUOTE:
000950 3801          .dw DO_COLON
                 PFA_ABORTQUOTE:
                 .endif
000951 3e74          .dw XT_SQUOTE
000952 0756          .dw XT_COMPILE
000953 0963          .dw XT_QABORT
000954 381b          .DW XT_EXIT
                 .include "words/abort.asm"
                 
                 ; Exceptions
                 ; send an exception -1
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_ABORT:
000955 ff05          .dw $ff05
000956 6261
000957 726f
000958 0074          .db "abort",0
000959 094b          .dw VE_HEAD
                     .set VE_HEAD = VE_ABORT
                 XT_ABORT:
00095a 3801          .dw DO_COLON
                 PFA_ABORT:
                 .endif
00095b 3838          .dw XT_DOLITERAL
00095c ffff          .dw -1
00095d 3d68          .dw XT_THROW
                 .include "words/q-abort.asm"
                 
                 ;   ROT IF ITYPE ABORT THEN 2DROP ;
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_QABORT:
00095e ff06          .dw $ff06
00095f 613f
000960 6f62
000961 7472          .db "?abort"
000962 0955          .dw VE_HEAD
                     .set VE_HEAD = VE_QABORT
                 XT_QABORT:
000963 3801          .dw DO_COLON
                 PFA_QABORT:
                 
                 .endif
000964 38dc
000965 3831              .DW XT_ROT,XT_DOCONDBRANCH
000966 0969              DEST(QABO1)
000967 0407
000968 095a              .DW XT_ITYPE,XT_ABORT
000969 3ebc
00096a 381b      QABO1:  .DW XT_2DROP,XT_EXIT
                 
                 .include "words/get-stack.asm"
                 
                 ; Tools
                 ; Get a stack from EEPROM
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_GET_STACK:
00096b ff09          .dw $ff09
00096c 6567
00096d 2d74
00096e 7473
00096f 6361
000970 006b          .db "get-stack",0
000971 095e          .dw VE_HEAD
                     .set VE_HEAD = VE_GET_STACK
                 XT_GET_STACK:
000972 3801          .dw DO_COLON
                 PFA_N_FETCH_E:
                 .endif
000973 38ac          .dw XT_DUP
000974 3c83          .dw XT_CELLPLUS
000975 38bf          .dw XT_SWAP
000976 3b4e          .dw XT_FETCHE
000977 38ac          .dw XT_DUP
000978 38fa          .dw XT_TO_R
000979 394f          .dw XT_ZERO
00097a 38bf          .dw XT_SWAP    ; go from bigger to smaller addresses
00097b 0820          .dw XT_QDOCHECK
00097c 3831          .dw XT_DOCONDBRANCH
00097d 0989          DEST(PFA_N_FETCH_E2)
00097e 3a8a          .dw XT_DODO
                 PFA_N_FETCH_E1:
                     ; ( ee-addr )
00097f 3a9b          .dw XT_I
000980 3a30          .dw XT_1MINUS
000981 3eae          .dw XT_CELLS ; ( -- ee-addr i*2 )
000982 38ca          .dw XT_OVER  ; ( -- ee-addr i*2 ee-addr )
000983 3998          .dw XT_PLUS  ; ( -- ee-addr ee-addr+i
000984 3b4e          .dw XT_FETCHE ;( -- ee-addr item_i )
000985 38bf          .dw XT_SWAP   ;( -- item_i ee-addr )
000986 3946          .dw XT_TRUE  ; shortcut for -1
000987 3aa9          .dw XT_DOPLUSLOOP
000988 097f          DEST(PFA_N_FETCH_E1)
                 PFA_N_FETCH_E2:
000989 3ebc          .dw XT_2DROP
00098a 38f1          .dw XT_R_FROM
00098b 381b          .dw XT_EXIT
                 
                 .include "words/set-stack.asm"
                 
                 ; Tools
                 ; Write a stack to EEPROM
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SET_STACK:
00098c ff09          .dw $ff09
00098d 6573
00098e 2d74
00098f 7473
000990 6361
000991 006b          .db "set-stack",0
000992 096b          .dw VE_HEAD
                     .set VE_HEAD = VE_SET_STACK
                 XT_SET_STACK:
000993 3801          .dw DO_COLON
                 PFA_SET_STACK:
                 .endif
000994 3eb3          .dw XT_2DUP
000995 3b2a          .dw XT_STOREE ; ( -- i_n .. i_0 n e-addr )
000996 38bf          .dw XT_SWAP    
000997 394f          .dw XT_ZERO
000998 0820          .dw XT_QDOCHECK
000999 3831          .dw XT_DOCONDBRANCH
00099a 09a1          DEST(PFA_SET_STACK2)
00099b 3a8a          .dw XT_DODO
                 PFA_SET_STACK1:
00099c 3c83          .dw XT_CELLPLUS ; ( -- i_x e-addr )
00099d 3ec4          .dw XT_TUCK      ; ( -- e-addr i_x e-addr
00099e 3b2a          .dw XT_STOREE
00099f 3ab8          .dw XT_DOLOOP
0009a0 099c          DEST(PFA_SET_STACK1)
                 PFA_SET_STACK2:
0009a1 38d4          .dw XT_DROP
0009a2 381b          .dw XT_EXIT
                 
                 .include "words/map-stack.asm"
                 
                 ; Tools
                 ; Iterate over a stack
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_MAPSTACK:
0009a3 ff09          .dw $ff09
0009a4 616d
0009a5 2d70
0009a6 7473
0009a7 6361
0009a8 006b          .db "map-stack",0
0009a9 098c          .dw VE_HEAD
                     .set VE_HEAD = VE_MAPSTACK
                 XT_MAPSTACK:
0009aa 3801          .dw DO_COLON
                 PFA_MAPSTACK:
                 .endif
0009ab 38ac          .dw XT_DUP
0009ac 3c83          .dw XT_CELLPLUS
0009ad 38bf          .dw XT_SWAP
0009ae 3b4e          .dw XT_FETCHE
0009af 3eae          .dw XT_CELLS
0009b0 3f8a          .dw XT_BOUNDS
0009b1 0820          .dw XT_QDOCHECK
0009b2 3831          .dw XT_DOCONDBRANCH
0009b3 09c7          DEST(PFA_MAPSTACK3)
0009b4 3a8a          .dw XT_DODO
                 PFA_MAPSTACK1:
0009b5 3a9b            .dw XT_I
0009b6 3b4e            .dw XT_FETCHE   ; -- i*x XT id
0009b7 38bf            .dw XT_SWAP
0009b8 38fa            .dw XT_TO_R
0009b9 3903            .dw XT_R_FETCH
0009ba 3825            .dw XT_EXECUTE  ; i*x id -- j*y true | i*x false
0009bb 38b4            .dw XT_QDUP
0009bc 3831            .dw XT_DOCONDBRANCH
0009bd 09c2            DEST(PFA_MAPSTACK2)
0009be 38f1               .dw XT_R_FROM
0009bf 38d4               .dw XT_DROP
0009c0 3ac3               .dw XT_UNLOOP
0009c1 381b               .dw XT_EXIT
                 PFA_MAPSTACK2:
0009c2 38f1            .dw XT_R_FROM
0009c3 3838            .dw XT_DOLITERAL
0009c4 0002            .dw 2
0009c5 3aa9            .dw XT_DOPLUSLOOP
0009c6 09b5            DEST(PFA_MAPSTACK1)
                 PFA_MAPSTACK3:
0009c7 38d4          .dw XT_DROP
0009c8 394f          .dw XT_ZERO
0009c9 381b          .dw XT_EXIT
                 
                 ;
                 ; : map-stack ( i*x XT e-addr -- j*y )
                 ;     dup cell+ swap @e cells bounds ?do 
                 ;       ( -- i*x XT )
                 ;       i @e swap >r r@ execute
                 ;       ?dup if r> drop unloop exit then
                 ;       r>
                 ;     2 +loop drop 0
                 ;
                 .include "words/get-current.asm"
                 
                 ; Search Order
                 ; get the wid of the current compilation word list
                 VE_GET_CURRENT:
0009ca ff0b          .dw $ff0b
0009cb 6567
0009cc 2d74
0009cd 7563
0009ce 7272
0009cf 6e65
0009d0 0074          .db "get-current",0
0009d1 09a3          .dw VE_HEAD
                     .set VE_HEAD = VE_GET_CURRENT
                 XT_GET_CURRENT:
0009d2 3801          .dw DO_COLON
                 PFA_GET_CURRENT:
0009d3 3838          .dw XT_DOLITERAL
0009d4 0044          .dw EE_CURRENT
0009d5 3b4e          .dw XT_FETCHE
0009d6 381b          .dw XT_EXIT
                 .include "words/get-order.asm"
                 
                 ; Search Order
                 ; Get the current search order word list
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_GET_ORDER:
0009d7 ff09          .dw $ff09
0009d8 6567
0009d9 2d74
0009da 726f
0009db 6564
0009dc 0072          .db "get-order",0
0009dd 09ca          .dw VE_HEAD
                     .set VE_HEAD = VE_GET_ORDER
                 XT_GET_ORDER:
0009de 3801          .dw DO_COLON
                 PFA_GET_ORDER:
                 .endif
0009df 3838          .dw XT_DOLITERAL
0009e0 0048          .dw CFG_ORDERLISTLEN
0009e1 0972          .dw XT_GET_STACK
0009e2 381b          .dw XT_EXIT
                 
                 .include "words/compare.asm"
                 
                 ; String
                 ; compares two strings in RAM
                 VE_COMPARE:
0009e3 ff07          .dw $ff07
0009e4 6f63
0009e5 706d
0009e6 7261
0009e7 0065          .db "compare",0
0009e8 09d7          .dw VE_HEAD
                     .set VE_HEAD = VE_COMPARE
                 XT_COMPARE:
0009e9 09ea          .dw PFA_COMPARE
                 PFA_COMPARE:
0009ea 93bf          push xh
0009eb 93af          push xl
0009ec 018c          movw temp0, tosl
0009ed 9189
0009ee 9199          loadtos
0009ef 01dc          movw xl, tosl
0009f0 9189
0009f1 9199          loadtos
0009f2 019c          movw temp2, tosl
0009f3 9189
0009f4 9199          loadtos
0009f5 01fc          movw zl, tosl
                 PFA_COMPARE_LOOP:
0009f6 90ed          ld temp4, X+
0009f7 90f1          ld temp5, Z+
0009f8 14ef          cp temp4, temp5
0009f9 f451          brne PFA_COMPARE_NOTEQUAL
0009fa 950a          dec temp0
0009fb f019          breq PFA_COMPARE_ENDREACHED2
0009fc 952a          dec temp2
0009fd f7c1          brne PFA_COMPARE_LOOP
0009fe c001          rjmp PFA_COMPARE_ENDREACHED
                 PFA_COMPARE_ENDREACHED2:
0009ff 952a          dec temp2
                 PFA_COMPARE_ENDREACHED:
000a00 2b02          or temp0, temp2
000a01 f411          brne PFA_COMPARE_CHECKLASTCHAR
000a02 2788          clr tosl
000a03 c002          rjmp PFA_COMPARE_DONE
                 PFA_COMPARE_CHECKLASTCHAR:
                 PFA_COMPARE_NOTEQUAL:
000a04 ef8f          ser tosl
000a05 c000          rjmp PFA_COMPARE_DONE
                 
                 PFA_COMPARE_DONE:
000a06 2f98          mov tosh, tosl
000a07 91af          pop xl
000a08 91bf          pop xh
000a09 940c 3805     jmp_ DO_NEXT
                 .include "words/nfa2lfa.asm"
                 
                 ; System
                 ; get the link field address from the name field address
                 VE_NFA2LFA:
000a0b ff07         .dw $ff07
000a0c 666e
000a0d 3e61
000a0e 666c
000a0f 0061         .db "nfa>lfa",0
000a10 09e3         .dw VE_HEAD
                    .set VE_HEAD = VE_NFA2LFA
                 XT_NFA2LFA:
000a11 3801          .dw DO_COLON
                 PFA_NFA2LFA:
000a12 06f9          .dw XT_NAME2STRING
000a13 3a2a          .dw XT_1PLUS
000a14 39ff          .dw XT_2SLASH
000a15 3998          .dw XT_PLUS
000a16 381b          .dw XT_EXIT
                 .elif AMFORTH_NRWW_SIZE > 2000
                 .else
                 .endif
                 .include "dict_appl.inc"
                 
                 ; they may be moved to the core dictionary if needed
                 .include "words/dot-s.asm"
                 
                 ; Tools
                 ; stack dump
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DOTS:
000a17 ff02          .dw $ff02
000a18 732e          .db ".s"
000a19 0a0b          .dw VE_HEAD
                     .set VE_HEAD = VE_DOTS
                 XT_DOTS:
000a1a 3801          .dw DO_COLON
                 PFA_DOTS:
                 .endif
000a1b 05ea          .dw XT_DEPTH
000a1c 3df4          .dw XT_UDOT
000a1d 3f9f          .dw XT_SPACE
000a1e 05ea          .dw XT_DEPTH
000a1f 394f          .dw XT_ZERO
000a20 0820          .dw XT_QDOCHECK
000a21 3831          .dw XT_DOCONDBRANCH
000a22 0a29          DEST(PFA_DOTS2)
000a23 3a8a          .dw XT_DODO
                 PFA_DOTS1:
000a24 3a9b          .dw XT_I
000a25 3c77          .dw XT_PICK
000a26 3df4          .dw XT_UDOT
000a27 3ab8          .dw XT_DOLOOP
000a28 0a24          DEST(PFA_DOTS1)
                 PFA_DOTS2:
000a29 381b          .dw XT_EXIT
                 .include "words/spirw.asm"
                 
                 ; MCU
                 ; SPI exchange of 1 byte
                 VE_SPIRW:
000a2a ff06          .dw $ff06
000a2b 2163
000a2c 7340
000a2d 6970          .db "c!@spi"
000a2e 0a17          .dw VE_HEAD
                     .set VE_HEAD  = VE_SPIRW
                 XT_SPIRW:
000a2f 0a30          .dw PFA_SPIRW
                 PFA_SPIRW:
000a30 d003          rcall do_spirw
000a31 2799          clr tosh
000a32 940c 3805     jmp_ DO_NEXT
                 
                 do_spirw:
000a34 bd8e          out_ SPDR, tosl
                 do_spirw1:
000a35 b50d          in_ temp0, SPSR
000a36 7f08          cbr temp0,7
000a37 bd0d          out_ SPSR, temp0
000a38 b50d          in_ temp0, SPSR
000a39 ff07          sbrs temp0, 7
000a3a cffa          rjmp do_spirw1   ; wait until complete
000a3b b58e          in_ tosl, SPDR
000a3c 9508          ret
                 .include "words/n-spi.asm"
                 
                 ; MCU
                 ; read len bytes from SPI to addr
                 VE_N_SPIR:
000a3d ff05          .dw $ff05
000a3e 406e
000a3f 7073
000a40 0069          .db "n@spi",0
000a41 0a2a          .dw VE_HEAD
                     .set VE_HEAD  = VE_N_SPIR
                 XT_N_SPIR:
000a42 0a43          .dw PFA_N_SPIR
                 PFA_N_SPIR:
000a43 018c          movw temp0, tosl
000a44 9189
000a45 9199          loadtos
000a46 01fc          movw zl, tosl
000a47 01c8          movw tosl, temp0
                 PFA_N_SPIR_LOOP:
000a48 bc2e          out_ SPDR, zerol
                 PFA_N_SPIR_LOOP1:
000a49 b52d          in_ temp2, SPSR
000a4a ff27          sbrs temp2, SPIF
000a4b cffd          rjmp PFA_N_SPIR_LOOP1
000a4c b52e          in_ temp2, SPDR
000a4d 9321          st Z+, temp2
000a4e 9701          sbiw tosl, 1
000a4f f7c1          brne PFA_N_SPIR_LOOP
000a50 9189
000a51 9199          loadtos
000a52 940c 3805     jmp_ DO_NEXT
                 
                 ; ( addr len -- ) 
                 ; MCU
                 ; write len bytes to SPI from addr
                 VE_N_SPIW:
000a54 ff05          .dw $ff05
000a55 216e
000a56 7073
000a57 0069          .db "n!spi",0
000a58 0a3d          .dw VE_HEAD
                     .set VE_HEAD  = VE_N_SPIW
                 XT_N_SPIW:
000a59 0a5a          .dw PFA_N_SPIW
                 PFA_N_SPIW:
000a5a 018c          movw temp0, tosl
000a5b 9189
000a5c 9199          loadtos
000a5d 01fc          movw zl, tosl
000a5e 01c8          movw tosl, temp0
                 PFA_N_SPIW_LOOP:
000a5f 9121          ld temp2, Z+
000a60 bd2e          out_ SPDR, temp2
                 PFA_N_SPIW_LOOP1:
000a61 b52d          in_ temp2, SPSR
000a62 ff27          sbrs temp2, SPIF
000a63 cffd          rjmp PFA_N_SPIW_LOOP1
000a64 b52e          in_ temp2, SPDR ; ignore the data
000a65 9701          sbiw tosl, 1
000a66 f7c1          brne PFA_N_SPIW_LOOP
000a67 9189
000a68 9199          loadtos
000a69 940c 3805     jmp_ DO_NEXT
                 .include "words/applturnkey.asm"
                 
                 ; R( -- )
                 ; application specific turnkey action
                 VE_APPLTURNKEY:
000a6b ff0b          .dw $ff0b
000a6c 7061
000a6d 6c70
000a6e 7574
000a6f 6e72
000a70 656b
000a71 0079          .db "applturnkey",0
000a72 0a54          .dw VE_HEAD
                     .set VE_HEAD = VE_APPLTURNKEY
                 XT_APPLTURNKEY:
000a73 3801          .dw DO_COLON
                 PFA_APPLTURNKEY:
000a74 00b4          .dw XT_USART
000a75 3c8a          .dw XT_INTON
000a76 0191          .dw XT_DOT_VER
000a77 3f9f          .dw XT_SPACE
000a78 3e96          .dw XT_F_CPU
000a79 3838          .dw XT_DOLITERAL
000a7a 03e8          .dw 1000
000a7b 39bd          .dw XT_UMSLASHMOD
000a7c 38bf          .dw XT_SWAP
000a7d 38d4          .dw XT_DROP
000a7e 3f32          .dw XT_DECIMAL
000a7f 0389          .dw XT_DOT
000a80 03d4          .dw XT_DOSLITERAL
000a81 0004          .dw 4
000a82 486b
000a83 207a          .db "kHz "
000a84 0407          .dw XT_ITYPE
000a85 381b          .dw XT_EXIT
                 .include "dict/compiler2.inc"
                 
                 ; included almost independently from each other
                 ; on a include-per-use basis
                 ;
                 .if DICT_COMPILER2 == 0
                 .set DICT_COMPILER2 = 1
                 
                 .include "words/set-current.asm"
                 
                 ; Search Order
                 ; set current word list to the given word list wid
                 VE_SET_CURRENT:
000a86 ff0b          .dw $ff0b
000a87 6573
000a88 2d74
000a89 7563
000a8a 7272
000a8b 6e65
000a8c 0074          .db "set-current",0
000a8d 0a6b          .dw VE_HEAD
                     .set VE_HEAD = VE_SET_CURRENT
                 XT_SET_CURRENT:
000a8e 3801          .dw DO_COLON
                 PFA_SET_CURRENT:
000a8f 3838          .dw XT_DOLITERAL
000a90 0044          .dw EE_CURRENT
000a91 3b2a          .dw XT_STOREE
000a92 381b          .dw XT_EXIT
                 .include "words/wordlist.asm"
                 
                 ; Search Order
                 ; create a new, empty wordlist
                 VE_WORDLIST:
000a93 ff08          .dw $ff08
000a94 6f77
000a95 6472
000a96 696c
000a97 7473          .db "wordlist"
000a98 0a86          .dw VE_HEAD
                     .set VE_HEAD = VE_WORDLIST
                 XT_WORDLIST:
000a99 3801          .dw DO_COLON
                 PFA_WORDLIST:
000a9a 3f0b          .dw XT_EHERE
000a9b 394f          .dw XT_ZERO
000a9c 38ca          .dw XT_OVER
000a9d 3b2a          .dw XT_STOREE
000a9e 38ac          .dw XT_DUP
000a9f 3c83          .dw XT_CELLPLUS
000aa0 01c7          .dw XT_DOTO
000aa1 3f0c          .dw PFA_EHERE
000aa2 381b          .dw XT_EXIT
                 
                 .include "words/only.asm"
                 
                 ; Search Order
                 ; replace the order list with the system default list
                 VE_ONLY:
000aa3 ff04          .dw $ff04
000aa4 6e6f
000aa5 796c          .db "only"
000aa6 0a93          .dw VE_HEAD
                     .set VE_HEAD = VE_ONLY
                 XT_ONLY:
000aa7 3801          .dw DO_COLON
                 PFA_ONLY:
000aa8 3838          .dw XT_DOLITERAL
000aa9 0046          .dw EE_FORTHWORDLIST
000aaa 3838          .dw XT_DOLITERAL
000aab 0001          .dw 1
000aac 0ac2          .dw XT_SET_ORDER
000aad 381b          .dw XT_EXIT
                 .include "words/forth-wordlist.asm"
                 
                 ; Search Order
                 ; get the system default word list
                 VE_FORTH_WORDLIST:
000aae ff0e          .dw $ff0e
000aaf 6f66
000ab0 7472
000ab1 2d68
000ab2 6f77
000ab3 6472
000ab4 696c
000ab5 7473          .db "forth-wordlist"
000ab6 0aa3          .dw VE_HEAD
                     .set VE_HEAD = VE_FORTH_WORDLIST
                 XT_FORTH_WORDLIST:
000ab7 386a          .dw PFA_DOVALUE1
                 PFA_FORTH_WORDLIST:
000ab8 0042          .dw EE_WL_FORTH
000ab9 3d82          .dw XT_EDEFERFETCH
000aba 3d8c          .dw XT_EDEFERSTORE
                 .include "words/set-order.asm"
                 
                 ; Search Order
                 ; replace the search order list
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SET_ORDER:
000abb ff09          .dw $ff09
000abc 6573
000abd 2d74
000abe 726f
000abf 6564
000ac0 0072          .db "set-order",0
000ac1 0aae          .dw VE_HEAD
                     .set VE_HEAD = VE_SET_ORDER
                 XT_SET_ORDER:
000ac2 3801          .dw DO_COLON
                 PFA_SET_ORDER:
                 .endif
000ac3 3838          .dw XT_DOLITERAL
000ac4 0048          .dw CFG_ORDERLISTLEN
000ac5 0993          .dw XT_SET_STACK
000ac6 381b          .dw XT_EXIT
                 
                 .include "words/set-recognizer.asm"
                 
                 ; Interpreter
                 ; replace the recognizer list
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SET_RECOGNIZERS:
000ac7 ff0f          .dw $ff0f
000ac8 6573
000ac9 2d74
000aca 6572
000acb 6f63
000acc 6e67
000acd 7a69
000ace 7265
000acf 0073          .db "set-recognizers",0
000ad0 0abb          .dw VE_HEAD
                     .set VE_HEAD = VE_SET_RECOGNIZERS
                 XT_SET_RECOGNIZERS:
000ad1 3801          .dw DO_COLON
                 PFA_SET_RECOGNIZERS:
                 .endif
000ad2 3838          .dw XT_DOLITERAL
000ad3 005a          .dw CFG_RECOGNIZERLISTLEN
000ad4 0993          .dw XT_SET_STACK
000ad5 381b          .dw XT_EXIT
                 
                 .include "words/get-recognizer.asm"
                 
                 ; Interpreter
                 ; Get the current recognizer list
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_GET_RECOGNIZERS:
000ad6 ff0f          .dw $ff0f
000ad7 6567
000ad8 2d74
000ad9 6572
000ada 6f63
000adb 6e67
000adc 7a69
000add 7265
000ade 0073          .db "get-recognizers",0
000adf 0ac7          .dw VE_HEAD
                     .set VE_HEAD = VE_GET_RECOGNIZERS
                 XT_GET_RECOGNIZERS:
000ae0 3801          .dw DO_COLON
                 PFA_GET_RECOGNIZERS:
                 .endif
000ae1 3838          .dw XT_DOLITERAL
000ae2 005a          .dw CFG_RECOGNIZERLISTLEN
000ae3 0972          .dw XT_GET_STACK
000ae4 381b          .dw XT_EXIT
                 .include "words/code.asm"
                 
                 ; Compiler
                 ; create named entry in the dictionary, XT is the data field
                 VE_CODE:
000ae5 ff04          .dw $ff04
000ae6 6f63
000ae7 6564          .db "code"
000ae8 0ad6          .dw VE_HEAD
                     .set VE_HEAD = VE_CODE
                 XT_CODE:
000ae9 3801          .dw DO_COLON
                 PFA_CODE:
000aea 0730          .dw XT_DOCREATE
000aeb 0894          .dw XT_REVEAL
000aec 3f02          .dw XT_DP
000aed 01d9          .dw XT_ICELLPLUS
000aee 0761          .dw XT_COMMA
000aef 381b          .dw XT_EXIT
                 .include "words/end-code.asm"
                 
                 ; Compiler
                 ; finish a code definition
                 VE_ENDCODE:
000af0 ff08          .dw $ff08
000af1 6e65
000af2 2d64
000af3 6f63
000af4 6564          .db "end-code"
000af5 0ae5          .dw VE_HEAD
                     .set VE_HEAD = VE_ENDCODE
                 XT_ENDCODE:
000af6 3801          .dw DO_COLON
                 PFA_ENDCODE:
000af7 0756          .dw XT_COMPILE
000af8 940c          .dw $940c
000af9 0756          .dw XT_COMPILE
000afa 3805          .dw DO_NEXT
000afb 381b          .dw XT_EXIT
                 .include "words/marker.asm"
                 
                 ; System Value
                 ; The eeprom address until which MARKER saves and restores the eeprom data.
                 VE_MARKER:
000afc ff08          .dw $ff08
000afd 6d28
000afe 7261
000aff 656b
000b00 2972          .db "(marker)"
000b01 0af0          .dw VE_HEAD
                     .set VE_HEAD = VE_MARKER
                 XT_MARKER:
000b02 386a          .dw PFA_DOVALUE1
                 PFA_MARKER:
000b03 0068          .dw EE_MARKER
000b04 3d82          .dw XT_EDEFERFETCH
000b05 3d8c          .dw XT_EDEFERSTORE
                 .include "words/postpone.asm"
                 
                 ; Compiler
                 ; Append the compilation semantics of "name" to the dictionary
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_POSTPONE:
000b06 0008          .dw $0008
000b07 6f70
000b08 7473
000b09 6f70
000b0a 656e          .db "postpone"
000b0b 0afc          .dw VE_HEAD
                     .set VE_HEAD = VE_POSTPONE
                 XT_POSTPONE:
000b0c 3801          .dw DO_COLON
                 PFA_POSTPONE:
                 .endif
000b0d 05b8          .dw XT_PARSENAME
000b0e 05fa          .dw XT_DORECOGNIZER
000b0f 01d9          .dw XT_ICELLPLUS 
000b10 01d9          .dw XT_ICELLPLUS
000b11 3bbb          .dw XT_FETCHI
000b12 3825          .dw XT_EXECUTE
000b13 381b          .dw XT_EXIT
                 .endif
                 .include "words/2r_fetch.asm"
                 
                 ; Stack
                 ; fetch content of TOR
                 VE_2R_FETCH:
000b14 ff03          .dw $ff03
000b15 7232
000b16 0040          .db "2r@",0
000b17 0b06          .dw VE_HEAD
                     .set VE_HEAD = VE_2R_FETCH
                 XT_2R_FETCH:
000b18 0b19          .dw PFA_2R_FETCH
                 PFA_2R_FETCH:
000b19 939a
000b1a 938a          savetos
000b1b 91ef          pop zl
000b1c 91ff          pop zh
000b1d 918f          pop tosl
000b1e 919f          pop tosh
000b1f 939f          push tosh
000b20 938f          push tosl
000b21 93ff          push zh
000b22 93ef          push zl
000b23 939a
000b24 938a          savetos
000b25 01cf          movw tosl, zl
000b26 940c 3805     jmp_ DO_NEXT
                 
                 .set DPSTART = pc
                 .if(pc>AMFORTH_RO_SEG)
                 .endif
                 
                 .org AMFORTH_RO_SEG
                 .include "amforth-interpreter.asm"
                 
                 
                 DO_COLON:
003801 93bf          push XH
003802 93af          push XL          ; PUSH IP
003803 01db          movw XL, wl
003804 9611          adiw xl, 1
                 DO_NEXT:
003805 f06e          brts DO_INTERRUPT
003806 01fd          movw zl, XL        ; READ IP
003807 0fee
003808 1fff
003809 9165
00380a 9175          readflashcell wl, wh
00380b 9611          adiw XL, 1        ; INC IP
                 
                 DO_EXECUTE:
00380c 01fb          movw zl, wl
00380d 0fee
00380e 1fff
00380f 9105
003810 9115          readflashcell temp0,temp1
003811 01f8          movw zl, temp0
003812 9409          ijmp
                 
                 DO_INTERRUPT:
                     ; here we deal with interrupts the forth way
003813 94e8          clt
003814 eb65          ldi wl, LOW(XT_ISREXEC)
003815 e37c          ldi wh, HIGH(XT_ISREXEC)
003816 cff5          rjmp DO_EXECUTE
                 .include "dict/nrww.inc"
                 
                 ; section together with the forth inner interpreter
                 
                 .include "words/exit.asm"
                 
                 ; Compiler
                 ; end of current colon word
                 VE_EXIT:
003817 ff04          .dw $ff04
003818 7865
003819 7469          .db "exit"
00381a 0b14          .dw VE_HEAD
                     .set VE_HEAD = VE_EXIT
                 XT_EXIT:
00381b 381c          .dw PFA_EXIT
                 PFA_EXIT:
00381c 91af          pop XL
00381d 91bf          pop XH
00381e cfe6          jmp_ DO_NEXT
                 .include "words/execute.asm"
                 
                 ; System
                 ; execute XT
                 VE_EXECUTE:
00381f ff07          .dw $ff07
003820 7865
003821 6365
003822 7475
003823 0065          .db "execute",0
003824 3817          .dw VE_HEAD
                     .set VE_HEAD = VE_EXECUTE
                 XT_EXECUTE:
003825 3826          .dw PFA_EXECUTE
                 PFA_EXECUTE:
003826 01bc          movw wl, tosl
003827 9189
003828 9199          loadtos
003829 cfe2          jmp_ DO_EXECUTE
                 .include "words/dobranch.asm"
                 
                 ; System
                 ; runtime of branch
                 ;VE_DOBRANCH:
                 ;    .dw $ff08
                 ;    .db "(branch)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOBRANCH
                 XT_DOBRANCH:
00382a 382b          .dw PFA_DOBRANCH
                 PFA_DOBRANCH:
00382b 01fd          movw zl, XL
00382c 0fee
00382d 1fff
00382e 91a5
00382f 91b5          readflashcell XL,XH
003830 cfd4          jmp_ DO_NEXT
                 .include "words/docondbranch.asm"
                 
                 ; System
                 ; runtime of ?branch
                 ;VE_DOCONDBRANCH:
                 ;    .dw $ff09
                 ;    .db "(?branch)"
                 ;    .dw  VE_HEAD
                 ;    .set VE_HEAD = VE_DOCONDBRANCH
                 XT_DOCONDBRANCH:
003831 3832          .dw PFA_DOCONDBRANCH
                 PFA_DOCONDBRANCH:
003832 2b98          or tosh, tosl
003833 9189
003834 9199          loadtos
003835 f3a9          brbs 1, PFA_DOBRANCH ; 1 is z flag; if tos is zero (false), do the branch
003836 9611          adiw XL, 1
003837 cfcd          jmp_ DO_NEXT
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/doliteral.asm"
                 
                 ; System
                 ; runtime of literal
                 ;VE_DOLITERAL:
                 ;    .dw $ff09
                 ;    .db "(literal)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOLITERAL
                 XT_DOLITERAL:
003838 3839          .dw PFA_DOLITERAL
                 PFA_DOLITERAL:
003839 939a
00383a 938a          savetos
00383b 01fd          movw zl, xl
00383c 0fee
00383d 1fff
00383e 9185
00383f 9195          readflashcell tosl,tosh
003840 9611          adiw xl, 1
003841 cfc3          jmp_ DO_NEXT
                 
                 .include "words/dovariable.asm"
                 
                 ; System
                 ; puts content of parameter field (1 cell) to TOS
                 ;VE_DOVARIABLE:
                 ;    .dw $ff0a
                 ;    .db "(variable)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOVARIABLE
                 XT_DOVARIABLE:
003842 3843          .dw PFA_DOVARIABLE
                 PFA_DOVARIABLE:
003843 939a
003844 938a          savetos
003845 01fb          movw zl, wl
003846 9631          adiw zl,1
003847 0fee
003848 1fff
003849 9185
00384a 9195          readflashcell tosl,tosh
00384b cfb9          jmp_ DO_NEXT
                 .include "words/doconstant.asm"
                 
                 ; System
                 ; place data field address on TOS
                 ;VE_DOCONSTANT:
                 ;    .dw $ff0a
                 ;    .db "(constant)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOCONSTANT
                 XT_DOCONSTANT:
00384c 384d          .dw PFA_DOCONSTANT
                 PFA_DOCONSTANT:
00384d 939a
00384e 938a          savetos
00384f 01cb          movw tosl, wl
003850 9601          adiw tosl, 1
003851 cfb3          jmp_ DO_NEXT
                 .include "words/douser.asm"
                 
                 ; System
                 ; runtime part of user
                 ;VE_DOUSER:
                 ;    .dw $ff06
                 ;    .db "(user)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOUSER
                 XT_DOUSER:
003852 3853          .dw PFA_DOUSER
                 PFA_DOUSER:
003853 939a
003854 938a          savetos
003855 01fb          movw zl, wl
003856 9631          adiw zl, 1
003857 0fee
003858 1fff
003859 9185
00385a 9195          readflashcell tosl,tosh
00385b 0d84          add tosl, upl
00385c 1d95          adc tosh, uph
00385d cfa7          jmp_ DO_NEXT
                 .include "words/do-value.asm"
                 
                 ; System
                 ; runtime of value
                 VE_DOVALUE:
00385e ff07          .dw $ff07
00385f 7628
003860 6c61
003861 6575
003862 0029          .db "(value)", 0
003863 381f          .dw VE_HEAD
                     .set VE_HEAD = VE_DOVALUE
                 XT_DOVALUE:
003864 3801          .dw DO_COLON
                 PFA_DOVALUE:
003865 0730          .dw XT_DOCREATE
003866 0894          .dw XT_REVEAL
003867 0756          .dw XT_COMPILE
003868 386a          .dw PFA_DOVALUE1
003869 381b          .dw XT_EXIT
                 PFA_DOVALUE1:
00386a 940e 08b8     call_ DO_DODOES
00386c 38ac          .dw XT_DUP
00386d 01d9          .dw XT_ICELLPLUS
00386e 3bbb          .dw XT_FETCHI
00386f 3825          .dw XT_EXECUTE
003870 381b          .dw XT_EXIT
                 
                 ; : (value) <builds does> dup icell+ @i execute ;
                 .include "words/fetch.asm"
                 
                 ; Memory
                 ; read 1 cell from RAM address
                 VE_FETCH:
003871 ff01          .dw $ff01
003872 0040          .db "@",0
003873 385e          .dw VE_HEAD
                     .set VE_HEAD = VE_FETCH
                 XT_FETCH:
003874 3875          .dw PFA_FETCH
                 PFA_FETCH:
                 .if WANT_UNIFIED == 1
                 .endif
                 PFA_FETCHRAM:
003875 01fc          movw zl, tosl
                     ; low byte is read before the high byte
003876 9181          ld tosl, z+
003877 9191          ld tosh, z+
003878 cf8c          jmp_ DO_NEXT
                 .if WANT_UNIFIED == 1
                 .endif
                 .include "words/store.asm"
                 
                 ; Memory
                 ; write n to RAM memory at addr, low byte first
                 VE_STORE:
003879 ff01          .dw $ff01
00387a 0021          .db "!",0
00387b 3871          .dw VE_HEAD
                     .set VE_HEAD = VE_STORE
                 XT_STORE:
00387c 387d          .dw PFA_STORE
                 PFA_STORE:
                 .if WANT_UNIFIED == 1
                 .endif
                 PFA_STORERAM:
00387d 01fc          movw zl, tosl
00387e 9189
00387f 9199          loadtos
                     ; the high byte is written before the low byte
003880 8391          std Z+1, tosh
003881 8380          std Z+0, tosl
003882 9189
003883 9199          loadtos
003884 cf80          jmp_ DO_NEXT
                 .if WANT_UNIFIED == 1
                 .endif
                 .include "words/cstore.asm"
                 
                 ; Memory
                 ; store a single byte to RAM address
                 VE_CSTORE:
003885 ff02          .dw $ff02
003886 2163          .db "c!"
003887 3879          .dw VE_HEAD
                     .set VE_HEAD = VE_CSTORE
                 XT_CSTORE:
003888 3889          .dw PFA_CSTORE
                 PFA_CSTORE:
003889 01fc          movw zl, tosl
00388a 9189
00388b 9199          loadtos
00388c 8380          st Z, tosl
00388d 9189
00388e 9199          loadtos
00388f cf75          jmp_ DO_NEXT
                 .include "words/cfetch.asm"
                 
                 ; Memory
                 ; fetch a single byte from memory mapped locations
                 VE_CFETCH:
003890 ff02          .dw $ff02
003891 4063          .db "c@"
003892 3885          .dw VE_HEAD
                     .set VE_HEAD  = VE_CFETCH
                 XT_CFETCH:
003893 3894          .dw PFA_CFETCH
                 PFA_CFETCH:
003894 01fc          movw zl, tosl
003895 2799          clr tosh
003896 8180          ld tosl, Z
003897 cf6d          jmp_ DO_NEXT
                 .include "words/fetch-u.asm"
                 
                 ; Memory
                 ; read 1 cell from USER area
                 VE_FETCHU:
003898 ff02          .dw $ff02
003899 7540          .db "@u"
00389a 3890          .dw VE_HEAD
                     .set VE_HEAD = VE_FETCHU
                 XT_FETCHU:
00389b 3801          .dw DO_COLON
                 PFA_FETCHU:
00389c 3af1          .dw XT_UP_FETCH
00389d 3998          .dw XT_PLUS
00389e 3874          .dw XT_FETCH
00389f 381b          .dw XT_EXIT
                 .include "words/store-u.asm"
                 
                 ; Memory
                 ; write n to USER area at offset
                 VE_STOREU:
0038a0 ff02          .dw $ff02
0038a1 7521          .db "!u"
0038a2 3898          .dw VE_HEAD
                     .set VE_HEAD = VE_STOREU
                 XT_STOREU:
0038a3 3801          .dw DO_COLON
                 PFA_STOREU:
0038a4 3af1          .dw XT_UP_FETCH
0038a5 3998          .dw XT_PLUS
0038a6 387c          .dw XT_STORE
0038a7 381b          .dw XT_EXIT
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/dup.asm"
                 
                 ; Stack
                 ; duplicate TOS
                 VE_DUP:
0038a8 ff03          .dw $ff03
0038a9 7564
0038aa 0070          .db "dup",0
0038ab 38a0          .dw VE_HEAD
                     .set VE_HEAD = VE_DUP
                 XT_DUP:
0038ac 38ad          .dw PFA_DUP
                 PFA_DUP:
0038ad 939a
0038ae 938a          savetos
0038af cf55          jmp_ DO_NEXT
                 .include "words/qdup.asm"
                 
                 ; Stack
                 ; duplicate TOS if non-zero
                 VE_QDUP:
0038b0 ff04          .dw $ff04
0038b1 643f
0038b2 7075          .db "?dup"
0038b3 38a8          .dw VE_HEAD
                     .set VE_HEAD = VE_QDUP
                 XT_QDUP:
0038b4 38b5          .dw PFA_QDUP
                 PFA_QDUP:
0038b5 2f08          mov temp0, tosl
0038b6 2b09          or temp0, tosh
0038b7 f011          breq PFA_QDUP1
0038b8 939a
0038b9 938a          savetos
                 PFA_QDUP1:
0038ba cf4a          jmp_ DO_NEXT
                 .include "words/swap.asm"
                 
                 ; Stack
                 ; swaps the two top level stack cells
                 VE_SWAP:
0038bb ff04          .dw $ff04
0038bc 7773
0038bd 7061          .db "swap"
0038be 38b0          .dw VE_HEAD
                     .set VE_HEAD = VE_SWAP
                 XT_SWAP:
0038bf 38c0          .dw PFA_SWAP
                 PFA_SWAP:
0038c0 018c          movw temp0, tosl
0038c1 9189
0038c2 9199          loadtos
0038c3 931a          st -Y, temp1
0038c4 930a          st -Y, temp0
0038c5 cf3f          jmp_ DO_NEXT
                 .include "words/over.asm"
                 
                 ; Stack
                 ; Place a copy of x1 on top of the stack
                 VE_OVER:
0038c6 ff04          .dw $ff04
0038c7 766f
0038c8 7265          .db "over"
0038c9 38bb          .dw VE_HEAD
                     .set VE_HEAD = VE_OVER
                 XT_OVER:
0038ca 38cb          .dw PFA_OVER
                 PFA_OVER:
0038cb 939a
0038cc 938a          savetos
0038cd 818a          ldd tosl, Y+2
0038ce 819b          ldd tosh, Y+3
                 
0038cf cf35          jmp_ DO_NEXT
                 .include "words/drop.asm"
                 
                 ; Stack
                 ; drop TOS
                 VE_DROP:
0038d0 ff04          .dw $ff04
0038d1 7264
0038d2 706f          .db "drop"
0038d3 38c6          .dw VE_HEAD
                     .set VE_HEAD = VE_DROP
                 XT_DROP:
0038d4 38d5          .dw PFA_DROP
                 PFA_DROP:
0038d5 9189
0038d6 9199          loadtos
0038d7 cf2d          jmp_ DO_NEXT
                 .include "words/rot.asm"
                 
                 ; Stack
                 ; rotate the three top level cells
                 VE_ROT:
0038d8 ff03          .dw $ff03
0038d9 6f72
0038da 0074          .db "rot",0
0038db 38d0          .dw VE_HEAD
                     .set VE_HEAD = VE_ROT
                 XT_ROT:
0038dc 38dd          .dw PFA_ROT
                 PFA_ROT:
0038dd 018c          movw temp0, tosl
0038de 9129          ld temp2, Y+
0038df 9139          ld temp3, Y+ 
0038e0 9189
0038e1 9199          loadtos
                         
0038e2 933a          st -Y, temp3
0038e3 932a          st -Y, temp2
0038e4 931a          st -Y, temp1
0038e5 930a          st -Y, temp0
                 
0038e6 cf1e          jmp_ DO_NEXT
                 .include "words/nip.asm"
                 
                 ; Stack
                 ; Remove Second of Stack
                 VE_NIP:
0038e7 ff03          .dw $ff03
0038e8 696e
0038e9 0070          .db "nip",0
0038ea 38d8          .dw VE_HEAD
                     .set VE_HEAD = VE_NIP
                 XT_NIP:
0038eb 38ec          .dw PFA_NIP
                 PFA_NIP:
0038ec 9622          adiw yl, 2
0038ed cf17          jmp_ DO_NEXT
                 ;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/r_from.asm"
                 
                 ; Stack
                 ; move TOR to TOS
                 VE_R_FROM:
0038ee ff02          .dw $ff02
0038ef 3e72          .db "r>"
0038f0 38e7          .dw VE_HEAD
                     .set VE_HEAD = VE_R_FROM
                 XT_R_FROM:
0038f1 38f2          .dw PFA_R_FROM
                 PFA_R_FROM:
0038f2 939a
0038f3 938a          savetos
0038f4 918f          pop tosl
0038f5 919f          pop tosh
0038f6 cf0e          jmp_ DO_NEXT
                 .include "words/to_r.asm"
                 
                 ; Stack
                 ; move TOS to TOR
                 VE_TO_R:
0038f7 ff02          .dw $ff02
0038f8 723e          .db ">r"
0038f9 38ee          .dw VE_HEAD
                     .set VE_HEAD = VE_TO_R
                 XT_TO_R:
0038fa 38fb          .dw PFA_TO_R
                 PFA_TO_R:
0038fb 939f          push tosh
0038fc 938f          push tosl
0038fd 9189
0038fe 9199          loadtos
0038ff cf05          jmp_ DO_NEXT
                 .include "words/r_fetch.asm"
                 
                 ; Stack
                 ; fetch content of TOR
                 VE_R_FETCH:
003900 ff02          .dw $ff02
003901 4072          .db "r@"
003902 38f7          .dw VE_HEAD
                     .set VE_HEAD = VE_R_FETCH
                 XT_R_FETCH:
003903 3904          .dw PFA_R_FETCH
                 PFA_R_FETCH:
003904 939a
003905 938a          savetos
003906 918f          pop tosl
003907 919f          pop tosh
003908 939f          push tosh
003909 938f          push tosl
00390a cefa          jmp_ DO_NEXT
                 
                 
                 .include "words/not-equal.asm"
                 
                 ; Compare
                 ; true if n1 is not equal to n2
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_NOTEQUAL:
00390b ff02          .dw $ff02
00390c 3e3c          .db "<>"
00390d 3900          .dw VE_HEAD
                     .set VE_HEAD = VE_NOTEQUAL
                 XT_NOTEQUAL:
00390e 3801          .dw DO_COLON
                 PFA_NOTEQUAL:
                 .endif
                 
00390f 3fd4
003910 3915
003911 381b          .DW XT_EQUAL,XT_ZEROEQUAL,XT_EXIT
                 .include "words/equalzero.asm"
                 
                 ; Compare
                 ; compare with 0 (zero)
                 VE_ZEROEQUAL:
003912 ff02          .dw $ff02
003913 3d30          .db "0="
003914 390b          .dw VE_HEAD
                     .set VE_HEAD = VE_ZEROEQUAL
                 XT_ZEROEQUAL:
003915 3916          .dw PFA_ZEROEQUAL
                 PFA_ZEROEQUAL:
003916 2b98          or tosh, tosl
003917 f5d1          brne PFA_ZERO1
003918 c030          rjmp PFA_TRUE1
                 .include "words/lesszero.asm"
                 
                 ; Compare
                 ; compare with zero
                 VE_ZEROLESS:
003919 ff02          .dw $ff02
00391a 3c30          .db "0<"
00391b 3912          .dw VE_HEAD
                     .set VE_HEAD = VE_ZEROLESS
                 XT_ZEROLESS:
00391c 391d          .dw PFA_ZEROLESS
                 PFA_ZEROLESS:
00391d fd97          sbrc tosh,7
00391e c02a          rjmp PFA_TRUE1
00391f c032          rjmp PFA_ZERO1
                 .include "words/greaterzero.asm"
                 
                 ; Compare
                 ; true if n1 is greater than 0
                 VE_GREATERZERO:
003920 ff02          .dw $ff02
003921 3e30          .db "0>"
003922 3919          .dw VE_HEAD
                     .set VE_HEAD = VE_GREATERZERO
                 XT_GREATERZERO:
003923 3924          .dw PFA_GREATERZERO
                 PFA_GREATERZERO:
003924 1582          cp tosl, zerol
003925 0593          cpc tosh, zeroh
003926 f15c          brlt PFA_ZERO1
003927 f151          brbs 1, PFA_ZERO1
003928 c020          rjmp PFA_TRUE1
                 .include "words/d-greaterzero.asm"
                 
                 ; Compare
                 ; compares if a double double cell number is greater 0
                 VE_DGREATERZERO:
003929 ff03          .dw $ff03
00392a 3064
00392b 003e          .db "d0>",0
00392c 3920          .dw VE_HEAD
                     .set VE_HEAD = VE_DGREATERZERO
                 XT_DGREATERZERO:
00392d 392e          .dw PFA_DGREATERZERO
                 PFA_DGREATERZERO:
00392e 1582          cp tosl, zerol
00392f 0593          cpc tosh, zeroh
003930 9189
003931 9199          loadtos
003932 0582          cpc tosl, zerol
003933 0593          cpc tosh, zeroh
003934 f0ec          brlt PFA_ZERO1
003935 f0e1          brbs 1, PFA_ZERO1
003936 c012          rjmp PFA_TRUE1
                 .include "words/d-lesszero.asm"
                 
                 ; Compare
                 ; compares if a double double cell number is less than 0
                 VE_DXT_ZEROLESS:
003937 ff03          .dw $ff03
003938 3064
003939 003c          .db "d0<",0
00393a 3929          .dw VE_HEAD
                     .set VE_HEAD = VE_DXT_ZEROLESS
                 XT_DXT_ZEROLESS:
00393b 393c          .dw PFA_DXT_ZEROLESS
                 PFA_DXT_ZEROLESS:
00393c 9622          adiw Y,2
00393d fd97          sbrc tosh,7
00393e 940c 3949     jmp PFA_TRUE1
003940 940c 3952     jmp PFA_ZERO1
                 
                 .include "words/true.asm"
                 
                 ; Arithmetics
                 ; leaves the value -1 (true) on TOS
                 VE_TRUE:
003942 ff04          .dw $ff04
003943 7274
003944 6575          .db "true"
003945 3937          .dw VE_HEAD
                     .set VE_HEAD = VE_TRUE
                 XT_TRUE:
003946 3947          .dw PFA_TRUE
                 PFA_TRUE:
003947 939a
003948 938a          savetos
                 PFA_TRUE1:
003949 ef8f          ser tosl
00394a ef9f          ser tosh
00394b ceb9          jmp_ DO_NEXT
                 .include "words/zero.asm"
                 
                 ; Arithmetics
                 ; place a value 0 on TOS
                 VE_ZERO:
00394c ff01          .dw $ff01
00394d 0030          .db "0",0
00394e 3942          .dw VE_HEAD
                     .set VE_HEAD = VE_ZERO
                 XT_ZERO:
00394f 3950          .dw PFA_ZERO
                 PFA_ZERO:
003950 939a
003951 938a          savetos
                 PFA_ZERO1:
003952 01c1          movw tosl, zerol
003953 ceb1          jmp_ DO_NEXT
                 .include "words/uless.asm"
                 
                 ; Compare
                 ; true if u1 < u2 (unsigned)
                 VE_ULESS:
003954 ff02          .dw $ff02
003955 3c75          .db "u<"
003956 394c          .dw VE_HEAD
                     .set VE_HEAD = VE_ULESS
                 XT_ULESS:
003957 3958          .dw PFA_ULESS
                 PFA_ULESS:
003958 9129          ld temp2, Y+
003959 9139          ld temp3, Y+
00395a 1782          cp tosl, temp2
00395b 0793          cpc tosh, temp3
00395c f3a8          brlo PFA_ZERO1
00395d f3a1          brbs 1, PFA_ZERO1
00395e cfea          jmp_ PFA_TRUE1
                 .include "words/u-greater.asm"
                 
                 ; Compare
                 ; true if u1 > u2 (unsigned)
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_UGREATER:
00395f ff02          .dw $ff02
003960 3e75          .db "u>"
003961 3954          .dw VE_HEAD
                     .set VE_HEAD = VE_UGREATER
                 XT_UGREATER:
003962 3801          .dw DO_COLON
                 PFA_UGREATER:
                 .endif
003963 38bf          .DW XT_SWAP
003964 3957          .dw XT_ULESS
003965 381b          .dw XT_EXIT
                 .include "words/less.asm"
                 
                 ; Compare
                 ; true if n1 is less than n2
                     VE_LESS:
003966 ff01          .dw $ff01
003967 003c          .db "<",0
003968 395f          .dw VE_HEAD
                     .set VE_HEAD = VE_LESS
                 XT_LESS:
003969 396a          .dw PFA_LESS
                 PFA_LESS:
00396a 9129          ld temp2, Y+
00396b 9139          ld temp3, Y+
00396c 1728          cp temp2, tosl
00396d 0739          cpc temp3, tosh
                 PFA_LESSDONE:
00396e f71c          brge PFA_ZERO1
00396f cfd9          rjmp PFA_TRUE1
                 .include "words/greater.asm"
                 
                 ; Compare
                 ; flag is true if n1 is greater than n2
                 VE_GREATER:
003970 ff01          .dw $ff01
003971 003e          .db ">",0
003972 3966          .dw VE_HEAD
                     .set VE_HEAD = VE_GREATER
                 XT_GREATER:
003973 3974          .dw PFA_GREATER
                 PFA_GREATER:
003974 9129          ld temp2, Y+
003975 9139          ld temp3, Y+
003976 1728          cp temp2, tosl
003977 0739          cpc temp3, tosh
                 PFA_GREATERDONE:
003978 f2cc          brlt PFA_ZERO1
003979 f2c1          brbs 1, PFA_ZERO1
00397a cfce          rjmp PFA_TRUE1
                 
                 .include "words/log2.asm"
                 
                 ; Arithmetics
                 ; logarithm to base 2 or highest set bitnumber
                 VE_LOG2:
00397b ff04          .dw $ff04
00397c 6f6c
00397d 3267          .db "log2"
00397e 3970          .dw VE_HEAD
                     .set VE_HEAD = VE_LOG2
                 XT_LOG2:
00397f 3980          .dw PFA_LOG2
                 PFA_LOG2:
003980 01fc          movw zl, tosl
003981 2799          clr tosh
003982 e180          ldi tosl, 16
                 PFA_LOG2_1:
003983 958a          dec tosl
003984 f022          brmi PFA_LOG2_2 ; wrong data
003985 0fee          lsl  zl
003986 1fff          rol  zh
003987 f7d8          brcc PFA_LOG2_1
003988 ce7c          jmp_ DO_NEXT
                 
                 PFA_LOG2_2:
003989 959a          dec tosh
00398a ce7a          jmp_ DO_NEXT
                 .include "words/minus.asm"
                 
                 ; Arithmetics
                 ; subtract n2 from n1
                 VE_MINUS:
00398b ff01          .dw $ff01
00398c 002d          .db "-",0
00398d 397b          .dw VE_HEAD
                     .set VE_HEAD = VE_MINUS
                 XT_MINUS:
00398e 398f          .dw PFA_MINUS
                 PFA_MINUS:
00398f 9109          ld temp0, Y+
003990 9119          ld temp1, Y+
003991 1b08          sub temp0, tosl
003992 0b19          sbc temp1, tosh
003993 01c8          movw tosl, temp0
003994 ce70          jmp_ DO_NEXT
                 .include "words/plus.asm"
                 
                 ; Arithmetics
                 ; add n1 and n2
                 VE_PLUS:
003995 ff01          .dw $ff01
003996 002b          .db "+",0
003997 398b          .dw VE_HEAD
                     .set VE_HEAD = VE_PLUS
                 XT_PLUS:
003998 3999          .dw PFA_PLUS
                 PFA_PLUS:
003999 9109          ld temp0, Y+
00399a 9119          ld temp1, Y+
00399b 0f80          add tosl, temp0
00399c 1f91          adc tosh, temp1
00399d ce67          jmp_ DO_NEXT
                 .include "words/mstar.asm"
                 
                 ; Arithmetics
                 ; multiply 2 cells to a double cell
                 VE_MSTAR:
00399e ff02          .dw $ff02
00399f 2a6d          .db "m*"
0039a0 3995          .dw VE_HEAD
                     .set VE_HEAD = VE_MSTAR
                 XT_MSTAR:
0039a1 39a2          .dw PFA_MSTAR
                 PFA_MSTAR:
0039a2 018c          movw temp0, tosl
0039a3 9189
0039a4 9199          loadtos
0039a5 019c          movw temp2, tosl
                     ; high cell ah*bh
0039a6 0231          muls temp3, temp1
0039a7 0170          movw temp4, r0
                     ; low cell  al*bl
0039a8 9f20          mul  temp2, temp0
0039a9 01c0          movw tosl, r0
                     ; signed ah*bl
0039aa 0330          mulsu temp3, temp0
0039ab 08f3          sbc   temp5, zeroh
0039ac 0d90          add   tosh,  r0
0039ad 1ce1          adc   temp4, r1
0039ae 1cf3          adc   temp5, zeroh
                     
                     ; signed al*bh
0039af 0312          mulsu temp1, temp2
0039b0 08f3          sbc   temp5, zeroh
0039b1 0d90          add   tosh,  r0
0039b2 1ce1          adc   temp4, r1
0039b3 1cf3          adc   temp5, zeroh
                 
0039b4 939a
0039b5 938a          savetos
0039b6 01c7          movw tosl, temp4
0039b7 ce4d          jmp_ DO_NEXT
                 .include "words/umslashmod.asm"
                 
                 ; Arithmetics
                 ; unsigned division ud / u2 with remainder
                 VE_UMSLASHMOD:
0039b8 ff06          .dw $ff06
0039b9 6d75
0039ba 6d2f
0039bb 646f          .db "um/mod"
0039bc 399e          .dw VE_HEAD
                     .set VE_HEAD = VE_UMSLASHMOD
                 XT_UMSLASHMOD:
0039bd 39be          .dw PFA_UMSLASHMOD
                 PFA_UMSLASHMOD:
0039be 017c          movw temp4, tosl
                 
0039bf 9129          ld temp2, Y+
0039c0 9139          ld temp3, Y+
                   
0039c1 9109          ld temp0, Y+
0039c2 9119          ld temp1, Y+
                 
                 ;; unsigned 32/16 -> 16r16 divide
                 
                 PFA_UMSLASHMODmod:
                 
                   ; set loop counter
0039c3 e140          ldi temp6,$10
                 
                 PFA_UMSLASHMODmod_loop:
                     ; shift left, saving high bit
0039c4 2755          clr temp7
0039c5 0f00          lsl temp0
0039c6 1f11          rol temp1
0039c7 1f22          rol temp2
0039c8 1f33          rol temp3
0039c9 1f55          rol temp7
                 
                   ; try subtracting divisor
0039ca 152e          cp temp2, temp4
0039cb 053f          cpc temp3, temp5
0039cc 0552          cpc temp7,zerol
                 
0039cd f018          brcs PFA_UMSLASHMODmod_loop_control
                 
                 PFA_UMSLASHMODmod_subtract:
                     ; dividend is large enough
                     ; do the subtraction for real
                     ; and set lowest bit
0039ce 9503          inc temp0
0039cf 192e          sub temp2, temp4
0039d0 093f          sbc temp3, temp5
                 
                 PFA_UMSLASHMODmod_loop_control:
0039d1 954a          dec  temp6
0039d2 f789          brne PFA_UMSLASHMODmod_loop
                 
                 PFA_UMSLASHMODmod_done:
                     ; put remainder on stack
0039d3 933a          st -Y,temp3
0039d4 932a          st -Y,temp2
                 
                     ; put quotient on stack
0039d5 01c8          movw tosl, temp0
0039d6 ce2e          jmp_ DO_NEXT
                 .include "words/umstar.asm"
                 
                 ; Arithmetics
                 ; multiply 2 unsigned cells to a double cell
                 VE_UMSTAR:
0039d7 ff03          .dw $ff03
0039d8 6d75
0039d9 002a          .db "um*",0
0039da 39b8          .dw VE_HEAD
                     .set VE_HEAD = VE_UMSTAR
                 XT_UMSTAR:
0039db 39dc          .dw PFA_UMSTAR
                 PFA_UMSTAR:
0039dc 018c          movw temp0, tosl
0039dd 9189
0039de 9199          loadtos
                     ; result: (temp3*temp1)* 65536 + (temp3*temp0 + temp1*temp2) * 256 + (temp0 * temp2)
                     ; low bytes
0039df 9f80          mul tosl,temp0
0039e0 01f0          movw zl, r0
0039e1 2722          clr temp2
0039e2 2733          clr temp3
                     ; middle bytes
0039e3 9f90          mul tosh, temp0
0039e4 0df0          add zh, r0
0039e5 1d21          adc temp2, r1
0039e6 1d33          adc temp3, zeroh
                         
0039e7 9f81          mul tosl, temp1
0039e8 0df0          add zh, r0
0039e9 1d21          adc temp2, r1
0039ea 1d33          adc temp3, zeroh
                     
0039eb 9f91          mul tosh, temp1
0039ec 0d20          add temp2, r0
0039ed 1d31          adc temp3, r1
0039ee 01cf          movw tosl, zl
0039ef 939a
0039f0 938a          savetos
0039f1 01c9          movw tosl, temp2
0039f2 ce12          jmp_ DO_NEXT
                 
                 .include "words/invert.asm"
                 
                 ; Arithmetics
                 ; 1-complement of TOS
                 VE_INVERT:
0039f3 ff06          .dw $ff06
0039f4 6e69
0039f5 6576
0039f6 7472          .db "invert"
0039f7 39d7          .dw VE_HEAD
                     .set VE_HEAD = VE_INVERT
                 XT_INVERT:
0039f8 39f9          .dw PFA_INVERT
                 PFA_INVERT:
0039f9 9580          com tosl
0039fa 9590          com tosh
0039fb ce09          jmp_ DO_NEXT
                 .include "words/2slash.asm"
                 
                 ; Arithmetics
                 ; arithmetic shift right
                 VE_2SLASH:
0039fc ff02          .dw $ff02
0039fd 2f32          .db "2/"
0039fe 39f3          .dw VE_HEAD
                     .set VE_HEAD = VE_2SLASH
                 XT_2SLASH:
0039ff 3a00          .dw PFA_2SLASH
                 PFA_2SLASH:
003a00 9595          asr tosh
003a01 9587          ror tosl
003a02 ce02          jmp_ DO_NEXT
                 .include "words/2star.asm"
                 
                 ; Arithmetics
                 ; arithmetic shift left, filling with zero
                 VE_2STAR:
003a03 ff02          .dw $ff02
003a04 2a32          .db "2*"
003a05 39fc          .dw VE_HEAD
                     .set VE_HEAD = VE_2STAR
                 XT_2STAR:
003a06 3a07          .dw PFA_2STAR
                 PFA_2STAR:
003a07 0f88          lsl tosl
003a08 1f99          rol tosh
003a09 cdfb          jmp_ DO_NEXT
                 .include "words/and.asm"
                 
                 ; Logic
                 ; bitwise and
                 VE_AND:
003a0a ff03          .dw $ff03
003a0b 6e61
003a0c 0064          .db "and",0
003a0d 3a03          .dw VE_HEAD
                     .set VE_HEAD = VE_AND
                 XT_AND:
003a0e 3a0f          .dw PFA_AND
                 PFA_AND:
003a0f 9109          ld temp0, Y+
003a10 9119          ld temp1, Y+
003a11 2380          and tosl, temp0
003a12 2391          and tosh, temp1
003a13 cdf1          jmp_ DO_NEXT
                 .include "words/or.asm"
                 
                 ; Logic
                 ; logical or
                 VE_OR:
003a14 ff02          .dw $ff02
003a15 726f          .db "or"
003a16 3a0a          .dw VE_HEAD
                     .set VE_HEAD = VE_OR
                 XT_OR:
003a17 3a18          .dw PFA_OR
                 PFA_OR:
003a18 9109          ld temp0, Y+
003a19 9119          ld temp1, Y+
003a1a 2b80          or tosl, temp0
003a1b 2b91          or tosh, temp1
003a1c cde8          jmp_ DO_NEXT
                 
                 .include "words/xor.asm"
                 
                 ; Logic
                 ; exclusive or
                 VE_XOR:
003a1d ff03          .dw $ff03
003a1e 6f78
003a1f 0072          .db "xor",0
003a20 3a14          .dw VE_HEAD
                     .set VE_HEAD = VE_XOR
                 XT_XOR:
003a21 3a22          .dw PFA_XOR
                 PFA_XOR:
003a22 9109          ld temp0, Y+
003a23 9119          ld temp1, Y+
003a24 2780          eor tosl, temp0
003a25 2791          eor tosh, temp1
003a26 cdde          jmp_ DO_NEXT
                 
                 .include "words/1plus.asm"
                 
                 ; Arithmetics
                 ; optimized increment
                 VE_1PLUS:
003a27 ff02          .dw $ff02
003a28 2b31          .db "1+"
003a29 3a1d          .dw VE_HEAD
                     .set VE_HEAD = VE_1PLUS
                 XT_1PLUS:
003a2a 3a2b          .dw PFA_1PLUS
                 PFA_1PLUS:
003a2b 9601          adiw tosl,1
003a2c cdd8          jmp_ DO_NEXT
                 .include "words/1minus.asm"
                 
                 ; Arithmetics
                 ; optimized decrement
                 VE_1MINUS:
003a2d ff02          .dw $ff02 
003a2e 2d31          .db "1-"
003a2f 3a27          .dw VE_HEAD
                     .set VE_HEAD = VE_1MINUS
                 XT_1MINUS:
003a30 3a31          .dw PFA_1MINUS
                 PFA_1MINUS:
003a31 9701          sbiw tosl, 1
003a32 cdd2          jmp_ DO_NEXT
                 .include "words/lshift.asm"
                 
                 ; Arithmetics
                 ; logically shift n1 left n2 times
                 VE_LSHIFT:
003a33 ff06          .dw $ff06
003a34 736c
003a35 6968
003a36 7466          .db "lshift"
003a37 3a2d          .dw VE_HEAD
                     .set VE_HEAD = VE_LSHIFT
                 XT_LSHIFT:
003a38 3a39          .dw PFA_LSHIFT
                 PFA_LSHIFT:
003a39 01fc          movw zl, tosl
003a3a 9189
003a3b 9199          loadtos
                 PFA_LSHIFT1:
003a3c 9731          sbiw zl, 1
003a3d f01a          brmi PFA_LSHIFT2
003a3e 0f88          lsl tosl
003a3f 1f99          rol tosh
003a40 cffb          rjmp PFA_LSHIFT1
                 PFA_LSHIFT2:
003a41 cdc3          jmp_ DO_NEXT
                 
                 .include "words/rshift.asm"
                 
                 ; Arithmetics
                 ; shift n1 n2-times logically right
                 VE_RSHIFT:
003a42 ff06          .dw $ff06
003a43 7372
003a44 6968
003a45 7466          .db "rshift"
003a46 3a33          .dw VE_HEAD
                     .set VE_HEAD = VE_RSHIFT
                 XT_RSHIFT:
003a47 3a48          .dw PFA_RSHIFT
                 PFA_RSHIFT:
003a48 01fc          movw zl, tosl
003a49 9189
003a4a 9199          loadtos
                 PFA_RSHIFT1:
003a4b 9731          sbiw zl, 1
003a4c f01a          brmi PFA_RSHIFT2
003a4d 9596          lsr tosh
003a4e 9587          ror tosl
003a4f cffb          rjmp PFA_RSHIFT1
                 PFA_RSHIFT2:
003a50 cdb4          jmp_ DO_NEXT
                 
                 .include "words/plusstore.asm"
                 
                 ; Arithmetics
                 ; add n to content of RAM address a-addr
                 VE_PLUSSTORE:
003a51 ff02          .dw $ff02
003a52 212b          .db "+!"
003a53 3a42          .dw VE_HEAD
                     .set VE_HEAD = VE_PLUSSTORE
                 XT_PLUSSTORE:
003a54 3a55          .dw PFA_PLUSSTORE
                 PFA_PLUSSTORE:
003a55 01fc          movw zl, tosl
003a56 9189
003a57 9199          loadtos
003a58 8120          ldd temp2, Z+0
003a59 8131          ldd temp3, Z+1
003a5a 0f82          add tosl, temp2
003a5b 1f93          adc tosh, temp3
003a5c 8380          std Z+0, tosl
003a5d 8391          std Z+1, tosh
003a5e 9189
003a5f 9199          loadtos
003a60 cda4          jmp_ DO_NEXT
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/rpfetch.asm"
                 
                 ; Stack
                 ; current return stack pointer address
                 VE_RP_FETCH:
003a61 ff03          .dw $ff03
003a62 7072
003a63 0040          .db "rp@",0
003a64 3a51          .dw VE_HEAD
                     .set VE_HEAD = VE_RP_FETCH
                 XT_RP_FETCH:
003a65 3a66          .dw PFA_RP_FETCH
                 PFA_RP_FETCH:
003a66 939a
003a67 938a          savetos
003a68 b78d          in tosl, SPL
003a69 b79e          in tosh, SPH
003a6a cd9a          jmp_ DO_NEXT
                 .include "words/rpstore.asm"
                 
                 ; Stack
                 ; set return stack pointer
                 VE_RP_STORE:
003a6b ff03          .dw $ff03
003a6c 7072
003a6d 0021          .db "rp!",0
003a6e 3a61          .dw VE_HEAD
                     .set VE_HEAD = VE_RP_STORE
                 XT_RP_STORE:
003a6f 3a70          .dw PFA_RP_STORE
                 PFA_RP_STORE:
003a70 b72f          in temp2, SREG
003a71 94f8          cli
003a72 bf8d          out SPL, tosl
003a73 bf9e          out SPH, tosh
003a74 bf2f          out SREG, temp2
003a75 9189
003a76 9199          loadtos
003a77 cd8d          jmp_ DO_NEXT
                 .include "words/spfetch.asm"
                 
                 ; Stack
                 ; current data stack pointer
                 VE_SP_FETCH:
003a78 ff03          .dw $ff03
003a79 7073
003a7a 0040          .db "sp@",0
003a7b 3a6b          .dw VE_HEAD
                     .set VE_HEAD = VE_SP_FETCH
                 XT_SP_FETCH:
003a7c 3a7d          .dw PFA_SP_FETCH
                 PFA_SP_FETCH:
003a7d 939a
003a7e 938a          savetos
003a7f 01ce          movw tosl, yl
003a80 cd84          jmp_ DO_NEXT
                 .include "words/spstore.asm"
                 
                 ; Stack
                 ; set data stack pointer to addr
                 VE_SP_STORE:
003a81 ff03          .dw $ff03
003a82 7073
003a83 0021          .db "sp!",0
003a84 3a78          .dw VE_HEAD
                     .set VE_HEAD = VE_SP_STORE
                 XT_SP_STORE:
003a85 3a86          .dw PFA_SP_STORE
                 PFA_SP_STORE:
003a86 01ec          movw yl, tosl
003a87 9189
003a88 9199          loadtos
003a89 cd7b          jmp_ DO_NEXT
                 
                 .include "words/dodo.asm"
                 
                 ; System
                 ; runtime of do
                 ;VE_DODO:
                 ;    .dw $ff04
                 ;    .db "(do)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DODO
                 XT_DODO:
003a8a 3a8b          .dw PFA_DODO
                 PFA_DODO:
003a8b 9129          ld temp2, Y+
003a8c 9139          ld temp3, Y+  ; limit
                 PFA_DODO1:
003a8d e8e0          ldi zl, $80
003a8e 0f3e          add temp3, zl
003a8f 1b82          sub  tosl, temp2
003a90 0b93          sbc  tosh, temp3
                 
003a91 933f          push temp3
003a92 932f          push temp2    ; limit  ( --> limit + $8000)
003a93 939f          push tosh
003a94 938f          push tosl     ; start -> index ( --> index - (limit - $8000)
003a95 9189
003a96 9199          loadtos
003a97 cd6d          jmp_ DO_NEXT
                 .include "words/i.asm"
                 
                 ; Compiler
                 ; current loop counter
                 VE_I:
003a98 ff01          .dw $FF01
003a99 0069          .db "i",0
003a9a 3a81          .dw VE_HEAD
                     .set VE_HEAD = VE_I
                 XT_I:
003a9b 3a9c          .dw PFA_I
                 PFA_I:
003a9c 939a
003a9d 938a          savetos
003a9e 918f          pop tosl
003a9f 919f          pop tosh  ; index
003aa0 91ef          pop zl
003aa1 91ff          pop zh    ; limit
003aa2 93ff          push zh
003aa3 93ef          push zl
003aa4 939f          push tosh
003aa5 938f          push tosl
003aa6 0f8e          add tosl, zl
003aa7 1f9f          adc tosh, zh
003aa8 cd5c          jmp_ DO_NEXT
                 .include "words/doplusloop.asm"
                 
                 ; System
                 ; runtime of +loop
                 ;VE_DOPLUSLOOP:
                 ;    .dw $ff07
                 ;    .db "(+loop)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOPLUSLOOP
                 XT_DOPLUSLOOP:
003aa9 3aaa          .dw PFA_DOPLUSLOOP
                 PFA_DOPLUSLOOP:
003aaa 91ef          pop zl
003aab 91ff          pop zh
003aac 0fe8          add zl, tosl
003aad 1ff9          adc zh, tosh
003aae 9189
003aaf 9199          loadtos
003ab0 f01b          brvs PFA_DOPLUSLOOP_LEAVE
                     ; next cycle
                 PFA_DOPLUSLOOP_NEXT:
                     ; next iteration
003ab1 93ff          push zh
003ab2 93ef          push zl
003ab3 cd77          rjmp PFA_DOBRANCH ; read next cell from dictionary and jump to its destination
                 PFA_DOPLUSLOOP_LEAVE:
003ab4 910f          pop  temp0
003ab5 911f          pop  temp1  ; remove limit
003ab6 9611          adiw xl, 1  ; skip branch-back address
003ab7 cd4d          jmp_ DO_NEXT
                 .include "words/doloop.asm"
                 
                 ; System
                 ; runtime of loop
                 ;VE_DOLOOP:
                 ;    .dw $ff06
                 ;    .db "(loop)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOLOOP
                 XT_DOLOOP:
003ab8 3ab9          .dw PFA_DOLOOP
                 PFA_DOLOOP:
003ab9 91ef          pop zl
003aba 91ff          pop zh
003abb 9631          adiw zl,1
003abc f3bb          brvs PFA_DOPLUSLOOP_LEAVE
003abd cff3          jmp_ PFA_DOPLUSLOOP_NEXT
                 .include "words/unloop.asm"
                 
                 ; Compiler
                 ; remove loop-sys, exit the loop and continue execution after it
                 VE_UNLOOP:
003abe ff06          .dw $ff06
003abf 6e75
003ac0 6f6c
003ac1 706f          .db "unloop"
003ac2 3a98          .dw VE_HEAD
                     .set VE_HEAD = VE_UNLOOP
                 XT_UNLOOP:
003ac3 3ac4          .dw PFA_UNLOOP
                 PFA_UNLOOP:
003ac4 911f          pop temp1
003ac5 910f          pop temp0
003ac6 911f          pop temp1
003ac7 910f          pop temp0
003ac8 cd3c          jmp_ DO_NEXT
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 
                 .include "words/cmove_g.asm"
                 
                 ; Memory
                 ; copy data in RAM from higher to lower addresses.
                 VE_CMOVE_G:
003ac9 ff06          .dw $ff06
003aca 6d63
003acb 766f
003acc 3e65          .db "cmove>"
003acd 3abe          .dw VE_HEAD
                     .set VE_HEAD  = VE_CMOVE_G
                 XT_CMOVE_G:
003ace 3acf          .dw PFA_CMOVE_G
                 PFA_CMOVE_G:
003acf 93bf          push xh
003ad0 93af          push xl
003ad1 91e9          ld zl, Y+
003ad2 91f9          ld zh, Y+ ; addr-to
003ad3 91a9          ld xl, Y+
003ad4 91b9          ld xh, Y+ ; addr-from
003ad5 2f09          mov temp0, tosh
003ad6 2b08          or temp0, tosl
003ad7 f041          brbs 1, PFA_CMOVE_G1
003ad8 0fe8          add zl, tosl
003ad9 1ff9          adc zh, tosh
003ada 0fa8          add xl, tosl
003adb 1fb9          adc xh, tosh
                 PFA_CMOVE_G2:
003adc 911e          ld temp1, -X
003add 9312          st -Z, temp1
003ade 9701          sbiw tosl, 1
003adf f7e1          brbc 1, PFA_CMOVE_G2
                 PFA_CMOVE_G1:
003ae0 91af          pop xl
003ae1 91bf          pop xh
003ae2 9189
003ae3 9199          loadtos
003ae4 cd20          jmp_ DO_NEXT
                 .include "words/byteswap.asm"
                 
                 ; Arithmetics
                 ; exchange the bytes of the TOS
                 VE_BYTESWAP:
003ae5 ff02          .dw $ff02
003ae6 3c3e          .db "><"
003ae7 3ac9          .dw VE_HEAD
                     .set VE_HEAD = VE_BYTESWAP
                 XT_BYTESWAP:
003ae8 3ae9          .dw PFA_BYTESWAP
                 PFA_BYTESWAP:
003ae9 2f09          mov temp0, tosh
003aea 2f98          mov tosh, tosl
003aeb 2f80          mov tosl, temp0
003aec cd18          jmp_ DO_NEXT
                 .include "words/up.asm"
                 
                 ; System Variable
                 ; get user area pointer
                 VE_UP_FETCH:
003aed ff03          .dw $ff03
003aee 7075
003aef 0040          .db "up@",0
003af0 3ae5          .dw VE_HEAD
                     .set VE_HEAD = VE_UP_FETCH
                 XT_UP_FETCH:
003af1 3af2          .dw PFA_UP_FETCH
                 PFA_UP_FETCH:
003af2 939a
003af3 938a          savetos
003af4 01c2          movw tosl, upl
003af5 cd0f          jmp_ DO_NEXT
                 
                 ; ( addr -- ) 
                 ; System Variable
                 ; set user area pointer
                 VE_UP_STORE:
003af6 ff03          .dw $ff03
003af7 7075
003af8 0021          .db "up!",0
003af9 3aed          .dw VE_HEAD
                     .set VE_HEAD = VE_UP_STORE
                 XT_UP_STORE:
003afa 3afb          .dw PFA_UP_STORE
                 PFA_UP_STORE:
003afb 012c          movw upl, tosl
003afc 9189
003afd 9199          loadtos
003afe cd06          jmp_ DO_NEXT
                 .include "words/1ms.asm"
                 
                 ; Time
                 ; busy waits (almost) exactly 1 millisecond
                 VE_1MS:
003aff ff03          .dw $ff03
003b00 6d31
003b01 0073          .db "1ms",0
003b02 3af6          .dw VE_HEAD
                     .set VE_HEAD = VE_1MS
                 XT_1MS:
003b03 3b04          .dw PFA_1MS
                 PFA_1MS:
003b04 eae0
003b05 e0ff
003b06 9731
003b07 f7f1          delay 1000
003b08 ccfc          jmp_ DO_NEXT
                 .include "words/2to_r.asm"
                 
                 ; Stack
                 ; move DTOS to TOR
                 VE_2TO_R:
003b09 ff03          .dw $ff03
003b0a 3e32
003b0b 0072          .db "2>r",0
003b0c 3aff          .dw VE_HEAD
                     .set VE_HEAD = VE_2TO_R
                 XT_2TO_R:
003b0d 3b0e          .dw PFA_2TO_R
                 PFA_2TO_R:
003b0e 01fc          movw zl, tosl
003b0f 9189
003b10 9199          loadtos
003b11 939f          push tosh
003b12 938f          push tosl
003b13 93ff          push zh
003b14 93ef          push zl
003b15 9189
003b16 9199          loadtos
003b17 cced          jmp_ DO_NEXT
                 .include "words/2r_from.asm"
                 
                 ; Stack
                 ; move DTOR to TOS
                 VE_2R_FROM:
003b18 ff03          .dw $ff03
003b19 7232
003b1a 003e          .db "2r>",0
003b1b 3b09          .dw VE_HEAD
                     .set VE_HEAD = VE_2R_FROM
                 XT_2R_FROM:
003b1c 3b1d          .dw PFA_2R_FROM
                 PFA_2R_FROM:
003b1d 939a
003b1e 938a          savetos
003b1f 91ef          pop zl
003b20 91ff          pop zh
003b21 918f          pop tosl
003b22 919f          pop tosh
003b23 939a
003b24 938a          savetos
003b25 01cf          movw tosl, zl
003b26 ccde          jmp_ DO_NEXT
                 
                 .include "words/store-e.asm"
                 
                 ; Memory
                 ; write n (2bytes) to eeprom address
                 VE_STOREE:
003b27 ff02          .dw $ff02
003b28 6521          .db "!e"
003b29 3b18          .dw VE_HEAD
                     .set VE_HEAD = VE_STOREE
                 XT_STOREE:
003b2a 3b2b          .dw PFA_STOREE
                 PFA_STOREE:
                 .if WANT_UNIFIED == 1
                 .endif
                 PFA_STOREE0:
003b2b 01fc          movw zl, tosl
003b2c 9189
003b2d 9199          loadtos
003b2e b72f          in_ temp2, SREG
003b2f 94f8          cli
003b30 d028          rcall PFA_FETCHE2
003b31 b500          in_  temp0, EEDR
003b32 1708          cp temp0,tosl
003b33 f009          breq PFA_STOREE3
003b34 d00b          rcall PFA_STOREE1
                 PFA_STOREE3:
003b35 9631          adiw zl,1
003b36 d022          rcall PFA_FETCHE2
003b37 b500          in_  temp0, EEDR
003b38 1709          cp temp0,tosh
003b39 f011          breq PFA_STOREE4
003b3a 2f89          mov tosl, tosh
003b3b d004          rcall PFA_STOREE1
                 PFA_STOREE4:
003b3c bf2f          out_ SREG, temp2
003b3d 9189
003b3e 9199          loadtos
003b3f ccc5          jmp_ DO_NEXT
                     
                 PFA_STOREE1:
003b40 99f9          sbic EECR, EEPE
003b41 cffe          rjmp PFA_STOREE1
                 
                 PFA_STOREE2: ; estore_wait_low_spm:
003b42 b707          in_ temp0, SPMCSR
003b43 fd00          sbrc temp0,SPMEN
003b44 cffd          rjmp PFA_STOREE2
                 
003b45 bdf2          out_ EEARH,zh
003b46 bde1          out_ EEARL,zl
003b47 bd80          out_ EEDR, tosl
003b48 9afa          sbi EECR,EEMPE
003b49 9af9          sbi EECR,EEPE
                 
003b4a 9508          ret
                 .if WANT_UNIFIED == 1
                 .endif
                 .include "words/fetch-e.asm"
                 
                 ; Memory
                 ; read 1 cell from eeprom
                 VE_FETCHE:
003b4b ff02          .dw $ff02
003b4c 6540          .db "@e"
003b4d 3b27          .dw VE_HEAD
                     .set VE_HEAD = VE_FETCHE
                 XT_FETCHE:
003b4e 3b4f          .dw PFA_FETCHE
                 PFA_FETCHE:
                 .if WANT_UNIFIED == 1
                 .endif
                 PFA_FETCHE1:
003b4f b72f          in_ temp2, SREG
003b50 94f8          cli
003b51 01fc          movw zl, tosl
003b52 d006          rcall PFA_FETCHE2
003b53 b580          in_ tosl, EEDR
                 
003b54 9631          adiw zl,1
                 
003b55 d003          rcall PFA_FETCHE2
003b56 b590          in_  tosh, EEDR
003b57 bf2f          out_ SREG, temp2
003b58 ccac          jmp_ DO_NEXT
                 
                 PFA_FETCHE2:
003b59 99f9          sbic EECR, EEPE
003b5a cffe          rjmp PFA_FETCHE2
                 
003b5b bdf2          out_ EEARH,zh
003b5c bde1          out_ EEARL,zl
                 
003b5d 9af8          sbi EECR,EERE
003b5e 9508          ret
                 
                 .if WANT_UNIFIED == 1
                 .endif
                 .include "words/store-i.asm"
                 
                 ; System Value
                 ; Deferred action to write a single 16bit cell to flash
                 VE_STOREI:
003b5f ff02          .dw $ff02
003b60 6921          .db "!i"
003b61 3b4b          .dw VE_HEAD
                     .set VE_HEAD = VE_STOREI
                 XT_STOREI:
003b62 3de1          .dw PFA_DODEFER1
                 PFA_STOREI:
003b63 003e          .dw EE_STOREI
003b64 3d82          .dw XT_EDEFERFETCH
003b65 3d8c          .dw XT_EDEFERSTORE
                 .if FLASHEND > $10000
                 .else
                   .include "words/store-i_nrww.asm"
                 
                 ; Memory
                 ; writes n to flash memory using assembly code (code to be placed in boot loader section)
                 VE_DO_STOREI_NRWW:
003b66 ff09          .dw $ff09
003b67 2128
003b68 2d69
003b69 726e
003b6a 7777
003b6b 0029          .db "(!i-nrww)",0
003b6c 3b5f          .dw VE_HEAD
                     .set VE_HEAD = VE_DO_STOREI_NRWW
                 XT_DO_STOREI:
003b6d 3b6e          .dw PFA_DO_STOREI_NRWW
                 PFA_DO_STOREI_NRWW:
                   ; store status register
003b6e b71f        in temp1,SREG
003b6f 931f        push temp1
003b70 94f8        cli
                 
003b71 019c        movw temp2, tosl ; save the (word) address
003b72 9189
003b73 9199        loadtos          ; get the new value for the flash cell
003b74 93af        push xl
003b75 93bf        push xh
003b76 93cf        push yl
003b77 93df        push yh
003b78 d009        rcall DO_STOREI_atmega
003b79 91df        pop yh
003b7a 91cf        pop yl
003b7b 91bf        pop xh
003b7c 91af        pop xl
                   ; finally clear the stack
003b7d 9189
003b7e 9199        loadtos
003b7f 911f        pop temp1
                   ; restore status register (and interrupt enable flag)
003b80 bf1f        out SREG,temp1
                 
003b81 cc83        jmp_ DO_NEXT
                 
                 ; 
                 DO_STOREI_atmega:
                   ; write data to temp page buffer
                   ; use the values in tosl/tosh at the
                   ; appropiate place
003b82 d011        rcall pageload
                 
                   ; erase page if needed
                   ; it is needed if a bit goes from 0 to 1
003b83 94e0        com temp4
003b84 94f0        com temp5
003b85 218e        and tosl, temp4
003b86 219f        and tosh, temp5
003b87 2b98        or tosh, tosl
003b88 f021        breq DO_STOREI_writepage 
003b89 94b3          inc erase_counter
003b8a 01f9          movw zl, temp2
003b8b e002          ldi temp0,(1<<PGERS)
003b8c d020          rcall dospm
                 
                 DO_STOREI_writepage:
                   ; write page
003b8d 01f9        movw zl, temp2
003b8e e004        ldi temp0,(1<<PGWRT)
003b8f d01d        rcall dospm
                 
                   ; reenable RWW section
003b90 01f9        movw zl, temp2
003b91 e100        ldi temp0,(1<<RWWSRE)
003b92 d01a        rcall dospm
003b93 9508        ret
                 
                 ; load the desired page
                 .equ pagemask = ~ ( PAGESIZE - 1 )
                 pageload:
003b94 01f9        movw zl, temp2
                   ; get the beginning of page
003b95 7ce0        andi zl,low(pagemask)
003b96 7fff        andi zh,high(pagemask)
003b97 01ef        movw y, z
                   ; loop counter (in words)
003b98 e4a0        ldi xl,low(pagesize)
003b99 e0b0        ldi xh,high(pagesize)
                 pageload_loop:
                   ; we need the current flash value anyways
003b9a 01fe        movw z, y
003b9b 0fee
003b9c 1fff
003b9d 9145
003b9e 9155        readflashcell temp6, temp7 ; destroys Z
                   ; now check: if Z points to the same cell as temp2/3, we want the new data
003b9f 01fe        movw z, y
003ba0 17e2        cp zl, temp2
003ba1 07f3        cpc zh, temp3
003ba2 f011        breq pageload_newdata
003ba3 010a          movw r0, temp6
003ba4 c002          rjmp pageload_cont
                 pageload_newdata:
003ba5 017a          movw temp4, temp6
003ba6 010c          movw r0, tosl
                 pageload_cont:
003ba7 2700        clr temp0
003ba8 d004        rcall dospm
003ba9 9621        adiw y, 1
003baa 9711        sbiw x, 1
003bab f771        brne pageload_loop
                 
                 pageload_done:
003bac 9508        ret
                 
                 
                 ;; dospm
                 ;;
                 ;; execute spm instruction
                 ;;   temp0 holds the value for SPMCR
                 
                 dospm:
                 dospm_wait_ee:
003bad 99f9        sbic EECR, EEPE
003bae cffe        rjmp dospm_wait_ee
                 dospm_wait_spm:
003baf b717        in_  temp1, SPMCSR
003bb0 fd10        sbrc temp1, SPMEN
003bb1 cffd        rjmp dospm_wait_spm
                 
                   ; turn the word addres into a byte address
003bb2 0fee
003bb3 1fff        writeflashcell
                   ; execute spm
003bb4 6001        ori temp0, (1<<SPMEN)
003bb5 bf07        out_ SPMCSR,temp0
003bb6 95e8        spm
003bb7 9508        ret
                 .endif
                 .include "words/fetch-i.asm"
                 
                 ; Memory
                 ; read 1 cell from flash
                 VE_FETCHI:
003bb8 ff02          .dw $ff02
003bb9 6940          .db "@i"
003bba 3b66          .dw VE_HEAD
                     .set VE_HEAD = VE_FETCHI
                 XT_FETCHI:
003bbb 3bbc          .dw PFA_FETCHI
                 PFA_FETCHI:
003bbc 01fc          movw zl, tosl
003bbd 0fee
003bbe 1fff
003bbf 9185
003bc0 9195          readflashcell tosl,tosh
003bc1 cc43          jmp_ DO_NEXT
                 
                 .if AMFORTH_NRWW_SIZE>8000
                 .elif AMFORTH_NRWW_SIZE>4000
                 .include "dict/core_4k.inc"
                 
                 ; in a short distance to DO_NEXT
                 .include "words/n_to_r.asm"
                 
                 ; Stack
                 ; move n items from data stack to return stack
                 VE_N_TO_R:
003bc2 ff03          .dw $ff03
003bc3 3e6e
003bc4 0072          .db "n>r",0
003bc5 3bb8          .dw VE_HEAD
                     .set VE_HEAD = VE_N_TO_R
                 XT_N_TO_R:
003bc6 3bc7          .dw PFA_N_TO_R
                 PFA_N_TO_R:
003bc7 01fc          movw zl, tosl
003bc8 2f08          mov  temp0, tosl
                 PFA_N_TO_R1:
003bc9 9189
003bca 9199          loadtos
003bcb 939f          push tosh
003bcc 938f          push tosl
003bcd 950a          dec temp0
003bce f7d1          brne PFA_N_TO_R1
003bcf 93ef          push zl
003bd0 93ff          push zh
003bd1 9189
003bd2 9199          loadtos
003bd3 cc31          jmp_ DO_NEXT
                 .include "words/n_r_from.asm"
                 
                 ; Stack
                 ; move n items from return stack to data stack
                 VE_N_R_FROM:
003bd4 ff03          .dw $ff03
003bd5 726e
003bd6 003e          .db "nr>",0
003bd7 3bc2          .dw VE_HEAD
                     .set VE_HEAD = VE_N_R_FROM
                 XT_N_R_FROM:
003bd8 3bd9          .dw PFA_N_R_FROM
                 PFA_N_R_FROM:
003bd9 939a
003bda 938a          savetos
003bdb 91ff          pop zh
003bdc 91ef          pop zl
003bdd 2f0e          mov  temp0, zl
                 PFA_N_R_FROM1:
003bde 918f          pop tosl
003bdf 919f          pop tosh
003be0 939a
003be1 938a          savetos
003be2 950a          dec temp0
003be3 f7d1          brne PFA_N_R_FROM1
003be4 01cf          movw tosl, zl
003be5 cc1f          jmp_ DO_NEXT
                 .include "words/d-2star.asm"
                 
                 ; Arithmetics
                 ; shift a double cell left
                 VE_D2STAR:
003be6 ff03          .dw $ff03
003be7 3264
003be8 002a          .db "d2*",0
003be9 3bd4          .dw VE_HEAD
                     .set VE_HEAD = VE_D2STAR
                 XT_D2STAR:
003bea 3beb          .dw PFA_D2STAR
                 PFA_D2STAR:
003beb 9109          ld temp0, Y+
003bec 9119          ld temp1, Y+
003bed 0f00          lsl temp0
003bee 1f11          rol temp1
003bef 1f88          rol tosl
003bf0 1f99          rol tosh
003bf1 931a          st -Y, temp1
003bf2 930a          st -Y, temp0
003bf3 cc11          jmp_ DO_NEXT
                 .include "words/d-2slash.asm"
                 
                 ; Arithmetics
                 ; shift a double cell value right
                 VE_D2SLASH:
003bf4 ff03          .dw $ff03
003bf5 3264
003bf6 002f          .db "d2/",0
003bf7 3be6          .dw VE_HEAD
                     .set VE_HEAD = VE_D2SLASH
                 XT_D2SLASH:
003bf8 3bf9          .dw PFA_D2SLASH
                 PFA_D2SLASH:
003bf9 9109          ld temp0, Y+
003bfa 9119          ld temp1, Y+
003bfb 9595          asr tosh
003bfc 9587          ror tosl
003bfd 9517          ror temp1
003bfe 9507          ror temp0
003bff 931a          st -Y, temp1
003c00 930a          st -Y, temp0
003c01 cc03          jmp_ DO_NEXT
                 .include "words/d-plus.asm"
                 
                 ; Arithmetics
                 ; add 2 double cell values
                 VE_DPLUS:
003c02 ff02          .dw $ff02
003c03 2b64          .db "d+"
003c04 3bf4          .dw VE_HEAD
                     .set VE_HEAD = VE_DPLUS
                 XT_DPLUS:
003c05 3c06          .dw PFA_DPLUS
                 PFA_DPLUS:
003c06 9129          ld temp2, Y+
003c07 9139          ld temp3, Y+
                 
003c08 90e9          ld temp4, Y+
003c09 90f9          ld temp5, Y+
003c0a 9149          ld temp6, Y+
003c0b 9159          ld temp7, Y+
                 
003c0c 0f24          add temp2, temp6
003c0d 1f35          adc temp3, temp7
003c0e 1d8e          adc tosl, temp4
003c0f 1d9f          adc tosh, temp5
                     
003c10 933a          st -Y, temp3
003c11 932a          st -Y, temp2
003c12 cbf2          jmp_ DO_NEXT
                 .include "words/d-minus.asm"
                 
                 ; Arithmetics
                 ; subtract d2 from d1 
                 VE_DMINUS:
003c13 ff02          .dw $ff02
003c14 2d64          .db "d-"
003c15 3c02          .dw VE_HEAD
                     .set VE_HEAD = VE_DMINUS
                 XT_DMINUS:
003c16 3c17          .dw PFA_DMINUS
                 PFA_DMINUS:
003c17 9129          ld temp2, Y+
003c18 9139          ld temp3, Y+
                 
003c19 90e9          ld temp4, Y+
003c1a 90f9          ld temp5, Y+
003c1b 9149          ld temp6, Y+
003c1c 9159          ld temp7, Y+
                 
003c1d 1b42          sub temp6, temp2
003c1e 0b53          sbc temp7, temp3
003c1f 0ae8          sbc temp4, tosl
003c20 0af9          sbc temp5, tosh
                 
003c21 935a          st -Y, temp7
003c22 934a          st -Y, temp6
003c23 01c7          movw tosl, temp4
003c24 cbe0          jmp_ DO_NEXT
                 .include "words/d-invert.asm"
                 
                 ; Arithmetics
                 ; invert all bits in the double cell value
                 VE_DINVERT:
003c25 ff07          .dw $ff07
003c26 6964
003c27 766e
003c28 7265
003c29 0074          .db "dinvert",0
003c2a 3c13          .dw VE_HEAD
                     .set VE_HEAD = VE_DINVERT
                 XT_DINVERT:
003c2b 3c2c          .dw PFA_DINVERT
                 PFA_DINVERT:
003c2c 9109          ld temp0, Y+
003c2d 9119          ld temp1, Y+
003c2e 9580          com tosl
003c2f 9590          com tosh
003c30 9500          com temp0
003c31 9510          com temp1
003c32 931a          st -Y, temp1
003c33 930a          st -Y, temp0
003c34 cbd0          jmp_ DO_NEXT
                 .include "words/slashmod.asm"
                 
                 ; Arithmetics
                 ; signed division n1/n2 with remainder and quotient
                 VE_SLASHMOD:
003c35 ff04          .dw $ff04
003c36 6d2f
003c37 646f          .db "/mod"
003c38 3c25          .dw VE_HEAD
                     .set VE_HEAD = VE_SLASHMOD
                 XT_SLASHMOD:
003c39 3c3a          .dw PFA_SLASHMOD
                 PFA_SLASHMOD:
003c3a 019c          movw temp2, tosl
                     
003c3b 9109          ld temp0, Y+
003c3c 9119          ld temp1, Y+
                 
003c3d 2f41          mov	temp6,temp1	;move dividend High to sign register
003c3e 2743          eor	temp6,temp3	;xor divisor High with sign register
003c3f ff17          sbrs	temp1,7	;if MSB in dividend set
003c40 c004          rjmp	PFA_SLASHMOD_1
003c41 9510          com	temp1		;    change sign of dividend
003c42 9500          com	temp0		
003c43 5f0f          subi	temp0,low(-1)
003c44 4f1f          sbci	temp1,high(-1)
                 PFA_SLASHMOD_1:	
003c45 ff37          sbrs	temp3,7	;if MSB in divisor set
003c46 c004          rjmp	PFA_SLASHMOD_2
003c47 9530          com	temp3		;    change sign of divisor
003c48 9520          com	temp2		
003c49 5f2f          subi	temp2,low(-1)
003c4a 4f3f          sbci	temp3,high(-1)
003c4b 24ee      PFA_SLASHMOD_2:	clr	temp4	;clear remainder Low byte
003c4c 18ff          sub	temp5,temp5;clear remainder High byte and carry
003c4d e151          ldi	temp7,17	;init loop counter
                 
003c4e 1f00      PFA_SLASHMOD_3:	rol	temp0		;shift left dividend
003c4f 1f11          rol	temp1
003c50 955a          dec	temp7		;decrement counter
003c51 f439          brne	PFA_SLASHMOD_5		;if done
003c52 ff47          sbrs	temp6,7		;    if MSB in sign register set
003c53 c004          rjmp	PFA_SLASHMOD_4
003c54 9510          com	temp1	;        change sign of result
003c55 9500          com	temp0
003c56 5f0f          subi	temp0,low(-1)
003c57 4f1f          sbci	temp1,high(-1)
003c58 c00b      PFA_SLASHMOD_4:	rjmp PFA_SLASHMODmod_done			;    return
003c59 1cee      PFA_SLASHMOD_5:	rol	temp4	;shift dividend into remainder
003c5a 1cff          rol	temp5
003c5b 1ae2          sub	temp4,temp2	;remainder = remainder - divisor
003c5c 0af3          sbc	temp5,temp3	;
003c5d f420          brcc	PFA_SLASHMOD_6		;if result negative
003c5e 0ee2          add	temp4,temp2	;    restore remainder
003c5f 1ef3          adc	temp5,temp3
003c60 9488          clc			;    clear carry to be shifted into result
003c61 cfec          rjmp	PFA_SLASHMOD_3		;else
003c62 9408      PFA_SLASHMOD_6:	sec			;    set carry to be shifted into result
003c63 cfea          rjmp	PFA_SLASHMOD_3
                 
                 PFA_SLASHMODmod_done:
                     ; put remainder on stack
003c64 92fa          st -Y,temp5
003c65 92ea          st -Y,temp4
                 
                     ; put quotient on stack
003c66 01c8          movw tosl, temp0
003c67 cb9d          jmp_ DO_NEXT
                 .include "words/abs.asm"
                 
                 ; Arithmetics
                 ; get the absolute value
                 VE_ABS:
003c68 ff03          .dw $ff03
003c69 6261
003c6a 0073          .db "abs",0
003c6b 3c35          .dw VE_HEAD
                     .set VE_HEAD = VE_ABS
                 XT_ABS:
003c6c 3c6d          .dw PFA_ABS
                 PFA_ABS:
003c6d 2399          tst tosh
003c6e f41a          brpl PFA_ABS1
003c6f 9580          com tosl
003c70 9590          com tosh
003c71 9601          adiw tosl, 1
                 PFA_ABS1:
003c72 cb92          jmp_ do_next
                 .include "words/pick.asm"
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_PICK:
003c73 ff04          .dw $ff04
003c74 6970
003c75 6b63          .db "pick"
003c76 3c68          .dw VE_HEAD
                     .set VE_HEAD = VE_PICK
                 XT_PICK:
003c77 3801          .dw DO_COLON
                 PFA_PICK:
                 .endif
003c78 3a2a          .dw XT_1PLUS
003c79 3eae          .dw XT_CELLS
003c7a 3a7c          .dw XT_SP_FETCH
003c7b 3998          .dw XT_PLUS
003c7c 3874          .dw XT_FETCH
003c7d 381b          .dw XT_EXIT
                 .include "words/cellplus.asm"
                 
                 ; Arithmetics
                 ; add the size of an address-unit to a-addr1
                 VE_CELLPLUS:
003c7e ff05          .dw $ff05
003c7f 6563
003c80 6c6c
003c81 002b          .db "cell+",0
003c82 3c73          .dw VE_HEAD
                     .set VE_HEAD = VE_CELLPLUS
                 XT_CELLPLUS:
003c83 3c84          .dw PFA_CELLPLUS
                 PFA_CELLPLUS:
003c84 9602          adiw tosl, CELLSIZE
003c85 cb7f          jmp_ DO_NEXT
                 .include "dict/interrupt.inc"
                 
                 .include "words/int-on.asm"
                 
                 ; Interrupt
                 ; turns on all interrupts
                 VE_INTON:
003c86 ff04          .dw $ff04
003c87 692b
003c88 746e          .db "+int"
003c89 3c7e          .dw VE_HEAD
                     .set VE_HEAD = VE_INTON
                 XT_INTON:
003c8a 3c8b          .dw PFA_INTON
                 PFA_INTON:
003c8b 9478          sei
003c8c cb78          jmp_ DO_NEXT
                 .include "words/int-off.asm"
                 
                 ; Interrupt
                 ; turns off all interrupts 
                 VE_INTOFF:
003c8d ff04          .dw $ff04
003c8e 692d
003c8f 746e          .db "-int"
003c90 3c86          .dw VE_HEAD
                     .set VE_HEAD = VE_INTOFF
                 XT_INTOFF:
003c91 3c92          .dw PFA_INTOFF
                 PFA_INTOFF:
003c92 94f8          cli
003c93 cb71          jmp_ DO_NEXT
                 .include "words/int-store.asm"
                 
                 ; Interrupt
                 ; stores XT as interrupt vector i
                 VE_INTSTORE:
003c94 ff04          .dw $ff04
003c95 6e69
003c96 2174          .db "int!"
003c97 3c8d          .dw VE_HEAD
                     .set VE_HEAD = VE_INTSTORE
                 XT_INTSTORE:
003c98 3801          .dw DO_COLON
                 PFA_INTSTORE:
003c99 3838          .dw XT_DOLITERAL
003c9a 0000          .dw intvec
003c9b 3998          .dw XT_PLUS
003c9c 3b2a          .dw XT_STOREE
003c9d 381b          .dw XT_EXIT
                 .include "words/int-fetch.asm"
                 
                 ; Interrupt
                 ; fetches XT from interrupt vector i
                 VE_INTFETCH:
003c9e ff04          .dw $ff04
003c9f 6e69
003ca0 4074          .db "int@"
003ca1 3c94          .dw VE_HEAD
                     .set VE_HEAD = VE_INTFETCH
                 XT_INTFETCH:
003ca2 3801          .dw DO_COLON
                 PFA_INTFETCH:
003ca3 3838          .dw XT_DOLITERAL
003ca4 0000          .dw intvec
003ca5 3998          .dw XT_PLUS
003ca6 3b4e          .dw XT_FETCHE
003ca7 381b          .dw XT_EXIT
                 .include "words/int-trap.asm"
                 
                 ; Interrupt
                 ; trigger an interrupt
                 VE_INTTRAP:
003ca8 ff08          .dw $ff08
003ca9 6e69
003caa 2d74
003cab 7274
003cac 7061          .db "int-trap"
003cad 3c9e          .dw VE_HEAD
                     .set VE_HEAD = VE_INTTRAP
                 XT_INTTRAP:
003cae 3caf          .dw PFA_INTTRAP
                 PFA_INTTRAP:
003caf 9380 0116     sts intcur, tosl
003cb1 9189
003cb2 9199          loadtos
003cb3 9468          set ; set the interrupt flag for the inner interpreter
003cb4 cb50          jmp_ DO_NEXT
                 
                 .include "words/isr-exec.asm"
                 
                 ; Interrupt
                 ; executes an interrupt service routine
                 ;VE_ISREXEC:
                 ;    .dw $ff08
                 ;    .db "isr-exec"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_ISREXEC
                 XT_ISREXEC:
003cb5 3801          .dw DO_COLON
                 PFA_ISREXEC:
003cb6 3838          .dw XT_DOLITERAL
003cb7 0116          .dw intcur
003cb8 3893          .dw XT_CFETCH
003cb9 3838          .dw XT_DOLITERAL
003cba 0000          .dw intvec
003cbb 3998          .dw XT_PLUS
003cbc 3b4e          .dw XT_FETCHE
003cbd 3825          .dw XT_EXECUTE
003cbe 3cc0          .dw XT_ISREND
003cbf 381b          .dw XT_EXIT
                 .include "words/isr-end.asm"
                 
                 ; Interrupt
                 ; re-enables interrupts in an ISR
                 ;VE_ISREND:
                 ;    .dw $ff07
                 ;    .db "isr-end",0
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_ISREND
                 XT_ISREND:
003cc0 3cc1          .dw PFA_ISREND
                 PFA_ISREND:
003cc1 d001          rcall PFA_ISREND1 ; clear the interrupt flag for the controller
003cc2 cb42          jmp_ DO_NEXT
                 PFA_ISREND1:
003cc3 9518          reti
                 
                 ; now the relocatable colon words
                 .include "words/prompt-ok.asm"
                 
                 ; System
                 ; send the READY prompt to the command line
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 ;VE_PROMPTOK:
                 ;    .dw $ff02
                 ;    .db "ok"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_PROMPTOK
                 XT_PROMPTOK:
003cc4 3801          .dw DO_COLON
                 PFA_PROMPTOK:
003cc5 03d4          .dw XT_DOSLITERAL
003cc6 0003          .dw 3
003cc7 6f20
003cc8 006b          .db " ok",0
                 .endif
003cc9 0407          .dw XT_ITYPE
003cca 381b          .dw XT_EXIT
                 .include "words/prompt-ready.asm"
                 
                 ; System
                 ; process the error prompt
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 ;VE_PROMPTRDY:
                 ;    .dw $ff04
                 ;    .db "p_er"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_PROMPTRDY
                 XT_PROMPTREADY:
003ccb 3801          .dw DO_COLON
                 PFA_PROMPTREADY:
003ccc 03d4          .dw XT_DOSLITERAL
003ccd 0002          .dw 2
003cce 203e          .db "> "
                 .endif
003ccf 3f92          .dw XT_CR
003cd0 0407          .dw XT_ITYPE
003cd1 381b          .dw XT_EXIT
                 .include "words/prompt-error.asm"
                 
                 ; System
                 ; process the error prompt
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 ;VE_PROMPTERROR:
                 ;    .dw $ff04
                 ;    .db "p_er"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_PROMPTERROR
                 XT_PROMPTERROR:
003cd2 3801          .dw DO_COLON
                 PFA_PROMPTERROR:
003cd3 03d4      	.dw XT_DOSLITERAL
003cd4 0004          .dw 4
003cd5 3f20
003cd6 203f          .db " ?? "
                 .endif
003cd7 0407          .dw XT_ITYPE
003cd8 3ea7          .dw XT_BASE
003cd9 3874          .dw XT_FETCH
003cda 38fa          .dw XT_TO_R
003cdb 3f32          .dw XT_DECIMAL
003cdc 0389          .dw XT_DOT
003cdd 3ecc          .dw XT_TO_IN
003cde 3874          .dw XT_FETCH
003cdf 0389          .dw XT_DOT
003ce0 38f1          .dw XT_R_FROM
003ce1 3ea7          .dw XT_BASE
003ce2 387c          .dw XT_STORE
003ce3 381b          .dw XT_EXIT
                 
                 .include "words/quit.asm"
                 
                 ; System
                 ; main loop of amforth. accept - interpret in an endless loop
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_QUIT:
003ce4 ff04          .dw $ff04
003ce5 7571
003ce6 7469          .db "quit"
003ce7 3ca8          .dw VE_HEAD
                     .set VE_HEAD = VE_QUIT
                 XT_QUIT:
003ce8 3801          .dw DO_COLON
                 PFA_QUIT:
                 .endif
                 PFA_QUIT1:
003ce9 0857
003cea 085e
003ceb 387c          .dw XT_LP0,XT_LP,XT_STORE
003cec 05d2          .dw XT_SP0
003ced 3a85          .dw XT_SP_STORE
003cee 05df          .dw XT_RP0
003cef 3a6f          .dw XT_RP_STORE
003cf0 08f9          .dw XT_LBRACKET
                 
                 PFA_QUIT2:
003cf1 3ea1          .dw XT_STATE
003cf2 3874          .dw XT_FETCH
003cf3 3915          .dw XT_ZEROEQUAL
003cf4 3831          .dw XT_DOCONDBRANCH
003cf5 3cf7          DEST(PFA_QUIT4)
003cf6 3ccb          .dw XT_PROMPTREADY
                 PFA_QUIT4:
003cf7 04df          .dw XT_REFILL
003cf8 3831          .dw XT_DOCONDBRANCH
003cf9 3cf1          DEST(PFA_QUIT2)
003cfa 3838          .dw XT_DOLITERAL
003cfb 0622          .dw XT_INTERPRET
003cfc 3d52          .dw XT_CATCH
003cfd 38b4          .dw XT_QDUP
003cfe 3831          .dw XT_DOCONDBRANCH
003cff 3d09          DEST(PFA_QUIT3)
003d00 38ac      	.dw XT_DUP
003d01 3838      	.dw XT_DOLITERAL
003d02 fffe      	.dw -2
003d03 3969      	.dw XT_LESS
003d04 3831      	.dw XT_DOCONDBRANCH
003d05 3d07      	DEST(PFA_QUIT5)
003d06 3cd2      	.dw XT_PROMPTERROR
                 PFA_QUIT5:
003d07 382a      	.dw XT_DOBRANCH
003d08 3ce9      	DEST(PFA_QUIT1)
                 PFA_QUIT3:
003d09 3cc4          .dw XT_PROMPTOK
003d0a 382a          .dw XT_DOBRANCH
003d0b 3cf1          DEST(PFA_QUIT2)
003d0c 381b          .dw XT_EXIT ; never reached
                 
                 .include "words/pause.asm"
                 
                 ; Multitasking
                 ; Fetch pause vector and execute it. may make a context/task switch
                 VE_PAUSE:
003d0d ff05          .dw $ff05
003d0e 6170
003d0f 7375
003d10 0065          .db "pause",0
003d11 3ce4          .dw VE_HEAD
                     .set VE_HEAD = VE_PAUSE
                 XT_PAUSE:
003d12 3de1          .dw PFA_DODEFER1
                 PFA_PAUSE:
003d13 017b          .dw ram_pause
003d14 3d96          .dw XT_RDEFERFETCH
003d15 3da0          .dw XT_RDEFERSTORE
                 
                 .dseg
00017b           ram_pause: .byte 2
                 .cseg
                 .include "words/cold.asm"
                 
                 ; System
                 ; start up amforth.
                 VE_COLD:
003d16 ff04          .dw $ff04
003d17 6f63
003d18 646c          .db "cold"
003d19 3d0d          .dw VE_HEAD
                     .set VE_HEAD = VE_COLD
                 XT_COLD:
003d1a 3d1b          .dw PFA_COLD
                 PFA_COLD:
003d1b b6a4          in_ mcu_boot, MCUSR
003d1c 2422          clr zerol
003d1d 2433          clr zeroh
003d1e be24          out_ MCUSR, zerol
                     ; clear RAM
003d1f e0e0          ldi zl, low(ramstart)
003d20 e0f1          ldi zh, high(ramstart)
                 clearloop:
003d21 9221          st Z+, zerol
003d22 30e0          cpi zl, low(sram_size+ramstart)
003d23 f7e9          brne clearloop
003d24 30f9          cpi zh, high(sram_size+ramstart)
003d25 f7d9          brne clearloop
                     ; init first user data area
                     ; allocate space for User Area
                 .dseg
00017d           ram_user1: .byte SYSUSERSIZE + APPUSERSIZE
                 .cseg
003d26 e7ed          ldi zl, low(ram_user1)
003d27 e0f1          ldi zh, high(ram_user1)
003d28 012f          movw upl, zl
                     ; init return stack pointer
003d29 ef0f          ldi temp0,low(rstackstart)
003d2a bf0d          out_ SPL,temp0
003d2b 8304          std Z+4, temp0
003d2c e018          ldi temp1,high(rstackstart)
003d2d bf1e          out_ SPH,temp1
003d2e 8315          std Z+5, temp1
                 
                     ; init parameter stack pointer
003d2f eacf          ldi yl,low(stackstart)
003d30 83c6          std Z+6, yl
003d31 e0d8          ldi yh,high(stackstart)
003d32 83d7          std Z+7, yh
                 
                     ; load Forth IP with starting word
003d33 e3ab          ldi XL, low(PFA_WARM)
003d34 e3bd          ldi XH, high(PFA_WARM)
                     ; its a far jump...
003d35 cacf          jmp_ DO_NEXT
                 .include "words/warm.asm"
                 
                 ; System
                 ; initialize amforth further. executes turnkey operation and go to quit
                 VE_WARM:
003d36 ff04          .dw $ff04
003d37 6177
003d38 6d72          .db "warm"
003d39 3d16          .dw VE_HEAD
                     .set VE_HEAD = VE_WARM
                 XT_WARM:
003d3a 3801          .dw DO_COLON
                 PFA_WARM:
003d3b 02a6          .dw XT_INITUSER
003d3c 3838          .dw XT_DOLITERAL
003d3d 01ac          .dw XT_NOOP
003d3e 3838          .dw XT_DOLITERAL
003d3f 3d12          .dw XT_PAUSE
003d40 3dc1          .dw XT_DEFERSTORE
003d41 08f9          .dw XT_LBRACKET
003d42 3f4d          .dw XT_TURNKEY
003d43 3ce8          .dw XT_QUIT
003d44 381b          .dw XT_EXIT
                 
                 .include "words/handler.asm"
                 
                 ; Exceptions
                 ; USER variable used by catch/throw
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_HANDLER:
003d45 ff07          .dw $ff07
003d46 6168
003d47 646e
003d48 656c
003d49 0072          .db "handler",0
003d4a 3d36          .dw VE_HEAD
                     .set VE_HEAD = VE_HANDLER
                 XT_HANDLER:
003d4b 3853          .dw PFA_DOUSER
                 PFA_HANDLER:
                 .endif
003d4c 000a          .dw USER_HANDLER
                 .include "words/catch.asm"
                 
                 ; Exceptions
                 ; execute XT and check for exceptions.
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_CATCH:
003d4d ff05          .dw $ff05
003d4e 6163
003d4f 6374
003d50 0068          .db "catch",0
003d51 3d45          .dw VE_HEAD
                     .set VE_HEAD = VE_CATCH
                 XT_CATCH:
003d52 3801          .dw DO_COLON
                 PFA_CATCH:
                 .endif
                 
                     ; sp@ >r
003d53 3a7c          .dw XT_SP_FETCH
003d54 38fa          .dw XT_TO_R
                     ; handler @ >r
003d55 3d4b          .dw XT_HANDLER
003d56 3874          .dw XT_FETCH
003d57 38fa          .dw XT_TO_R
                     ; rp@ handler !
003d58 3a65          .dw XT_RP_FETCH
003d59 3d4b          .dw XT_HANDLER
003d5a 387c          .dw XT_STORE
003d5b 3825          .dw XT_EXECUTE
                     ; r> handler !
003d5c 38f1          .dw XT_R_FROM
003d5d 3d4b          .dw XT_HANDLER
003d5e 387c          .dw XT_STORE
003d5f 38f1          .dw XT_R_FROM
003d60 38d4          .dw XT_DROP
003d61 394f          .dw XT_ZERO
003d62 381b          .dw XT_EXIT
                 .include "words/throw.asm"
                 
                 ; Exceptions
                 ; throw an exception
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_THROW:
003d63 ff05          .dw $ff05
003d64 6874
003d65 6f72
003d66 0077          .db "throw",0
003d67 3d4d          .dw VE_HEAD
                     .set VE_HEAD = VE_THROW
                 XT_THROW:
003d68 3801          .dw DO_COLON
                 PFA_THROW:
                 .endif
003d69 38ac          .dw XT_DUP
003d6a 3915          .dw XT_ZEROEQUAL
003d6b 3831          .dw XT_DOCONDBRANCH
003d6c 3d6f          DEST(PFA_THROW1)
003d6d 38d4      	.dw XT_DROP
003d6e 381b      	.dw XT_EXIT
                 PFA_THROW1:
003d6f 3d4b          .dw XT_HANDLER
003d70 3874          .dw XT_FETCH
003d71 3a6f          .dw XT_RP_STORE
003d72 38f1          .dw XT_R_FROM
003d73 3d4b          .dw XT_HANDLER
003d74 387c          .dw XT_STORE
003d75 38f1          .dw XT_R_FROM
003d76 38bf          .dw XT_SWAP
003d77 38fa          .dw XT_TO_R
003d78 3a85          .dw XT_SP_STORE
003d79 38d4          .dw XT_DROP
003d7a 38f1          .dw XT_R_FROM    
003d7b 381b          .dw XT_EXIT
                 
                 
                 
                 .include "words/edefer-fetch.asm"
                 
                 ; System
                 ; does the real defer@ for eeprom defers
                 VE_EDEFERFETCH:
003d7c ff07          .dw $ff07
003d7d 6445
003d7e 6665
003d7f 7265
003d80 0040          .db "Edefer@",0
003d81 3d63          .dw VE_HEAD
                     .set VE_HEAD = VE_EDEFERFETCH
                 XT_EDEFERFETCH:
003d82 3801          .dw DO_COLON
                 PFA_EDEFERFETCH:
003d83 3bbb          .dw XT_FETCHI
003d84 3b4e          .dw XT_FETCHE
003d85 381b          .dw XT_EXIT
                 .include "words/edefer-store.asm"
                 
                 ; System
                 ; does the real defer! for eeprom defers
                 VE_EDEFERSTORE:
003d86 ff07          .dw $ff07
003d87 6445
003d88 6665
003d89 7265
003d8a 0021          .db "Edefer!",0
003d8b 3d7c          .dw VE_HEAD
                     .set VE_HEAD = VE_EDEFERSTORE
                 XT_EDEFERSTORE:
003d8c 3801          .dw DO_COLON
                 PFA_EDEFERSTORE:
003d8d 3bbb          .dw XT_FETCHI
003d8e 3b2a          .dw XT_STOREE
003d8f 381b          .dw XT_EXIT
                 .include "words/rdefer-fetch.asm"
                 
                 ; System
                 ; The defer@ for ram defers
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_RDEFERFETCH:
003d90 ff07          .dw $ff07
003d91 6452
003d92 6665
003d93 7265
003d94 0040          .db "Rdefer@",0
003d95 3d86          .dw VE_HEAD
                     .set VE_HEAD = VE_RDEFERFETCH
                 XT_RDEFERFETCH:
003d96 3801          .dw DO_COLON
                 PFA_RDEFERFETCH:
                 .endif
003d97 3bbb          .dw XT_FETCHI
003d98 3874          .dw XT_FETCH
003d99 381b          .dw XT_EXIT
                 .include "words/rdefer-store.asm"
                 
                 ; System
                 ; The defer! for ram defers
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_RDEFERSTORE:
003d9a ff07          .dw $ff07
003d9b 6452
003d9c 6665
003d9d 7265
003d9e 0021          .db "Rdefer!",0
003d9f 3d90          .dw VE_HEAD
                     .set VE_HEAD = VE_RDEFERSTORE
                 XT_RDEFERSTORE:
003da0 3801          .dw DO_COLON
                 PFA_RDEFERSTORE:
                 .endif
003da1 3bbb          .dw XT_FETCHI
003da2 387c          .dw XT_STORE
003da3 381b          .dw XT_EXIT
                 
                 .include "words/udefer-fetch.asm"
                 
                 ; System
                 ; does the real defer@ for user based defers
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_UDEFERFETCH:
003da4 ff07          .dw $ff07
003da5 6455
003da6 6665
003da7 7265
003da8 0040          .db "Udefer@",0
003da9 3d9a          .dw VE_HEAD
                     .set VE_HEAD = VE_UDEFERFETCH
                 XT_UDEFERFETCH:
003daa 3801          .dw DO_COLON
                 PFA_UDEFERFETCH:
                 .endif
003dab 3bbb          .dw XT_FETCHI
003dac 3af1          .dw XT_UP_FETCH
003dad 3998          .dw XT_PLUS
003dae 3874          .dw XT_FETCH
003daf 381b          .dw XT_EXIT
                 .include "words/udefer-store.asm"
                 
                 ; System
                 ; does the real defer! for user based defers
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_UDEFERSTORE:
003db0 ff07          .dw $ff07
003db1 6455
003db2 6665
003db3 7265
003db4 0021          .db "Udefer!",0
003db5 3da4          .dw VE_HEAD
                     .set VE_HEAD = VE_UDEFERSTORE
                 XT_UDEFERSTORE:
003db6 3801          .dw DO_COLON
                 PFA_UDEFERSTORE:
                 .endif
                 
003db7 3bbb          .dw XT_FETCHI
003db8 3af1          .dw XT_UP_FETCH
003db9 3998          .dw XT_PLUS
003dba 387c          .dw XT_STORE
003dbb 381b          .dw XT_EXIT
                 
                 .include "words/defer-store.asm"
                 
                 ; System
                 ; stores xt1 as the xt to be executed when xt2 is called
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DEFERSTORE:
003dbc ff06          .dw $ff06
003dbd 6564
003dbe 6566
003dbf 2172          .db "defer!"
003dc0 3db0          .dw VE_HEAD
                     .set VE_HEAD = VE_DEFERSTORE
                 XT_DEFERSTORE:
003dc1 3801          .dw DO_COLON
                 PFA_DEFERSTORE:
                 .endif
003dc2 3fc1          .dw XT_TO_BODY
003dc3 38ac          .dw XT_DUP
003dc4 01d9          .dw XT_ICELLPLUS
003dc5 01d9          .dw XT_ICELLPLUS
003dc6 3bbb          .dw XT_FETCHI
003dc7 3825          .dw XT_EXECUTE
003dc8 381b          .dw XT_EXIT
                 
                 .include "words/defer-fetch.asm"
                 
                 ; System
                 ; returns the XT associated with the given XT
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DEFERFETCH:
003dc9 ff06          .dw $ff06
003dca 6564
003dcb 6566
003dcc 4072          .db "defer@"
003dcd 3dbc          .dw VE_HEAD
                     .set VE_HEAD = VE_DEFERFETCH
                 XT_DEFERFETCH:
003dce 3801          .dw DO_COLON
                 PFA_DEFERFETCH:
                 .endif
003dcf 3fc1          .dw XT_TO_BODY 
003dd0 38ac          .dw XT_DUP
003dd1 01d9          .dw XT_ICELLPLUS
003dd2 3bbb          .dw XT_FETCHI
003dd3 3825          .dw XT_EXECUTE
003dd4 381b          .dw XT_EXIT
                 .include "words/do-defer.asm"
                 
                 ; System
                 ; runtime of defer
                 VE_DODEFER:
003dd5 ff07          .dw $ff07
003dd6 6428
003dd7 6665
003dd8 7265
003dd9 0029          .db "(defer)", 0
003dda 3dc9          .dw VE_HEAD
                     .set VE_HEAD = VE_DODEFER
                 XT_DODEFER:
003ddb 3801          .dw DO_COLON
                 PFA_DODEFER:
003ddc 0730          .dw XT_DOCREATE
003ddd 0894          .dw XT_REVEAL
003dde 0756          .dw XT_COMPILE
003ddf 3de1          .dw PFA_DODEFER1
003de0 381b          .dw XT_EXIT
                 PFA_DODEFER1:
003de1 940e 08b8     call_ DO_DODOES
003de3 38ac          .dw XT_DUP
003de4 01d9          .dw XT_ICELLPLUS
003de5 3bbb          .dw XT_FETCHI
003de6 3825          .dw XT_EXECUTE 
003de7 3825          .dw XT_EXECUTE
003de8 381b          .dw XT_EXIT
                 
                 ; : (defer) <builds does> dup i-cell+ @i execute execute ;
                 
                 
                 .include "words/d-equal.asm"
                 
                 ; Compare
                 ; compares two double cell values
                 VE_DEQUAL:
003de9 ff02          .dw $ff02
003dea 3d64          .db "d="
003deb 3dd5          .dw VE_HEAD
                     .set VE_HEAD = VE_DEQUAL
                 XT_DEQUAL:
003dec 3801          .dw DO_COLON
                 PFA_DEQUAL:
003ded 3c16          .dw XT_DMINUS
003dee 3a17          .dw XT_OR
003def 3915          .dw XT_ZEROEQUAL
003df0 381b          .dw XT_EXIT
                 .include "words/u-dot.asm"
                 
                 ; Numeric IO
                 ; unsigned PNO with single cell numbers
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_UDOT:
003df1 ff02          .dw $ff02
003df2 2e75          .db "u."
003df3 3de9          .dw VE_HEAD
                     .set VE_HEAD = VE_UDOT
                 XT_UDOT:
003df4 3801          .dw DO_COLON
                 PFA_UDOT:
                 .endif
003df5 394f          .dw XT_ZERO
003df6 0391          .dw XT_UDDOT
003df7 381b          .dw XT_EXIT
                 ; : u.        ( us -- )    0 ud. ;
                 .include "words/u-dot-r.asm"
                 
                 ; Numeric IO
                 ; unsigned PNO with single cells numbers, right aligned in width w
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 
                 VE_UDOTR:
003df8 ff03          .dw $ff03
003df9 2e75
003dfa 0072          .db "u.r",0
003dfb 3df1          .dw VE_HEAD
                     .set VE_HEAD = VE_UDOTR
                 XT_UDOTR:
003dfc 3801          .dw DO_COLON
                 PFA_UDOTR:
                 .endif
003dfd 394f          .dw XT_ZERO
003dfe 38bf          .dw XT_SWAP
003dff 039a          .dw XT_UDDOTR
003e00 381b          .dw XT_EXIT
                 ; : u.r       ( s n -- )   0 swap ud.r ;
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/uslashmod.asm"
                 
                 ; Arithmetics
                 ; unsigned division with remainder
                 VE_USLASHMOD:
003e01 ff05          .dw $ff05
003e02 2f75
003e03 6f6d
003e04 0064          .db "u/mod",0
003e05 3df8          .dw VE_HEAD
                     .set VE_HEAD = VE_USLASHMOD
                 XT_USLASHMOD:
003e06 3801          .dw DO_COLON
                 PFA_USLASHMOD:
003e07 38fa          .dw XT_TO_R
003e08 394f          .dw XT_ZERO
003e09 38f1          .dw XT_R_FROM
003e0a 39bd          .dw XT_UMSLASHMOD
003e0b 381b          .dw XT_EXIT
                 .include "words/negate.asm"
                 
                 ; Logic
                 ; 2-complement
                 VE_NEGATE:
003e0c ff06          .dw $ff06
003e0d 656e
003e0e 6167
003e0f 6574          .db "negate"
003e10 3e01          .dw VE_HEAD
                     .set VE_HEAD = VE_NEGATE
                 XT_NEGATE:
003e11 3801          .dw DO_COLON
                 PFA_NEGATE:
003e12 39f8          .dw XT_INVERT
003e13 3a2a          .dw XT_1PLUS
003e14 381b          .dw XT_EXIT
                 .include "words/slash.asm"
                 
                 ; Arithmetics
                 ; divide n1 by n2. giving the quotient
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 
                 VE_SLASH:
003e15 ff01          .dw $ff01
003e16 002f          .db "/",0
003e17 3e0c          .dw VE_HEAD
                     .set VE_HEAD = VE_SLASH
                 XT_SLASH:
003e18 3801          .dw DO_COLON
                 PFA_SLASH:
                 .endif
003e19 3c39          .dw XT_SLASHMOD
003e1a 38eb          .dw XT_NIP
003e1b 381b          .dw XT_EXIT
                 
                 .include "words/mod.asm"
                 
                 ; Arithmetics
                 ; divide n1 by n2 giving the remainder n3
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 
                 VE_MOD:
003e1c ff03          .dw $ff03
003e1d 6f6d
003e1e 0064          .db "mod",0
003e1f 3e15          .dw VE_HEAD
                     .set VE_HEAD = VE_MOD
                 XT_MOD:
003e20 3801          .dw DO_COLON
                 PFA_MOD:
                 .endif
003e21 3c39          .dw XT_SLASHMOD
003e22 38d4          .dw XT_DROP
003e23 381b          .dw XT_EXIT
                 
                 .include "words/min.asm"
                 
                 ; Compare
                 ; compare two values leave the smaller one
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 
                 VE_MIN:
003e24 ff03          .dw $ff03
003e25 696d
003e26 006e          .db "min",0
003e27 3e1c          .dw VE_HEAD
                     .set VE_HEAD = VE_MIN
                 XT_MIN:
003e28 3801          .dw DO_COLON
                 PFA_MIN:
                 .endif
003e29 3eb3          .dw XT_2DUP
003e2a 3973          .dw XT_GREATER
003e2b 3831          .dw XT_DOCONDBRANCH
003e2c 3e2e          DEST(PFA_MIN1)
003e2d 38bf          .dw XT_SWAP
                 PFA_MIN1:
003e2e 38d4          .dw XT_DROP
003e2f 381b          .dw XT_EXIT
                 .include "words/max.asm"
                 
                 ; Compare
                 ; compare two values, leave the bigger one
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_MAX:
003e30 ff03          .dw $ff03
003e31 616d
003e32 0078          .db "max",0
003e33 3e24          .dw VE_HEAD
                     .set VE_HEAD = VE_MAX
                 XT_MAX:
003e34 3801          .dw DO_COLON
                 PFA_MAX:
                 
                 .endif
003e35 3eb3          .dw XT_2DUP
003e36 3969          .dw XT_LESS
003e37 3831          .dw XT_DOCONDBRANCH
003e38 3e3a          DEST(PFA_MAX1)
003e39 38bf          .dw XT_SWAP
                 PFA_MAX1:
003e3a 38d4          .dw XT_DROP
003e3b 381b          .dw XT_EXIT
                 .include "words/within.asm"
                 
                 ; Compare
                 ; check if n is within min..max
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_WITHIN:
003e3c ff06          .dw $ff06
003e3d 6977
003e3e 6874
003e3f 6e69          .db "within"
003e40 3e30          .dw VE_HEAD
                     .set VE_HEAD = VE_WITHIN
                 XT_WITHIN:
003e41 3801          .dw DO_COLON
                 PFA_WITHIN:
                 .endif
003e42 38ca          .dw XT_OVER
003e43 398e          .dw XT_MINUS
003e44 38fa          .dw XT_TO_R
003e45 398e          .dw XT_MINUS
003e46 38f1          .dw XT_R_FROM
003e47 3957          .dw XT_ULESS
003e48 381b          .dw XT_EXIT
                 
                 .include "words/show-wordlist.asm"
                 
                 ; Tools
                 ; prints the name of the words in a wordlist
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SHOWWORDLIST:
003e49 ff0d          .dw $ff0d
003e4a 6873
003e4b 776f
003e4c 772d
003e4d 726f
003e4e 6c64
003e4f 7369
003e50 0074          .db "show-wordlist",0
003e51 3e3c          .dw VE_HEAD
                     .set VE_HEAD = VE_SHOWWORDLIST
                 XT_SHOWWORDLIST:
003e52 3801          .dw DO_COLON
                 PFA_SHOWWORDLIST:
                 .endif
003e53 3838          .dw XT_DOLITERAL
003e54 3e58          .dw XT_SHOWWORD
003e55 38bf          .dw XT_SWAP
003e56 06de          .dw XT_TRAVERSEWORDLIST
003e57 381b          .dw XT_EXIT
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 XT_SHOWWORD:
003e58 3801          .dw DO_COLON
                 PFA_SHOWWORD:
                 .endif
003e59 06f9          .dw XT_NAME2STRING
003e5a 0407          .dw XT_ITYPE
003e5b 3f9f          .dw XT_SPACE         ; ( -- addr n)
003e5c 3946          .dw XT_TRUE
003e5d 381b          .dw XT_EXIT
                 .include "words/words.asm"
                 
                 ; Tools
                 ; prints a list of all (visible) words in the dictionary
                 VE_WORDS:
003e5e ff05          .dw $ff05
003e5f 6f77
003e60 6472
003e61 0073          .db "words",0
003e62 3e49          .dw VE_HEAD
                     .set VE_HEAD = VE_WORDS
                 XT_WORDS:
003e63 3801          .dw DO_COLON
                 PFA_WORDS:
003e64 3838          .dw XT_DOLITERAL
003e65 004a          .dw CFG_ORDERLIST
003e66 3b4e          .dw XT_FETCHE
003e67 3e52          .dw XT_SHOWWORDLIST
003e68 381b          .dw XT_EXIT
                 
                 .include "words/dot-quote.asm"
                 
                 ; Compiler
                 ; compiles string into dictionary to be printed at runtime
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 
                 VE_DOTSTRING:
003e69 0002          .dw $0002
003e6a 222e          .db ".",$22
003e6b 3e5e          .dw VE_HEAD
                     .set VE_HEAD = VE_DOTSTRING
                 XT_DOTSTRING:
003e6c 3801          .dw DO_COLON
                 PFA_DOTSTRING:
                 .endif
003e6d 3e74          .dw XT_SQUOTE
003e6e 0756          .dw XT_COMPILE
003e6f 0407          .dw XT_ITYPE
003e70 381b          .dw XT_EXIT
                 .include "words/squote.asm"
                 
                 ; Compiler
                 ; compiles a string to flash, at runtime leaves ( -- flash-addr count) on stack
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SQUOTE:
003e71 0002        .dw $0002
003e72 2273        .db "s",$22
003e73 3e69        .dw VE_HEAD
                   .set VE_HEAD = VE_SQUOTE
                 XT_SQUOTE:
003e74 3801          .dw DO_COLON
                 PFA_SQUOTE:
                 .endif
003e75 3838          .dw XT_DOLITERAL
003e76 0022          .dw 34   ; 0x22 
003e77 058a          .dw XT_PARSE       ; ( -- addr n)
003e78 3ea1          .dw XT_STATE
003e79 3874          .dw XT_FETCH
003e7a 3831          .dw XT_DOCONDBRANCH
003e7b 3e7d          DEST(PFA_SQUOTE1)
003e7c 0782            .dw XT_SLITERAL
                 PFA_SQUOTE1:
003e7d 381b          .dw XT_EXIT
                 .include "words/fill.asm"
                 
                 ; Memory
                 ; fill u bytes memory beginning at a-addr with character c
                 VE_FILL:
003e7e ff04          .dw $ff04
003e7f 6966
003e80 6c6c          .db "fill"
003e81 3e71          .dw VE_HEAD
                     .set VE_HEAD = VE_FILL
                 XT_FILL:
003e82 3801          .dw DO_COLON
                 PFA_FILL:
003e83 38dc          .dw XT_ROT
003e84 38dc          .dw XT_ROT
003e85 38b4
003e86 3831          .dw XT_QDUP,XT_DOCONDBRANCH
003e87 3e8f          DEST(PFA_FILL2)
003e88 3f8a          .dw XT_BOUNDS
003e89 3a8a          .dw XT_DODO
                 PFA_FILL1:
003e8a 38ac          .dw XT_DUP
003e8b 3a9b          .dw XT_I
003e8c 3888          .dw XT_CSTORE  ; ( -- c c-addr)
003e8d 3ab8          .dw XT_DOLOOP
003e8e 3e8a          .dw PFA_FILL1
                 PFA_FILL2:
003e8f 38d4          .dw XT_DROP
003e90 381b          .dw XT_EXIT
                 
                 .include "words/f_cpu.asm"
                 
                 ; System
                 ; put the cpu frequency in Hz on stack
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_F_CPU:
003e91 ff05          .dw $ff05
003e92 5f66
003e93 7063
003e94 0075          .db "f_cpu",0
003e95 3e7e          .dw VE_HEAD
                     .set VE_HEAD = VE_F_CPU
                 XT_F_CPU:
003e96 3801          .dw DO_COLON
                 PFA_F_CPU:
                 .endif
003e97 3838          .dw XT_DOLITERAL
003e98 2400          .dw (F_CPU % 65536)
003e99 3838          .dw XT_DOLITERAL
003e9a 00f4          .dw (F_CPU / 65536)
003e9b 381b          .dw XT_EXIT
                 .include "words/state.asm"
                 
                 ; System Variable
                 ; system state
                 VE_STATE:
003e9c ff05          .dw $ff05
003e9d 7473
003e9e 7461
003e9f 0065          .db "state",0
003ea0 3e91          .dw VE_HEAD
                     .set VE_HEAD = VE_STATE
                 XT_STATE:
003ea1 3843          .dw PFA_DOVARIABLE
                 PFA_STATE:
003ea2 01a3          .dw ram_state
                 
                 .dseg
0001a3           ram_state: .byte 2
                 .include "words/base.asm"
                 
                 ; Numeric IO
                 ; location of the cell containing the number conversion radix
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_BASE:
003ea3 ff04          .dw $ff04
003ea4 6162
003ea5 6573          .db "base"
003ea6 3e9c          .dw VE_HEAD
                     .set VE_HEAD = VE_BASE
                 XT_BASE:
003ea7 3853          .dw PFA_DOUSER
                 PFA_BASE:
                 .endif
003ea8 000c          .dw USER_BASE
                 
                 .include "words/cells.asm"
                 
                 ; Arithmetics
                 ; n2 is the size in address units of n1 cells
                 VE_CELLS:
003ea9 ff05          .dw $ff05
003eaa 6563
003eab 6c6c
003eac 0073          .db "cells",0
003ead 3ea3          .dw VE_HEAD
                     .set VE_HEAD = VE_CELLS
                 XT_CELLS:
003eae 3a07          .dw PFA_2STAR
                 
                 .include "words/2dup.asm"
                 
                 ; Stack
                 ; Duplicate the 2 top elements
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_2DUP:
003eaf ff04          .dw $ff04
003eb0 6432
003eb1 7075          .db "2dup"
003eb2 3ea9          .dw VE_HEAD
                     .set VE_HEAD = VE_2DUP
                 XT_2DUP:
003eb3 3801          .dw DO_COLON
                 PFA_2DUP:
                 .endif
                 
003eb4 38ca          .dw XT_OVER
003eb5 38ca          .dw XT_OVER
003eb6 381b          .dw XT_EXIT
                 .include "words/2drop.asm"
                 
                 ; Stack
                 ; Remove the 2 top elements
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_2DROP:
003eb7 ff05          .dw $ff05
003eb8 6432
003eb9 6f72
003eba 0070          .db "2drop",0
003ebb 3eaf          .dw VE_HEAD
                     .set VE_HEAD = VE_2DROP
                 XT_2DROP:
003ebc 3801          .dw DO_COLON
                 PFA_2DROP:
                 .endif
003ebd 38d4          .dw XT_DROP
003ebe 38d4          .dw XT_DROP
003ebf 381b          .dw XT_EXIT
                 .include "words/tuck.asm"
                 
                 ; Stack
                 ; Copy the first (top) stack item below the second stack item. 
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_TUCK:
003ec0 ff04          .dw $ff04
003ec1 7574
003ec2 6b63          .db "tuck"
003ec3 3eb7          .dw VE_HEAD
                     .set VE_HEAD = VE_TUCK
                 XT_TUCK:
003ec4 3801          .dw DO_COLON
                 PFA_TUCK:
                 .endif
003ec5 38bf          .dw XT_SWAP
003ec6 38ca          .dw XT_OVER
003ec7 381b          .dw XT_EXIT
                 
                 .include "words/to-in.asm"
                 
                 ; System Variable
                 ; pointer to current read position in input buffer
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_TO_IN:
003ec8 ff03          .dw $ff03
003ec9 693e
003eca 006e          .db ">in",0
003ecb 3ec0          .dw VE_HEAD
                     .set VE_HEAD = VE_TO_IN
                 XT_TO_IN:
003ecc 3853          .dw PFA_DOUSER
                 PFA_TO_IN:
                 .endif
003ecd 0018          .dw USER_TO_IN
                 .include "words/sharptib.asm"
                 
                 ; System Variable
                 ; variable holding the number of characters in TIB
                 VE_NUMBERTIB:
003ece ff04          .dw $ff04
003ecf 7423
003ed0 6269          .db "#tib"
003ed1 3ec8          .dw VE_HEAD
                     .set VE_HEAD  = VE_NUMBERTIB
                 XT_NUMBERTIB:
003ed2 3843          .dw PFA_DOVARIABLE
                 PFA_NUMBERTIB:
003ed3 01a5          .dw ram_sharptib
                 
                 .dseg
0001a5           ram_sharptib: .byte 2
                 .cseg
                  
                 .include "words/pad.asm"
                 
                 ; System Variable
                 ; Address of the temporary scratch buffer.
                 VE_PAD:
003ed4 ff03          .dw $ff03
003ed5 6170
003ed6 0064          .db "pad",0
003ed7 3ece          .dw VE_HEAD
                     .set VE_HEAD = VE_PAD
                 XT_PAD:
003ed8 3801          .dw DO_COLON
                 PFA_PAD:
003ed9 3f13          .dw XT_HERE
003eda 3838          .dw XT_DOLITERAL
003edb 0064          .dw 100
003edc 3998          .dw XT_PLUS
003edd 381b          .dw XT_EXIT
                 .include "words/emit.asm"
                 
                 ; Character IO
                 ; fetch the emit vector and execute it. should emit a character from TOS
                 VE_EMIT:
003ede ff04          .dw $ff04
003edf 6d65
003ee0 7469          .db "emit"
003ee1 3ed4          .dw VE_HEAD
                     .set VE_HEAD = VE_EMIT
                 XT_EMIT:
003ee2 3de1          .dw PFA_DODEFER1
                 PFA_EMIT:
003ee3 000e          .dw USER_EMIT
003ee4 3daa          .dw XT_UDEFERFETCH
003ee5 3db6          .dw XT_UDEFERSTORE
                 .include "words/emitq.asm"
                 
                 ; Character IO
                 ; fetch emit? vector and execute it. should return the ready-to-send condition
                 VE_EMITQ:
003ee6 ff05          .dw $ff05
003ee7 6d65
003ee8 7469
003ee9 003f          .db "emit?",0
003eea 3ede          .dw VE_HEAD
                     .set VE_HEAD = VE_EMITQ
                 XT_EMITQ:
003eeb 3de1          .dw PFA_DODEFER1
                 PFA_EMITQ:
003eec 0010          .dw USER_EMITQ
003eed 3daa          .dw XT_UDEFERFETCH
003eee 3db6          .dw XT_UDEFERSTORE
                 .include "words/key.asm"
                 
                 ; Character IO
                 ; fetch key vector and execute it, should leave a single character on TOS
                 VE_KEY:
003eef ff03          .dw $ff03
003ef0 656b
003ef1 0079          .db "key",0
003ef2 3ee6          .dw VE_HEAD
                     .set VE_HEAD = VE_KEY
                 XT_KEY:
003ef3 3de1          .dw PFA_DODEFER1
                 PFA_KEY:
003ef4 0012          .dw USER_KEY
003ef5 3daa          .dw XT_UDEFERFETCH
003ef6 3db6          .dw XT_UDEFERSTORE
                 .include "words/keyq.asm"
                 
                 ; Character IO
                 ; fetch key? vector and execute it. should turn on key sender, if it is disabled/stopped
                 VE_KEYQ:
003ef7 ff04          .dw $ff04
003ef8 656b
003ef9 3f79          .db "key?"
003efa 3eef          .dw VE_HEAD
                     .set VE_HEAD = VE_KEYQ
                 XT_KEYQ:
003efb 3de1          .dw PFA_DODEFER1
                 PFA_KEYQ:
003efc 0014          .dw USER_KEYQ
003efd 3daa          .dw XT_UDEFERFETCH
003efe 3db6          .dw XT_UDEFERSTORE
                 
                 .include "words/dp.asm"
                 
                 ; System Value
                 ; address of the next free dictionary cell
                 VE_DP:
003eff ff02          .dw $ff02
003f00 7064          .db "dp"
003f01 3ef7          .dw VE_HEAD
                     .set VE_HEAD = VE_DP
                 XT_DP:
003f02 386a          .dw PFA_DOVALUE1
                 PFA_DP:
003f03 0036          .dw EE_DP
003f04 3d82          .dw XT_EDEFERFETCH
003f05 3d8c          .dw XT_EDEFERSTORE
                 .include "words/ehere.asm"
                 
                 ; System Value
                 ; address of the next free address in eeprom
                 VE_EHERE:
003f06 ff05          .dw $ff05
003f07 6865
003f08 7265
003f09 0065          .db "ehere",0
003f0a 3eff          .dw VE_HEAD
                     .set VE_HEAD = VE_EHERE
                 XT_EHERE:
003f0b 386a          .dw PFA_DOVALUE1
                 PFA_EHERE:
003f0c 003a          .dw EE_EHERE
003f0d 3d82          .dw XT_EDEFERFETCH
003f0e 3d8c          .dw XT_EDEFERSTORE
                 .include "words/here.asm"
                 
                 ; System Value
                 ; address of the next free data space (RAM) cell
                 VE_HERE:
003f0f ff04          .dw $ff04
003f10 6568
003f11 6572          .db "here"
003f12 3f06          .dw VE_HEAD
                     .set VE_HEAD = VE_HERE
                 XT_HERE:
003f13 386a          .dw PFA_DOVALUE1
                 PFA_HERE:
003f14 0038          .dw EE_HERE
003f15 3d82          .dw XT_EDEFERFETCH
003f16 3d8c          .dw XT_EDEFERSTORE
                 .include "words/allot.asm"
                 
                 ; System
                 ; allocate or release memory in RAM
                 VE_ALLOT:
003f17 ff05          .dw $ff05
003f18 6c61
003f19 6f6c
003f1a 0074          .db "allot",0
003f1b 3f0f          .dw VE_HEAD
                     .set VE_HEAD = VE_ALLOT
                 XT_ALLOT:
003f1c 3801          .dw DO_COLON
                 PFA_ALLOT:
003f1d 3f13          .dw XT_HERE
003f1e 3998          .dw XT_PLUS
003f1f 01c7          .dw XT_DOTO
003f20 3f14          .dw PFA_HERE
003f21 381b          .dw XT_EXIT
                 
                 .include "words/bin.asm"
                 
                 ; Numeric IO
                 ; set base for numeric conversion to 10
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_BIN:
003f22 ff03          .dw $ff03
003f23 6962
003f24 006e          .db "bin",0
003f25 3f17          .dw VE_HEAD
                     .set VE_HEAD = VE_BIN
                 XT_BIN:
003f26 3801          .dw DO_COLON
                 PFA_BIN:
                 .endif
003f27 3838          .dw XT_DOLITERAL
003f28 0002          .dw 2
003f29 3ea7          .dw XT_BASE
003f2a 387c          .dw XT_STORE
003f2b 381b          .dw XT_EXIT
                 .include "words/decimal.asm"
                 
                 ; Numeric IO
                 ; set base for numeric conversion to 10
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DECIMAL:
003f2c ff07          .dw $ff07
003f2d 6564
003f2e 6963
003f2f 616d
003f30 006c          .db "decimal",0
003f31 3f22          .dw VE_HEAD
                     .set VE_HEAD = VE_DECIMAL
                 XT_DECIMAL:
003f32 3801          .dw DO_COLON
                 PFA_DECIMAL:
                 .endif
003f33 3838          .dw XT_DOLITERAL
003f34 000a          .dw 10
003f35 3ea7          .dw XT_BASE
003f36 387c          .dw XT_STORE
003f37 381b          .dw XT_EXIT
                 .include "words/hex.asm"
                 
                 ; Numeric IO
                 ; set base for numeric conversion to 10
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_HEX:
003f38 ff03          .dw $ff03
003f39 6568
003f3a 0078          .db "hex",0
003f3b 3f2c          .dw VE_HEAD
                     .set VE_HEAD = VE_HEX
                 XT_HEX:
003f3c 3801          .dw DO_COLON
                 PFA_HEX:
                 .endif
003f3d 3838          .dw XT_DOLITERAL
003f3e 0010          .dw 16
003f3f 3ea7          .dw XT_BASE
003f40 387c          .dw XT_STORE
003f41 381b          .dw XT_EXIT
                 .include "words/bl.asm"
                 
                 ; Character IO
                 ; put ascii code of the blank to the stack
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_BL:
003f42 ff02          .dw $ff02
003f43 6c62          .db "bl"
003f44 3f38          .dw VE_HEAD
                     .set VE_HEAD = VE_BL
                 XT_BL:
003f45 3843          .dw PFA_DOVARIABLE
                 PFA_BL:
                 .endif
003f46 0020          .dw 32
                 
                 .include "words/turnkey.asm"
                 
                 ; System Value
                 ; Deferred action during startup/reset
                 VE_TURNKEY:
003f47 ff07          .dw $ff07
003f48 7574
003f49 6e72
003f4a 656b
003f4b 0079          .db "turnkey",0
003f4c 3f42          .dw VE_HEAD
                     .set VE_HEAD = VE_TURNKEY
                 XT_TURNKEY:
003f4d 3de1          .dw PFA_DODEFER1
                 PFA_TURNKEY:
003f4e 003c          .dw EE_TURNKEY
003f4f 3d82          .dw XT_EDEFERFETCH
003f50 3d8c          .dw XT_EDEFERSTORE
                 .include "words/to-upper.asm"
                 
                 ; String
                 ; if c is a lowercase letter convert it to uppercase
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_TOUPPER:
003f51 ff07          .dw $ff07 
003f52 6f74
003f53 7075
003f54 6570
003f55 0072          .db "toupper",0
003f56 3f47          .dw VE_HEAD
                     .set VE_HEAD = VE_TOUPPER
                 XT_TOUPPER:
003f57 3801          .dw DO_COLON 
                 PFA_TOUPPER:
                 .endif
003f58 38ac          .dw XT_DUP 
003f59 3838          .dw XT_DOLITERAL 
003f5a 0061          .dw 'a' 
003f5b 3838          .dw XT_DOLITERAL 
003f5c 007b          .dw 'z'+1
003f5d 3e41          .dw XT_WITHIN 
003f5e 3831          .dw XT_DOCONDBRANCH
003f5f 3f63          DEST(PFA_TOUPPER0)
003f60 3838          .dw XT_DOLITERAL
003f61 00df          .dw 223 ; inverse of 0x20: 0xdf
003f62 3a0e          .dw XT_AND 
                 PFA_TOUPPER0:
003f63 381b          .dw XT_EXIT 
                 .include "words/to-lower.asm"
                 
                 ; String
                 ; if C is an uppercase letter convert it to lowercase
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 
                 VE_TOLOWER:
003f64 ff07          .dw $ff07
003f65 6f74
003f66 6f6c
003f67 6577
003f68 0072          .db "tolower",0
003f69 3f51          .dw VE_HEAD
                     .set VE_HEAD = VE_TOLOWER
                 XT_TOLOWER:
003f6a 3801          .dw DO_COLON
                 PFA_TOLOWER:
                 .endif
003f6b 38ac          .dw XT_DUP
003f6c 3838          .dw XT_DOLITERAL
003f6d 0041          .dw 'A'
003f6e 3838          .dw XT_DOLITERAL
003f6f 005b          .dw 'Z'+1
003f70 3e41          .dw XT_WITHIN
003f71 3831          .dw XT_DOCONDBRANCH
003f72 3f76          DEST(PFA_TOLOWER0)
003f73 3838          .dw XT_DOLITERAL
003f74 0020          .dw 32
003f75 3a17          .dw XT_OR 
                 PFA_TOLOWER0:
003f76 381b          .dw XT_EXIT 
                 
                 .include "words/q-stack.asm"
                 
                 ; Tools
                 ; check data stack depth and exit to quit if underrun
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_QSTACK:
003f77 ff06          .dw $ff06
003f78 733f
003f79 6174
003f7a 6b63          .db "?stack"
003f7b 3f64          .dw VE_HEAD
                     .set VE_HEAD = VE_QSTACK
                 XT_QSTACK:
003f7c 3801          .dw DO_COLON
                 PFA_QSTACK:
                 .endif
003f7d 05ea          .dw XT_DEPTH
003f7e 391c          .dw XT_ZEROLESS
003f7f 3831          .dw XT_DOCONDBRANCH
003f80 3f84          DEST(PFA_QSTACK1)
003f81 3838            .dw XT_DOLITERAL
003f82 fffc            .dw -4
003f83 3d68            .dw XT_THROW
                 PFA_QSTACK1:
003f84 381b          .dw XT_EXIT
                 .include "words/bounds.asm"
                 
                 ; Tools
                 ; convert a string to an address range
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_BOUNDS:
003f85 ff06          .dw $ff06
003f86 6f62
003f87 6e75
003f88 7364          .db "bounds"
003f89 3f77          .dw VE_HEAD
                     .set VE_HEAD = VE_BOUNDS
                 XT_BOUNDS:
003f8a 3801          .dw DO_COLON
                 PFA_BOUNDS:
                 .endif
003f8b 38ca          .dw XT_OVER
003f8c 3998          .dw XT_PLUS
003f8d 38bf          .dw XT_SWAP
003f8e 381b          .dw XT_EXIT
                 .include "words/cr.asm"
                 
                 ; Character IO
                 ; cause subsequent output appear at the beginning of the next line
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_CR:
003f8f ff02          .dw 0xff02
003f90 7263          .db "cr"
003f91 3f85          .dw VE_HEAD
                     .set VE_HEAD = VE_CR
                 XT_CR:
003f92 3801          .dw DO_COLON
                 PFA_CR:
                 .endif
                 
003f93 3838          .dw XT_DOLITERAL
003f94 000d          .dw 13
003f95 3ee2          .dw XT_EMIT
003f96 3838          .dw XT_DOLITERAL
003f97 000a          .dw 10
003f98 3ee2          .dw XT_EMIT
003f99 381b          .dw XT_EXIT
                 .include "words/space.asm"
                 
                 ; Character IO
                 ; emits a space (bl)
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SPACE:
003f9a ff05          .dw $ff05
003f9b 7073
003f9c 6361
003f9d 0065          .db "space",0
003f9e 3f8f          .dw VE_HEAD
                     .set VE_HEAD = VE_SPACE
                 XT_SPACE:
003f9f 3801          .dw DO_COLON
                 PFA_SPACE:
                 .endif
003fa0 3f45          .dw XT_BL
003fa1 3ee2          .dw XT_EMIT
003fa2 381b          .dw XT_EXIT
                 .include "words/spaces.asm"
                 
                 ; Character IO
                 ; emits n space(s) (bl)
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SPACES:
003fa3 ff06          .dw $ff06
003fa4 7073
003fa5 6361
003fa6 7365          .db "spaces"
003fa7 3f9a          .dw VE_HEAD
                     .set VE_HEAD = VE_SPACES
                 XT_SPACES:
003fa8 3801          .dw DO_COLON
                 PFA_SPACES:
                 
                 .endif
                 ;C SPACES   n --            output n spaces
                 ;   BEGIN DUP 0> WHILE SPACE 1- REPEAT DROP ;
003fa9 394f
003faa 3e34      	.DW XT_ZERO, XT_MAX
003fab 38ac
003fac 3831      SPCS1:  .DW XT_DUP,XT_DOCONDBRANCH
003fad 3fb2              DEST(SPCS2)
003fae 3f9f
003faf 3a30
003fb0 382a              .DW XT_SPACE,XT_1MINUS,XT_DOBRANCH
003fb1 3fab              DEST(SPCS1)
003fb2 38d4
003fb3 381b      SPCS2:  .DW XT_DROP,XT_EXIT
                 .include "words/s-to-d.asm"
                 
                 ; Conversion
                 ; extend (signed) single cell value to double cell
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_S2D:
003fb4 ff03          .dw $ff03
003fb5 3e73
003fb6 0064          .db "s>d",0
003fb7 3fa3          .dw VE_HEAD
                     .set VE_HEAD = VE_S2D
                 XT_S2D:
003fb8 3801          .dw DO_COLON
                 PFA_S2D:
                 .endif
003fb9 38ac          .dw XT_DUP
003fba 391c          .dw XT_ZEROLESS
003fbb 381b          .dw XT_EXIT
                 .include "words/to-body.asm"
                 
                 ; Core
                 ; get body from XT
                 VE_TO_BODY:
003fbc ff05          .dw $ff05
003fbd 623e
003fbe 646f
003fbf 0079          .db ">body",0
003fc0 3fb4          .dw VE_HEAD
                     .set VE_HEAD = VE_TO_BODY
                 XT_TO_BODY:
003fc1 3a2b          .dw PFA_1PLUS
                 .elif AMFORTH_NRWW_SIZE>2000
                 .else
                 .endif
                 ; now colon words
                 ;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/2literal.asm"
                 
                 ; Compiler
                 ; compile a cell pair literal in colon definitions
                 VE_2LITERAL:
003fc2 0008          .dw $0008
003fc3 6c32
003fc4 7469
003fc5 7265
003fc6 6c61          .db "2literal"
003fc7 3fbc          .dw VE_HEAD
                     .set VE_HEAD = VE_2LITERAL
                 XT_2LITERAL:
003fc8 3801          .dw DO_COLON
                 PFA_2LITERAL:
003fc9 38bf          .dw XT_SWAP
003fca 0756          .dw XT_COMPILE
003fcb 3838          .dw XT_DOLITERAL
003fcc 0761          .dw XT_COMMA
003fcd 0756          .dw XT_COMPILE
003fce 3838          .dw XT_DOLITERAL
003fcf 0761          .dw XT_COMMA
                     
003fd0 381b          .dw XT_EXIT
                 .include "words/equal.asm"
                 
                 ; Compare
                 ; compares two values for equality
                 VE_EQUAL:
003fd1 ff01          .dw $ff01
003fd2 003d          .db "=",0
003fd3 3fc2          .dw VE_HEAD
                     .set VE_HEAD = VE_EQUAL
                 XT_EQUAL:
003fd4 3801          .dw DO_COLON
                 PFA_EQUAL:
003fd5 398e          .dw XT_MINUS
003fd6 3915          .dw XT_ZEROEQUAL
003fd7 381b          .dw XT_EXIT
                 .include "words/num-constants.asm"
                 
                 .endif
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_ONE:
003fd8 ff01          .dw $ff01
003fd9 0031          .db "1",0
003fda 3fd1          .dw VE_HEAD
                     .set VE_HEAD = VE_ONE
                 XT_ONE:
003fdb 3843          .dw PFA_DOVARIABLE
                 PFA_ONE:
                 .endif
003fdc 0001              .DW 1
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_TWO:
003fdd ff01          .dw $ff01
003fde 0032          .db "2",0
003fdf 3fd8          .dw VE_HEAD
                     .set VE_HEAD = VE_TWO
                 XT_TWO:
003fe0 3843          .dw PFA_DOVARIABLE
                 PFA_TWO:
                 .endif
003fe1 0002              .DW 2
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_MINUSONE:
003fe2 ff02          .dw $ff02
003fe3 312d          .db "-1"
003fe4 3fdd          .dw VE_HEAD
                     .set VE_HEAD = VE_MINUSONE
                 XT_MINUSONE:
003fe5 3843          .dw PFA_DOVARIABLE
                 PFA_MINUSONE:
                 .endif
003fe6 ffff              .DW -1
                 .include "dict_appl_core.inc"
                 
                 ; do not delete it!
                 
                 .set flashlast = pc
                 .if (pc>FLASHEND)
                 .endif
                 
                 .dseg
                 ; define a label for the 1st free ram address
                 HERESTART:
                 .eseg
                 .include "amforth-eeprom.inc"
000034 ff ff     
                 EE_DP:
000036 28 0b         .dw DPSTART      ; Dictionary Pointer
                 EE_HERE:
000038 a7 01         .dw HERESTART    ; Memory Allocation
                 EE_EHERE:
00003a 88 00         .dw EHERESTART     ; EEProm Memory Allocation
                 EE_TURNKEY:
00003c 73 0a         .dw XT_APPLTURNKEY  ; TURNKEY
                 EE_STOREI:
00003e 6d 3b         .dw XT_DO_STOREI  ; Store a cell into flash
                 
                 EE_ENVIRONMENT:
000040 03 03         .dw VE_ENVHEAD   ; environmental queries
                 EE_WL_FORTH:
000042 46 00         .dw EE_FORTHWORDLIST; forth-wordlist
                 EE_CURRENT:
000044 46 00         .dw EE_FORTHWORDLIST
                 EE_FORTHWORDLIST:
000046 e2 3f         .dw VE_HEAD      ; pre-defined (compiled in) wordlist
                 CFG_ORDERLISTLEN:
000048 01 00         .dw 1
                 CFG_ORDERLIST: ; list of wordlist id, exactly numwordlist entries
00004a 46 00         .dw EE_FORTHWORDLIST      ; get/set-order
00004c               .byte  (NUMWORDLISTS-1)*CELLSIZE ; one slot is already used
                 CFG_RECOGNIZERLISTLEN:
00005a 02 00         .dw 2
                 CFG_RECOGNIZERLIST:
00005c 6d 06         .dw XT_REC_WORD
00005e 58 06         .dw XT_REC_NUM
000060               .byte  (NUMRECOGNIZERS-2)*CELLSIZE ; two slots are already used
                 
                 EE_WLSCOPE:
000064 d2 09         .dw XT_GET_CURRENT  ; default wordlist scope
                 
                 ; LEAVE stack is between data stack and return stack.
                 EE_LP0:
000066 b0 08         .dw stackstart+1
                 
                 ; MARKER saves everything up to here. Nothing beyond gets saved
                 EE_MARKER:
000068 68 00         .dw EE_MARKER
                 
                 ; default user area
                 EE_INITUSER:
00006a 00 00         .dw 0  ; USER_STATE
00006c 00 00         .dw 0  ; USER_FOLLOWER
00006e ff 08         .dw rstackstart  ; USER_RP
000070 af 08         .dw stackstart   ; USER_SP0
000072 af 08         .dw stackstart   ; USER_SP
                     
000074 00 00         .dw 0  ; USER_HANDLER
000076 0a 00         .dw 10 ; USER_BASE
                     
000078 90 00         .dw XT_TX  ; USER_EMIT
00007a 9e 00         .dw XT_TXQ ; USER_EMITQ
00007c 66 00         .dw XT_RX  ; USER_KEY
00007e 80 00         .dw XT_RXQ ; USER_KEYQ
000080 86 02         .dw XT_SOURCETIB ; USER_SKEY
000082 00 00         .dw 0            ; USER_G_IN
000084 73 02         .dw XT_REFILLTIB ; USER_REFILL  
                 
                 ; calculate baud rate error
                 .equ UBRR_VAL   = ((F_CPU+BAUD*8)/(BAUD*16)-1)  ; smart round
                 .equ BAUD_REAL  = (F_CPU/(16*(UBRR_VAL+1)))     ; effective baud rate
                 .equ BAUD_ERROR = ((BAUD_REAL*1000)/BAUD-1000)  ; error in pro mille
                 
                 .if ((BAUD_ERROR>BAUD_MAXERROR) || (BAUD_ERROR<-BAUD_MAXERROR))       
                 .endif
                 EE_UBRRVAL:
000086 19 00         .dw UBRR_VAL     ; BAUDRATE
                 ; 1st free address in EEPROM.
                 EHERESTART:
                 .cseg


RESOURCE USE INFORMATION
------------------------

Notice:
The register and instruction counts are symbol table hit counts,
and hence implicitly used resources are not counted, eg, the
'lpm' instruction without operands implicitly uses r0 and z,
none of which are counted.

x,y,z are separate entities in the symbol table and are
counted separately from r26..r31 here.

.dseg memory usage only counts static data declared with .byte

"ATmega328P" register use summary:
r0 :  20 r1 :   5 r2 :   9 r3 :  11 r4 :   4 r5 :   1 r6 :   0 r7 :   0 
r8 :   0 r9 :   0 r10:   1 r11:   1 r12:   0 r13:   0 r14:  22 r15:  20 
r16:  87 r17:  56 r18:  61 r19:  37 r20:  13 r21:  11 r22:  11 r23:   3 
r24: 210 r25: 145 r26:  39 r27:  21 r28:   7 r29:   4 r30:  88 r31:  47 
x  :   4 y  : 213 z  :  48 
Registers used: 29 out of 35 (82.9%)

"ATmega328P" instruction use summary:
.lds  :   0 .sts  :   0 adc   :  21 add   :  16 adiw  :  18 and   :   4 
andi  :   3 asr   :   2 bclr  :   0 bld   :   0 brbc  :   2 brbs  :   7 
brcc  :   3 brcs  :   1 break :   0 breq  :   6 brge  :   1 brhc  :   0 
brhs  :   0 brid  :   0 brie  :   0 brlo  :   1 brlt  :   3 brmi  :   3 
brne  :  21 brpl  :   1 brsh  :   0 brtc  :   0 brts  :   1 brvc  :   0 
brvs  :   2 bset  :   0 bst   :   0 call  :   2 cbi   :   7 cbr   :   1 
clc   :   2 clh   :   0 cli   :   7 cln   :   0 clr   :  12 cls   :   0 
clt   :   1 clv   :   0 clz   :   0 com   :  16 cp    :  10 cpc   :  10 
cpi   :   2 cpse  :   0 dec   :  10 eor   :   3 fmul  :   0 fmuls :   0 
fmulsu:   0 icall :   0 ijmp  :   1 in    :  26 inc   :   3 jmp   :  13 
ld    : 142 ldd   :   4 ldi   :  39 lds   :   2 lpm   :  16 lsl   :  14 
lsr   :   1 mov   :  12 movw  :  72 mul   :   5 muls  :   1 mulsu :   2 
neg   :   0 nop   :   0 or    :   9 ori   :   2 out   :  23 pop   :  52 
push  :  46 rcall :  39 ret   :   7 reti  :   2 rjmp  : 108 rol   :  23 
ror   :   6 sbc   :   9 sbci  :   3 sbi   :   8 sbic  :   3 sbis  :   0 
sbiw  :  16 sbr   :   0 sbrc  :   5 sbrs  :   7 sec   :   1 seh   :   0 
sei   :   1 sen   :   0 ser   :   4 ses   :   0 set   :   2 sev   :   0 
sez   :   0 sleep :   0 spm   :   2 st    :  78 std   :   8 sts   :   3 
sub   :   6 subi  :   3 swap  :   0 tst   :   1 wdr   :   0 
Instructions used: 77 out of 113 (68.1%)

"ATmega328P" memory use summary [bytes]:
Segment   Begin    End      Code   Data   Used    Size   Use%
---------------------------------------------------------------
[.cseg] 0x000000 0x007fce   2096  11658  13754   32768  42.0%
[.dseg] 0x000100 0x0001a7      0    167    167    2048   8.2%
[.eseg] 0x000000 0x000088      0    136    136    1024  13.3%

Assembly complete, 0 errors, 5 warnings
