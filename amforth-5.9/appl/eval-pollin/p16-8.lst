
AVRASM ver. 2.1.52  p16-8.asm Fri Jul 10 18:43:16 2015

p16-8.asm(5): Including file '../../avr8\preamble.inc'
../../avr8\preamble.inc(2): Including file '../../avr8\macros.asm'
../../avr8\macros.asm(6): Including file '../../avr8\user.inc'
../../avr8\preamble.inc(6): Including file '../../avr8/devices/atmega16\device.asm'
../../avr8/devices/atmega16\device.asm(5): Including file '../../avr8/Atmel/Appnotes2\m16def.inc'
p16-8.asm(14): Including file '../../avr8\drivers/usart.asm'
../../avr8\drivers/usart.asm(30): Including file '../../avr8\drivers/usart_common.asm'
../../avr8\drivers/usart_common.asm(5): Including file '../../avr8\drivers/usart-isr-rx.asm'
../../avr8\drivers/usart_common.asm(17): Including file '../../avr8\words/usart-tx-poll.asm'
../../avr8\drivers/usart_common.asm(22): Including file '../../avr8\words/ubrr.asm'
../../avr8\drivers/usart_common.asm(23): Including file '../../avr8\words/usart.asm'
p16-8.asm(19): Including file '../../avr8\drivers/1wire.asm'
p16-8.asm(21): Including file '../../avr8\amforth.asm'
../../avr8\amforth.asm(12): Including file '../../avr8\drivers/generic-isr.asm'
../../avr8\amforth.asm(14): Including file '../../avr8\dict/rww.inc'
../../avr8\dict/rww.inc(1): Including file '../../avr8\words/mplus.asm'
../../avr8\dict/rww.inc(2): Including file '../../common\words/ud-star.asm'
../../avr8\dict/rww.inc(3): Including file '../../common\words/umax.asm'
../../avr8\dict/rww.inc(4): Including file '../../common\words/umin.asm'
../../avr8\dict/rww.inc(5): Including file '../../avr8\words/immediate-q.asm'
../../avr8\dict/rww.inc(6): Including file '../../avr8\words/name2flags.asm'
../../avr8\dict/rww.inc(7): Including file '../../common\words/name2interpret.asm'
../../avr8\dict/rww.inc(8): Including file '../../common\words/name2compile.asm'
../../avr8\dict/rww.inc(15): Including file '../../avr8\dict/appl_2k.inc'
../../avr8\dict/appl_2k.inc(1): Including file '../../avr8\words/d-2star.asm'
../../avr8\dict/appl_2k.inc(2): Including file '../../avr8\words/d-2slash.asm'
../../avr8\dict/appl_2k.inc(3): Including file '../../avr8\words/d-plus.asm'
../../avr8\dict/appl_2k.inc(4): Including file '../../avr8\words/d-minus.asm'
../../avr8\dict/appl_2k.inc(5): Including file '../../avr8\words/d-invert.asm'
../../avr8\dict/appl_2k.inc(6): Including file '../../avr8\words/d-equal.asm'
../../avr8\dict/appl_2k.inc(7): Including file '../../common\words/u-dot.asm'
../../avr8\dict/appl_2k.inc(8): Including file '../../common\words/u-dot-r.asm'
../../avr8\dict/appl_2k.inc(10): Including file '../../common\words/show-wordlist.asm'
../../avr8\dict/appl_2k.inc(11): Including file '../../avr8\words/words.asm'
../../avr8\dict/appl_2k.inc(12): Including file '../../avr8\dict/interrupt.inc'
../../avr8\dict/interrupt.inc(2): Including file '../../avr8\words/int-on.asm'
../../avr8\dict/interrupt.inc(3): Including file '../../avr8\words/int-off.asm'
../../avr8\dict/interrupt.inc(4): Including file '../../avr8\words/int-store.asm'
../../avr8\dict/interrupt.inc(5): Including file '../../avr8\words/int-fetch.asm'
../../avr8\dict/interrupt.inc(6): Including file '../../avr8\words/int-trap.asm'
../../avr8\dict/interrupt.inc(8): Including file '../../avr8\words/isr-exec.asm'
../../avr8\dict/interrupt.inc(9): Including file '../../avr8\words/isr-end.asm'
../../avr8\dict/appl_2k.inc(14): Including file '../../common\words/pick.asm'
../../avr8\dict/appl_2k.inc(15): Including file '../../common\words/dot-quote.asm'
../../avr8\dict/appl_2k.inc(16): Including file '../../common\words/squote.asm'
../../avr8\dict/appl_2k.inc(18): Including file '../../avr8\words/fill.asm'
../../avr8\dict/appl_2k.inc(19): Including file '../../avr8\dict/compiler1.inc'
../../avr8\dict/compiler1.inc(2): Including file '../../avr8\words/docreate.asm'
../../avr8\dict/compiler1.inc(3): Including file '../../common\words/backslash.asm'
../../avr8\dict/compiler1.inc(4): Including file '../../common\words/l-paren.asm'
../../avr8\dict/compiler1.inc(6): Including file '../../common\words/compile.asm'
../../avr8\dict/compiler1.inc(7): Including file '../../avr8\words/comma.asm'
../../avr8\dict/compiler1.inc(8): Including file '../../common\words/brackettick.asm'
../../avr8\dict/compiler1.inc(11): Including file '../../common\words/literal.asm'
../../avr8\dict/compiler1.inc(12): Including file '../../common\words/sliteral.asm'
../../avr8\dict/compiler1.inc(13): Including file '../../avr8\words/g-mark.asm'
../../avr8\dict/compiler1.inc(14): Including file '../../avr8\words/g-resolve.asm'
../../avr8\dict/compiler1.inc(15): Including file '../../avr8\words/l_mark.asm'
../../avr8\dict/compiler1.inc(16): Including file '../../avr8\words/l_resolve.asm'
../../avr8\dict/compiler1.inc(18): Including file '../../common\words/ahead.asm'
../../avr8\dict/compiler1.inc(19): Including file '../../common\words/if.asm'
../../avr8\dict/compiler1.inc(20): Including file '../../common\words/else.asm'
../../avr8\dict/compiler1.inc(21): Including file '../../common\words/then.asm'
../../avr8\dict/compiler1.inc(22): Including file '../../common\words/begin.asm'
../../avr8\dict/compiler1.inc(23): Including file '../../common\words/while.asm'
../../avr8\dict/compiler1.inc(24): Including file '../../common\words/repeat.asm'
../../avr8\dict/compiler1.inc(25): Including file '../../common\words/until.asm'
../../avr8\dict/compiler1.inc(26): Including file '../../common\words/again.asm'
../../avr8\dict/compiler1.inc(27): Including file '../../common\words/do.asm'
../../avr8\dict/compiler1.inc(28): Including file '../../common\words/loop.asm'
../../avr8\dict/compiler1.inc(29): Including file '../../common\words/plusloop.asm'
../../avr8\dict/compiler1.inc(30): Including file '../../common\words/leave.asm'
../../avr8\dict/compiler1.inc(31): Including file '../../common\words/qdo.asm'
../../avr8\dict/compiler1.inc(32): Including file '../../common\words/endloop.asm'
../../avr8\dict/compiler1.inc(34): Including file '../../common\words/l-from.asm'
../../avr8\dict/compiler1.inc(35): Including file '../../common\words/to-l.asm'
../../avr8\dict/compiler1.inc(36): Including file '../../avr8\words/lp0.asm'
../../avr8\dict/compiler1.inc(37): Including file '../../avr8\words/lp.asm'
../../avr8\dict/compiler1.inc(39): Including file '../../avr8\words/create.asm'
../../avr8\dict/compiler1.inc(40): Including file '../../avr8\words/header.asm'
../../avr8\dict/compiler1.inc(41): Including file '../../avr8\words/wlscope.asm'
../../avr8\dict/compiler1.inc(42): Including file '../../avr8\words/reveal.asm'
../../avr8\dict/compiler1.inc(43): Including file '../../avr8\words/latest.asm'
../../avr8\dict/compiler1.inc(44): Including file '../../avr8\words/does.asm'
../../avr8\dict/compiler1.inc(45): Including file '../../common\words/colon.asm'
../../avr8\dict/compiler1.inc(46): Including file '../../avr8\words/colon-noname.asm'
../../avr8\dict/compiler1.inc(47): Including file '../../common\words/semicolon.asm'
../../avr8\dict/compiler1.inc(48): Including file '../../common\words/right-bracket.asm'
../../avr8\dict/compiler1.inc(49): Including file '../../common\words/left-bracket.asm'
../../avr8\dict/compiler1.inc(50): Including file '../../common\words/variable.asm'
../../avr8\dict/compiler1.inc(51): Including file '../../common\words/constant.asm'
../../avr8\dict/compiler1.inc(52): Including file '../../avr8\words/user.asm'
../../avr8\dict/compiler1.inc(54): Including file '../../avr8\words/recurse.asm'
../../avr8\dict/compiler1.inc(55): Including file '../../avr8\words/immediate.asm'
../../avr8\dict/compiler1.inc(57): Including file '../../common\words/bracketchar.asm'
../../avr8\dict/compiler1.inc(58): Including file '../../common\words/abort-string.asm'
../../avr8\dict/compiler1.inc(59): Including file '../../common\words/abort.asm'
../../avr8\dict/compiler1.inc(60): Including file '../../common\words/q-abort.asm'
../../avr8\dict/compiler1.inc(62): Including file '../../common\words/get-stack.asm'
../../avr8\dict/compiler1.inc(63): Including file '../../common\words/set-stack.asm'
../../avr8\dict/compiler1.inc(64): Including file '../../common\words/map-stack.asm'
../../avr8\dict/compiler1.inc(65): Including file '../../avr8\words/get-current.asm'
../../avr8\dict/compiler1.inc(66): Including file '../../common\words/get-order.asm'
../../avr8\dict/compiler1.inc(68): Including file '../../avr8\words/compare.asm'
../../avr8\dict/compiler1.inc(69): Including file '../../avr8\words/nfa2lfa.asm'
../../avr8\dict/appl_2k.inc(21): Including file '../../avr8\words/environment.asm'
../../avr8\dict/appl_2k.inc(22): Including file '../../avr8\words/env-wordlists.asm'
../../avr8\dict/appl_2k.inc(23): Including file '../../avr8\words/env-slashpad.asm'
../../avr8\dict/appl_2k.inc(24): Including file '../../avr8\words/env-slashhold.asm'
../../avr8\dict/appl_2k.inc(25): Including file '../../common\words/env-forthname.asm'
../../avr8\dict/appl_2k.inc(26): Including file '../../common\words/env-forthversion.asm'
../../avr8\dict/appl_2k.inc(27): Including file '../../common\words/env-cpu.asm'
../../avr8\dict/appl_2k.inc(28): Including file '../../avr8\words/env-mcuinfo.asm'
../../avr8\dict/appl_2k.inc(29): Including file '../../avr8\words/env-usersize.asm'
../../avr8\dict/appl_2k.inc(31): Including file '../../common\words/f_cpu.asm'
../../avr8\dict/appl_2k.inc(32): Including file '../../avr8\words/state.asm'
../../avr8\dict/appl_2k.inc(33): Including file '../../common\words/base.asm'
../../avr8\dict/appl_2k.inc(35): Including file '../../avr8\words/cells.asm'
../../avr8\dict/appl_2k.inc(36): Including file '../../avr8\words/cellplus.asm'
../../avr8\dict/appl_2k.inc(38): Including file '../../common\words/2dup.asm'
../../avr8\dict/appl_2k.inc(39): Including file '../../common\words/2drop.asm'
../../avr8\dict/appl_2k.inc(41): Including file '../../common\words/tuck.asm'
../../avr8\dict/appl_2k.inc(43): Including file '../../common\words/to-in.asm'
../../avr8\dict/appl_2k.inc(44): Including file '../../avr8\words/sharptib.asm'
../../avr8\dict/appl_2k.inc(45): Including file '../../avr8\words/pad.asm'
../../avr8\dict/appl_2k.inc(46): Including file '../../avr8\words/emit.asm'
../../avr8\dict/appl_2k.inc(47): Including file '../../avr8\words/emitq.asm'
../../avr8\dict/appl_2k.inc(48): Including file '../../avr8\words/key.asm'
../../avr8\dict/appl_2k.inc(49): Including file '../../avr8\words/keyq.asm'
../../avr8\dict/appl_2k.inc(51): Including file '../../avr8\words/dp.asm'
../../avr8\dict/appl_2k.inc(52): Including file '../../avr8\words/ehere.asm'
../../avr8\dict/appl_2k.inc(53): Including file '../../avr8\words/here.asm'
../../avr8\dict/appl_2k.inc(54): Including file '../../avr8\words/allot.asm'
../../avr8\dict/appl_2k.inc(56): Including file '../../common\words/bin.asm'
../../avr8\dict/appl_2k.inc(57): Including file '../../common\words/decimal.asm'
../../avr8\dict/appl_2k.inc(58): Including file '../../common\words/hex.asm'
../../avr8\dict/appl_2k.inc(59): Including file '../../common\words/bl.asm'
../../avr8\dict/appl_2k.inc(61): Including file '../../avr8\words/turnkey.asm'
../../avr8\dict/appl_2k.inc(63): Including file '../../avr8\words/slashmod.asm'
../../avr8\dict/appl_2k.inc(64): Including file '../../avr8\words/uslashmod.asm'
../../avr8\dict/appl_2k.inc(65): Including file '../../avr8\words/negate.asm'
../../avr8\dict/appl_2k.inc(66): Including file '../../common\words/slash.asm'
../../avr8\dict/appl_2k.inc(67): Including file '../../common\words/mod.asm'
../../avr8\dict/appl_2k.inc(68): Including file '../../avr8\words/abs.asm'
../../avr8\dict/appl_2k.inc(69): Including file '../../common\words/min.asm'
../../avr8\dict/appl_2k.inc(70): Including file '../../common\words/max.asm'
../../avr8\dict/appl_2k.inc(71): Including file '../../common\words/within.asm'
../../avr8\dict/appl_2k.inc(73): Including file '../../common\words/to-upper.asm'
../../avr8\dict/appl_2k.inc(74): Including file '../../common\words/to-lower.asm'
../../avr8\dict/appl_2k.inc(76): Including file '../../avr8\words/hld.asm'
../../avr8\dict/appl_2k.inc(77): Including file '../../common\words/hold.asm'
../../avr8\dict/appl_2k.inc(78): Including file '../../common\words/less-sharp.asm'
../../avr8\dict/appl_2k.inc(79): Including file '../../common\words/sharp.asm'
../../avr8\dict/appl_2k.inc(80): Including file '../../common\words/sharp-s.asm'
../../avr8\dict/appl_2k.inc(81): Including file '../../common\words/sharp-greater.asm'
../../avr8\dict/appl_2k.inc(82): Including file '../../common\words/sign.asm'
../../avr8\dict/appl_2k.inc(83): Including file '../../common\words/d-dot-r.asm'
../../avr8\dict/appl_2k.inc(84): Including file '../../common\words/dot-r.asm'
../../avr8\dict/appl_2k.inc(85): Including file '../../common\words/d-dot.asm'
../../avr8\dict/appl_2k.inc(86): Including file '../../common\words/dot.asm'
../../avr8\dict/appl_2k.inc(87): Including file '../../common\words/ud-dot.asm'
../../avr8\dict/appl_2k.inc(88): Including file '../../common\words/ud-dot-r.asm'
../../avr8\dict/appl_2k.inc(89): Including file '../../common\words/ud-slash-mod.asm'
../../avr8\dict/appl_2k.inc(90): Including file '../../common\words/digit-q.asm'
../../avr8\dict/appl_2k.inc(92): Including file '../../avr8\words/do-sliteral.asm'
../../avr8\dict/appl_2k.inc(93): Including file '../../avr8\words/scomma.asm'
../../avr8\dict/appl_2k.inc(94): Including file '../../avr8\words/itype.asm'
../../avr8\dict/appl_2k.inc(95): Including file '../../avr8\words/icount.asm'
../../avr8\dict/appl_2k.inc(96): Including file '../../common\words/cr.asm'
../../avr8\dict/appl_2k.inc(97): Including file '../../common\words/space.asm'
../../avr8\dict/appl_2k.inc(98): Including file '../../common\words/spaces.asm'
../../avr8\dict/appl_2k.inc(99): Including file '../../common\words/type.asm'
../../avr8\dict/appl_2k.inc(100): Including file '../../common\words/tick.asm'
../../avr8\dict/appl_2k.inc(102): Including file '../../common\words/handler.asm'
../../avr8\dict/appl_2k.inc(103): Including file '../../common\words/catch.asm'
../../avr8\dict/appl_2k.inc(104): Including file '../../common\words/throw.asm'
../../avr8\dict/appl_2k.inc(106): Including file '../../common\words/cskip.asm'
../../avr8\dict/appl_2k.inc(107): Including file '../../common\words/cscan.asm'
../../avr8\dict/appl_2k.inc(108): Including file '../../common\words/accept.asm'
../../avr8\dict/appl_2k.inc(109): Including file '../../avr8\words/refill.asm'
../../avr8\dict/appl_2k.inc(110): Including file '../../common\words/char.asm'
../../avr8\dict/appl_2k.inc(111): Including file '../../common\words/number.asm'
../../avr8\dict/appl_2k.inc(112): Including file '../../common\words/q-sign.asm'
../../avr8\dict/appl_2k.inc(113): Including file '../../common\words/set-base.asm'
../../avr8\dict/appl_2k.inc(114): Including file '../../common\words/to-number.asm'
../../avr8\dict/appl_2k.inc(115): Including file '../../common\words/parse.asm'
../../avr8\dict/appl_2k.inc(116): Including file '../../avr8\words/source.asm'
../../avr8\dict/appl_2k.inc(117): Including file '../../common\words/slash-string.asm'
../../avr8\dict/appl_2k.inc(118): Including file '../../common\words/parse-name.asm'
../../avr8\dict/appl_2k.inc(119): Including file '../../common\words/find-name.asm'
../../avr8\dict/appl_2k.inc(121): Including file '../../common\words/quit.asm'
../../avr8\dict/appl_2k.inc(122): Including file '../../common\words/prompt-ok.asm'
../../avr8\dict/appl_2k.inc(123): Including file '../../common\words/prompt-ready.asm'
../../avr8\dict/appl_2k.inc(124): Including file '../../common\words/prompt-error.asm'
../../avr8\dict/appl_2k.inc(125): Including file '../../avr8\words/pause.asm'
../../avr8\dict/appl_2k.inc(126): Including file '../../avr8\words/cold.asm'
../../avr8\dict/appl_2k.inc(127): Including file '../../avr8\words/warm.asm'
../../avr8\dict/appl_2k.inc(129): Including file '../../avr8\words/sp0.asm'
../../avr8\dict/appl_2k.inc(130): Including file '../../avr8\words/rp0.asm'
../../avr8\dict/appl_2k.inc(131): Including file '../../common\words/depth.asm'
../../avr8\dict/appl_2k.inc(132): Including file '../../common\words/do-recognizer.asm'
../../avr8\dict/appl_2k.inc(133): Including file '../../common\words/interpret.asm'
../../avr8\dict/appl_2k.inc(134): Including file '../../common\words/r-intnumber.asm'
../../avr8\dict/appl_2k.inc(135): Including file '../../common\words/r-word.asm'
../../avr8\dict/appl_2k.inc(136): Including file '../../common\words/r-fail.asm'
../../avr8\dict/appl_2k.inc(138): Including file '../../common\words/q-stack.asm'
../../avr8\dict/appl_2k.inc(139): Including file '../../common\words/ver.asm'
../../avr8\dict/appl_2k.inc(141): Including file '../../avr8\words/noop.asm'
../../avr8\dict/appl_2k.inc(142): Including file '../../avr8\words/unused.asm'
../../avr8\dict/appl_2k.inc(144): Including file '../../common\words/to.asm'
../../avr8\dict/appl_2k.inc(145): Including file '../../avr8\words/i-cellplus.asm'
../../avr8\dict/appl_2k.inc(147): Including file '../../avr8\words/edefer-fetch.asm'
../../avr8\dict/appl_2k.inc(148): Including file '../../avr8\words/edefer-store.asm'
../../avr8\dict/appl_2k.inc(149): Including file '../../common\words/rdefer-fetch.asm'
../../avr8\dict/appl_2k.inc(150): Including file '../../common\words/rdefer-store.asm'
../../avr8\dict/appl_2k.inc(151): Including file '../../common\words/udefer-fetch.asm'
../../avr8\dict/appl_2k.inc(152): Including file '../../common\words/udefer-store.asm'
../../avr8\dict/appl_2k.inc(153): Including file '../../common\words/defer-store.asm'
../../avr8\dict/appl_2k.inc(154): Including file '../../common\words/defer-fetch.asm'
../../avr8\dict/appl_2k.inc(155): Including file '../../avr8\words/do-defer.asm'
../../avr8\dict/appl_2k.inc(157): Including file '../../common\words/search-wordlist.asm'
../../avr8\dict/appl_2k.inc(158): Including file '../../common\words/traverse-wordlist.asm'
../../avr8\dict/appl_2k.inc(159): Including file '../../common\words/name2string.asm'
../../avr8\dict/appl_2k.inc(160): Including file '../../avr8\words/nfa2cfa.asm'
../../avr8\dict/appl_2k.inc(161): Including file '../../avr8\words/icompare.asm'
../../avr8\dict/appl_2k.inc(163): Including file '../../common\words/star.asm'
../../avr8\dict/appl_2k.inc(164): Including file '../../avr8\words/j.asm'
../../avr8\dict/appl_2k.inc(166): Including file '../../avr8\words/dabs.asm'
../../avr8\dict/appl_2k.inc(167): Including file '../../avr8\words/dnegate.asm'
../../avr8\dict/appl_2k.inc(168): Including file '../../avr8\words/cmove.asm'
../../avr8\dict/appl_2k.inc(169): Including file '../../common\words/2swap.asm'
../../avr8\dict/appl_2k.inc(171): Including file '../../avr8\words/tib.asm'
../../avr8\dict/appl_2k.inc(173): Including file '../../avr8\words/init-user.asm'
../../avr8\dict/appl_2k.inc(174): Including file '../../common\words/bounds.asm'
../../avr8\dict/appl_2k.inc(175): Including file '../../common\words/s-to-d.asm'
../../avr8\dict/appl_2k.inc(176): Including file '../../avr8\words/to-body.asm'
../../avr8\amforth.asm(15): Including file 'dict_appl.inc'
dict_appl.inc(3): Including file '../../common\words/dot-s.asm'
dict_appl.inc(4): Including file '../../avr8\words/spirw.asm'
dict_appl.inc(5): Including file '../../avr8\words/n-spi.asm'
dict_appl.inc(6): Including file 'words/applturnkey.asm'
dict_appl.inc(7): Including file '../../avr8\dict/compiler2.inc'
../../avr8\dict/compiler2.inc(8): Including file '../../avr8\words/set-current.asm'
../../avr8\dict/compiler2.inc(9): Including file '../../avr8\words/wordlist.asm'
../../avr8\dict/compiler2.inc(11): Including file '../../avr8\words/only.asm'
../../avr8\dict/compiler2.inc(12): Including file '../../avr8\words/forth-wordlist.asm'
../../avr8\dict/compiler2.inc(13): Including file '../../common\words/set-order.asm'
../../avr8\dict/compiler2.inc(14): Including file '../../common\words/set-recognizer.asm'
../../avr8\dict/compiler2.inc(15): Including file '../../common\words/get-recognizer.asm'
../../avr8\dict/compiler2.inc(16): Including file '../../avr8\words/code.asm'
../../avr8\dict/compiler2.inc(17): Including file '../../avr8\words/end-code.asm'
../../avr8\dict/compiler2.inc(18): Including file '../../avr8\words/marker.asm'
../../avr8\dict/compiler2.inc(19): Including file '../../common\words/postpone.asm'
dict_appl.inc(8): Including file '../../avr8\words/2r_fetch.asm'
../../avr8\amforth.asm(23): Including file '../../avr8\amforth-interpreter.asm'
../../avr8\amforth.asm(24): Including file '../../avr8\dict/nrww.inc'
../../avr8\dict/nrww.inc(4): Including file '../../avr8\words/exit.asm'
../../avr8\dict/nrww.inc(5): Including file '../../avr8\words/execute.asm'
../../avr8\dict/nrww.inc(6): Including file '../../avr8\words/dobranch.asm'
../../avr8\dict/nrww.inc(7): Including file '../../avr8\words/docondbranch.asm'
../../avr8\dict/nrww.inc(10): Including file '../../avr8\words/doliteral.asm'
../../avr8\dict/nrww.inc(11): Including file '../../avr8\words/dovariable.asm'
../../avr8\dict/nrww.inc(12): Including file '../../avr8\words/doconstant.asm'
../../avr8\dict/nrww.inc(13): Including file '../../avr8\words/douser.asm'
../../avr8\dict/nrww.inc(14): Including file '../../avr8\words/do-value.asm'
../../avr8\dict/nrww.inc(15): Including file '../../avr8\words/fetch.asm'
../../avr8\dict/nrww.inc(16): Including file '../../avr8\words/store.asm'
../../avr8\dict/nrww.inc(17): Including file '../../avr8\words/cstore.asm'
../../avr8\dict/nrww.inc(18): Including file '../../avr8\words/cfetch.asm'
../../avr8\dict/nrww.inc(19): Including file '../../avr8\words/fetch-u.asm'
../../avr8\dict/nrww.inc(20): Including file '../../avr8\words/store-u.asm'
../../avr8\dict/nrww.inc(23): Including file '../../avr8\words/dup.asm'
../../avr8\dict/nrww.inc(24): Including file '../../avr8\words/qdup.asm'
../../avr8\dict/nrww.inc(25): Including file '../../avr8\words/swap.asm'
../../avr8\dict/nrww.inc(26): Including file '../../avr8\words/over.asm'
../../avr8\dict/nrww.inc(27): Including file '../../avr8\words/drop.asm'
../../avr8\dict/nrww.inc(28): Including file '../../avr8\words/rot.asm'
../../avr8\dict/nrww.inc(29): Including file '../../avr8\words/nip.asm'
../../avr8\dict/nrww.inc(31): Including file '../../avr8\words/r_from.asm'
../../avr8\dict/nrww.inc(32): Including file '../../avr8\words/to_r.asm'
../../avr8\dict/nrww.inc(33): Including file '../../avr8\words/r_fetch.asm'
../../avr8\dict/nrww.inc(36): Including file '../../common\words/not-equal.asm'
../../avr8\dict/nrww.inc(37): Including file '../../avr8\words/equalzero.asm'
../../avr8\dict/nrww.inc(38): Including file '../../avr8\words/lesszero.asm'
../../avr8\dict/nrww.inc(39): Including file '../../avr8\words/greaterzero.asm'
../../avr8\dict/nrww.inc(40): Including file '../../avr8\words/d-greaterzero.asm'
../../avr8\dict/nrww.inc(41): Including file '../../avr8\words/d-lesszero.asm'
../../avr8\dict/nrww.inc(43): Including file '../../avr8\words/true.asm'
../../avr8\dict/nrww.inc(44): Including file '../../avr8\words/zero.asm'
../../avr8\dict/nrww.inc(45): Including file '../../avr8\words/uless.asm'
../../avr8\dict/nrww.inc(46): Including file '../../common\words/u-greater.asm'
../../avr8\dict/nrww.inc(47): Including file '../../avr8\words/less.asm'
../../avr8\dict/nrww.inc(48): Including file '../../avr8\words/greater.asm'
../../avr8\dict/nrww.inc(50): Including file '../../avr8\words/log2.asm'
../../avr8\dict/nrww.inc(51): Including file '../../avr8\words/minus.asm'
../../avr8\dict/nrww.inc(52): Including file '../../avr8\words/plus.asm'
../../avr8\dict/nrww.inc(53): Including file '../../avr8\words/mstar.asm'
../../avr8\dict/nrww.inc(54): Including file '../../avr8\words/umslashmod.asm'
../../avr8\dict/nrww.inc(55): Including file '../../avr8\words/umstar.asm'
../../avr8\dict/nrww.inc(57): Including file '../../avr8\words/invert.asm'
../../avr8\dict/nrww.inc(58): Including file '../../avr8\words/2slash.asm'
../../avr8\dict/nrww.inc(59): Including file '../../avr8\words/2star.asm'
../../avr8\dict/nrww.inc(60): Including file '../../avr8\words/and.asm'
../../avr8\dict/nrww.inc(61): Including file '../../avr8\words/or.asm'
../../avr8\dict/nrww.inc(62): Including file '../../avr8\words/xor.asm'
../../avr8\dict/nrww.inc(64): Including file '../../avr8\words/1plus.asm'
../../avr8\dict/nrww.inc(65): Including file '../../avr8\words/1minus.asm'
../../avr8\dict/nrww.inc(66): Including file '../../avr8\words/lshift.asm'
../../avr8\dict/nrww.inc(67): Including file '../../avr8\words/rshift.asm'
../../avr8\dict/nrww.inc(68): Including file '../../avr8\words/plusstore.asm'
../../avr8\dict/nrww.inc(70): Including file '../../avr8\words/rpfetch.asm'
../../avr8\dict/nrww.inc(71): Including file '../../avr8\words/rpstore.asm'
../../avr8\dict/nrww.inc(72): Including file '../../avr8\words/spfetch.asm'
../../avr8\dict/nrww.inc(73): Including file '../../avr8\words/spstore.asm'
../../avr8\dict/nrww.inc(75): Including file '../../avr8\words/dodo.asm'
../../avr8\dict/nrww.inc(76): Including file '../../avr8\words/i.asm'
../../avr8\dict/nrww.inc(77): Including file '../../avr8\words/doplusloop.asm'
../../avr8\dict/nrww.inc(78): Including file '../../avr8\words/doloop.asm'
../../avr8\dict/nrww.inc(79): Including file '../../avr8\words/unloop.asm'
../../avr8\dict/nrww.inc(83): Including file '../../avr8\words/cmove_g.asm'
../../avr8\dict/nrww.inc(84): Including file '../../avr8\words/byteswap.asm'
../../avr8\dict/nrww.inc(85): Including file '../../avr8\words/up.asm'
../../avr8\dict/nrww.inc(86): Including file '../../avr8\words/1ms.asm'
../../avr8\dict/nrww.inc(87): Including file '../../avr8\words/2to_r.asm'
../../avr8\dict/nrww.inc(88): Including file '../../avr8\words/2r_from.asm'
../../avr8\dict/nrww.inc(90): Including file '../../avr8\words/store-e.asm'
../../avr8\dict/nrww.inc(91): Including file '../../avr8\words/fetch-e.asm'
../../avr8\dict/nrww.inc(92): Including file '../../avr8\words/store-i.asm'
../../avr8\dict/nrww.inc(96): Including file '../../avr8\words/store-i_nrww.asm'
../../avr8\dict/nrww.inc(98): Including file '../../avr8\words/fetch-i.asm'
../../avr8\dict/nrww.inc(105): Including file '../../avr8\dict/core_2k.inc'
../../avr8\dict/nrww.inc(111): Including file '../../avr8\words/2literal.asm'
../../avr8\dict/nrww.inc(112): Including file '../../avr8\words/equal.asm'
../../avr8\dict/nrww.inc(113): Including file '../../common\words/num-constants.asm'
../../avr8\amforth.asm(25): Including file 'dict_appl_core.inc'
../../avr8\amforth.asm(36): Including file '../../avr8\amforth-eeprom.inc'
                 
                 
                 ; file see ../template/template.asm. You may want to
                 ; copy that file to this one and edit it afterwards.
                 
                 .include "preamble.inc"
                 
                 .include "macros.asm"
                 
                 .set DICT_COMPILER2 = 0 ;
                 .set cpu_msp430 = 0
                 .set cpu_avr8   = 1
                 
                 .include "user.inc"
                 
                 ; 
                 
                 ; used by the multitasker
                 .set USER_STATE    = 0
                 .set USER_FOLLOWER = 2
                 
                 ; stackpointer, used by mulitasker
                 .set USER_RP      = 4
                 .set USER_SP0     = 6
                 .set USER_SP      = 8
                 
                 ; excpection handling
                 .set USER_HANDLER = 10
                 
                 ; numeric IO
                 .set USER_BASE  = 12
                 
                 ; character IO 
                 .set USER_EMIT  = 14
                 .set USER_EMITQ = 16
                 .set USER_KEY   = 18
                 .set USER_KEYQ  = 20
                 
                 .set USER_SOURCE  = 22
                 .set USER_TO_IN   = 24
                 .set USER_REFILL  = 26
                 
                 .set SYSUSERSIZE = 28
                 ; 
                 
                   .def zerol = r2
                   .def zeroh = r3
                   .def upl = r4
                   .def uph = r5
                 
                   .def al  = r6
                   .def ah  = r7
                   .def bl  = r8
                   .def bh  = r9
                 
                 ; internal
                   .def mcu_boot      = r10
                   .def erase_counter = r11
                 
                   .def temp4 = r14
                   .def temp5 = r15
                 
                   .def temp0 = r16
                   .def temp1 = r17
                   .def temp2 = r18
                   .def temp3 = r19
                 
                   .def temp6 = r20
                   .def temp7 = r21
                 
                   .def tosl = r24
                   .def tosh = r25
                 
                   .def wl = r22
                   .def wh = r23
                 
                 .macro loadtos
                     ld tosl, Y+
                     ld tosh, Y+
                 .endmacro
                 
                 .macro savetos
                     st -Y, tosh
                     st -Y, tosl
                 .endmacro
                 
                 .macro in_
                 .if (@1 < $40)
                   in @0,@1
                 .else
                   lds @0,@1
                 .endif
                 .endmacro
                 
                 .macro out_
                 .if (@0 < $40)
                   out @0,@1
                 .else
                   sts @0,@1
                 .endif
                 .endmacro
                 
                 .macro sbi_
                 .if (@0 < $40)
                   sbi @0,@1
                 .else
                   in_ @2,@0
                   ori @2,exp2(@1)
                   out_ @0,@2
                 .endif
                 .endmacro
                 
                 .macro cbi_
                 .if (@0 < $40)
                   cbi @0,@1
                 .else
                   in_ @2,@0
                   andi @2,~(exp2(@1))
                   out_ @0,@2
                 .endif
                 .endmacro
                 
                 .macro jmp_
                 	; a more flexible macro
                     .ifdef @0
                     .if (@0-pc > 2040) || (pc-@0>2040)
                 	jmp @0
                 	.else
                 	rjmp @0
                 	.endif
                 	.else
                 	jmp @0
                 	.endif
                 .endmacro
                 .macro call_
                 	; a more flexible macro
                     .ifdef @0
                     .if (@0-pc > 2040) || (pc-@0>2040)
                 	call @0
                 	.else
                 	rcall @0
                 	.endif
                 	.else
                 	call @0
                 	.endif
                 .endmacro
                 
                 ;               F_CPU
                 ;    µsec   16000000   14745600    8000000  1000000
                 ;    1            16      14,74          8        1
                 ;    10          160     147,45         80       10
                 ;    100        1600    1474,56        800      100
                 ;    1000      16000   14745,6        8000     1000
                 ;
                 ; cycles = µsec * f_cpu / 1e6
                 ; n_loops=cycles/5
                 ;
                 ;     cycles already used will be subtracted from the delay
                 ;     the waittime resolution is 1 cycle (delay from exact to +1 cycle)
                 ;     the maximum delay at 20MHz (50ns/clock) is 38350ns
                 ;     waitcount register must specify an immediate register
                 ;
                 ; busy waits a specfied amount of microseconds
                 .macro   delay
                       .set cycles = ( ( @0 * F_CPU ) / 1000000 )
                       .if (cycles > ( 256 * 255 * 4 + 2))
                         .error "MACRO delay - too many cycles to burn"
                       .else
                         .if (cycles > 6)
                           .set  loop_cycles = (cycles / 4)      
                           ldi   zl,low(loop_cycles)
                           ldi   zh,high(loop_cycles)
                           sbiw  Z, 1
                           brne  pc-1
                           .set  cycles = (cycles - (loop_cycles * 4))
                         .endif
                         .if (cycles > 0)
                           .if   (cycles & 4)
                             rjmp  pc+1
                             rjmp  pc+1
                           .endif
                           .if   (cycles & 2)
                             rjmp  pc+1
                           .endif
                           .if   (cycles & 1)
                             nop
                           .endif
                         .endif
                       .endif
                 .endmacro
                 
                 ; portability macros, they come from the msp430 branches
                 
                 .macro DEST
                     .dw @0
                 .endm
                 
                 ; controller specific file selected via include
                 ; directory definition when calling the assembler (-I)
                 .include "device.asm"
                 
                 ; generated automatically, do not edit
                 
                 .list
                 
                 .equ ramstart =  96
                 .equ CELLSIZE = 2
                 .macro readflashcell
                 	lsl zl
                 	rol zh
                 	lpm @0, Z+
                 	lpm @1, Z+
                 .endmacro
                 .macro writeflashcell
                 	lsl zl
                 	rol zh
                 .endmacro
                 .set WANT_TIMER_COUNTER_0 = 0
                 .set WANT_TIMER_COUNTER_1 = 0
                 .set WANT_EXTERNAL_INTERRUPT = 0
                 .set WANT_EEPROM = 0
                 .set WANT_CPU = 0
                 .set WANT_TIMER_COUNTER_2 = 0
                 .set WANT_SPI = 0
                 .set WANT_USART = 0
                 .set WANT_TWI = 0
                 .set WANT_ANALOG_COMPARATOR = 0
                 .set WANT_AD_CONVERTER = 0
                 .set WANT_JTAG = 0
                 .set WANT_BOOT_LOAD = 0
                 .set WANT_PORTA = 0
                 .set WANT_PORTB = 0
                 .set WANT_PORTC = 0
                 .set WANT_PORTD = 0
                 .set WANT_WATCHDOG = 0
                 .equ intvecsize = 2 ; please verify; flash size: 16384 bytes
                 .equ pclen = 2 ; please verify
                 .overlap
                 .org 2
000002 d109      	 rcall isr ; External Interrupt Request 0
                 .org 4
000004 d107      	 rcall isr ; External Interrupt Request 1
                 .org 6
000006 d105      	 rcall isr ; Timer/Counter2 Compare Match
                 .org 8
000008 d103      	 rcall isr ; Timer/Counter2 Overflow
                 .org 10
00000a d101      	 rcall isr ; Timer/Counter1 Capture Event
                 .org 12
00000c d0ff      	 rcall isr ; Timer/Counter1 Compare Match A
                 .org 14
00000e d0fd      	 rcall isr ; Timer/Counter1 Compare Match B
                 .org 16
000010 d0fb      	 rcall isr ; Timer/Counter1 Overflow
                 .org 18
000012 d0f9      	 rcall isr ; Timer/Counter0 Overflow
                 .org 20
000014 d0f7      	 rcall isr ; Serial Transfer Complete
                 .org 22
000016 d0f5      	 rcall isr ; USART, Rx Complete
                 .org 24
000018 d0f3      	 rcall isr ; USART Data Register Empty
                 .org 26
00001a d0f1      	 rcall isr ; USART, Tx Complete
                 .org 28
00001c d0ef      	 rcall isr ; ADC Conversion Complete
                 .org 30
00001e d0ed      	 rcall isr ; EEPROM Ready
                 .org 32
000020 d0eb      	 rcall isr ; Analog Comparator
                 .org 34
000022 d0e9      	 rcall isr ; 2-wire Serial Interface
                 .org 36
000024 d0e7      	 rcall isr ; External Interrupt Request 2
                 .org 38
000026 d0e5      	 rcall isr ; Timer/Counter0 Compare Match
                 .org 40
000028 d0e3      	 rcall isr ; Store Program Memory Ready
                 .equ INTVECTORS = 21
                 .nooverlap
                 
                 ; compatability layer (maybe empty)
                 .equ EEPE = EEWE
                 .equ EEMPE = EEMWE
                 
                 ; controller data area, environment query mcu-info
                 mcu_info:
                 mcu_ramsize:
000029 0400      	.dw 1024
                 mcu_eepromsize:
00002a 0200      	.dw 512
                 mcu_maxdp:
00002b 3800      	.dw 14336 
                 mcu_numints:
00002c 0015      	.dw 21
                 mcu_name:
00002d 0008      	.dw  8
00002e 5441
00002f 656d
000030 6167
000031 3631      	.db "ATmega16"
                 .set codestart=pc
                 
                 ; some defaults, change them in your application master file
                 ; see template.asm for an example
                 
                 .set AMFORTH_RO_SEG = NRWW_START_ADDR
                 
                 ; receiving is asynchron, so an interrupt queue is useful.
                 .set WANT_ISR_RX = 1
                 
                 ; case insensitve dictionary lookup.
                 .set WANT_IGNORECASE = 0
                 
                 ; map all memories to one address space. Details in the
                 ; technical guide
                 .set WANT_UNIFIED = 0
                 
                 ; terminal input buffer
                 .set TIBSIZE  = 90    ; ANS94 needs at least 80 characters per line
                 
                 ; USER variables *in addition* to system ones
                 .set APPUSERSIZE = 10  ; size of application specific user area in bytes
                 
                 ; addresses of various data segments
                 .set rstackstart = RAMEND      ; start address of return stack, grows downward
                 .set stackstart  = RAMEND - 80 ; start address of data stack, grows downward
                 ; change only if you know what to you do
                 .set NUMWORDLISTS = 8 ; number of word lists in the searh order, at least 8
                 .set NUMRECOGNIZERS = 4 ; total number of recognizers, two are always used.
                 
                 ; 10 per mille (1 per cent) is ok.
                 .set BAUD = 38400
                 .set BAUD_MAXERROR = 10
                 
                 ; Dictionary setup
                 .set VE_HEAD = $0000
                 .set VE_ENVHEAD = $0000
                 
                 
                 .set AMFORTH_RO_SEG = NRWW_START_ADDR+1
                 
                 ; cpu clock in hertz
                 .equ F_CPU = 8000000
                 .set BAUD_MAXERROR = 30
                 .equ TIMER_INT = OVF2addr
                 
                 .include "drivers/usart.asm"
                 
                 .equ BAUDRATE_LOW = UBRRL+$20
                 .equ BAUDRATE_HIGH = UBRRH+$20
                 .equ USART_C = UCSRC+$20
                 .equ USART_B = UCSRB+$20
                 .equ USART_A = UCSRA+$20
                 .equ USART_DATA = UDR+$20
                 .equ bm_USARTC_en   = 1 << 7
                 
                 ; some generic constants
                 .equ bm_USART_RXRD = 1 << RXC
                 .equ bm_USART_TXRD = 1 << UDRE
                 .equ bm_ENABLE_TX  = 1 << TXEN
                 .equ bm_ENABLE_RX  = 1 << RXEN
                 .equ bm_ENABLE_INT_RX = 1<<RXCIE
                 .equ bm_ENABLE_INT_TX = 1<<UDRE
                 
                 .equ bm_ASYNC       = 0 << 6
                 .equ bm_SYNC        = 1 << 6
                 .equ bm_NO_PARITY   = 0 << 4
                 .equ bm_EVEN_PARITY = 2 << 4
                 .equ bm_ODD_PARITY  = 3 << 4
                 .equ bm_1STOPBIT    = 0 << 3
                 .equ bm_2STOPBIT    = 1 << 3
                 .equ bm_5BIT        = 0 << 1
                 .equ bm_6BIT        = 1 << 1
                 .equ bm_7BIT        = 2 << 1
                 .equ bm_8BIT        = 3 << 1
                 
                 .include "drivers/usart_common.asm"
                 
                 .set USART_C_VALUE = bm_ASYNC | bm_NO_PARITY | bm_1STOPBIT | bm_8BIT
                 .if WANT_ISR_RX == 1
                   .set USART_B_VALUE = bm_ENABLE_TX | bm_ENABLE_RX | bm_ENABLE_INT_RX
                   .include "drivers/usart-isr-rx.asm"
                 
                 
                 ; sizes have to be powers of 2!
                 .equ usart_rx_size = $10
                 .equ usart_rx_mask = usart_rx_size - 1
                 .dseg
000060           usart_rx_data: .byte usart_rx_size+2
000072           usart_rx_in: .byte 2
000074           usart_rx_out: .byte 2
                 
                 .cseg
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 ; forth code:
                 ; : rx-isr USART_DATA c@
                 ;    usart_rx_data usart_rx_in c@ dup >r
                 ;    + !
                 ;    r> 1+ usart_rx_mask and usart_rx_in c!
                 ; ;
                 ; setup with
                 ; ' rx-isr URXCaddr int!
                 usart_rx_isr:
000032 93af        push xl
000033 b7af        in xl, SREG
000034 93af        push xl
000035 93bf        push xh
000036 93ef        push zl
000037 93ff        push zh
                 
000038 91b0 002c   lds xh, USART_DATA
                 usart_rx_store:
00003a 91a0 0072   lds xl, usart_rx_in
00003c e6e0        ldi zl, low(usart_rx_data)
00003d e0f0        ldi zh, high(usart_rx_data)
00003e 0fea        add zl, xl
00003f 1df3        adc zh, zeroh
000040 83b0        st Z, xh
                 
000041 95a3        inc xl
000042 70af        andi xl,usart_rx_mask
                 
000043 93a0 0072   sts usart_rx_in, xl
                 
                 usart_rx_isr_finish:
000045 91ff        pop zh
000046 91ef        pop zl
000047 91bf        pop xh
000048 91af        pop xl
000049 bfaf        out SREG, xl
00004a 91af        pop xl
00004b 9518        reti
                 
                 .set usartpc = pc
                 .org URXCaddr
000016 c01b        jmp_ usart_rx_isr
                 .org usartpc
                 
                 
                 ; ( -- ) Hardware Access
                 ; R( --)
                 ; initialize usart
                 ;VE_USART_INIT_RX:
                 ;  .dw $ff06
                 ;  .db "+usart"
                 ;  .dw VE_HEAD
                 ;  .set VE_HEAD = VE_USART_INIT_RX
                 XT_USART_INIT_RX_ISR:
00004c 1c01        .dw DO_COLON
                 PFA_USART_INIT_RX_ISR:          ; ( -- )
00004d 1d4f        .dw XT_ZERO
00004e 1c38        .dw XT_DOLITERAL
00004f 0072        .dw usart_rx_in
000050 1c88        .dw XT_CSTORE
000051 1d4f        .dw XT_ZERO
000052 1c38        .dw XT_DOLITERAL
000053 0074        .dw usart_rx_out
000054 1c88        .dw XT_CSTORE
                 
000055 1c1b        .dw XT_EXIT
                 
                 ; ( -- c)
                 ; MCU
                 ; get 1 character from input queue, wait if needed using interrupt driver
                 VE_RX_ISR:
000056 ff06          .dw $ff06
000057 7872
000058 692d
000059 7273          .db "rx-isr"
00005a 0000          .dw VE_HEAD
                     .set VE_HEAD = VE_RX_ISR
                 XT_RX_ISR:
00005b 1c01          .dw DO_COLON
                 PFA_RX_ISR:
00005c 0075        .dw XT_RXQ_ISR
00005d 1c31        .dw XT_DOCONDBRANCH
00005e 005c        .dw PFA_RX_ISR
00005f 1c38        .dw XT_DOLITERAL
000060 0074        .dw usart_rx_out
000061 1c93        .dw XT_CFETCH
000062 1cac        .dw XT_DUP
000063 1e2a        .dw XT_1PLUS
000064 1c38        .dw XT_DOLITERAL
000065 000f        .dw usart_rx_mask
000066 1e0e        .dw XT_AND
000067 1c38        .dw XT_DOLITERAL
000068 0074        .dw usart_rx_out
000069 1c88        .dw XT_CSTORE
00006a 1c38        .dw XT_DOLITERAL
00006b 0060        .dw usart_rx_data
00006c 1d98        .dw XT_PLUS
00006d 1c93        .dw XT_CFETCH
00006e 1c1b        .dw XT_EXIT
                 
                 ; ( -- f)  
                 ; MCU
                 ; check if unread characters are in the input queue using interrupt driver
                 VE_RXQ_ISR:
00006f ff07          .dw $ff07
000070 7872
000071 2d3f
000072 7369
000073 0072          .db "rx?-isr",0
000074 0056          .dw VE_HEAD
                     .set VE_HEAD = VE_RXQ_ISR
                 XT_RXQ_ISR:
000075 1c01          .dw DO_COLON
                 PFA_RXQ_ISR:
000076 0ad1        .dw XT_PAUSE
000077 1c38        .dw XT_DOLITERAL
000078 0074        .dw usart_rx_out
000079 1c93        .dw XT_CFETCH
00007a 1c38        .dw XT_DOLITERAL
00007b 0072        .dw usart_rx_in
00007c 1c93        .dw XT_CFETCH
00007d 1d0e        .dw XT_NOTEQUAL
00007e 1c1b        .dw XT_EXIT
                   .set XT_RX  = XT_RX_ISR
                   .set XT_RXQ = XT_RXQ_ISR
                   .set XT_USART_INIT_RX = XT_USART_INIT_RX_ISR
                 .else
                 .endif
                 
                 .include "words/usart-tx-poll.asm"
                 
                 ; MCU
                 ; check availability and send one character to the terminal using register poll
                 VE_TX_POLL:
00007f ff07          .dw $ff07
000080 7874
000081 702d
000082 6c6f
000083 006c          .db "tx-poll",0
000084 006f          .dw VE_HEAD
                     .set VE_HEAD = VE_TX_POLL
                 XT_TX_POLL:
000085 1c01          .dw DO_COLON
                 PFA_TX_POLL:
                   ; wait for data ready
000086 0093        .dw XT_TXQ_POLL
000087 1c31        .dw XT_DOCONDBRANCH
000088 0086        .dw PFA_TX_POLL
                   ; send to usart
000089 1c38        .dw XT_DOLITERAL
00008a 002c        .dw USART_DATA
00008b 1c88        .dw XT_CSTORE
00008c 1c1b        .dw XT_EXIT
                 
                 ; ( -- f) MCU
                 ; MCU
                 ; check if a character can be send using register poll
                 VE_TXQ_POLL:
00008d ff08          .dw $ff08
00008e 7874
00008f 2d3f
000090 6f70
000091 6c6c          .db "tx?-poll"
000092 007f          .dw VE_HEAD
                     .set VE_HEAD = VE_TXQ_POLL
                 XT_TXQ_POLL:
000093 1c01          .dw DO_COLON
                 PFA_TXQ_POLL:
000094 0ad1        .dw XT_PAUSE
000095 1c38        .dw XT_DOLITERAL
000096 002b        .dw USART_A
000097 1c93        .dw XT_CFETCH
000098 1c38        .dw XT_DOLITERAL
000099 0020        .dw bm_USART_TXRD
00009a 1e0e        .dw XT_AND
00009b 1c1b        .dw XT_EXIT
                 .set XT_TX  = XT_TX_POLL
                 .set XT_TXQ = XT_TXQ_POLL
                 .set XT_USART_INIT_TX = 0
                 
                 .include "words/ubrr.asm"
                 
                 ; MCU
                 ; returns usart UBRR settings
                 VE_UBRR:
00009c ff04        .dw $ff04
00009d 6275
00009e 7272        .db "ubrr"
00009f 008d        .dw VE_HEAD
                   .set VE_HEAD = VE_UBRR
                 XT_UBRR:
0000a0 1c6a        .dw PFA_DOVALUE1
                 PFA_UBRR:          ; ( -- )
0000a1 007c        .dw EE_UBRRVAL
0000a2 0c3c        .dw XT_EDEFERFETCH
0000a3 0c46        .dw XT_EDEFERSTORE
                 .include "words/usart.asm"
                 
                 ; MCU
                 ; initialize usart
                 VE_USART:
0000a4 ff06        .dw $ff06
0000a5 752b
0000a6 6173
0000a7 7472        .db "+usart"
0000a8 009c        .dw VE_HEAD
                   .set VE_HEAD = VE_USART
                 XT_USART:
0000a9 1c01        .dw DO_COLON
                 PFA_USART:          ; ( -- )
                 
0000aa 1c38        .dw XT_DOLITERAL
0000ab 0098        .dw USART_B_VALUE
0000ac 1c38        .dw XT_DOLITERAL
0000ad 002a        .dw USART_B
0000ae 1c88        .dw XT_CSTORE
                 
0000af 1c38        .dw XT_DOLITERAL
0000b0 0006        .dw USART_C_VALUE
0000b1 1c38        .dw XT_DOLITERAL
0000b2 00c0        .dw USART_C | bm_USARTC_en
0000b3 1c88        .dw XT_CSTORE
                 
0000b4 00a0        .dw XT_UBRR
0000b5 1cac        .dw XT_DUP
0000b6 1ee8        .dw XT_BYTESWAP
0000b7 1c38        .dw XT_DOLITERAL
0000b8 0040        .dw BAUDRATE_HIGH
0000b9 1c88        .dw XT_CSTORE
0000ba 1c38        .dw XT_DOLITERAL
0000bb 0029        .dw BAUDRATE_LOW
0000bc 1c88        .dw XT_CSTORE
                 .if XT_USART_INIT_RX!=0
0000bd 004c        .dw XT_USART_INIT_RX
                 .endif
                 .if XT_USART_INIT_TX!=0
                 .endif
                 
0000be 1c1b        .dw XT_EXIT
                 
                 ; settings for 1wire interface
                 .equ OW_PORT=PORTB
                 .EQU OW_BIT=4
                 .include "drivers/1wire.asm"
                 
                 ;   B. J. Rodriguez (MSP 430)
                 ;   Matthias Trute (AVR Atmega)
                 ; COPYRIGHT
                 ;   (c) 2012 Bradford J. Rodriguez for the 430 code and API
                 
                 ;  adapted 430 assembly code to AVR
                 ;  wishlist: 
                 ;     use a configurable pin at runtime, compatible with bitnames.frt
                 ;     no external pull up, no external power supply for devices
                 ;     ???
                 ;
                 ;.EQU OW_BIT=4
                 ;.equ OW_PORT=PORTE
                 .set OW_DDR=(OW_PORT-1)
                 .set OW_PIN=(OW_DDR-1)
                 
                 ;****f* 1W.RESET
                 ; NAME
                 ;   1W.RESET
                 ; SYNOPSIS
                 ;   1W.RESET ( -- f )  Initialize 1-wire devices; return true if present
                 ; DESCRIPTION
                 ;   This configures the port pin used by the 1-wire interface, and then
                 ;   sends an "initialize" sequence to the 1-wire devices.  If any device
                 ;   is present, it will be detected.
                 ;
                 ;   Timing, per DS18B20 data sheet:
                 ;   a) Output "0" (drive output low) for >480 usec.
                 ;   b) Output "1" (let output float).
                 ;   c) After 15 to 60 usec, device will drive pin low for 60 to 240 usec.
                 ;      So, wait 75 usec and sample input.
                 ;   d) Leave output high (floating) for at least 480 usec.
                 ;******
                 ; ( -- f )
                 ; Hardware
                 ; Initialize 1-wire devices; return true if present
                 VE_OW_RESET:
0000bf ff08          .dw $ff08
0000c0 7731
0000c1 722e
0000c2 7365
0000c3 7465          .db "1w.reset"
0000c4 00a4          .dw VE_HEAD
                     .set VE_HEAD = VE_OW_RESET
                 XT_OW_RESET:
0000c5 00c6          .dw PFA_OW_RESET
                 PFA_OW_RESET:
0000c6 939a
0000c7 938a          savetos
0000c8 2799          clr tosh
                     ; setup to output
0000c9 9abc          sbi OW_DDR, OW_BIT
                     ; Pull output low
0000ca 98c4          cbi OW_PORT, OW_BIT
                     ; Delay >480 usec        
0000cb ece0
0000cc e0f3
0000cd 9731
0000ce f7f1          DELAY   480
                     ; Critical timing period, disable interrupts.
0000cf b71f          in temp1, SREG
0000d0 94f8          cli
                     ; Pull output high
0000d1 9ac4          sbi OW_PORT, OW_BIT
                     ; make pin input, sends "1"
0000d2 98bc          cbi OW_DDR, OW_BIT 
0000d3 e8e0
0000d4 e0f0
0000d5 9731
0000d6 f7f1          DELAY   64 ; delayB
                     ; Sample input pin, set TOS if input is zero
0000d7 b386          in tosl, OW_PIN
0000d8 ff84          sbrs tosl, OW_BIT
0000d9 ef9f          ser  tosh
                     ; End critical timing period, enable interrupts
0000da bf1f          out SREG, temp1
                     ; release bus
0000db 98bc          cbi OW_DDR, OW_BIT
0000dc 98c4          cbi OW_PORT, OW_BIT
                 
                     ; Delay rest of 480 usec 
0000dd e4e0
0000de e0f3
0000df 9731
0000e0 f7f1          DELAY   416
                     ; we now have the result flag in TOS        
0000e1 2f89          mov tosl, tosh
0000e2 940c 1c05     jmp_ DO_NEXT
                     
                 ;****f* 1W.SLOT
                 ; NAME
                 ;   1W.SLOT
                 ; SYNOPSIS
                 ;   1W.SLOT ( c -- c' ) Write and read one bit to/from 1-wire.
                 ; DESCRIPTION
                 ;   The "touch byte" function is described in Dallas App Note 74.
                 ;   It outputs a byte to the 1-wire pin, LSB first, and reads back
                 ;   the state of the 1-wire pin after a suitable delay.
                 ;   To read a byte, output $FF and read the reply data.
                 ;   To write a byte, output that byte and discard the reply.
                 ;
                 ;   This function performs one bit of the "touch" operation --
                 ;   one read/write "slot" in Dallas jargon.  Perform this eight
                 ;   times in a row to get the "touch byte" function.
                 ;
                 ; PARAMETERS
                 ;   The input parameter is xxxxxxxxbbbbbbbo where
                 ;   'xxxxxxxx' are don't cares,
                 ;   'bbbbbbb' are bits to be shifted down, and
                 ;   'o' is the bit to be output in the slot.  This must be 1
                 ;   to create a read slot.
                 ;
                 ;   The returned value is xxxxxxxxibbbbbbb where
                 ;   'xxxxxxxx' are not known (the input shifted down 1 position),
                 ;   'i' is the bit read during the slot.  This has no meaning
                 ;   if it was a write slot.
                 ;   'bbbbbbb' are the 7 input bits, shifted down one position.
                 ;
                 ;   This peculiar parameter usage allows OWTOUCH to be written as
                 ;     OWSLOT OWSLOT OWSLOT OWSLOT OWSLOT OWSLOT OWSLOT OWSLOT 
                 ;
                 ; NOTES 
                 ;   Interrupts are disabled during each bit.
                 
                 ;   Timing, per DS18B20 data sheet:
                 ;   a) Output "0" for start period.  (> 1 us, < 15 us, typ. 6 us*)
                 ;   b) Output data bit (0 or 1), open drain 
                 ;   c) After MS from start of cycle, sample input (15 to 60 us, typ. 25 us*)
                 ;   d) After write-0 period from start of cycle, output "1" (>60 us)
                 ;   e) After recovery period, loop or return. (> 1 us)
                 ;   For writes, DS18B20 samples input 15 to 60 usec from start of cycle.
                 ;   * "Typical" values are per App Note 132 for a 300m cable length.
                 
                 ;   ---------        -------------------------------
                 ;            \      /                        /
                 ;             ------------------------------- 
                 ;            a      b          c             d     e
                 ;            |  6us |   19us   |    35us     | 2us |
                 ;******
                 ; ( c -- c' )
                 ; Hardware
                 ; Write and read one bit to/from 1-wire.
                 VE_OW_SLOT:
0000e4 ff07          .dw $ff07
0000e5 7731
0000e6 732e
0000e7 6f6c
0000e8 0074          .db "1w.slot",0
0000e9 00bf          .dw VE_HEAD
                     .set VE_HEAD = VE_OW_SLOT
                 XT_OW_SLOT:
0000ea 00eb          .dw PFA_OW_SLOT
                 PFA_OW_SLOT:
                     ; pull low
0000eb 9abc          sbi OW_DDR, OW_BIT
0000ec 98c4          cbi OW_PORT, OW_BIT
                     ; disable interrupts
0000ed b71f          in temp1, SREG
0000ee 94f8          cli
0000ef e0ec
0000f0 e0f0
0000f1 9731
0000f2 f7f1          DELAY   6 ; DELAY A
                     ; check bit
0000f3 9488          clc
0000f4 9587          ror tosl
0000f5 f410          brcc PFA_OW_SLOT0 ; a 0 keeps the bus low
                       ; release bus, a 1 is written
0000f6 98bc            cbi OW_DDR, OW_BIT
0000f7 9ac4            sbi OW_PORT, OW_BIT
                 PFA_OW_SLOT0:
                     ; sample the input (no action required if zero)
0000f8 e1e2
0000f9 e0f0
0000fa 9731
0000fb f7f1          DELAY 9   ; wait DELAY E to sample
0000fc b306          in temp0, OW_PIN
0000fd fd04          sbrc temp0, OW_BIT
0000fe 6880          ori tosl, $80
                 
0000ff e6e6
000100 e0f0
000101 9731
000102 f7f1          DELAY   51 ; DELAY B
000103 98bc          cbi OW_DDR, OW_BIT
000104 9ac4          sbi OW_PORT, OW_BIT ; release bus
000105 e0e4
000106 e0f0
000107 9731
000108 f7f1          delay 2
                     ; re-enable interrupts
000109 bf1f          out SREG, temp1
00010a 940c 1c05     jmp_ DO_NEXT
                 
                 .include "amforth.asm"
                 
                 ;;;;
                 ;;;; GPL V2 (only)
                 
                 .set AMFORTH_NRWW_SIZE=(FLASHEND-AMFORTH_RO_SEG)*2
                 
                 .set corepc = pc
                 .org $0000
000000 940c 0ada   jmp_ PFA_COLD
                 
                 .org corepc
                 .include "drivers/generic-isr.asm"
                 
                 .dseg
000076           intcur: .byte 1
                 .eseg
000000           intvec: .byte INTVECTORS * CELLSIZE
                 .cseg
                 
                 ; interrupt routine gets called (again) by rcall! This gives the
                 ; address of the int-vector on the stack.
                 isr:
00010c 920a          st -Y, r0
00010d b60f          in r0, SREG
00010e 920a          st -Y, r0
                 .if (pclen==3)
                 .endif
00010f 900f          pop r0
000110 900f          pop r0          ; = intnum * intvectorsize + 1 (address following the rcall)
000111 940a          dec r0
                 .if intvecsize == 1 ;
                 .endif
000112 9200 0076     sts intcur, r0
000114 9009          ld r0, Y+
000115 be0f          out SREG, r0
000116 9009          ld r0, Y+
000117 9468          set ; set the interrupt flag for the inner interpreter
000118 9508          ret ; returns the interrupt, the rcall stack frame is removed!
                 
                 ; lower part of the dictionary
                 .include "dict/rww.inc"
                 
                 
                 ; Arithmetics
                 ; add a number to a double cell
                 VE_MPLUS:
000119 ff02          .dw $ff02
00011a 2b6d          .db "m+"
00011b 00e4          .dw VE_HEAD
                     .set VE_HEAD = VE_MPLUS
                 XT_MPLUS:
00011c 1c01          .dw DO_COLON
                 PFA_MPLUS:
00011d 0deb          .dw XT_S2D
00011e 01a3          .dw XT_DPLUS
00011f 1c1b          .dw XT_EXIT
                 .include "words/ud-star.asm"
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_UDSTAR:
000120 ff03          .dw $ff03
000121 6475
../../common\words/ud-star.asm(9): warning: .cseg .db misalignment - padding zero byte
000122 002a          .db "ud*"
000123 0119          .dw VE_HEAD
                     .set VE_HEAD = VE_UDSTAR
                 XT_UDSTAR:
000124 1c01          .dw DO_COLON
                 PFA_UDSTAR:
                 
                 .endif
                 ;Z UD*      ud1 d2 -- ud3      32*16->32 multiply
                 ;   XT_DUP >R UM* DROP  XT_SWAP R> UM* ROT + ;
                 
000125 1cac
000126 1cfa
000127 1ddb
000128 1cd4              .DW XT_DUP,XT_TO_R,XT_UMSTAR,XT_DROP
000129 1cbf
00012a 1cf1
00012b 1ddb
00012c 1cdc
00012d 1d98
00012e 1c1b              .DW XT_SWAP,XT_R_FROM,XT_UMSTAR,XT_ROT,XT_PLUS,XT_EXIT
                 .include "words/umax.asm"
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_UMAX:
00012f ff04          .dw $ff04
000130 6d75
000131 7861          .db "umax"
000132 0120          .dw VE_HEAD
                     .set VE_HEAD = VE_UMAX
                 XT_UMAX:
000133 1c01          .dw DO_COLON
                 PFA_UMAX:
                 .endif
                 
000134 05f8
000135 1d57              .DW XT_2DUP,XT_ULESS
000136 1c31      	.dw XT_DOCONDBRANCH
000137 0139      	 DEST(UMAX1)
000138 1cbf              .DW XT_SWAP
000139 1cd4      UMAX1:  .DW XT_DROP
00013a 1c1b      	.dw XT_EXIT
                 .include "words/umin.asm"
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_UMIN:
00013b ff04          .dw $ff04
00013c 6d75
00013d 6e69          .db "umin"
00013e 012f          .dw VE_HEAD
                     .set VE_HEAD = VE_UMIN
                 XT_UMIN:
00013f 1c01          .dw DO_COLON
                 PFA_UMIN:
                 .endif
000140 05f8
000141 1d62              .DW XT_2DUP,XT_UGREATER
000142 1c31      	.dw XT_DOCONDBRANCH
000143 0145      	DEST(UMIN1)
000144 1cbf              .DW XT_SWAP
000145 1cd4      UMIN1:  .DW XT_DROP
000146 1c1b      	.dw XT_EXIT
                 .include "words/immediate-q.asm"
                 
                 ; Tools
                 ; get count information out of a counted string in flash
                 ;VE_IMMEDIATEQ:
                 ;    .dw $ff06
                 ;    .db "immediate?"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_IMMEDIATEQ
                 XT_IMMEDIATEQ:
000147 1c01          .dw DO_COLON
                 PFA_IMMEDIATEQ:
000148 1c38          .dw XT_DOLITERAL
000149 8000          .dw $8000
00014a 1e0e          .dw XT_AND
00014b 1d15          .dw XT_ZEROEQUAL
00014c 1c31          .dw XT_DOCONDBRANCH
00014d 0151          DEST(IMMEDIATEQ1)
00014e 1c38           .dw XT_DOLITERAL
00014f 0001           .dw 1
000150 1c1b           .dw XT_EXIT
                 IMMEDIATEQ1:
                     ; not immediate
000151 1d46          .dw XT_TRUE
000152 1c1b          .dw XT_EXIT
                 .include "words/name2flags.asm"
                 
                 ; Tools
                 ; get the flags from a name token
                 VE_NAME2FLAGS:
000153 ff0a          .dw $ff0a
000154 616e
000155 656d
000156 663e
000157 616c
000158 7367          .db "name>flags"
000159 013b          .dw VE_HEAD
                     .set VE_HEAD = VE_NAME2FLAGS
                 XT_NAME2FLAGS:
00015a 1c01          .dw DO_COLON
                 PFA_NAME2FLAGS:
00015b 1fbb          .dw XT_FETCHI ; skip to link field
00015c 1c38          .dw XT_DOLITERAL
00015d ff00          .dw $ff00
00015e 1e0e          .dw XT_AND
00015f 1c1b          .dw XT_EXIT
                 .include "words/name2interpret.asm"
                 
                 ; Tools (ext)
                 ; get the execution token from the name token
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_NAME2INTERPRET:
000160 ff0e          .dw $ff0e
000161 616e
000162 656d
000163 693e
000164 746e
000165 7265
000166 7270
000167 7465          .db "name>interpret"
000168 0153          .dw VE_HEAD
                     .set VE_HEAD = VE_NAME2INTERPRET
                 XT_NAME2INTERPRET:
000169 1c01          .dw DO_COLON
                 PFA_NAME2INTERPRET:
                 .endif
00016a 0d06          .dw XT_NFA2CFA
00016b 1c1b          .dw XT_EXIT
                 .include "words/name2compile.asm"
                 
                 ; Tools (ext)
                 ; get the execution token from the name token in compile state
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_NAME2COMPILE:
00016c ff0c          .dw $ff0c
00016d 616e
00016e 656d
00016f 633e
000170 6d6f
000171 6970
000172 656c          .db "name>compile"
000173 0160          .dw VE_HEAD
                     .set VE_HEAD = VE_NAME2COMPILE
                 XT_NAME2COMPILE:
000174 1c01          .dw DO_COLON
                 PFA_NAME2COMPILE:
                 .endif
000175 1cac          .dw XT_DUP
000176 0d06          .dw XT_NFA2CFA
000177 1cbf          .dw XT_SWAP
000178 015a          .dw XT_NAME2FLAGS
000179 0147          .dw XT_IMMEDIATEQ
00017a 1c31          .dw XT_DOCONDBRANCH
00017b 017f          DEST(NAME2COMPILE1)
00017c 1c38      	.dw XT_DOLITERAL
00017d 02ba      	.dw XT_COMMA
00017e 1c1b      	.dw XT_EXIT
                 NAME2COMPILE1:
00017f 1c38      	.dw XT_DOLITERAL
000180 1c25      	.dw XT_EXECUTE
000181 1c1b          .dw XT_EXIT
                 
                 .if AMFORTH_NRWW_SIZE > 8000
                 .elif AMFORTH_NRWW_SIZE > 4000
                 .elif AMFORTH_NRWW_SIZE > 2000
                 .include "dict/appl_2k.inc"
                 
                 
                 ; Arithmetics
                 ; shift a double cell left
                 VE_D2STAR:
000182 ff03          .dw $ff03
000183 3264
000184 002a          .db "d2*",0
000185 016c          .dw VE_HEAD
                     .set VE_HEAD = VE_D2STAR
                 XT_D2STAR:
000186 0187          .dw PFA_D2STAR
                 PFA_D2STAR:
000187 9109          ld temp0, Y+
000188 9119          ld temp1, Y+
000189 0f00          lsl temp0
00018a 1f11          rol temp1
00018b 1f88          rol tosl
00018c 1f99          rol tosh
00018d 931a          st -Y, temp1
00018e 930a          st -Y, temp0
00018f 940c 1c05     jmp_ DO_NEXT
                 .include "words/d-2slash.asm"
                 
                 ; Arithmetics
                 ; shift a double cell value right
                 VE_D2SLASH:
000191 ff03          .dw $ff03
000192 3264
000193 002f          .db "d2/",0
000194 0182          .dw VE_HEAD
                     .set VE_HEAD = VE_D2SLASH
                 XT_D2SLASH:
000195 0196          .dw PFA_D2SLASH
                 PFA_D2SLASH:
000196 9109          ld temp0, Y+
000197 9119          ld temp1, Y+
000198 9595          asr tosh
000199 9587          ror tosl
00019a 9517          ror temp1
00019b 9507          ror temp0
00019c 931a          st -Y, temp1
00019d 930a          st -Y, temp0
00019e 940c 1c05     jmp_ DO_NEXT
                 .include "words/d-plus.asm"
                 
                 ; Arithmetics
                 ; add 2 double cell values
                 VE_DPLUS:
0001a0 ff02          .dw $ff02
0001a1 2b64          .db "d+"
0001a2 0191          .dw VE_HEAD
                     .set VE_HEAD = VE_DPLUS
                 XT_DPLUS:
0001a3 01a4          .dw PFA_DPLUS
                 PFA_DPLUS:
0001a4 9129          ld temp2, Y+
0001a5 9139          ld temp3, Y+
                 
0001a6 90e9          ld temp4, Y+
0001a7 90f9          ld temp5, Y+
0001a8 9149          ld temp6, Y+
0001a9 9159          ld temp7, Y+
                 
0001aa 0f24          add temp2, temp6
0001ab 1f35          adc temp3, temp7
0001ac 1d8e          adc tosl, temp4
0001ad 1d9f          adc tosh, temp5
                     
0001ae 933a          st -Y, temp3
0001af 932a          st -Y, temp2
0001b0 940c 1c05     jmp_ DO_NEXT
                 .include "words/d-minus.asm"
                 
                 ; Arithmetics
                 ; subtract d2 from d1 
                 VE_DMINUS:
0001b2 ff02          .dw $ff02
0001b3 2d64          .db "d-"
0001b4 01a0          .dw VE_HEAD
                     .set VE_HEAD = VE_DMINUS
                 XT_DMINUS:
0001b5 01b6          .dw PFA_DMINUS
                 PFA_DMINUS:
0001b6 9129          ld temp2, Y+
0001b7 9139          ld temp3, Y+
                 
0001b8 90e9          ld temp4, Y+
0001b9 90f9          ld temp5, Y+
0001ba 9149          ld temp6, Y+
0001bb 9159          ld temp7, Y+
                 
0001bc 1b42          sub temp6, temp2
0001bd 0b53          sbc temp7, temp3
0001be 0ae8          sbc temp4, tosl
0001bf 0af9          sbc temp5, tosh
                 
0001c0 935a          st -Y, temp7
0001c1 934a          st -Y, temp6
0001c2 01c7          movw tosl, temp4
0001c3 940c 1c05     jmp_ DO_NEXT
                 .include "words/d-invert.asm"
                 
                 ; Arithmetics
                 ; invert all bits in the double cell value
                 VE_DINVERT:
0001c5 ff07          .dw $ff07
0001c6 6964
0001c7 766e
0001c8 7265
0001c9 0074          .db "dinvert",0
0001ca 01b2          .dw VE_HEAD
                     .set VE_HEAD = VE_DINVERT
                 XT_DINVERT:
0001cb 01cc          .dw PFA_DINVERT
                 PFA_DINVERT:
0001cc 9109          ld temp0, Y+
0001cd 9119          ld temp1, Y+
0001ce 9580          com tosl
0001cf 9590          com tosh
0001d0 9500          com temp0
0001d1 9510          com temp1
0001d2 931a          st -Y, temp1
0001d3 930a          st -Y, temp0
0001d4 940c 1c05     jmp_ DO_NEXT
                 .include "words/d-equal.asm"
                 
                 ; Compare
                 ; compares two double cell values
                 VE_DEQUAL:
0001d6 ff02          .dw $ff02
0001d7 3d64          .db "d="
0001d8 01c5          .dw VE_HEAD
                     .set VE_HEAD = VE_DEQUAL
                 XT_DEQUAL:
0001d9 1c01          .dw DO_COLON
                 PFA_DEQUAL:
0001da 01b5          .dw XT_DMINUS
0001db 1e17          .dw XT_OR
0001dc 1d15          .dw XT_ZEROEQUAL
0001dd 1c1b          .dw XT_EXIT
                 .include "words/u-dot.asm"
                 
                 ; Numeric IO
                 ; unsigned PNO with single cell numbers
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_UDOT:
0001de ff02          .dw $ff02
0001df 2e75          .db "u."
0001e0 01d6          .dw VE_HEAD
                     .set VE_HEAD = VE_UDOT
                 XT_UDOT:
0001e1 1c01          .dw DO_COLON
                 PFA_UDOT:
                 .endif
0001e2 1d4f          .dw XT_ZERO
0001e3 07c9          .dw XT_UDDOT
0001e4 1c1b          .dw XT_EXIT
                 ; : u.        ( us -- )    0 ud. ;
                 .include "words/u-dot-r.asm"
                 
                 ; Numeric IO
                 ; unsigned PNO with single cells numbers, right aligned in width w
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 
                 VE_UDOTR:
0001e5 ff03          .dw $ff03
0001e6 2e75
0001e7 0072          .db "u.r",0
0001e8 01de          .dw VE_HEAD
                     .set VE_HEAD = VE_UDOTR
                 XT_UDOTR:
0001e9 1c01          .dw DO_COLON
                 PFA_UDOTR:
                 .endif
0001ea 1d4f          .dw XT_ZERO
0001eb 1cbf          .dw XT_SWAP
0001ec 07d2          .dw XT_UDDOTR
0001ed 1c1b          .dw XT_EXIT
                 ; : u.r       ( s n -- )   0 swap ud.r ;
                 
                 .include "words/show-wordlist.asm"
                 
                 ; Tools
                 ; prints the name of the words in a wordlist
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SHOWWORDLIST:
0001ee ff0d          .dw $ff0d
0001ef 6873
0001f0 776f
0001f1 772d
0001f2 726f
0001f3 6c64
0001f4 7369
0001f5 0074          .db "show-wordlist",0
0001f6 01e5          .dw VE_HEAD
                     .set VE_HEAD = VE_SHOWWORDLIST
                 XT_SHOWWORDLIST:
0001f7 1c01          .dw DO_COLON
                 PFA_SHOWWORDLIST:
                 .endif
0001f8 1c38          .dw XT_DOLITERAL
0001f9 01fd          .dw XT_SHOWWORD
0001fa 1cbf          .dw XT_SWAP
0001fb 0cdf          .dw XT_TRAVERSEWORDLIST
0001fc 1c1b          .dw XT_EXIT
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 XT_SHOWWORD:
0001fd 1c01          .dw DO_COLON
                 PFA_SHOWWORD:
                 .endif
0001fe 0cfa          .dw XT_NAME2STRING
0001ff 083f          .dw XT_ITYPE
000200 0881          .dw XT_SPACE         ; ( -- addr n)
000201 1d46          .dw XT_TRUE
000202 1c1b          .dw XT_EXIT
                 .include "words/words.asm"
                 
                 ; Tools
                 ; prints a list of all (visible) words in the dictionary
                 VE_WORDS:
000203 ff05          .dw $ff05
000204 6f77
000205 6472
000206 0073          .db "words",0
000207 01ee          .dw VE_HEAD
                     .set VE_HEAD = VE_WORDS
                 XT_WORDS:
000208 1c01          .dw DO_COLON
                 PFA_WORDS:
000209 1c38          .dw XT_DOLITERAL
00020a 0040          .dw CFG_ORDERLIST
00020b 1f4e          .dw XT_FETCHE
00020c 01f7          .dw XT_SHOWWORDLIST
00020d 1c1b          .dw XT_EXIT
                 .include "dict/interrupt.inc"
                 
                 .include "words/int-on.asm"
                 
                 ; Interrupt
                 ; turns on all interrupts
                 VE_INTON:
00020e ff04          .dw $ff04
00020f 692b
000210 746e          .db "+int"
000211 0203          .dw VE_HEAD
                     .set VE_HEAD = VE_INTON
                 XT_INTON:
000212 0213          .dw PFA_INTON
                 PFA_INTON:
000213 9478          sei
000214 940c 1c05     jmp_ DO_NEXT
                 .include "words/int-off.asm"
                 
                 ; Interrupt
                 ; turns off all interrupts 
                 VE_INTOFF:
000216 ff04          .dw $ff04
000217 692d
000218 746e          .db "-int"
000219 020e          .dw VE_HEAD
                     .set VE_HEAD = VE_INTOFF
                 XT_INTOFF:
00021a 021b          .dw PFA_INTOFF
                 PFA_INTOFF:
00021b 94f8          cli
00021c 940c 1c05     jmp_ DO_NEXT
                 .include "words/int-store.asm"
                 
                 ; Interrupt
                 ; stores XT as interrupt vector i
                 VE_INTSTORE:
00021e ff04          .dw $ff04
00021f 6e69
000220 2174          .db "int!"
000221 0216          .dw VE_HEAD
                     .set VE_HEAD = VE_INTSTORE
                 XT_INTSTORE:
000222 1c01          .dw DO_COLON
                 PFA_INTSTORE:
000223 1c38          .dw XT_DOLITERAL
000224 0000          .dw intvec
000225 1d98          .dw XT_PLUS
000226 1f2a          .dw XT_STOREE
000227 1c1b          .dw XT_EXIT
                 .include "words/int-fetch.asm"
                 
                 ; Interrupt
                 ; fetches XT from interrupt vector i
                 VE_INTFETCH:
000228 ff04          .dw $ff04
000229 6e69
00022a 4074          .db "int@"
00022b 021e          .dw VE_HEAD
                     .set VE_HEAD = VE_INTFETCH
                 XT_INTFETCH:
00022c 1c01          .dw DO_COLON
                 PFA_INTFETCH:
00022d 1c38          .dw XT_DOLITERAL
00022e 0000          .dw intvec
00022f 1d98          .dw XT_PLUS
000230 1f4e          .dw XT_FETCHE
000231 1c1b          .dw XT_EXIT
                 .include "words/int-trap.asm"
                 
                 ; Interrupt
                 ; trigger an interrupt
                 VE_INTTRAP:
000232 ff08          .dw $ff08
000233 6e69
000234 2d74
000235 7274
000236 7061          .db "int-trap"
000237 0228          .dw VE_HEAD
                     .set VE_HEAD = VE_INTTRAP
                 XT_INTTRAP:
000238 0239          .dw PFA_INTTRAP
                 PFA_INTTRAP:
000239 9380 0076     sts intcur, tosl
00023b 9189
00023c 9199          loadtos
00023d 9468          set ; set the interrupt flag for the inner interpreter
00023e 940c 1c05     jmp_ DO_NEXT
                 
                 .include "words/isr-exec.asm"
                 
                 ; Interrupt
                 ; executes an interrupt service routine
                 ;VE_ISREXEC:
                 ;    .dw $ff08
                 ;    .db "isr-exec"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_ISREXEC
                 XT_ISREXEC:
000240 1c01          .dw DO_COLON
                 PFA_ISREXEC:
000241 1c38          .dw XT_DOLITERAL
000242 0076          .dw intcur
000243 1c93          .dw XT_CFETCH
000244 1c38          .dw XT_DOLITERAL
000245 0000          .dw intvec
000246 1d98          .dw XT_PLUS
000247 1f4e          .dw XT_FETCHE
000248 1c25          .dw XT_EXECUTE
000249 024b          .dw XT_ISREND
00024a 1c1b          .dw XT_EXIT
                 .include "words/isr-end.asm"
                 
                 ; Interrupt
                 ; re-enables interrupts in an ISR
                 ;VE_ISREND:
                 ;    .dw $ff07
                 ;    .db "isr-end",0
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_ISREND
                 XT_ISREND:
00024b 024c          .dw PFA_ISREND
                 PFA_ISREND:
00024c d002          rcall PFA_ISREND1 ; clear the interrupt flag for the controller
00024d 940c 1c05     jmp_ DO_NEXT
                 PFA_ISREND1:
00024f 9518          reti
                 
                 .include "words/pick.asm"
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_PICK:
000250 ff04          .dw $ff04
000251 6970
000252 6b63          .db "pick"
000253 0232          .dw VE_HEAD
                     .set VE_HEAD = VE_PICK
                 XT_PICK:
000254 1c01          .dw DO_COLON
                 PFA_PICK:
                 .endif
000255 1e2a          .dw XT_1PLUS
000256 05ea          .dw XT_CELLS
000257 1e7c          .dw XT_SP_FETCH
000258 1d98          .dw XT_PLUS
000259 1c74          .dw XT_FETCH
00025a 1c1b          .dw XT_EXIT
                 .include "words/dot-quote.asm"
                 
                 ; Compiler
                 ; compiles string into dictionary to be printed at runtime
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 
                 VE_DOTSTRING:
00025b 0002          .dw $0002
00025c 222e          .db ".",$22
00025d 0250          .dw VE_HEAD
                     .set VE_HEAD = VE_DOTSTRING
                 XT_DOTSTRING:
00025e 1c01          .dw DO_COLON
                 PFA_DOTSTRING:
                 .endif
00025f 0266          .dw XT_SQUOTE
000260 02af          .dw XT_COMPILE
000261 083f          .dw XT_ITYPE
000262 1c1b          .dw XT_EXIT
                 .include "words/squote.asm"
                 
                 ; Compiler
                 ; compiles a string to flash, at runtime leaves ( -- flash-addr count) on stack
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SQUOTE:
000263 0002        .dw $0002
000264 2273        .db "s",$22
000265 025b        .dw VE_HEAD
                   .set VE_HEAD = VE_SQUOTE
                 XT_SQUOTE:
000266 1c01          .dw DO_COLON
                 PFA_SQUOTE:
                 .endif
000267 1c38          .dw XT_DOLITERAL
000268 0022          .dw 34   ; 0x22 
000269 0a1e          .dw XT_PARSE       ; ( -- addr n)
00026a 05dd          .dw XT_STATE
00026b 1c74          .dw XT_FETCH
00026c 1c31          .dw XT_DOCONDBRANCH
00026d 026f          DEST(PFA_SQUOTE1)
00026e 02db            .dw XT_SLITERAL
                 PFA_SQUOTE1:
00026f 1c1b          .dw XT_EXIT
                 
                 .include "words/fill.asm"
                 
                 ; Memory
                 ; fill u bytes memory beginning at a-addr with character c
                 VE_FILL:
000270 ff04          .dw $ff04
000271 6966
000272 6c6c          .db "fill"
000273 0263          .dw VE_HEAD
                     .set VE_HEAD = VE_FILL
                 XT_FILL:
000274 1c01          .dw DO_COLON
                 PFA_FILL:
000275 1cdc          .dw XT_ROT
000276 1cdc          .dw XT_ROT
000277 1cb4
000278 1c31          .dw XT_QDUP,XT_DOCONDBRANCH
000279 0281          DEST(PFA_FILL2)
00027a 0de2          .dw XT_BOUNDS
00027b 1e8a          .dw XT_DODO
                 PFA_FILL1:
00027c 1cac          .dw XT_DUP
00027d 1e9b          .dw XT_I
00027e 1c88          .dw XT_CSTORE  ; ( -- c c-addr)
00027f 1eb8          .dw XT_DOLOOP
000280 027c          .dw PFA_FILL1
                 PFA_FILL2:
000281 1cd4          .dw XT_DROP
000282 1c1b          .dw XT_EXIT
                 .include "dict/compiler1.inc"
                 
                 .include "words/docreate.asm"
                 
                 ; Compiler
                 ; parse the input and create an empty vocabulary entry without XT and data field (PF)
                 VE_DOCREATE:
000283 ff08          .dw $ff08
000284 6328
000285 6572
000286 7461
000287 2965          .db "(create)"
000288 0270          .dw VE_HEAD
                     .set VE_HEAD = VE_DOCREATE
                 XT_DOCREATE:
000289 1c01          .dw DO_COLON
                 PFA_DOCREATE:
00028a 0a4c          .dw XT_PARSENAME
00028b 03e4          .dw XT_WLSCOPE
00028c 1cac          .dw XT_DUP
00028d 1cfa          .dw XT_TO_R
00028e 03c9          .dw XT_HEADER
00028f 1cf1          .dw XT_R_FROM
                 .dseg
000077           COLON_SMUDGE: .byte 4
                 .cseg
000290 1c38          .dw XT_DOLITERAL
000291 0079          .dw COLON_SMUDGE+2
000292 1c7c          .dw XT_STORE		; save wid
000293 1c38          .dw XT_DOLITERAL
000294 0077          .dw COLON_SMUDGE+0
000295 1c7c          .dw XT_STORE		; save NFA
                 
000296 1c1b          .dw XT_EXIT
                 .include "words/backslash.asm"
                 
                 ; Compiler
                 ; everything up to the end of the current line is a comment
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_BACKSLASH:
000297 0001          .dw $0001
000298 005c          .db $5c,0
000299 0283          .dw VE_HEAD
                     .set VE_HEAD = VE_BACKSLASH
                 XT_BACKSLASH:
00029a 1c01          .dw DO_COLON
                 PFA_BACKSLASH:
                 .endif
00029b 0a33          .dw XT_SOURCE
00029c 1ceb          .dw XT_NIP
00029d 0611          .dw XT_TO_IN
00029e 1c7c          .dw XT_STORE
00029f 1c1b          .dw XT_EXIT
                 .include "words/l-paren.asm"
                 
                 ; Compiler
                 ; skip everything up to the closing bracket on the same line
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_LPAREN:
0002a0 0001          .dw $0001
0002a1 0028          .db "(" ,0
0002a2 0297          .dw VE_HEAD
                     .set VE_HEAD = VE_LPAREN
                 XT_LPAREN:
0002a3 1c01          .dw DO_COLON
                 PFA_LPAREN:
                 .endif
0002a4 1c38          .dw XT_DOLITERAL
0002a5 0029          .dw ')'
0002a6 0a1e          .dw XT_PARSE
0002a7 0601          .dw XT_2DROP
0002a8 1c1b          .dw XT_EXIT
                 
                 .include "words/compile.asm"
                 
                 ; Dictionary
                 ; read the following cell from the dictionary and append it to the current dictionary position.
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_COMPILE:
0002a9 ff07          .dw $ff07
0002aa 6f63
0002ab 706d
0002ac 6c69
0002ad 0065          .db "compile",0
0002ae 02a0          .dw  VE_HEAD
                     .set VE_HEAD = VE_COMPILE
                 XT_COMPILE:
0002af 1c01          .dw DO_COLON
                 PFA_COMPILE:
                 .endif
0002b0 1cf1          .dw XT_R_FROM
0002b1 1cac          .dw XT_DUP
0002b2 0c33          .dw XT_ICELLPLUS
0002b3 1cfa          .dw XT_TO_R
0002b4 1fbb          .dw XT_FETCHI
0002b5 02ba          .dw XT_COMMA
0002b6 1c1b          .dw XT_EXIT
                 .include "words/comma.asm"
                 
                 ; Dictionary
                 ; compile 16 bit into flash at DP
                 VE_COMMA:
0002b7 ff01          .dw $ff01
0002b8 002c          .db ',',0 ; ,
0002b9 02a9          .dw VE_HEAD
                     .set VE_HEAD = VE_COMMA
                 XT_COMMA:
0002ba 1c01          .dw DO_COLON
                 PFA_COMMA:
0002bb 0647          .dw XT_DP
0002bc 1f62          .dw XT_STOREI
0002bd 0647          .dw XT_DP
0002be 1e2a          .dw XT_1PLUS
0002bf 0c21          .dw XT_DOTO
0002c0 0648          .dw PFA_DP
0002c1 1c1b          .dw XT_EXIT
                 .include "words/brackettick.asm"
                 
                 ; Compiler
                 ; what ' does in the interpreter mode, do in colon definitions
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_BRACKETTICK:
0002c2 0003          .dw $0003
0002c3 275b
0002c4 005d          .db "[']",0
0002c5 02b7          .dw VE_HEAD
                     .set VE_HEAD = VE_BRACKETTICK
                 XT_BRACKETTICK:
0002c6 1c01          .dw DO_COLON
                 PFA_BRACKETTICK:
                 .endif
0002c7 08a9          .dw XT_TICK
0002c8 02d0          .dw XT_LITERAL
0002c9 1c1b          .dw XT_EXIT
                 
                 
                 .include "words/literal.asm"
                 
                 ; Compiler
                 ; compile a literal in colon defintions
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_LITERAL:
0002ca 0007          .dw $0007
0002cb 696c
0002cc 6574
0002cd 6172
0002ce 006c          .db "literal",0
0002cf 02c2          .dw VE_HEAD
                     .set VE_HEAD = VE_LITERAL
                 XT_LITERAL:
0002d0 1c01          .dw DO_COLON
                 PFA_LITERAL:
                 .endif
0002d1 02af              .DW XT_COMPILE
0002d2 1c38              .DW XT_DOLITERAL
0002d3 02ba              .DW XT_COMMA
0002d4 1c1b              .DW XT_EXIT
                 .include "words/sliteral.asm"
                 
                 ; String
                 ; compiles a string to flash, at runtime leaves ( -- flash-addr count) on stack
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SLITERAL:
0002d5 0008        .dw $0008
0002d6 6c73
0002d7 7469
0002d8 7265
0002d9 6c61        .db "sliteral"
0002da 02ca        .dw VE_HEAD
                   .set VE_HEAD = VE_SLITERAL
                 XT_SLITERAL:
0002db 1c01          .dw DO_COLON
                 PFA_SLITERAL:
                 .endif
0002dc 02af          .dw XT_COMPILE
0002dd 080c          .dw XT_DOSLITERAL    ; ( -- addr n)
0002de 081a          .dw XT_SCOMMA
0002df 1c1b          .dw XT_EXIT
                 .include "words/g-mark.asm"
                 
                 ; Compiler
                 ; places current dictionary position for backward resolves
                 ;VE_GMARK:
                 ;    .dw $ff05
                 ;    .db ">mark"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_GMARK
                 XT_GMARK:
0002e0 1c01          .dw DO_COLON
                 PFA_GMARK:
0002e1 0647          .dw XT_DP
0002e2 02af          .dw XT_COMPILE
0002e3 ffff          .dw -1           ; ffff does not erase flash
0002e4 1c1b          .dw XT_EXIT
                 .include "words/g-resolve.asm"
                 
                 ; Compiler
                 ; resolve backward jumps
                 ;VE_GRESOLVE:
                 ;    .dw $ff08
                 ;    .db ">resolve"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_GRESOLVE
                 XT_GRESOLVE:
0002e5 1c01          .dw DO_COLON
                 PFA_GRESOLVE:
0002e6 0bde          .dw XT_QSTACK
0002e7 0647          .dw XT_DP
0002e8 1cbf          .dw XT_SWAP
0002e9 1f62          .dw XT_STOREI
0002ea 1c1b          .dw XT_EXIT
                 .include "words/l_mark.asm"
                 
                 ; Compiler
                 ; place destination for backward branch
                 ;VE_LMARK:
                 ;    .dw $ff05
                 ;    .db "<mark"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_LMARK
                 XT_LMARK:
0002eb 1c01          .dw DO_COLON
                 PFA_LMARK:
0002ec 0647          .dw XT_DP
0002ed 1c1b          .dw XT_EXIT
                 .include "words/l_resolve.asm"
                 
                 ; Compiler
                 ; resolve backward branch
                 ;VE_LRESOLVE:
                 ;    .dw $ff08
                 ;    .db "<resolve"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_LRESOLVE
                 XT_LRESOLVE:
0002ee 1c01          .dw DO_COLON
                 PFA_LRESOLVE:
0002ef 0bde          .dw XT_QSTACK
0002f0 02ba          .dw XT_COMMA
0002f1 1c1b          .dw XT_EXIT
                 
                 .include "words/ahead.asm"
                 
                 ; Compiler
                 ; do a unconditional branch
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_AHEAD:
0002f2 0005          .dw $0005
0002f3 6861
0002f4 6165
0002f5 0064          .db "ahead",0
0002f6 02d5          .dw VE_HEAD
                     .set VE_HEAD = VE_AHEAD
                 XT_AHEAD:
0002f7 1c01          .dw DO_COLON
                 PFA_AHEAD:
                 .endif
0002f8 02af          .dw XT_COMPILE
0002f9 1c2a          .dw XT_DOBRANCH
0002fa 02e0          .dw XT_GMARK
0002fb 1c1b          .dw XT_EXIT
                 .include "words/if.asm"
                 
                 ; Compiler
                 ; start conditional branch
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_IF:
0002fc 0002          .dw $0002
0002fd 6669          .db "if"
0002fe 02f2          .dw VE_HEAD
                     .set VE_HEAD = VE_IF
                 XT_IF:
0002ff 1c01          .dw DO_COLON
                 PFA_IF:
                 .endif
000300 02af          .dw XT_COMPILE
000301 1c31          .dw XT_DOCONDBRANCH
000302 02e0          .dw XT_GMARK
000303 1c1b          .dw XT_EXIT
                 .include "words/else.asm"
                 
                 ; Compiler
                 ; resolve the forward reference and place a new unresolved forward reference
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_ELSE:
000304 0004          .dw $0004
000305 6c65
000306 6573          .db "else"
000307 02fc          .dw VE_HEAD
                     .set VE_HEAD = VE_ELSE
                 XT_ELSE:
000308 1c01          .dw DO_COLON
                 PFA_ELSE:
                 .endif
000309 02af          .dw XT_COMPILE
00030a 1c2a          .dw XT_DOBRANCH
00030b 02e0          .dw XT_GMARK
00030c 1cbf          .dw XT_SWAP
00030d 02e5          .dw XT_GRESOLVE
00030e 1c1b          .dw XT_EXIT
                 .include "words/then.asm"
                 
                 ; Compiler
                 ; finish if
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_THEN:
00030f 0004          .dw $0004
000310 6874
000311 6e65          .db "then"
000312 0304          .dw VE_HEAD
                     .set VE_HEAD = VE_THEN
                 XT_THEN:
000313 1c01          .dw DO_COLON
                 PFA_THEN:
                 .endif
000314 02e5          .dw XT_GRESOLVE
000315 1c1b          .dw XT_EXIT
                 .include "words/begin.asm"
                 
                 ; Compiler
                 ; put the next location for a transfer of control onto the control flow stack
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_BEGIN:
000316 0005          .dw $0005
000317 6562
000318 6967
000319 006e          .db "begin",0
00031a 030f          .dw VE_HEAD
                     .set VE_HEAD = VE_BEGIN
                 XT_BEGIN:
00031b 1c01          .dw DO_COLON
                 PFA_BEGIN:
                 .endif
00031c 02eb          .dw XT_LMARK
00031d 1c1b          .dw XT_EXIT
                 .include "words/while.asm"
                 
                 ; Compiler
                 ; at runtime skip until repeat if non-true
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_WHILE:
00031e 0005          .dw $0005
00031f 6877
000320 6c69
000321 0065          .db "while",0
000322 0316          .dw VE_HEAD
                     .set VE_HEAD = VE_WHILE
                 XT_WHILE:
000323 1c01          .dw DO_COLON
                 PFA_WHILE:
                 .endif
000324 02ff          .dw XT_IF
000325 1cbf          .dw XT_SWAP
000326 1c1b          .dw XT_EXIT
                 .include "words/repeat.asm"
                 
                 ; Compiler
                 ; continue execution at dest, resolve orig
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_REPEAT:
000327 0006          .dw $0006
000328 6572
000329 6570
00032a 7461          .db "repeat"
00032b 031e          .dw VE_HEAD
                     .set VE_HEAD = VE_REPEAT
                 XT_REPEAT:
00032c 1c01          .dw DO_COLON
                 PFA_REPEAT:
                 .endif
00032d 0340          .dw XT_AGAIN
00032e 0313          .dw XT_THEN
00032f 1c1b          .dw XT_EXIT
                 .include "words/until.asm"
                 
                 ; Compiler
                 ; finish begin with conditional branch, leaves the loop if true flag at runtime
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_UNTIL:
000330 0005          .dw $0005
000331 6e75
000332 6974
000333 006c          .db "until",0
000334 0327          .dw VE_HEAD
                     .set VE_HEAD = VE_UNTIL
                 XT_UNTIL:
000335 1c01          .dw DO_COLON
                 PFA_UNTIL:
                 .endif
000336 1c38          .dw XT_DOLITERAL
000337 1c31          .dw XT_DOCONDBRANCH
000338 02ba          .dw XT_COMMA
                 
000339 02ee          .dw XT_LRESOLVE
00033a 1c1b          .dw XT_EXIT
                 .include "words/again.asm"
                 
                 ; Compiler
                 ; compile a jump back to dest
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_AGAIN:
00033b 0005          .dw $0005
00033c 6761
00033d 6961
00033e 006e          .db "again",0
00033f 0330          .dw VE_HEAD
                     .set VE_HEAD = VE_AGAIN
                 XT_AGAIN:
000340 1c01          .dw DO_COLON
                 PFA_AGAIN:
                 .endif
000341 02af          .dw XT_COMPILE
000342 1c2a          .dw XT_DOBRANCH
000343 02ee          .dw XT_LRESOLVE
000344 1c1b          .dw XT_EXIT
                 .include "words/do.asm"
                 
                 ; Compiler
                 ; start do .. [+]loop
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DO:
000345 0002          .dw $0002
000346 6f64          .db "do"
000347 033b          .dw VE_HEAD
                     .set VE_HEAD = VE_DO
                 XT_DO:
000348 1c01          .dw DO_COLON
                 PFA_DO:
                 
                 .endif
000349 02af          .dw XT_COMPILE
00034a 1e8a          .dw XT_DODO
00034b 02eb          .dw XT_LMARK
00034c 1d4f          .dw XT_ZERO
00034d 03a3          .dw XT_TO_L
00034e 1c1b          .dw XT_EXIT
                 .include "words/loop.asm"
                 
                 ; Compiler
                 ; compile (loop) and resolve the backward branch
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_LOOP:
00034f 0004          .dw $0004
000350 6f6c
000351 706f          .db "loop"
000352 0345          .dw VE_HEAD
                     .set VE_HEAD = VE_LOOP
                 XT_LOOP:
000353 1c01          .dw DO_COLON
                 PFA_LOOP:
                 .endif
000354 02af          .dw XT_COMPILE
000355 1eb8          .dw XT_DOLOOP
000356 038a          .dw XT_ENDLOOP
000357 1c1b          .dw XT_EXIT
                 .include "words/plusloop.asm"
                 
                 ; Compiler
                 ; compile (+loop) and resolve branches
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_PLUSLOOP:
000358 0005          .dw $0005
000359 6c2b
00035a 6f6f
00035b 0070          .db "+loop",0
00035c 034f          .dw VE_HEAD
                     .set VE_HEAD = VE_PLUSLOOP
                 XT_PLUSLOOP:
00035d 1c01          .dw DO_COLON
                 PFA_PLUSLOOP:
                 .endif
00035e 02af          .dw XT_COMPILE
00035f 1ea9          .dw XT_DOPLUSLOOP
000360 038a          .dw XT_ENDLOOP
000361 1c1b          .dw XT_EXIT
                 .include "words/leave.asm"
                 
                 ; Compiler
                 ; immediatly leave the current DO..LOOP
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_LEAVE:
000362 0005         .dw $0005
000363 656c
000364 7661
000365 0065         .db "leave",0
000366 0358         .dw VE_HEAD
                    .set VE_HEAD = VE_LEAVE
                 XT_LEAVE:
000367 1c01          .dw DO_COLON
                 PFA_LEAVE:
                 .endif
000368 02af
000369 1ec3          .DW XT_COMPILE,XT_UNLOOP
00036a 02f7
00036b 03a3
00036c 1c1b          .DW XT_AHEAD,XT_TO_L,XT_EXIT
                 .include "words/qdo.asm"
                 
                 ; Compiler
                 ; start a ?do .. [+]loop control structure
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 VE_QDO:
00036d 0003          .dw $0003
00036e 643f
00036f 006f          .db "?do",0
000370 0362          .dw VE_HEAD
                     .set VE_HEAD = VE_QDO
                 XT_QDO:
000371 1c01          .dw DO_COLON
                 PFA_QDO:
                 .endif
000372 02af          .dw XT_COMPILE
000373 0379          .dw XT_QDOCHECK
000374 02ff          .dw XT_IF
000375 0348          .dw XT_DO
000376 1cbf          .dw XT_SWAP    ; DO sets a 0 marker on the leave stack
000377 03a3          .dw XT_TO_L    ; then follows at the end.
000378 1c1b          .dw XT_EXIT
                 
                 ; there is no special runtime for ?do, the do runtime
                 ; gets wrapped with the sequence
                 ; ... ?do-check if do ..... loop then
                 ; with
                 ; : ?do-check ( n1 n2 -- n1 n2 true | false )
                 ;   2dup = dup >r if 2drop then r> invert ;
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 XT_QDOCHECK:
000379 1c01          .dw DO_COLON
                 PFA_QDOCHECK:
                 .endif
00037a 05f8          .dw XT_2DUP
00037b 1fd4          .dw XT_EQUAL
00037c 1cac          .dw XT_DUP
00037d 1cfa          .dw XT_TO_R
00037e 1c31          .dw XT_DOCONDBRANCH
00037f 0381          DEST(PFA_QDOCHECK1)
000380 0601          .dw XT_2DROP
                 PFA_QDOCHECK1:
000381 1cf1          .dw XT_R_FROM
000382 1df8          .dw XT_INVERT
000383 1c1b          .dw XT_EXIT
                 .include "words/endloop.asm"
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_ENDLOOP:
000384 ff07          .dw $ff07
000385 6e65
000386 6c64
000387 6f6f
000388 0070          .db "endloop",0
000389 036d          .dw VE_HEAD
                     .set VE_HEAD = VE_ENDLOOP
                 XT_ENDLOOP:
00038a 1c01          .dw DO_COLON
                 PFA_ENDLOOP:
                 .endif
                 ;Z ENDLOOP   adrs xt --   L: 0 a1 a2 .. aN --
                 ;   <resolve                backward loop
                 ;   BEGIN L> ?DUP WHILE POSTPONE THEN REPEAT ;
                 ;                                 resolve LEAVEs
                 ; This is a common factor of LOOP and +LOOP.
                 
00038b 02ee              .DW XT_LRESOLVE
00038c 0397
00038d 1cb4
00038e 1c31      LOOP1:  .DW XT_L_FROM,XT_QDUP,XT_DOCONDBRANCH
00038f 0393               DEST(LOOP2)
000390 0313              .DW XT_THEN
000391 1c2a      	.dw XT_DOBRANCH
000392 038c               DEST(LOOP1)
000393 1c1b      LOOP2:  .DW XT_EXIT
                 ; leave address stack
                 .include "words/l-from.asm"
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_L_FROM:
000394 ff02          .dw $ff02
000395 3e6c          .db "l>"
000396 0384          .dw VE_HEAD
                     .set VE_HEAD = VE_L_FROM
                 XT_L_FROM:
000397 1c01          .dw DO_COLON
                 PFA_L_FROM:
                 
                 .endif
                 ;Z L>   -- x   L: x --      move from leave stack
                 ;   LP @ @  -2 LP +! ;
                 
000398 03b7          .dw XT_LP
000399 1c74          .dw XT_FETCH
00039a 1c74          .dw XT_FETCH
00039b 1c38          .dw XT_DOLITERAL
00039c fffe          .dw -2
00039d 03b7          .dw XT_LP
00039e 1e54          .dw XT_PLUSSTORE
00039f 1c1b          .dw XT_EXIT
                 .include "words/to-l.asm"
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_TO_L:
0003a0 ff02          .dw $ff02
0003a1 6c3e          .db ">l"
0003a2 0394          .dw VE_HEAD
                     .set VE_HEAD = VE_TO_L
                 XT_TO_L:
0003a3 1c01          .dw DO_COLON
                 PFA_TO_L:
                 .endif
                 ;Z >L   x --   L: -- x        move to leave stack
                 ;   CELL LP +!  LP @ ! ;      (L stack grows up)
                 
0003a4 1c38              .dw XT_DOLITERAL
0003a5 0002      	.dw 2
0003a6 03b7      	.dw XT_LP
0003a7 1e54      	.dw XT_PLUSSTORE
0003a8 03b7      	.dw XT_LP
0003a9 1c74      	.dw XT_FETCH
0003aa 1c7c      	.dw XT_STORE
0003ab 1c1b      	.dw XT_EXIT
                 .include "words/lp0.asm"
                 
                 ; Stack
                 ; start address of leave stack
                 VE_LP0:
0003ac ff03          .dw $ff03
0003ad 706c
0003ae 0030          .db "lp0",0
0003af 03a0          .dw VE_HEAD
                     .set VE_HEAD = VE_LP0
                 XT_LP0:
0003b0 1c6a          .dw PFA_DOVALUE1
                 PFA_LP0:
0003b1 005c          .dw EE_LP0
0003b2 0c3c          .dw XT_EDEFERFETCH
0003b3 0c46          .dw XT_EDEFERSTORE
                 .include "words/lp.asm"
                 
                 ; System Variable
                 ; leave stack pointer
                 VE_LP:
0003b4 ff02          .dw $ff02
0003b5 706c          .db "lp"
0003b6 03ac          .dw VE_HEAD
                     .set VE_HEAD = VE_LP
                 XT_LP:
0003b7 1c43          .dw PFA_DOVARIABLE
                 PFA_LP:
0003b8 007b          .dw ram_lp
                 
                 .dseg
00007b           ram_lp: .byte 2
                 .cseg
                 
                 
                 .include "words/create.asm"
                 
                 ; Dictionary
                 ; create a dictionary header. XT is (constant), with the address of the data field of name
                 VE_CREATE:
0003b9 ff06          .dw $ff06
0003ba 7263
0003bb 6165
0003bc 6574          .db "create"
0003bd 03b4          .dw VE_HEAD
                     .set VE_HEAD = VE_CREATE
                 XT_CREATE:
0003be 1c01          .dw DO_COLON
                 PFA_CREATE:
0003bf 0289          .dw XT_DOCREATE
0003c0 03ed          .dw XT_REVEAL
0003c1 02af          .dw XT_COMPILE
0003c2 1c4d          .dw PFA_DOCONSTANT
0003c3 1c1b          .dw XT_EXIT
                 .include "words/header.asm"
                 
                 ; Compiler
                 ; creates the vocabulary header without XT and data field (PF) in the wordlist wid
                 VE_HEADER:
0003c4 ff06          .dw $ff06
0003c5 6568
0003c6 6461
0003c7 7265          .db "header"
0003c8 03b9          .dw VE_HEAD
                     .set VE_HEAD = VE_HEADER
                 XT_HEADER:
0003c9 1c01          .dw DO_COLON
                 PFA_HEADER:
0003ca 0647          .dw XT_DP           ; the new Name Field
0003cb 1cfa          .dw XT_TO_R
0003cc 1cfa          .dw XT_TO_R		; ( R: NFA WID )
0003cd 1cac          .dw XT_DUP    
0003ce 1d23          .dw XT_GREATERZERO 
0003cf 1c31          .dw XT_DOCONDBRANCH
0003d0 03db          .dw PFA_HEADER1
0003d1 1cac          .dw XT_DUP
0003d2 1c38          .dw XT_DOLITERAL
0003d3 ff00          .dw $ff00           ; all flags are off (e.g. immediate)
0003d4 1e17          .dw XT_OR
0003d5 081e          .dw XT_DOSCOMMA
                     ; make the link to the previous entry in this wordlist
0003d6 1cf1          .dw XT_R_FROM
0003d7 1f4e          .dw XT_FETCHE
0003d8 02ba          .dw XT_COMMA
0003d9 1cf1          .dw XT_R_FROM
0003da 1c1b          .dw XT_EXIT
                 
                 PFA_HEADER1:
                     ; -16: attempt to use zero length string as a name
0003db 1c38          .dw XT_DOLITERAL
0003dc fff0          .dw -16
0003dd 08d8          .dw XT_THROW
                 
                 .include "words/wlscope.asm"
                 
                 ; Compiler
                 ; dynamically place a word in a wordlist. The word name may be changed.
                 VE_WLSCOPE:
0003de ff07          .dw $ff07
0003df 6c77
0003e0 6373
0003e1 706f
0003e2 0065          .db "wlscope",0
0003e3 03c4          .dw VE_HEAD
                     .set VE_HEAD = VE_WLSCOPE
                 XT_WLSCOPE:
0003e4 0c9b          .dw PFA_DODEFER1
                 PFA_WLSCOPE:
0003e5 005a          .dw EE_WLSCOPE
0003e6 0c3c          .dw XT_EDEFERFETCH
0003e7 0c46          .dw XT_EDEFERSTORE
                 
                 ; wlscope, "wordlist scope" ( addr len -- addr' len' wid ), is a deferred word
                 ; which enables the AmForth application to choose the wordlist ( wid ) for the
                 ; new voc entry based on the input ( addr len ) string. The name of the new voc
                 ; entry ( addr' len' ) may be different from the input string. Note that all
                 ; created voc entry types pass through the wlscope mechanism. The default
                 ; wlscope action passes the input string to the output without modification and
                 ; uses get-current to select the wid.
                 .include "words/reveal.asm"
                 
                 ; Dictionary
                 ; makes an entry in a wordlist visible, if not already done.
                 VE_REVEAL:
0003e8 ff06          .dw $ff06
0003e9 6572
0003ea 6576
0003eb 6c61          .db "reveal"
0003ec 03de          .dw VE_HEAD
                     .set VE_HEAD = VE_REVEAL
                 XT_REVEAL:
0003ed 1c01          .dw DO_COLON
                 PFA_REVEAL:
0003ee 1c38          .dw XT_DOLITERAL
0003ef 0077          .dw COLON_SMUDGE+0
0003f0 1c74          .dw XT_FETCH
0003f1 1cb4          .dw XT_QDUP
0003f2 1c31          .dw XT_DOCONDBRANCH
0003f3 03fc          .dw PFA_REVEAL1
                 ;
0003f4 1c38          .dw XT_DOLITERAL
0003f5 0079          .dw COLON_SMUDGE+2
0003f6 1c74          .dw XT_FETCH		; ( NFA WID )
0003f7 1f2a          .dw XT_STOREE
                     ; prevent duplicate actions and cooperate with :noname
0003f8 1d4f          .dw XT_ZERO
0003f9 1c38          .dw XT_DOLITERAL
0003fa 0077          .dw COLON_SMUDGE+0
0003fb 1c7c          .dw XT_STORE
                 PFA_REVEAL1:
0003fc 1c1b          .dw XT_EXIT
                 .include "words/latest.asm"
                 
                 ; System Variable
                 ; system LATEST
                 VE_LATEST:
0003fd ff06          .dw $ff06
0003fe 616c
0003ff 6574
000400 7473          .db "latest"
000401 03e8          .dw VE_HEAD
                     .set VE_HEAD = VE_LATEST
                 XT_LATEST:
000402 1c43          .dw PFA_DOVARIABLE
                 PFA_LATEST:
000403 007d          .dw ram_LATEST
                 
                 .dseg
00007d           ram_LATEST: .byte 2
                 .cseg
                 .include "words/does.asm"
                 
                 ; Compiler
                 ; organize the XT replacement to call other colon code
                 VE_DOES:
000404 0005          .dw $0005
000405 6f64
000406 7365
000407 003e          .db "does>",0
000408 03fd          .dw VE_HEAD
                     .set VE_HEAD = VE_DOES
                 XT_DOES:
000409 1c01          .dw DO_COLON
                 PFA_DOES:
00040a 02af          .dw XT_COMPILE
00040b 041c          .dw XT_DODOES
00040c 02af          .dw XT_COMPILE  ; create a code snippet to be used in an embedded XT
00040d 940e          .dw $940e       ; the address of this compiled
00040e 02af          .dw XT_COMPILE  ; code will replace the XT of the 
00040f 0411          .dw DO_DODOES   ; word that CREATE created
000410 1c1b          .dw XT_EXIT     ; 
                 
                 DO_DODOES: ; ( -- PFA )
000411 939a
000412 938a          savetos
000413 01cb          movw tosl, wl
000414 9601          adiw tosl, 1
                     ; the following takes the address from a real uC-call
                 .if (pclen==3)
                 .endif
000415 917f          pop wh
000416 916f          pop wl
                 
000417 93bf          push XH
000418 93af          push XL
000419 01db          movw XL, wl
00041a 940c 1c05     jmp_ DO_NEXT
                 
                 ; ( -- )
                 ; System
                 ; replace the XT written by CREATE to call the code that follows does>
                 ;VE_DODOES:
                 ;   .dw $ff07
                 ;   .db "(does>)"
                 ;   .set VE_HEAD = VE_DODOES
                 XT_DODOES:
00041c 1c01          .dw DO_COLON
                 PFA_DODOES:
00041d 1cf1          .dw XT_R_FROM
00041e 1c38          .dw XT_DOLITERAL
00041f 0079          .dw COLON_SMUDGE+2
000420 1c74          .dw XT_FETCH
000421 1f4e          .dw XT_FETCHE
000422 056a          .dw XT_NFA2LFA
000423 1e2a          .dw XT_1PLUS   ; lfa>xt
                 
000424 1f62          .dw XT_STOREI
000425 1c1b          .dw XT_EXIT
                 .include "words/colon.asm"
                 
                 ; Compiler
                 ; create a named entry in the dictionary, XT is DO_COLON
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_COLON:
000426 ff01          .dw $ff01
000427 003a          .db ":",0
000428 0404          .dw VE_HEAD
                     .set VE_HEAD = VE_COLON
                 XT_COLON:
000429 1c01          .dw DO_COLON
                 PFA_COLON:
                 .endif
00042a 0289          .dw XT_DOCREATE
00042b 0434          .dw XT_COLONNONAME
00042c 1cd4          .dw XT_DROP
00042d 1c1b          .dw XT_EXIT
                 .include "words/colon-noname.asm"
                 
                 ; Compiler
                 ; create an unnamed entry in the dictionary, XT is DO_COLON
                 VE_COLONNONAME:
00042e ff07          .dw $ff07
00042f 6e3a
000430 6e6f
000431 6d61
000432 0065          .db ":noname",0
000433 0426          .dw VE_HEAD
                     .set VE_HEAD = VE_COLONNONAME
                 XT_COLONNONAME:
000434 1c01          .dw DO_COLON
                 PFA_COLONNONAME:
000435 0647          .dw XT_DP
000436 1cac          .dw XT_DUP
000437 0402          .dw XT_LATEST
000438 1c7c          .dw XT_STORE
                 
000439 02af          .dw XT_COMPILE
00043a 1c01          .dw DO_COLON
                 
00043b 0449          .dw XT_RBRACKET
00043c 1c1b          .dw XT_EXIT
                 .include "words/semicolon.asm"
                 
                 ; Compiler
                 ; finish colon defintion, compiles (exit) and returns to interpret state 
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 
                 VE_SEMICOLON:
00043d 0001          .dw $0001
00043e 003b          .db $3b,0
00043f 042e          .dw VE_HEAD
                     .set VE_HEAD = VE_SEMICOLON
                 XT_SEMICOLON:
000440 1c01          .dw DO_COLON
                 PFA_SEMICOLON:
                 .endif
000441 02af          .dw XT_COMPILE
000442 1c1b          .dw XT_EXIT
000443 0452          .dw XT_LBRACKET
000444 03ed          .dw XT_REVEAL
000445 1c1b          .dw XT_EXIT
                 .include "words/right-bracket.asm"
                 
                 ; Compiler
                 ; enter compiler mode
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_RBRACKET:
000446 ff01          .dw $ff01
000447 005d          .db "]",0
000448 043d          .dw VE_HEAD
                     .set VE_HEAD = VE_RBRACKET
                 XT_RBRACKET:
000449 1c01          .dw DO_COLON
                 PFA_RBRACKET:
                 .endif
00044a 1c38          .dw XT_DOLITERAL
00044b 0001          .dw 1
00044c 05dd          .dw XT_STATE
00044d 1c7c          .dw XT_STORE
00044e 1c1b          .dw XT_EXIT
                 .include "words/left-bracket.asm"
                 
                 ; Compiler
                 ; enter interpreter mode
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_LBRACKET:
00044f 0001          .dw $0001
000450 005b          .db "[",0
000451 0446          .dw VE_HEAD
                     .set VE_HEAD = VE_LBRACKET
                 XT_LBRACKET:
000452 1c01          .dw DO_COLON
                 PFA_LBRACKET:
                 .endif
000453 1d4f          .dw XT_ZERO
000454 05dd          .dw XT_STATE
000455 1c7c          .dw XT_STORE
000456 1c1b          .dw XT_EXIT
                 .include "words/variable.asm"
                 
                 ; Compiler
                 ; create a dictionary entry for a variable and allocate 1 cell RAM
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 VE_VARIABLE:
000457 ff08          .dw $ff08
000458 6176
000459 6972
00045a 6261
00045b 656c          .db "variable"
00045c 044f          .dw VE_HEAD
                     .set VE_HEAD = VE_VARIABLE
                 XT_VARIABLE:
00045d 1c01          .dw DO_COLON
                 PFA_VARIABLE:
                 .endif
00045e 0658          .dw XT_HERE
00045f 046a          .dw XT_CONSTANT
000460 1c38          .dw XT_DOLITERAL
000461 0002          .dw 2
000462 0661          .dw XT_ALLOT
000463 1c1b          .dw XT_EXIT
                 .include "words/constant.asm"
                 
                 ; Compiler
                 ; create a constant in the dictionary
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 VE_CONSTANT:
000464 ff08          .dw $ff08
000465 6f63
000466 736e
000467 6174
000468 746e          .db "constant"
000469 0457          .dw VE_HEAD
                     .set VE_HEAD = VE_CONSTANT
                 XT_CONSTANT:
00046a 1c01          .dw DO_COLON
                 PFA_CONSTANT:
                 .endif
00046b 0289          .dw XT_DOCREATE
00046c 03ed          .dw XT_REVEAL
00046d 02af          .dw XT_COMPILE
00046e 1c43          .dw PFA_DOVARIABLE
00046f 02ba          .dw XT_COMMA
000470 1c1b          .dw XT_EXIT
                 .include "words/user.asm"
                 
                 ; Compiler
                 ; create a dictionary entry for a user variable at offset n
                 VE_USER:
000471 ff04          .dw $ff04
000472 7375
000473 7265          .db "user"
000474 0464          .dw VE_HEAD
                     .set VE_HEAD = VE_USER
                 XT_USER:
000475 1c01          .dw DO_COLON
                 PFA_USER:
000476 0289          .dw XT_DOCREATE
000477 03ed          .dw XT_REVEAL
                 
000478 02af          .dw XT_COMPILE
000479 1c53          .dw PFA_DOUSER
00047a 02ba          .dw XT_COMMA
00047b 1c1b          .dw XT_EXIT
                 
                 .include "words/recurse.asm"
                 
                 ; Compiler
                 ; compile the XT of the word currently being defined into the dictionary
                 VE_RECURSE:
00047c 0007          .dw $0007
00047d 6572
00047e 7563
00047f 7372
000480 0065          .db "recurse",0
000481 0471          .dw VE_HEAD
                     .set VE_HEAD = VE_RECURSE
                 XT_RECURSE:
000482 1c01          .dw DO_COLON
                 PFA_RECURSE:
000483 0402          .dw XT_LATEST
000484 1c74          .dw XT_FETCH
000485 02ba          .dw XT_COMMA
000486 1c1b          .dw XT_EXIT
                 .include "words/immediate.asm"
                 
                 ; Compiler
                 ; set immediate flag for the most recent word definition
                 VE_IMMEDIATE:
000487 ff09          .dw $ff09
000488 6d69
000489 656d
00048a 6964
00048b 7461
00048c 0065          .db "immediate",0
00048d 047c          .dw VE_HEAD
                     .set VE_HEAD = VE_IMMEDIATE
                 XT_IMMEDIATE:
00048e 1c01          .dw DO_COLON
                 PFA_IMMEDIATE:
00048f 052b          .dw XT_GET_CURRENT
000490 1f4e          .dw XT_FETCHE
000491 1cac          .dw XT_DUP
000492 1fbb          .dw XT_FETCHI
000493 1c38          .dw XT_DOLITERAL
000494 7fff          .dw $7fff
000495 1e0e          .dw XT_AND
000496 1cbf          .dw XT_SWAP
000497 1f62          .dw XT_STOREI
000498 1c1b          .dw XT_EXIT
                 
                 .include "words/bracketchar.asm"
                 
                 ; Tools
                 ; skip leading space delimites, place the first character of the word on the stack
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_BRACKETCHAR:
000499 0006          .dw $0006
00049a 635b
00049b 6168
00049c 5d72          .db "[char]"
00049d 0487          .dw VE_HEAD
                     .set VE_HEAD = VE_BRACKETCHAR
                 XT_BRACKETCHAR:
00049e 1c01          .dw DO_COLON
                 PFA_BRACKETCHAR:
                 .endif
00049f 02af          .dw XT_COMPILE
0004a0 1c38          .dw XT_DOLITERAL
0004a1 097b          .dw XT_CHAR
0004a2 02ba          .dw XT_COMMA
0004a3 1c1b          .dw XT_EXIT
                 .include "words/abort-string.asm"
                 
                 ;C         i*x x1 --       R: j*x --      x1<>0
                 ;   POSTPONE IS" POSTPONE ?ABORT ; IMMEDIATE
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_ABORTQUOTE:
0004a4 0006          .dw $0006
0004a5 6261
0004a6 726f
0004a7 2274          .db "abort",'"'
0004a8 0499          .dw VE_HEAD
                     .set VE_HEAD = VE_ABORTQUOTE
                 XT_ABORTQUOTE:
0004a9 1c01          .dw DO_COLON
                 PFA_ABORTQUOTE:
                 .endif
0004aa 0266          .dw XT_SQUOTE
0004ab 02af          .dw XT_COMPILE
0004ac 04bc          .dw XT_QABORT
0004ad 1c1b          .DW XT_EXIT
                 .include "words/abort.asm"
                 
                 ; Exceptions
                 ; send an exception -1
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_ABORT:
0004ae ff05          .dw $ff05
0004af 6261
0004b0 726f
0004b1 0074          .db "abort",0
0004b2 04a4          .dw VE_HEAD
                     .set VE_HEAD = VE_ABORT
                 XT_ABORT:
0004b3 1c01          .dw DO_COLON
                 PFA_ABORT:
                 .endif
0004b4 1c38          .dw XT_DOLITERAL
0004b5 ffff          .dw -1
0004b6 08d8          .dw XT_THROW
                 .include "words/q-abort.asm"
                 
                 ;   ROT IF ITYPE ABORT THEN 2DROP ;
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_QABORT:
0004b7 ff06          .dw $ff06
0004b8 613f
0004b9 6f62
0004ba 7472          .db "?abort"
0004bb 04ae          .dw VE_HEAD
                     .set VE_HEAD = VE_QABORT
                 XT_QABORT:
0004bc 1c01          .dw DO_COLON
                 PFA_QABORT:
                 
                 .endif
0004bd 1cdc
0004be 1c31              .DW XT_ROT,XT_DOCONDBRANCH
0004bf 04c2              DEST(QABO1)
0004c0 083f
0004c1 04b3              .DW XT_ITYPE,XT_ABORT
0004c2 0601
0004c3 1c1b      QABO1:  .DW XT_2DROP,XT_EXIT
                 
                 .include "words/get-stack.asm"
                 
                 ; Tools
                 ; Get a stack from EEPROM
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_GET_STACK:
0004c4 ff09          .dw $ff09
0004c5 6567
0004c6 2d74
0004c7 7473
0004c8 6361
0004c9 006b          .db "get-stack",0
0004ca 04b7          .dw VE_HEAD
                     .set VE_HEAD = VE_GET_STACK
                 XT_GET_STACK:
0004cb 1c01          .dw DO_COLON
                 PFA_N_FETCH_E:
                 .endif
0004cc 1cac          .dw XT_DUP
0004cd 05f0          .dw XT_CELLPLUS
0004ce 1cbf          .dw XT_SWAP
0004cf 1f4e          .dw XT_FETCHE
0004d0 1cac          .dw XT_DUP
0004d1 1cfa          .dw XT_TO_R
0004d2 1d4f          .dw XT_ZERO
0004d3 1cbf          .dw XT_SWAP    ; go from bigger to smaller addresses
0004d4 0379          .dw XT_QDOCHECK
0004d5 1c31          .dw XT_DOCONDBRANCH
0004d6 04e2          DEST(PFA_N_FETCH_E2)
0004d7 1e8a          .dw XT_DODO
                 PFA_N_FETCH_E1:
                     ; ( ee-addr )
0004d8 1e9b          .dw XT_I
0004d9 1e30          .dw XT_1MINUS
0004da 05ea          .dw XT_CELLS ; ( -- ee-addr i*2 )
0004db 1cca          .dw XT_OVER  ; ( -- ee-addr i*2 ee-addr )
0004dc 1d98          .dw XT_PLUS  ; ( -- ee-addr ee-addr+i
0004dd 1f4e          .dw XT_FETCHE ;( -- ee-addr item_i )
0004de 1cbf          .dw XT_SWAP   ;( -- item_i ee-addr )
0004df 1d46          .dw XT_TRUE  ; shortcut for -1
0004e0 1ea9          .dw XT_DOPLUSLOOP
0004e1 04d8          DEST(PFA_N_FETCH_E1)
                 PFA_N_FETCH_E2:
0004e2 0601          .dw XT_2DROP
0004e3 1cf1          .dw XT_R_FROM
0004e4 1c1b          .dw XT_EXIT
                 
                 .include "words/set-stack.asm"
                 
                 ; Tools
                 ; Write a stack to EEPROM
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SET_STACK:
0004e5 ff09          .dw $ff09
0004e6 6573
0004e7 2d74
0004e8 7473
0004e9 6361
0004ea 006b          .db "set-stack",0
0004eb 04c4          .dw VE_HEAD
                     .set VE_HEAD = VE_SET_STACK
                 XT_SET_STACK:
0004ec 1c01          .dw DO_COLON
                 PFA_SET_STACK:
                 .endif
0004ed 05f8          .dw XT_2DUP
0004ee 1f2a          .dw XT_STOREE ; ( -- i_n .. i_0 n e-addr )
0004ef 1cbf          .dw XT_SWAP    
0004f0 1d4f          .dw XT_ZERO
0004f1 0379          .dw XT_QDOCHECK
0004f2 1c31          .dw XT_DOCONDBRANCH
0004f3 04fa          DEST(PFA_SET_STACK2)
0004f4 1e8a          .dw XT_DODO
                 PFA_SET_STACK1:
0004f5 05f0          .dw XT_CELLPLUS ; ( -- i_x e-addr )
0004f6 0609          .dw XT_TUCK      ; ( -- e-addr i_x e-addr
0004f7 1f2a          .dw XT_STOREE
0004f8 1eb8          .dw XT_DOLOOP
0004f9 04f5          DEST(PFA_SET_STACK1)
                 PFA_SET_STACK2:
0004fa 1cd4          .dw XT_DROP
0004fb 1c1b          .dw XT_EXIT
                 
                 .include "words/map-stack.asm"
                 
                 ; Tools
                 ; Iterate over a stack
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_MAPSTACK:
0004fc ff09          .dw $ff09
0004fd 616d
0004fe 2d70
0004ff 7473
000500 6361
000501 006b          .db "map-stack",0
000502 04e5          .dw VE_HEAD
                     .set VE_HEAD = VE_MAPSTACK
                 XT_MAPSTACK:
000503 1c01          .dw DO_COLON
                 PFA_MAPSTACK:
                 .endif
000504 1cac          .dw XT_DUP
000505 05f0          .dw XT_CELLPLUS
000506 1cbf          .dw XT_SWAP
000507 1f4e          .dw XT_FETCHE
000508 05ea          .dw XT_CELLS
000509 0de2          .dw XT_BOUNDS
00050a 0379          .dw XT_QDOCHECK
00050b 1c31          .dw XT_DOCONDBRANCH
00050c 0520          DEST(PFA_MAPSTACK3)
00050d 1e8a          .dw XT_DODO
                 PFA_MAPSTACK1:
00050e 1e9b            .dw XT_I
00050f 1f4e            .dw XT_FETCHE   ; -- i*x XT id
000510 1cbf            .dw XT_SWAP
000511 1cfa            .dw XT_TO_R
000512 1d03            .dw XT_R_FETCH
000513 1c25            .dw XT_EXECUTE  ; i*x id -- j*y true | i*x false
000514 1cb4            .dw XT_QDUP
000515 1c31            .dw XT_DOCONDBRANCH
000516 051b            DEST(PFA_MAPSTACK2)
000517 1cf1               .dw XT_R_FROM
000518 1cd4               .dw XT_DROP
000519 1ec3               .dw XT_UNLOOP
00051a 1c1b               .dw XT_EXIT
                 PFA_MAPSTACK2:
00051b 1cf1            .dw XT_R_FROM
00051c 1c38            .dw XT_DOLITERAL
00051d 0002            .dw 2
00051e 1ea9            .dw XT_DOPLUSLOOP
00051f 050e            DEST(PFA_MAPSTACK1)
                 PFA_MAPSTACK3:
000520 1cd4          .dw XT_DROP
000521 1d4f          .dw XT_ZERO
000522 1c1b          .dw XT_EXIT
                 
                 ;
                 ; : map-stack ( i*x XT e-addr -- j*y )
                 ;     dup cell+ swap @e cells bounds ?do 
                 ;       ( -- i*x XT )
                 ;       i @e swap >r r@ execute
                 ;       ?dup if r> drop unloop exit then
                 ;       r>
                 ;     2 +loop drop 0
                 ;
                 .include "words/get-current.asm"
                 
                 ; Search Order
                 ; get the wid of the current compilation word list
                 VE_GET_CURRENT:
000523 ff0b          .dw $ff0b
000524 6567
000525 2d74
000526 7563
000527 7272
000528 6e65
000529 0074          .db "get-current",0
00052a 04fc          .dw VE_HEAD
                     .set VE_HEAD = VE_GET_CURRENT
                 XT_GET_CURRENT:
00052b 1c01          .dw DO_COLON
                 PFA_GET_CURRENT:
00052c 1c38          .dw XT_DOLITERAL
00052d 003a          .dw EE_CURRENT
00052e 1f4e          .dw XT_FETCHE
00052f 1c1b          .dw XT_EXIT
                 .include "words/get-order.asm"
                 
                 ; Search Order
                 ; Get the current search order word list
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_GET_ORDER:
000530 ff09          .dw $ff09
000531 6567
000532 2d74
000533 726f
000534 6564
000535 0072          .db "get-order",0
000536 0523          .dw VE_HEAD
                     .set VE_HEAD = VE_GET_ORDER
                 XT_GET_ORDER:
000537 1c01          .dw DO_COLON
                 PFA_GET_ORDER:
                 .endif
000538 1c38          .dw XT_DOLITERAL
000539 003e          .dw CFG_ORDERLISTLEN
00053a 04cb          .dw XT_GET_STACK
00053b 1c1b          .dw XT_EXIT
                 
                 .include "words/compare.asm"
                 
                 ; String
                 ; compares two strings in RAM
                 VE_COMPARE:
00053c ff07          .dw $ff07
00053d 6f63
00053e 706d
00053f 7261
000540 0065          .db "compare",0
000541 0530          .dw VE_HEAD
                     .set VE_HEAD = VE_COMPARE
                 XT_COMPARE:
000542 0543          .dw PFA_COMPARE
                 PFA_COMPARE:
000543 93bf          push xh
000544 93af          push xl
000545 018c          movw temp0, tosl
000546 9189
000547 9199          loadtos
000548 01dc          movw xl, tosl
000549 9189
00054a 9199          loadtos
00054b 019c          movw temp2, tosl
00054c 9189
00054d 9199          loadtos
00054e 01fc          movw zl, tosl
                 PFA_COMPARE_LOOP:
00054f 90ed          ld temp4, X+
000550 90f1          ld temp5, Z+
000551 14ef          cp temp4, temp5
000552 f451          brne PFA_COMPARE_NOTEQUAL
000553 950a          dec temp0
000554 f019          breq PFA_COMPARE_ENDREACHED2
000555 952a          dec temp2
000556 f7c1          brne PFA_COMPARE_LOOP
000557 c001          rjmp PFA_COMPARE_ENDREACHED
                 PFA_COMPARE_ENDREACHED2:
000558 952a          dec temp2
                 PFA_COMPARE_ENDREACHED:
000559 2b02          or temp0, temp2
00055a f411          brne PFA_COMPARE_CHECKLASTCHAR
00055b 2788          clr tosl
00055c c002          rjmp PFA_COMPARE_DONE
                 PFA_COMPARE_CHECKLASTCHAR:
                 PFA_COMPARE_NOTEQUAL:
00055d ef8f          ser tosl
00055e c000          rjmp PFA_COMPARE_DONE
                 
                 PFA_COMPARE_DONE:
00055f 2f98          mov tosh, tosl
000560 91af          pop xl
000561 91bf          pop xh
000562 940c 1c05     jmp_ DO_NEXT
                 .include "words/nfa2lfa.asm"
                 
                 ; System
                 ; get the link field address from the name field address
                 VE_NFA2LFA:
000564 ff07         .dw $ff07
000565 666e
000566 3e61
000567 666c
000568 0061         .db "nfa>lfa",0
000569 053c         .dw VE_HEAD
                    .set VE_HEAD = VE_NFA2LFA
                 XT_NFA2LFA:
00056a 1c01          .dw DO_COLON
                 PFA_NFA2LFA:
00056b 0cfa          .dw XT_NAME2STRING
00056c 1e2a          .dw XT_1PLUS
00056d 1dff          .dw XT_2SLASH
00056e 1d98          .dw XT_PLUS
00056f 1c1b          .dw XT_EXIT
                 
                 .include "words/environment.asm"
                 
                 ; System Value
                 ; word list identifier of the environmental search list
                 VE_ENVIRONMENT:
000570 ff0b          .dw $ff0b
000571 6e65
000572 6976
000573 6f72
000574 6d6e
000575 6e65
000576 0074          .db "environment",0
000577 0564          .dw VE_HEAD
                     .set VE_HEAD = VE_ENVIRONMENT
                 XT_ENVIRONMENT:
000578 1c43          .dw PFA_DOVARIABLE
                 PFA_ENVIRONMENT:
000579 0036          .dw EE_ENVIRONMENT
                 .include "words/env-wordlists.asm"
                 
                 ; Environment
                 ; maximum number of wordlists in the dictionary search order
                 VE_ENVWORDLISTS:
00057a ff09          .dw $ff09
00057b 6f77
00057c 6472
00057d 696c
00057e 7473
00057f 0073          .db "wordlists",0
000580 0000          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENVWORDLISTS
                 XT_ENVWORDLISTS:
000581 1c01          .dw DO_COLON
                 PFA_ENVWORDLISTS:
000582 1c38          .dw XT_DOLITERAL
000583 0008          .dw NUMWORDLISTS
000584 1c1b          .dw XT_EXIT
                 .include "words/env-slashpad.asm"
                 
                 ; Environment
                 ; Size of the PAD buffer in bytes
                 VE_ENVSLASHPAD:
000585 ff04          .dw $ff04
000586 702f
000587 6461          .db "/pad"
000588 057a          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENVSLASHPAD
                 XT_ENVSLASHPAD:
000589 1c01          .dw DO_COLON
                 PFA_ENVSLASHPAD:
00058a 1e7c          .dw XT_SP_FETCH
00058b 061d          .dw XT_PAD
00058c 1d8e          .dw XT_MINUS
00058d 1c1b          .dw XT_EXIT
                 .include "words/env-slashhold.asm"
                 
                 ; Environment
                 ; size of the pictured numeric output buffer in bytes
                 VE_ENVSLASHHOLD:
00058e ff05          .dw $ff05
00058f 682f
000590 6c6f
000591 0064          .db "/hold",0
000592 0585          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENVSLASHHOLD
                 XT_ENVSLASHHOLD:
000593 1c01          .dw DO_COLON
                 PFA_ENVSLASHHOLD:
000594 061d          .dw XT_PAD
000595 0658          .dw XT_HERE
000596 1d8e          .dw XT_MINUS
000597 1c1b          .dw XT_EXIT
                 .include "words/env-forthname.asm"
                 
                 ; Environment
                 ; flash address of the amforth name string
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_ENV_FORTHNAME:
000598 ff0a          .dw $ff0a
000599 6f66
00059a 7472
00059b 2d68
00059c 616e
00059d 656d          .db "forth-name"
00059e 058e          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENV_FORTHNAME
                 XT_ENV_FORTHNAME:
00059f 1c01          .dw DO_COLON
                 PFA_EN_FORTHNAME:
0005a0 080c          .dw XT_DOSLITERAL
0005a1 0007          .dw 7
                 .endif
0005a2 6d61
0005a3 6f66
0005a4 7472
../../common\words/env-forthname.asm(22): warning: .cseg .db misalignment - padding zero byte
0005a5 0068          .db "amforth"
                 .if cpu_msp430==1
                 .endif
0005a6 1c1b          .dw XT_EXIT
                 .include "words/env-forthversion.asm"
                 
                 ; Environment
                 ; version number of amforth
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_ENV_FORTHVERSION:
0005a7 ff07          .dw $ff07
0005a8 6576
0005a9 7372
0005aa 6f69
0005ab 006e          .db "version",0
0005ac 0598          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENV_FORTHVERSION
                 XT_ENV_FORTHVERSION:
0005ad 1c01          .dw DO_COLON
                 PFA_EN_FORTHVERSION:
                 .endif
0005ae 1c38          .dw XT_DOLITERAL
0005af 003b          .dw 59
0005b0 1c1b          .dw XT_EXIT
                 .include "words/env-cpu.asm"
                 
                 ; Environment
                 ; flash address of the CPU identification string
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_ENV_CPU:
0005b1 ff03          .dw $ff03
0005b2 7063
0005b3 0075          .db "cpu",0
0005b4 05a7          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENV_CPU
                 XT_ENV_CPU:
0005b5 1c01          .dw DO_COLON
                 PFA_EN_CPU:
0005b6 1c38          .dw XT_DOLITERAL
0005b7 002d          .dw mcu_name
0005b8 086b          .dw XT_ICOUNT
                 .endif
0005b9 1c1b          .dw XT_EXIT
                 .include "words/env-mcuinfo.asm"
                 
                 ; Environment
                 ; flash address of some CPU specific parameters
                 VE_ENV_MCUINFO:
0005ba ff08          .dw $ff08
0005bb 636d
0005bc 2d75
0005bd 6e69
0005be 6f66          .db "mcu-info"
0005bf 05b1          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENV_MCUINFO
                 XT_ENV_MCUINFO:
0005c0 1c01          .dw DO_COLON
                 PFA_EN_MCUINFO:
0005c1 1c38          .dw XT_DOLITERAL
0005c2 0029          .dw mcu_info
0005c3 1c1b          .dw XT_EXIT
                 .include "words/env-usersize.asm"
                 
                 ; Environment
                 ; size of the USER area in bytes
                 VE_ENVUSERSIZE:
0005c4 ff05          .dw $ff05
0005c5 752f
0005c6 6573
0005c7 0072          .db "/user",0
0005c8 05ba          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENVUSERSIZE
                 XT_ENVUSERSIZE:
0005c9 1c01          .dw DO_COLON
                 PFA_ENVUSERSIZE:
0005ca 1c38          .dw XT_DOLITERAL
0005cb 0026          .dw SYSUSERSIZE + APPUSERSIZE
0005cc 1c1b          .dw XT_EXIT
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/f_cpu.asm"
                 
                 ; System
                 ; put the cpu frequency in Hz on stack
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_F_CPU:
0005cd ff05          .dw $ff05
0005ce 5f66
0005cf 7063
0005d0 0075          .db "f_cpu",0
0005d1 0570          .dw VE_HEAD
                     .set VE_HEAD = VE_F_CPU
                 XT_F_CPU:
0005d2 1c01          .dw DO_COLON
                 PFA_F_CPU:
                 .endif
0005d3 1c38          .dw XT_DOLITERAL
0005d4 1200          .dw (F_CPU % 65536)
0005d5 1c38          .dw XT_DOLITERAL
0005d6 007a          .dw (F_CPU / 65536)
0005d7 1c1b          .dw XT_EXIT
                 .include "words/state.asm"
                 
                 ; System Variable
                 ; system state
                 VE_STATE:
0005d8 ff05          .dw $ff05
0005d9 7473
0005da 7461
0005db 0065          .db "state",0
0005dc 05cd          .dw VE_HEAD
                     .set VE_HEAD = VE_STATE
                 XT_STATE:
0005dd 1c43          .dw PFA_DOVARIABLE
                 PFA_STATE:
0005de 007f          .dw ram_state
                 
                 .dseg
00007f           ram_state: .byte 2
                 .include "words/base.asm"
                 
                 ; Numeric IO
                 ; location of the cell containing the number conversion radix
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_BASE:
0005df ff04          .dw $ff04
0005e0 6162
0005e1 6573          .db "base"
0005e2 05d8          .dw VE_HEAD
                     .set VE_HEAD = VE_BASE
                 XT_BASE:
0005e3 1c53          .dw PFA_DOUSER
                 PFA_BASE:
                 .endif
0005e4 000c          .dw USER_BASE
                 
                 .include "words/cells.asm"
                 
                 ; Arithmetics
                 ; n2 is the size in address units of n1 cells
                 VE_CELLS:
0005e5 ff05          .dw $ff05
0005e6 6563
0005e7 6c6c
0005e8 0073          .db "cells",0
0005e9 05df          .dw VE_HEAD
                     .set VE_HEAD = VE_CELLS
                 XT_CELLS:
0005ea 1e07          .dw PFA_2STAR
                 .include "words/cellplus.asm"
                 
                 ; Arithmetics
                 ; add the size of an address-unit to a-addr1
                 VE_CELLPLUS:
0005eb ff05          .dw $ff05
0005ec 6563
0005ed 6c6c
0005ee 002b          .db "cell+",0
0005ef 05e5          .dw VE_HEAD
                     .set VE_HEAD = VE_CELLPLUS
                 XT_CELLPLUS:
0005f0 05f1          .dw PFA_CELLPLUS
                 PFA_CELLPLUS:
0005f1 9602          adiw tosl, CELLSIZE
0005f2 940c 1c05     jmp_ DO_NEXT
                 
                 .include "words/2dup.asm"
                 
                 ; Stack
                 ; Duplicate the 2 top elements
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_2DUP:
0005f4 ff04          .dw $ff04
0005f5 6432
0005f6 7075          .db "2dup"
0005f7 05eb          .dw VE_HEAD
                     .set VE_HEAD = VE_2DUP
                 XT_2DUP:
0005f8 1c01          .dw DO_COLON
                 PFA_2DUP:
                 .endif
                 
0005f9 1cca          .dw XT_OVER
0005fa 1cca          .dw XT_OVER
0005fb 1c1b          .dw XT_EXIT
                 .include "words/2drop.asm"
                 
                 ; Stack
                 ; Remove the 2 top elements
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_2DROP:
0005fc ff05          .dw $ff05
0005fd 6432
0005fe 6f72
0005ff 0070          .db "2drop",0
000600 05f4          .dw VE_HEAD
                     .set VE_HEAD = VE_2DROP
                 XT_2DROP:
000601 1c01          .dw DO_COLON
                 PFA_2DROP:
                 .endif
000602 1cd4          .dw XT_DROP
000603 1cd4          .dw XT_DROP
000604 1c1b          .dw XT_EXIT
                 
                 .include "words/tuck.asm"
                 
                 ; Stack
                 ; Copy the first (top) stack item below the second stack item. 
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_TUCK:
000605 ff04          .dw $ff04
000606 7574
000607 6b63          .db "tuck"
000608 05fc          .dw VE_HEAD
                     .set VE_HEAD = VE_TUCK
                 XT_TUCK:
000609 1c01          .dw DO_COLON
                 PFA_TUCK:
                 .endif
00060a 1cbf          .dw XT_SWAP
00060b 1cca          .dw XT_OVER
00060c 1c1b          .dw XT_EXIT
                 
                 .include "words/to-in.asm"
                 
                 ; System Variable
                 ; pointer to current read position in input buffer
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_TO_IN:
00060d ff03          .dw $ff03
00060e 693e
00060f 006e          .db ">in",0
000610 0605          .dw VE_HEAD
                     .set VE_HEAD = VE_TO_IN
                 XT_TO_IN:
000611 1c53          .dw PFA_DOUSER
                 PFA_TO_IN:
                 .endif
000612 0018          .dw USER_TO_IN
                 .include "words/sharptib.asm"
                 
                 ; System Variable
                 ; variable holding the number of characters in TIB
                 VE_NUMBERTIB:
000613 ff04          .dw $ff04
000614 7423
000615 6269          .db "#tib"
000616 060d          .dw VE_HEAD
                     .set VE_HEAD  = VE_NUMBERTIB
                 XT_NUMBERTIB:
000617 1c43          .dw PFA_DOVARIABLE
                 PFA_NUMBERTIB:
000618 0081          .dw ram_sharptib
                 
                 .dseg
000081           ram_sharptib: .byte 2
                 .cseg
                  
                 .include "words/pad.asm"
                 
                 ; System Variable
                 ; Address of the temporary scratch buffer.
                 VE_PAD:
000619 ff03          .dw $ff03
00061a 6170
00061b 0064          .db "pad",0
00061c 0613          .dw VE_HEAD
                     .set VE_HEAD = VE_PAD
                 XT_PAD:
00061d 1c01          .dw DO_COLON
                 PFA_PAD:
00061e 0658          .dw XT_HERE
00061f 1c38          .dw XT_DOLITERAL
000620 0064          .dw 100
000621 1d98          .dw XT_PLUS
000622 1c1b          .dw XT_EXIT
                 .include "words/emit.asm"
                 
                 ; Character IO
                 ; fetch the emit vector and execute it. should emit a character from TOS
                 VE_EMIT:
000623 ff04          .dw $ff04
000624 6d65
000625 7469          .db "emit"
000626 0619          .dw VE_HEAD
                     .set VE_HEAD = VE_EMIT
                 XT_EMIT:
000627 0c9b          .dw PFA_DODEFER1
                 PFA_EMIT:
000628 000e          .dw USER_EMIT
000629 0c64          .dw XT_UDEFERFETCH
00062a 0c70          .dw XT_UDEFERSTORE
                 .include "words/emitq.asm"
                 
                 ; Character IO
                 ; fetch emit? vector and execute it. should return the ready-to-send condition
                 VE_EMITQ:
00062b ff05          .dw $ff05
00062c 6d65
00062d 7469
00062e 003f          .db "emit?",0
00062f 0623          .dw VE_HEAD
                     .set VE_HEAD = VE_EMITQ
                 XT_EMITQ:
000630 0c9b          .dw PFA_DODEFER1
                 PFA_EMITQ:
000631 0010          .dw USER_EMITQ
000632 0c64          .dw XT_UDEFERFETCH
000633 0c70          .dw XT_UDEFERSTORE
                 .include "words/key.asm"
                 
                 ; Character IO
                 ; fetch key vector and execute it, should leave a single character on TOS
                 VE_KEY:
000634 ff03          .dw $ff03
000635 656b
000636 0079          .db "key",0
000637 062b          .dw VE_HEAD
                     .set VE_HEAD = VE_KEY
                 XT_KEY:
000638 0c9b          .dw PFA_DODEFER1
                 PFA_KEY:
000639 0012          .dw USER_KEY
00063a 0c64          .dw XT_UDEFERFETCH
00063b 0c70          .dw XT_UDEFERSTORE
                 .include "words/keyq.asm"
                 
                 ; Character IO
                 ; fetch key? vector and execute it. should turn on key sender, if it is disabled/stopped
                 VE_KEYQ:
00063c ff04          .dw $ff04
00063d 656b
00063e 3f79          .db "key?"
00063f 0634          .dw VE_HEAD
                     .set VE_HEAD = VE_KEYQ
                 XT_KEYQ:
000640 0c9b          .dw PFA_DODEFER1
                 PFA_KEYQ:
000641 0014          .dw USER_KEYQ
000642 0c64          .dw XT_UDEFERFETCH
000643 0c70          .dw XT_UDEFERSTORE
                 
                 .include "words/dp.asm"
                 
                 ; System Value
                 ; address of the next free dictionary cell
                 VE_DP:
000644 ff02          .dw $ff02
000645 7064          .db "dp"
000646 063c          .dw VE_HEAD
                     .set VE_HEAD = VE_DP
                 XT_DP:
000647 1c6a          .dw PFA_DOVALUE1
                 PFA_DP:
000648 002c          .dw EE_DP
000649 0c3c          .dw XT_EDEFERFETCH
00064a 0c46          .dw XT_EDEFERSTORE
                 .include "words/ehere.asm"
                 
                 ; System Value
                 ; address of the next free address in eeprom
                 VE_EHERE:
00064b ff05          .dw $ff05
00064c 6865
00064d 7265
00064e 0065          .db "ehere",0
00064f 0644          .dw VE_HEAD
                     .set VE_HEAD = VE_EHERE
                 XT_EHERE:
000650 1c6a          .dw PFA_DOVALUE1
                 PFA_EHERE:
000651 0030          .dw EE_EHERE
000652 0c3c          .dw XT_EDEFERFETCH
000653 0c46          .dw XT_EDEFERSTORE
                 .include "words/here.asm"
                 
                 ; System Value
                 ; address of the next free data space (RAM) cell
                 VE_HERE:
000654 ff04          .dw $ff04
000655 6568
000656 6572          .db "here"
000657 064b          .dw VE_HEAD
                     .set VE_HEAD = VE_HERE
                 XT_HERE:
000658 1c6a          .dw PFA_DOVALUE1
                 PFA_HERE:
000659 002e          .dw EE_HERE
00065a 0c3c          .dw XT_EDEFERFETCH
00065b 0c46          .dw XT_EDEFERSTORE
                 .include "words/allot.asm"
                 
                 ; System
                 ; allocate or release memory in RAM
                 VE_ALLOT:
00065c ff05          .dw $ff05
00065d 6c61
00065e 6f6c
00065f 0074          .db "allot",0
000660 0654          .dw VE_HEAD
                     .set VE_HEAD = VE_ALLOT
                 XT_ALLOT:
000661 1c01          .dw DO_COLON
                 PFA_ALLOT:
000662 0658          .dw XT_HERE
000663 1d98          .dw XT_PLUS
000664 0c21          .dw XT_DOTO
000665 0659          .dw PFA_HERE
000666 1c1b          .dw XT_EXIT
                 
                 .include "words/bin.asm"
                 
                 ; Numeric IO
                 ; set base for numeric conversion to 10
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_BIN:
000667 ff03          .dw $ff03
000668 6962
000669 006e          .db "bin",0
00066a 065c          .dw VE_HEAD
                     .set VE_HEAD = VE_BIN
                 XT_BIN:
00066b 1c01          .dw DO_COLON
                 PFA_BIN:
                 .endif
00066c 1c38          .dw XT_DOLITERAL
00066d 0002          .dw 2
00066e 05e3          .dw XT_BASE
00066f 1c7c          .dw XT_STORE
000670 1c1b          .dw XT_EXIT
                 .include "words/decimal.asm"
                 
                 ; Numeric IO
                 ; set base for numeric conversion to 10
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DECIMAL:
000671 ff07          .dw $ff07
000672 6564
000673 6963
000674 616d
000675 006c          .db "decimal",0
000676 0667          .dw VE_HEAD
                     .set VE_HEAD = VE_DECIMAL
                 XT_DECIMAL:
000677 1c01          .dw DO_COLON
                 PFA_DECIMAL:
                 .endif
000678 1c38          .dw XT_DOLITERAL
000679 000a          .dw 10
00067a 05e3          .dw XT_BASE
00067b 1c7c          .dw XT_STORE
00067c 1c1b          .dw XT_EXIT
                 .include "words/hex.asm"
                 
                 ; Numeric IO
                 ; set base for numeric conversion to 10
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_HEX:
00067d ff03          .dw $ff03
00067e 6568
00067f 0078          .db "hex",0
000680 0671          .dw VE_HEAD
                     .set VE_HEAD = VE_HEX
                 XT_HEX:
000681 1c01          .dw DO_COLON
                 PFA_HEX:
                 .endif
000682 1c38          .dw XT_DOLITERAL
000683 0010          .dw 16
000684 05e3          .dw XT_BASE
000685 1c7c          .dw XT_STORE
000686 1c1b          .dw XT_EXIT
                 .include "words/bl.asm"
                 
                 ; Character IO
                 ; put ascii code of the blank to the stack
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_BL:
000687 ff02          .dw $ff02
000688 6c62          .db "bl"
000689 067d          .dw VE_HEAD
                     .set VE_HEAD = VE_BL
                 XT_BL:
00068a 1c43          .dw PFA_DOVARIABLE
                 PFA_BL:
                 .endif
00068b 0020          .dw 32
                 
                 .include "words/turnkey.asm"
                 
                 ; System Value
                 ; Deferred action during startup/reset
                 VE_TURNKEY:
00068c ff07          .dw $ff07
00068d 7574
00068e 6e72
00068f 656b
000690 0079          .db "turnkey",0
000691 0687          .dw VE_HEAD
                     .set VE_HEAD = VE_TURNKEY
                 XT_TURNKEY:
000692 0c9b          .dw PFA_DODEFER1
                 PFA_TURNKEY:
000693 0032          .dw EE_TURNKEY
000694 0c3c          .dw XT_EDEFERFETCH
000695 0c46          .dw XT_EDEFERSTORE
                 
                 .include "words/slashmod.asm"
                 
                 ; Arithmetics
                 ; signed division n1/n2 with remainder and quotient
                 VE_SLASHMOD:
000696 ff04          .dw $ff04
000697 6d2f
000698 646f          .db "/mod"
000699 068c          .dw VE_HEAD
                     .set VE_HEAD = VE_SLASHMOD
                 XT_SLASHMOD:
00069a 069b          .dw PFA_SLASHMOD
                 PFA_SLASHMOD:
00069b 019c          movw temp2, tosl
                     
00069c 9109          ld temp0, Y+
00069d 9119          ld temp1, Y+
                 
00069e 2f41          mov	temp6,temp1	;move dividend High to sign register
00069f 2743          eor	temp6,temp3	;xor divisor High with sign register
0006a0 ff17          sbrs	temp1,7	;if MSB in dividend set
0006a1 c004          rjmp	PFA_SLASHMOD_1
0006a2 9510          com	temp1		;    change sign of dividend
0006a3 9500          com	temp0		
0006a4 5f0f          subi	temp0,low(-1)
0006a5 4f1f          sbci	temp1,high(-1)
                 PFA_SLASHMOD_1:	
0006a6 ff37          sbrs	temp3,7	;if MSB in divisor set
0006a7 c004          rjmp	PFA_SLASHMOD_2
0006a8 9530          com	temp3		;    change sign of divisor
0006a9 9520          com	temp2		
0006aa 5f2f          subi	temp2,low(-1)
0006ab 4f3f          sbci	temp3,high(-1)
0006ac 24ee      PFA_SLASHMOD_2:	clr	temp4	;clear remainder Low byte
0006ad 18ff          sub	temp5,temp5;clear remainder High byte and carry
0006ae e151          ldi	temp7,17	;init loop counter
                 
0006af 1f00      PFA_SLASHMOD_3:	rol	temp0		;shift left dividend
0006b0 1f11          rol	temp1
0006b1 955a          dec	temp7		;decrement counter
0006b2 f439          brne	PFA_SLASHMOD_5		;if done
0006b3 ff47          sbrs	temp6,7		;    if MSB in sign register set
0006b4 c004          rjmp	PFA_SLASHMOD_4
0006b5 9510          com	temp1	;        change sign of result
0006b6 9500          com	temp0
0006b7 5f0f          subi	temp0,low(-1)
0006b8 4f1f          sbci	temp1,high(-1)
0006b9 c00b      PFA_SLASHMOD_4:	rjmp PFA_SLASHMODmod_done			;    return
0006ba 1cee      PFA_SLASHMOD_5:	rol	temp4	;shift dividend into remainder
0006bb 1cff          rol	temp5
0006bc 1ae2          sub	temp4,temp2	;remainder = remainder - divisor
0006bd 0af3          sbc	temp5,temp3	;
0006be f420          brcc	PFA_SLASHMOD_6		;if result negative
0006bf 0ee2          add	temp4,temp2	;    restore remainder
0006c0 1ef3          adc	temp5,temp3
0006c1 9488          clc			;    clear carry to be shifted into result
0006c2 cfec          rjmp	PFA_SLASHMOD_3		;else
0006c3 9408      PFA_SLASHMOD_6:	sec			;    set carry to be shifted into result
0006c4 cfea          rjmp	PFA_SLASHMOD_3
                 
                 PFA_SLASHMODmod_done:
                     ; put remainder on stack
0006c5 92fa          st -Y,temp5
0006c6 92ea          st -Y,temp4
                 
                     ; put quotient on stack
0006c7 01c8          movw tosl, temp0
0006c8 940c 1c05     jmp_ DO_NEXT
                 .include "words/uslashmod.asm"
                 
                 ; Arithmetics
                 ; unsigned division with remainder
                 VE_USLASHMOD:
0006ca ff05          .dw $ff05
0006cb 2f75
0006cc 6f6d
0006cd 0064          .db "u/mod",0
0006ce 0696          .dw VE_HEAD
                     .set VE_HEAD = VE_USLASHMOD
                 XT_USLASHMOD:
0006cf 1c01          .dw DO_COLON
                 PFA_USLASHMOD:
0006d0 1cfa          .dw XT_TO_R
0006d1 1d4f          .dw XT_ZERO
0006d2 1cf1          .dw XT_R_FROM
0006d3 1dbd          .dw XT_UMSLASHMOD
0006d4 1c1b          .dw XT_EXIT
                 .include "words/negate.asm"
                 
                 ; Logic
                 ; 2-complement
                 VE_NEGATE:
0006d5 ff06          .dw $ff06
0006d6 656e
0006d7 6167
0006d8 6574          .db "negate"
0006d9 06ca          .dw VE_HEAD
                     .set VE_HEAD = VE_NEGATE
                 XT_NEGATE:
0006da 1c01          .dw DO_COLON
                 PFA_NEGATE:
0006db 1df8          .dw XT_INVERT
0006dc 1e2a          .dw XT_1PLUS
0006dd 1c1b          .dw XT_EXIT
                 .include "words/slash.asm"
                 
                 ; Arithmetics
                 ; divide n1 by n2. giving the quotient
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 
                 VE_SLASH:
0006de ff01          .dw $ff01
0006df 002f          .db "/",0
0006e0 06d5          .dw VE_HEAD
                     .set VE_HEAD = VE_SLASH
                 XT_SLASH:
0006e1 1c01          .dw DO_COLON
                 PFA_SLASH:
                 .endif
0006e2 069a          .dw XT_SLASHMOD
0006e3 1ceb          .dw XT_NIP
0006e4 1c1b          .dw XT_EXIT
                 
                 .include "words/mod.asm"
                 
                 ; Arithmetics
                 ; divide n1 by n2 giving the remainder n3
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 
                 VE_MOD:
0006e5 ff03          .dw $ff03
0006e6 6f6d
0006e7 0064          .db "mod",0
0006e8 06de          .dw VE_HEAD
                     .set VE_HEAD = VE_MOD
                 XT_MOD:
0006e9 1c01          .dw DO_COLON
                 PFA_MOD:
                 .endif
0006ea 069a          .dw XT_SLASHMOD
0006eb 1cd4          .dw XT_DROP
0006ec 1c1b          .dw XT_EXIT
                 .include "words/abs.asm"
                 
                 ; Arithmetics
                 ; get the absolute value
                 VE_ABS:
0006ed ff03          .dw $ff03
0006ee 6261
0006ef 0073          .db "abs",0
0006f0 06e5          .dw VE_HEAD
                     .set VE_HEAD = VE_ABS
                 XT_ABS:
0006f1 06f2          .dw PFA_ABS
                 PFA_ABS:
0006f2 2399          tst tosh
0006f3 f41a          brpl PFA_ABS1
0006f4 9580          com tosl
0006f5 9590          com tosh
0006f6 9601          adiw tosl, 1
                 PFA_ABS1:
0006f7 940c 1c05     jmp_ do_next
                 .include "words/min.asm"
                 
                 ; Compare
                 ; compare two values leave the smaller one
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 
                 VE_MIN:
0006f9 ff03          .dw $ff03
0006fa 696d
0006fb 006e          .db "min",0
0006fc 06ed          .dw VE_HEAD
                     .set VE_HEAD = VE_MIN
                 XT_MIN:
0006fd 1c01          .dw DO_COLON
                 PFA_MIN:
                 .endif
0006fe 05f8          .dw XT_2DUP
0006ff 1d73          .dw XT_GREATER
000700 1c31          .dw XT_DOCONDBRANCH
000701 0703          DEST(PFA_MIN1)
000702 1cbf          .dw XT_SWAP
                 PFA_MIN1:
000703 1cd4          .dw XT_DROP
000704 1c1b          .dw XT_EXIT
                 .include "words/max.asm"
                 
                 ; Compare
                 ; compare two values, leave the bigger one
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_MAX:
000705 ff03          .dw $ff03
000706 616d
000707 0078          .db "max",0
000708 06f9          .dw VE_HEAD
                     .set VE_HEAD = VE_MAX
                 XT_MAX:
000709 1c01          .dw DO_COLON
                 PFA_MAX:
                 
                 .endif
00070a 05f8          .dw XT_2DUP
00070b 1d69          .dw XT_LESS
00070c 1c31          .dw XT_DOCONDBRANCH
00070d 070f          DEST(PFA_MAX1)
00070e 1cbf          .dw XT_SWAP
                 PFA_MAX1:
00070f 1cd4          .dw XT_DROP
000710 1c1b          .dw XT_EXIT
                 .include "words/within.asm"
                 
                 ; Compare
                 ; check if n is within min..max
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_WITHIN:
000711 ff06          .dw $ff06
000712 6977
000713 6874
000714 6e69          .db "within"
000715 0705          .dw VE_HEAD
                     .set VE_HEAD = VE_WITHIN
                 XT_WITHIN:
000716 1c01          .dw DO_COLON
                 PFA_WITHIN:
                 .endif
000717 1cca          .dw XT_OVER
000718 1d8e          .dw XT_MINUS
000719 1cfa          .dw XT_TO_R
00071a 1d8e          .dw XT_MINUS
00071b 1cf1          .dw XT_R_FROM
00071c 1d57          .dw XT_ULESS
00071d 1c1b          .dw XT_EXIT
                 
                 .include "words/to-upper.asm"
                 
                 ; String
                 ; if c is a lowercase letter convert it to uppercase
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_TOUPPER:
00071e ff07          .dw $ff07 
00071f 6f74
000720 7075
000721 6570
000722 0072          .db "toupper",0
000723 0711          .dw VE_HEAD
                     .set VE_HEAD = VE_TOUPPER
                 XT_TOUPPER:
000724 1c01          .dw DO_COLON 
                 PFA_TOUPPER:
                 .endif
000725 1cac          .dw XT_DUP 
000726 1c38          .dw XT_DOLITERAL 
000727 0061          .dw 'a' 
000728 1c38          .dw XT_DOLITERAL 
000729 007b          .dw 'z'+1
00072a 0716          .dw XT_WITHIN 
00072b 1c31          .dw XT_DOCONDBRANCH
00072c 0730          DEST(PFA_TOUPPER0)
00072d 1c38          .dw XT_DOLITERAL
00072e 00df          .dw 223 ; inverse of 0x20: 0xdf
00072f 1e0e          .dw XT_AND 
                 PFA_TOUPPER0:
000730 1c1b          .dw XT_EXIT 
                 .include "words/to-lower.asm"
                 
                 ; String
                 ; if C is an uppercase letter convert it to lowercase
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 
                 VE_TOLOWER:
000731 ff07          .dw $ff07
000732 6f74
000733 6f6c
000734 6577
000735 0072          .db "tolower",0
000736 071e          .dw VE_HEAD
                     .set VE_HEAD = VE_TOLOWER
                 XT_TOLOWER:
000737 1c01          .dw DO_COLON
                 PFA_TOLOWER:
                 .endif
000738 1cac          .dw XT_DUP
000739 1c38          .dw XT_DOLITERAL
00073a 0041          .dw 'A'
00073b 1c38          .dw XT_DOLITERAL
00073c 005b          .dw 'Z'+1
00073d 0716          .dw XT_WITHIN
00073e 1c31          .dw XT_DOCONDBRANCH
00073f 0743          DEST(PFA_TOLOWER0)
000740 1c38          .dw XT_DOLITERAL
000741 0020          .dw 32
000742 1e17          .dw XT_OR 
                 PFA_TOLOWER0:
000743 1c1b          .dw XT_EXIT 
                 ;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/hld.asm"
                 
                 ; Numeric IO
                 ; pointer to current write position in the Pictured Numeric Output buffer
                 VE_HLD:
000744 ff03          .dw $ff03
000745 6c68
000746 0064          .db "hld",0
000747 0731          .dw VE_HEAD
                     .set VE_HEAD = VE_HLD
                 XT_HLD:
000748 1c43          .dw PFA_DOVARIABLE
                 PFA_HLD:
000749 0083          .dw ram_hld
                 
                 .dseg
000083           ram_hld: .byte 2
                 .cseg
                 .include "words/hold.asm"
                 
                 ; Numeric IO
                 ; prepend character to pictured numeric output buffer
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_HOLD:
00074a ff04          .dw $ff04
00074b 6f68
00074c 646c          .db "hold"
00074d 0744          .dw VE_HEAD
                     .set VE_HEAD = VE_HOLD
                 XT_HOLD:
00074e 1c01          .dw DO_COLON
                 PFA_HOLD:
                 .endif
00074f 0748          .dw XT_HLD
000750 1cac          .dw XT_DUP
000751 1c74          .dw XT_FETCH
000752 1e30          .dw XT_1MINUS
000753 1cac          .dw XT_DUP
000754 1cfa          .dw XT_TO_R
000755 1cbf          .dw XT_SWAP
000756 1c7c          .dw XT_STORE
000757 1cf1          .dw XT_R_FROM
000758 1c88          .dw XT_CSTORE
000759 1c1b          .dw XT_EXIT
                 .include "words/less-sharp.asm" ; <#
                 
                 ; Numeric IO
                 ; initialize the pictured numeric output conversion process
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_L_SHARP:
00075a ff02          .dw $ff02
00075b 233c          .db "<#"
00075c 074a          .dw VE_HEAD
                     .set VE_HEAD = VE_L_SHARP
                 XT_L_SHARP:
00075d 1c01          .dw DO_COLON
                 PFA_L_SHARP:
                 .endif
00075e 061d          .dw XT_PAD
00075f 0748          .dw XT_HLD
000760 1c7c          .dw XT_STORE
000761 1c1b          .dw XT_EXIT
                 .include "words/sharp.asm"
                 
                 ; Numeric IO
                 ; pictured numeric output: convert one digit
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 
                 VE_SHARP:
000762 ff01          .dw $ff01
000763 0023          .db "#",0
000764 075a          .dw VE_HEAD
                     .set VE_HEAD = VE_SHARP
                 XT_SHARP:
000765 1c01          .dw DO_COLON
                 PFA_SHARP:
                 .endif
000766 05e3          .dw XT_BASE
000767 1c74          .dw XT_FETCH
000768 07e2          .dw XT_UDSLASHMOD
000769 1cdc          .dw XT_ROT
00076a 1c38          .dw XT_DOLITERAL
00076b 0009          .dw 9
00076c 1cca          .dw XT_OVER
00076d 1d69          .dw XT_LESS
00076e 1c31          .dw XT_DOCONDBRANCH
00076f 0773          DEST(PFA_SHARP1)
000770 1c38          .dw XT_DOLITERAL
000771 0007          .dw 7
000772 1d98          .dw XT_PLUS
                 PFA_SHARP1:
000773 1c38          .dw XT_DOLITERAL
000774 0030          .dw 48 ; ASCII 0
000775 1d98          .dw XT_PLUS
000776 074e          .dw XT_HOLD
000777 1c1b          .dw XT_EXIT
                 ; : #    ( ud1 -- ud2 ) 
                 ;        base @ ud/mod rot 9 over < if 7 + then 30 + hold ; 
                 .include "words/sharp-s.asm"
                 
                 ; Numeric IO
                 ; pictured numeric output: convert all digits until 0 (zero) is reached
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SHARP_S:
000778 ff02          .dw $ff02
000779 7323          .db "#s"
00077a 0762          .dw VE_HEAD
                     .set VE_HEAD = VE_SHARP_S
                 XT_SHARP_S:
00077b 1c01          .dw DO_COLON
                 PFA_SHARP_S:
                 .endif
                 NUMS1:
00077c 0765          .dw XT_SHARP
00077d 05f8          .dw XT_2DUP
00077e 1e17          .dw XT_OR
00077f 1d15          .dw XT_ZEROEQUAL
000780 1c31          .dw XT_DOCONDBRANCH
000781 077c          DEST(NUMS1) ; PFA_SHARP_S
000782 1c1b          .dw XT_EXIT
                 .include "words/sharp-greater.asm" ; #>
                 
                 ; Numeric IO
                 ; Pictured Numeric Output: convert PNO buffer into an string
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SHARP_G:
000783 ff02          .dw $ff02
000784 3e23          .db "#>"
000785 0778          .dw VE_HEAD
                     .set VE_HEAD = VE_SHARP_G
                 XT_SHARP_G:
000786 1c01          .dw DO_COLON
                 PFA_SHARP_G:
                 .endif
000787 0601          .dw XT_2DROP
000788 0748          .dw XT_HLD
000789 1c74          .dw XT_FETCH
00078a 061d          .dw XT_PAD
00078b 1cca          .dw XT_OVER
00078c 1d8e          .dw XT_MINUS
00078d 1c1b          .dw XT_EXIT
                 .include "words/sign.asm"
                 
                 ; Numeric IO
                 ; place a - in HLD if n is negative
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SIGN:
00078e ff04          .dw $ff04
00078f 6973
000790 6e67          .db "sign"
000791 0783          .dw VE_HEAD
                     .set VE_HEAD = VE_SIGN
                 XT_SIGN:
000792 1c01          .dw DO_COLON
                 PFA_SIGN:
                 .endif
000793 1d1c          .dw XT_ZEROLESS
000794 1c31          .dw XT_DOCONDBRANCH
000795 0799          DEST(PFA_SIGN1)
000796 1c38          .dw XT_DOLITERAL
000797 002d          .dw 45 ; ascii -
000798 074e          .dw XT_HOLD
                 PFA_SIGN1:
000799 1c1b          .dw XT_EXIT
                 .include "words/d-dot-r.asm"
                 
                 ; Numeric IO
                 ; singed PNO with double cell numbers, right aligned in width w
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DDOTR:
00079a ff03          .dw $ff03
00079b 2e64
00079c 0072          .db "d.r",0
00079d 078e          .dw VE_HEAD
                     .set VE_HEAD = VE_DDOTR
                 XT_DDOTR:
00079e 1c01          .dw DO_COLON
                 PFA_DDOTR:
                 
                 .endif
00079f 1cfa          .dw XT_TO_R
0007a0 0609          .dw XT_TUCK
0007a1 0d5c          .dw XT_DABS
0007a2 075d          .dw XT_L_SHARP
0007a3 077b          .dw XT_SHARP_S
0007a4 1cdc          .dw XT_ROT
0007a5 0792          .dw XT_SIGN
0007a6 0786          .dw XT_SHARP_G
0007a7 1cf1          .dw XT_R_FROM
0007a8 1cca          .dw XT_OVER
0007a9 1d8e          .dw XT_MINUS
0007aa 088a          .dw XT_SPACES
0007ab 089a          .dw XT_TYPE
0007ac 1c1b          .dw XT_EXIT
                 ; : d.r       ( d n -- )
                 ;             >r swap over dabs <# #s rot sign #> r> over - spaces type ;
                 .include "words/dot-r.asm"
                 
                 ; Numeric IO
                 ; singed PNO with single cell numbers, right aligned in width w
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DOTR:
0007ad ff02          .dw $ff02
0007ae 722e          .db ".r"
0007af 079a          .dw VE_HEAD
                     .set VE_HEAD = VE_DOTR
                 XT_DOTR:
0007b0 1c01          .dw DO_COLON
                 PFA_DOTR:
                 
                 .endif
0007b1 1cfa          .dw XT_TO_R
0007b2 0deb          .dw XT_S2D
0007b3 1cf1          .dw XT_R_FROM
0007b4 079e          .dw XT_DDOTR
0007b5 1c1b          .dw XT_EXIT
                 ; : .r        ( s n -- )  >r s>d r> d.r ;
                 .include "words/d-dot.asm"
                 
                 ; Numeric IO
                 ; singed PNO with double cell numbers
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DDOT:
0007b6 ff02          .dw $ff02
0007b7 2e64          .db "d."
0007b8 07ad          .dw VE_HEAD
                     .set VE_HEAD = VE_DDOT
                 XT_DDOT:
0007b9 1c01          .dw DO_COLON
                 PFA_DDOT:
                 
                 .endif
0007ba 1d4f          .dw XT_ZERO
0007bb 079e          .dw XT_DDOTR
0007bc 0881          .dw XT_SPACE
0007bd 1c1b          .dw XT_EXIT
                 ; : d.        ( d -- )    0 d.r space ;
                 .include "words/dot.asm"
                 
                 ; Numeric IO
                 ; singed PNO with single cell numbers
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 
                 VE_DOT:
0007be ff01          .dw $ff01
0007bf 002e          .db ".",0
0007c0 07b6          .dw VE_HEAD
                     .set VE_HEAD = VE_DOT
                 XT_DOT:
0007c1 1c01          .dw DO_COLON
                 PFA_DOT:
                 .endif
0007c2 0deb          .dw XT_S2D
0007c3 07b9          .dw XT_DDOT
0007c4 1c1b          .dw XT_EXIT
                 ; : .         ( s -- )    s>d d. ; 
                 .include "words/ud-dot.asm"
                 
                 ; Numeric IO
                 ; unsigned PNO with double cell numbers
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_UDDOT:
0007c5 ff03          .dw $ff03
0007c6 6475
0007c7 002e          .db "ud.",0
0007c8 07be          .dw VE_HEAD
                     .set VE_HEAD = VE_UDDOT
                 XT_UDDOT:
0007c9 1c01          .dw DO_COLON
                 PFA_UDDOT:
                 .endif
0007ca 1d4f          .dw XT_ZERO
0007cb 07d2          .dw XT_UDDOTR
0007cc 0881          .dw XT_SPACE
0007cd 1c1b          .dw XT_EXIT
                 .include "words/ud-dot-r.asm"
                 
                 ; Numeric IO
                 ; unsigned PNO with double cell numbers, right aligned in width w
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 
                 VE_UDDOTR:
0007ce ff04          .dw $ff04
0007cf 6475
0007d0 722e          .db "ud.r"
0007d1 07c5          .dw VE_HEAD
                     .set VE_HEAD = VE_UDDOTR
                 XT_UDDOTR:
0007d2 1c01          .dw DO_COLON
                 PFA_UDDOTR:
                 .endif
0007d3 1cfa          .dw XT_TO_R
0007d4 075d          .dw XT_L_SHARP
0007d5 077b          .dw XT_SHARP_S
0007d6 0786          .dw XT_SHARP_G
0007d7 1cf1          .dw XT_R_FROM
0007d8 1cca          .dw XT_OVER
0007d9 1d8e          .dw XT_MINUS
0007da 088a          .dw XT_SPACES
0007db 089a          .dw XT_TYPE
0007dc 1c1b          .dw XT_EXIT
                 .include "words/ud-slash-mod.asm"
                 
                 ; Arithmetics
                 ; unsigned double cell division with remainder
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_UDSLASHMOD:
0007dd ff06          .dw $ff06
0007de 6475
0007df 6d2f
0007e0 646f          .db "ud/mod"
0007e1 07ce          .dw VE_HEAD
                     .set VE_HEAD = VE_UDSLASHMOD
                 XT_UDSLASHMOD:
0007e2 1c01          .dw DO_COLON
                 PFA_UDSLASHMOD:
                 .endif
0007e3 1cfa          .dw XT_TO_R
0007e4 1d4f          .dw XT_ZERO
0007e5 1d03          .dw XT_R_FETCH
0007e6 1dbd          .dw XT_UMSLASHMOD
0007e7 1cf1          .dw XT_R_FROM
0007e8 1cbf          .dw XT_SWAP
0007e9 1cfa          .dw XT_TO_R
0007ea 1dbd          .dw XT_UMSLASHMOD
0007eb 1cf1          .dw XT_R_FROM
0007ec 1c1b          .dw XT_EXIT
                 .include "words/digit-q.asm"
                 
                 ; Numeric IO
                 ; tries to convert a character to a number, set flag accordingly
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DIGITQ:
0007ed ff06          .dw $ff06 
0007ee 6964
0007ef 6967
0007f0 3f74          .db "digit?"
0007f1 07dd          .dw VE_HEAD
                     .set VE_HEAD = VE_DIGITQ
                 XT_DIGITQ:
0007f2 1c01          .dw DO_COLON 
                 PFA_DIGITQ:
                 .endif
0007f3 0724          .dw XT_TOUPPER
0007f4 1cac
0007f5 1c38
0007f6 0039
0007f7 1d73
0007f8 1c38
0007f9 0100          .DW XT_DUP,XT_DOLITERAL,57,XT_GREATER,XT_DOLITERAL,256
0007fa 1e0e
0007fb 1d98
0007fc 1cac
0007fd 1c38
0007fe 0140
0007ff 1d73          .DW XT_AND,XT_PLUS,XT_DUP,XT_DOLITERAL,320,XT_GREATER
000800 1c38
000801 0107
000802 1e0e
000803 1d8e
000804 1c38
000805 0030          .DW XT_DOLITERAL,263,XT_AND,XT_MINUS,XT_DOLITERAL,48
000806 1d8e
000807 1cac
000808 05e3
000809 1c74
00080a 1d57          .DW XT_MINUS,XT_DUP,XT_BASE,XT_FETCH,XT_ULESS
00080b 1c1b          .DW XT_EXIT
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/do-sliteral.asm"
                 
                 ; String
                 ; runtime portion of sliteral
                 ;VE_DOSLITERAL:
                 ;  .dw $ff0a
                 ;  .db "(sliteral)"
                 ;  .dw VE_HEAD
                 ;  .set VE_HEAD = VE_DOSLITERAL
                 XT_DOSLITERAL:
00080c 1c01        .dw DO_COLON
                 PFA_DOSLITERAL:
00080d 1d03        .dw XT_R_FETCH   ; ( -- addr )
00080e 086b        .dw XT_ICOUNT
00080f 1cf1        .dw XT_R_FROM
000810 1cca        .dw XT_OVER     ; ( -- addr' n addr n)
000811 1e2a        .dw XT_1PLUS
000812 1dff        .dw XT_2SLASH   ; ( -- addr' n addr k )
000813 1d98        .dw XT_PLUS     ; ( -- addr' n addr'' )
000814 1e2a        .dw XT_1PLUS
000815 1cfa        .dw XT_TO_R     ; ( -- )
000816 1c1b        .dw XT_EXIT
                 .include "words/scomma.asm"
                 
                 ; Compiler
                 ; compiles a string from RAM to Flash
                 VE_SCOMMA:
000817 ff02        .dw $ff02
000818 2c73        .db "s",$2c
000819 07ed        .dw VE_HEAD
                   .set VE_HEAD = VE_SCOMMA
                 XT_SCOMMA:
00081a 1c01          .dw DO_COLON
                 PFA_SCOMMA:
00081b 1cac          .dw XT_DUP
00081c 081e          .dw XT_DOSCOMMA
00081d 1c1b          .dw XT_EXIT
                 
                 ; ( addr len len' -- ) 
                 ; Compiler
                 ; compiles a string from RAM to Flash
                 ;VE_DOSCOMMA:
                 ;  .dw $ff04
                 ;  .db "(s",$2c,")"
                 ;  .dw VE_HEAD
                 ;  .set VE_HEAD = VE_DOSCOMMA
                 XT_DOSCOMMA:
00081e 1c01          .dw DO_COLON
                 PFA_DOSCOMMA:
00081f 02ba          .dw XT_COMMA
000820 1cac          .dw XT_DUP   ; ( --addr len len)
000821 1dff          .dw XT_2SLASH ; ( -- addr len len/2
000822 0609          .dw XT_TUCK   ; ( -- addr len/2 len len/2
000823 1e06          .dw XT_2STAR  ; ( -- addr len/2 len len'
000824 1d8e          .dw XT_MINUS  ; ( -- addr len/2 rem
000825 1cfa          .dw XT_TO_R
000826 1d4f          .dw XT_ZERO
000827 0379          .dw XT_QDOCHECK
000828 1c31          .dw XT_DOCONDBRANCH
000829 0831          .dw PFA_SCOMMA2
00082a 1e8a          .dw XT_DODO
                 PFA_SCOMMA1:
00082b 1cac          .dw XT_DUP         ; ( -- addr addr )
00082c 1c74          .dw XT_FETCH       ; ( -- addr c1c2 )
00082d 02ba          .dw XT_COMMA       ; ( -- addr )
00082e 05f0          .dw XT_CELLPLUS    ; ( -- addr+cell )
00082f 1eb8          .dw XT_DOLOOP
000830 082b          .dw PFA_SCOMMA1
                 PFA_SCOMMA2:
000831 1cf1          .dw XT_R_FROM
000832 1d23          .dw XT_GREATERZERO
000833 1c31          .dw XT_DOCONDBRANCH
000834 0838          .dw PFA_SCOMMA3
000835 1cac            .dw XT_DUP     ; well, tricky
000836 1c93            .dw XT_CFETCH
000837 02ba            .dw XT_COMMA
                 PFA_SCOMMA3:
000838 1cd4          .dw XT_DROP        ; ( -- )
000839 1c1b          .dw XT_EXIT
                 .include "words/itype.asm"
                 
                 ; Tools
                 ; reads string from flash and prints it
                 VE_ITYPE:
00083a ff05          .dw $ff05
00083b 7469
00083c 7079
00083d 0065          .db "itype",0
00083e 0817          .dw VE_HEAD
                     .set VE_HEAD = VE_ITYPE
                 XT_ITYPE:
00083f 1c01          .dw DO_COLON
                 PFA_ITYPE:
000840 1cac          .dw XT_DUP    ; ( --addr len len)
000841 1dff          .dw XT_2SLASH ; ( -- addr len len/2
000842 0609          .dw XT_TUCK   ; ( -- addr len/2 len len/2
000843 1e06          .dw XT_2STAR  ; ( -- addr len/2 len len'
000844 1d8e          .dw XT_MINUS  ; ( -- addr len/2 rem
000845 1cfa          .dw XT_TO_R
000846 1d4f          .dw XT_ZERO
000847 0379          .dw XT_QDOCHECK
000848 1c31          .dw XT_DOCONDBRANCH
000849 0853          .dw PFA_ITYPE2
00084a 1e8a          .dw XT_DODO
                 PFA_ITYPE1:
00084b 1cac          .dw XT_DUP         ; ( -- addr addr )
00084c 1fbb          .dw XT_FETCHI      ; ( -- addr c1c2 )
00084d 1cac          .dw XT_DUP
00084e 0860          .dw XT_LOWEMIT
00084f 085c          .dw XT_HIEMIT
000850 1e2a          .dw XT_1PLUS    ; ( -- addr+cell )
000851 1eb8          .dw XT_DOLOOP
000852 084b          .dw PFA_ITYPE1
                 PFA_ITYPE2:
000853 1cf1          .dw XT_R_FROM
000854 1d23          .dw XT_GREATERZERO
000855 1c31          .dw XT_DOCONDBRANCH
000856 085a          .dw PFA_ITYPE3
000857 1cac            .dw XT_DUP     ; make sure the drop below has always something to do
000858 1fbb            .dw XT_FETCHI
000859 0860            .dw XT_LOWEMIT
                 PFA_ITYPE3:
00085a 1cd4          .dw XT_DROP
00085b 1c1b          .dw XT_EXIT
                 
                 ; ( w -- )
                 ; R( -- )
                 ; content of cell fetched on stack.
                 ;VE_HIEMIT:
                 ;    .dw $ff06
                 ;    .db "hiemit"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_HIEMIT
                 XT_HIEMIT:
00085c 1c01          .dw DO_COLON
                 PFA_HIEMIT:
00085d 1ee8          .dw XT_BYTESWAP
00085e 0860          .dw XT_LOWEMIT
00085f 1c1b          .dw XT_EXIT
                 
                 ; ( w -- )
                 ; R( -- )
                 ; content of cell fetched on stack.
                 ;VE_LOWEMIT:
                 ;    .dw $ff07
                 ;    .db "lowemit"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_LOWEMIT
                 XT_LOWEMIT:
000860 1c01          .dw DO_COLON
                 PFA_LOWEMIT:
000861 1c38          .dw XT_DOLITERAL
000862 00ff          .dw $00ff
000863 1e0e          .dw XT_AND
000864 0627          .dw XT_EMIT
000865 1c1b          .dw XT_EXIT
                 .include "words/icount.asm"
                 
                 ; Tools
                 ; get count information out of a counted string in flash
                 VE_ICOUNT:
000866 ff06          .dw $ff06
000867 6369
000868 756f
000869 746e          .db "icount"
00086a 083a          .dw VE_HEAD
                     .set VE_HEAD = VE_ICOUNT
                 XT_ICOUNT:
00086b 1c01          .dw DO_COLON
                 PFA_ICOUNT:
00086c 1cac          .dw XT_DUP
00086d 1e2a          .dw XT_1PLUS
00086e 1cbf          .dw XT_SWAP
00086f 1fbb          .dw XT_FETCHI
000870 1c1b          .dw XT_EXIT
                 .include "words/cr.asm"
                 
                 ; Character IO
                 ; cause subsequent output appear at the beginning of the next line
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_CR:
000871 ff02          .dw 0xff02
000872 7263          .db "cr"
000873 0866          .dw VE_HEAD
                     .set VE_HEAD = VE_CR
                 XT_CR:
000874 1c01          .dw DO_COLON
                 PFA_CR:
                 .endif
                 
000875 1c38          .dw XT_DOLITERAL
000876 000d          .dw 13
000877 0627          .dw XT_EMIT
000878 1c38          .dw XT_DOLITERAL
000879 000a          .dw 10
00087a 0627          .dw XT_EMIT
00087b 1c1b          .dw XT_EXIT
                 .include "words/space.asm"
                 
                 ; Character IO
                 ; emits a space (bl)
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SPACE:
00087c ff05          .dw $ff05
00087d 7073
00087e 6361
00087f 0065          .db "space",0
000880 0871          .dw VE_HEAD
                     .set VE_HEAD = VE_SPACE
                 XT_SPACE:
000881 1c01          .dw DO_COLON
                 PFA_SPACE:
                 .endif
000882 068a          .dw XT_BL
000883 0627          .dw XT_EMIT
000884 1c1b          .dw XT_EXIT
                 .include "words/spaces.asm"
                 
                 ; Character IO
                 ; emits n space(s) (bl)
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SPACES:
000885 ff06          .dw $ff06
000886 7073
000887 6361
000888 7365          .db "spaces"
000889 087c          .dw VE_HEAD
                     .set VE_HEAD = VE_SPACES
                 XT_SPACES:
00088a 1c01          .dw DO_COLON
                 PFA_SPACES:
                 
                 .endif
                 ;C SPACES   n --            output n spaces
                 ;   BEGIN DUP 0> WHILE SPACE 1- REPEAT DROP ;
00088b 1d4f
00088c 0709      	.DW XT_ZERO, XT_MAX
00088d 1cac
00088e 1c31      SPCS1:  .DW XT_DUP,XT_DOCONDBRANCH
00088f 0894              DEST(SPCS2)
000890 0881
000891 1e30
000892 1c2a              .DW XT_SPACE,XT_1MINUS,XT_DOBRANCH
000893 088d              DEST(SPCS1)
000894 1cd4
000895 1c1b      SPCS2:  .DW XT_DROP,XT_EXIT
                 .include "words/type.asm"
                 
                 ; Character IO
                 ; print a RAM based string
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_TYPE:
000896 ff04          .dw $ff04
000897 7974
000898 6570          .db "type"
000899 0885          .dw VE_HEAD
                     .set VE_HEAD = VE_TYPE
                 XT_TYPE:
00089a 1c01          .dw DO_COLON
                 PFA_TYPE:
                 
                 .endif
00089b 0de2          .dw XT_BOUNDS
00089c 0379          .dw XT_QDOCHECK
00089d 1c31          .dw XT_DOCONDBRANCH
00089e 08a5          DEST(PFA_TYPE2)
00089f 1e8a          .dw XT_DODO
                 PFA_TYPE1:
0008a0 1e9b          .dw XT_I
0008a1 1c93          .dw XT_CFETCH
0008a2 0627          .dw XT_EMIT
0008a3 1eb8          .dw XT_DOLOOP
0008a4 08a0          DEST(PFA_TYPE1)
                 PFA_TYPE2:
0008a5 1c1b          .dw XT_EXIT
                 .include "words/tick.asm"
                 
                 ; Dictionary
                 ; search dictionary for name, return XT or throw an exception -13
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_TICK:
0008a6 ff01          .dw $ff01
0008a7 0027          .db "'",0
0008a8 0896          .dw VE_HEAD
                     .set VE_HEAD = VE_TICK
                 XT_TICK:
0008a9 1c01          .dw DO_COLON
                 PFA_TICK:
                 .endif
0008aa 0a4c          .dw XT_PARSENAME
0008ab 0b31          .dw XT_DORECOGNIZER
0008ac 0bb4          .dw XT_R_WORD
0008ad 1fd4          .dw XT_EQUAL
0008ae 1c31          .dw XT_DOCONDBRANCH
0008af 08b2          DEST(PFA_TICK1)
0008b0 1cd4          .dw XT_DROP
0008b1 1c1b          .dw XT_EXIT
                 PFA_TICK1:
0008b2 1c38          .dw XT_DOLITERAL
0008b3 fff3          .dw -13
0008b4 08d8          .dw XT_THROW
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/handler.asm"
                 
                 ; Exceptions
                 ; USER variable used by catch/throw
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_HANDLER:
0008b5 ff07          .dw $ff07
0008b6 6168
0008b7 646e
0008b8 656c
0008b9 0072          .db "handler",0
0008ba 08a6          .dw VE_HEAD
                     .set VE_HEAD = VE_HANDLER
                 XT_HANDLER:
0008bb 1c53          .dw PFA_DOUSER
                 PFA_HANDLER:
                 .endif
0008bc 000a          .dw USER_HANDLER
                 .include "words/catch.asm"
                 
                 ; Exceptions
                 ; execute XT and check for exceptions.
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_CATCH:
0008bd ff05          .dw $ff05
0008be 6163
0008bf 6374
0008c0 0068          .db "catch",0
0008c1 08b5          .dw VE_HEAD
                     .set VE_HEAD = VE_CATCH
                 XT_CATCH:
0008c2 1c01          .dw DO_COLON
                 PFA_CATCH:
                 .endif
                 
                     ; sp@ >r
0008c3 1e7c          .dw XT_SP_FETCH
0008c4 1cfa          .dw XT_TO_R
                     ; handler @ >r
0008c5 08bb          .dw XT_HANDLER
0008c6 1c74          .dw XT_FETCH
0008c7 1cfa          .dw XT_TO_R
                     ; rp@ handler !
0008c8 1e65          .dw XT_RP_FETCH
0008c9 08bb          .dw XT_HANDLER
0008ca 1c7c          .dw XT_STORE
0008cb 1c25          .dw XT_EXECUTE
                     ; r> handler !
0008cc 1cf1          .dw XT_R_FROM
0008cd 08bb          .dw XT_HANDLER
0008ce 1c7c          .dw XT_STORE
0008cf 1cf1          .dw XT_R_FROM
0008d0 1cd4          .dw XT_DROP
0008d1 1d4f          .dw XT_ZERO
0008d2 1c1b          .dw XT_EXIT
                 .include "words/throw.asm"
                 
                 ; Exceptions
                 ; throw an exception
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_THROW:
0008d3 ff05          .dw $ff05
0008d4 6874
0008d5 6f72
0008d6 0077          .db "throw",0
0008d7 08bd          .dw VE_HEAD
                     .set VE_HEAD = VE_THROW
                 XT_THROW:
0008d8 1c01          .dw DO_COLON
                 PFA_THROW:
                 .endif
0008d9 1cac          .dw XT_DUP
0008da 1d15          .dw XT_ZEROEQUAL
0008db 1c31          .dw XT_DOCONDBRANCH
0008dc 08df          DEST(PFA_THROW1)
0008dd 1cd4      	.dw XT_DROP
0008de 1c1b      	.dw XT_EXIT
                 PFA_THROW1:
0008df 08bb          .dw XT_HANDLER
0008e0 1c74          .dw XT_FETCH
0008e1 1e6f          .dw XT_RP_STORE
0008e2 1cf1          .dw XT_R_FROM
0008e3 08bb          .dw XT_HANDLER
0008e4 1c7c          .dw XT_STORE
0008e5 1cf1          .dw XT_R_FROM
0008e6 1cbf          .dw XT_SWAP
0008e7 1cfa          .dw XT_TO_R
0008e8 1e85          .dw XT_SP_STORE
0008e9 1cd4          .dw XT_DROP
0008ea 1cf1          .dw XT_R_FROM    
0008eb 1c1b          .dw XT_EXIT
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/cskip.asm"
                 
                 ; String
                 ; skips leading occurancies in string at addr1/n1 leaving addr2/n2 pointing to the 1st non-c character
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_CSKIP:
0008ec ff05          .dw $ff05
0008ed 7363
0008ee 696b
0008ef 0070          .db "cskip",0
0008f0 08d3          .dw VE_HEAD
                     .set VE_HEAD = VE_CSKIP
                 XT_CSKIP:
0008f1 1c01          .dw DO_COLON
                 PFA_CSKIP:
                 .endif
0008f2 1cfa          .dw XT_TO_R           ; ( -- addr1 n1 )
                 PFA_CSKIP1:
0008f3 1cac          .dw XT_DUP            ; ( -- addr' n' n' )
0008f4 1c31          .dw XT_DOCONDBRANCH   ; ( -- addr' n')
0008f5 0901          DEST(PFA_CSKIP2)
0008f6 1cca          .dw XT_OVER           ; ( -- addr' n' addr' )
0008f7 1c93          .dw XT_CFETCH         ; ( -- addr' n' c' )
0008f8 1d03          .dw XT_R_FETCH        ; ( -- addr' n' c' c )
0008f9 1fd4          .dw XT_EQUAL          ; ( -- addr' n' f )
0008fa 1c31          .dw XT_DOCONDBRANCH   ; ( -- addr' n')
0008fb 0901          DEST(PFA_CSKIP2)
0008fc 1c38          .dw XT_DOLITERAL
0008fd 0001          .dw 1
0008fe 0a3d          .dw XT_SLASHSTRING
0008ff 1c2a          .dw XT_DOBRANCH
000900 08f3          DEST(PFA_CSKIP1)
                 PFA_CSKIP2:
000901 1cf1          .dw XT_R_FROM
000902 1cd4          .dw XT_DROP           ; ( -- addr2 n2)
000903 1c1b          .dw XT_EXIT
                 .include "words/cscan.asm"
                 
                 ; String
                 ; Scan string at addr1/n1 for the first occurance of c, leaving addr1/n2, char at n2 is first non-c character
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_CSCAN:
000904 ff05          .dw $ff05
000905 7363
000906 6163
../../common\words/cscan.asm(12): warning: .cseg .db misalignment - padding zero byte
000907 006e          .db "cscan"
000908 08ec          .dw VE_HEAD
                     .set VE_HEAD = VE_CSCAN
                 XT_CSCAN:
000909 1c01          .dw DO_COLON
                 PFA_CSCAN:
                 .endif
00090a 1cfa          .dw XT_TO_R
00090b 1cca          .dw XT_OVER
                 PFA_CSCAN1:
00090c 1cac          .dw XT_DUP
00090d 1c93          .dw XT_CFETCH
00090e 1d03          .dw XT_R_FETCH
00090f 1fd4          .dw XT_EQUAL
000910 1d15          .dw XT_ZEROEQUAL
000911 1c31          .dw XT_DOCONDBRANCH
000912 091e          DEST(PFA_CSCAN2)
000913 1cbf            .dw XT_SWAP
000914 1e30            .dw XT_1MINUS
000915 1cbf            .dw XT_SWAP
000916 1cca            .dw XT_OVER
000917 1d1c            .dw XT_ZEROLESS ; not negative
000918 1d15            .dw XT_ZEROEQUAL
000919 1c31            .dw XT_DOCONDBRANCH
00091a 091e            DEST(PFA_CSCAN2)
00091b 1e2a              .dw XT_1PLUS
00091c 1c2a              .dw XT_DOBRANCH
00091d 090c              DEST(PFA_CSCAN1)
                 PFA_CSCAN2:
00091e 1ceb          .dw XT_NIP
00091f 1cca          .dw XT_OVER
000920 1d8e          .dw XT_MINUS
000921 1cf1          .dw XT_R_FROM
000922 1cd4          .dw XT_DROP
000923 1c1b          .dw XT_EXIT
                 
                 ; : my-cscan ( addr len c -- addr len' )
                 ;    >r over ( -- addr len addr )
                 ;    begin
                 ;      dup c@ r@ <> while
                 ;       swap 1- swap over 0 >=  while
                 ;        1+ 
                 ;     repeat then
                 ;     nip over - r> drop 
                 ; ;
                 .include "words/accept.asm"
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_ACCEPT:
000924 ff06          .dw $ff06
000925 6361
000926 6563
000927 7470          .db "accept"
000928 0904          .dw VE_HEAD
                     .set VE_HEAD = VE_ACCEPT
                 XT_ACCEPT:
000929 1c01          .dw DO_COLON
                 PFA_ACCEPT:
                 
                 .endif
00092a 1cca
00092b 1d98
00092c 1e30
00092d 1cca              .DW XT_OVER,XT_PLUS,XT_1MINUS,XT_OVER
00092e 0638
00092f 1cac
000930 0963
000931 1d15
000932 1c31      ACC1:   .DW XT_KEY,XT_DUP,XT_CRLFQ,XT_ZEROEQUAL,XT_DOCONDBRANCH
000933 0955              DEST(ACC5)
000934 1cac
000935 1c38
000936 0008
000937 1fd4
000938 1c31              .DW XT_DUP,XT_DOLITERAL,8,XT_EQUAL,XT_DOCONDBRANCH
000939 094c              DEST(ACC3)
00093a 1cd4
00093b 1cdc
00093c 05f8
00093d 1d73
00093e 1cfa
00093f 1cdc
000940 1cdc
000941 1cf1
000942 1c31              .DW XT_DROP,XT_ROT,XT_2DUP,XT_GREATER,XT_TO_R,XT_ROT,XT_ROT,XT_R_FROM,XT_DOCONDBRANCH
000943 094a      	DEST(ACC6)
000944 095b
000945 1e30
000946 1cfa
000947 1cca
000948 1cf1
000949 0133      	.DW XT_BS,XT_1MINUS,XT_TO_R,XT_OVER,XT_R_FROM,XT_UMAX
                 ACC6:
00094a 1c2a              .DW XT_DOBRANCH
00094b 0953              DEST(ACC4)
00094c 1cac
00094d 0627
00094e 1cca
00094f 1c88
000950 1e2a
000951 1cca
000952 013f      ACC3:   .DW XT_DUP,XT_EMIT,XT_OVER,XT_CSTORE,XT_1PLUS,XT_OVER,XT_UMIN
000953 1c2a      ACC4:   .DW XT_DOBRANCH
000954 092e              DEST(ACC1)
000955 1cd4
000956 1ceb
000957 1cbf
000958 1d8e
000959 0874
00095a 1c1b      ACC5:   .DW XT_DROP,XT_NIP,XT_SWAP,XT_MINUS,XT_CR,XT_EXIT
                 
                 
                 ; ( --  ) 
                 ; System
                 ; send a backspace character to overwrite the current char
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 ;VE_BS:
                 ;    .dw $ff02
                 ;    .db "bs"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_BS
                 XT_BS:
00095b 1c01          .dw DO_COLON
                 .endif
00095c 1c38          .dw XT_DOLITERAL
00095d 0008          .dw 8
00095e 1cac          .dw XT_DUP
00095f 0627          .dw XT_EMIT
000960 0881          .dw XT_SPACE
000961 0627          .dw XT_EMIT
000962 1c1b          .dw XT_EXIT
                 
                 
                 ; ( c -- f ) 
                 ; System
                 ; is the character a line end character?
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 ;VE_CRLFQ:
                 ;    .dw $ff02
                 ;    .db "crlf?"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_CRLFQ
                 XT_CRLFQ:
000963 1c01          .dw DO_COLON
                 .endif
000964 1cac          .dw XT_DUP
000965 1c38          .dw XT_DOLITERAL
000966 000d          .dw 13
000967 1fd4          .dw XT_EQUAL
000968 1cbf          .dw XT_SWAP
000969 1c38          .dw XT_DOLITERAL
00096a 000a          .dw 10
00096b 1fd4          .dw XT_EQUAL
00096c 1e17          .dw XT_OR
00096d 1c1b          .dw XT_EXIT
                 .include "words/refill.asm"
                 
                 ; System
                 ; refills the input buffer
                 VE_REFILL:
00096e ff06          .dw $ff06
00096f 6572
000970 6966
000971 6c6c          .db "refill"
000972 0924          .dw VE_HEAD
                     .set VE_HEAD = VE_REFILL
                 XT_REFILL:
000973 0c9b          .dw PFA_DODEFER1
                 PFA_REFILL:
000974 001a          .dw USER_REFILL
000975 0c64          .dw XT_UDEFERFETCH
000976 0c70          .dw XT_UDEFERSTORE
                 
                 .include "words/char.asm"
                 
                 ; Tools
                 ; copy the first character of the next word onto the stack
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_CHAR:
000977 ff04          .dw $ff04
000978 6863
000979 7261          .db "char"
00097a 096e          .dw VE_HEAD
                     .set VE_HEAD = VE_CHAR
                 XT_CHAR:
00097b 1c01          .dw DO_COLON
                 PFA_CHAR:
                 .endif
00097c 0a4c          .dw XT_PARSENAME
00097d 1cd4          .dw XT_DROP
00097e 1c93          .dw XT_CFETCH
00097f 1c1b          .dw XT_EXIT
                 .include "words/number.asm"
                 
                 ; Numeric IO
                 ; convert a string at addr to a number
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_NUMBER:
000980 ff06          .dw $ff06
000981 756e
000982 626d
000983 7265          .db "number"
000984 0977          .dw VE_HEAD
                     .set VE_HEAD = VE_NUMBER
                 XT_NUMBER:
000985 1c01          .dw DO_COLON
                 PFA_NUMBER:
                 .endif
000986 05e3          .dw XT_BASE
000987 1c74          .dw XT_FETCH
000988 1cfa          .dw XT_TO_R
000989 09cc          .dw XT_QSIGN
00098a 1cfa          .dw XT_TO_R
00098b 09e0          .dw XT_SET_BASE
00098c 09cc          .dw XT_QSIGN
00098d 1cf1          .dw XT_R_FROM
00098e 1e17          .dw XT_OR
00098f 1cfa          .dw XT_TO_R
                     ; check whether something is left
000990 1cac          .dw XT_DUP
000991 1d15          .dw XT_ZEROEQUAL
000992 1c31          .dw XT_DOCONDBRANCH
000993 099c          DEST(PFA_NUMBER0)
                       ; nothing is left. It cannot be a number at all
000994 0601            .dw XT_2DROP
000995 1cf1            .dw XT_R_FROM
000996 1cd4            .dw XT_DROP
000997 1cf1            .dw XT_R_FROM
000998 05e3            .dw XT_BASE
000999 1c7c            .dw XT_STORE
00099a 1d4f            .dw XT_ZERO
00099b 1c1b            .dw XT_EXIT
                 PFA_NUMBER0:
00099c 1f0d          .dw XT_2TO_R
00099d 1d4f          .dw XT_ZERO       ; starting value
00099e 1d4f          .dw XT_ZERO
00099f 1f1c          .dw XT_2R_FROM
0009a0 09ff          .dw XT_TO_NUMBER ; ( 0. addr len -- d addr' len'
                     ; check length of the remaining string.
                     ; if zero: a single cell number is entered
0009a1 1cb4          .dw XT_QDUP
0009a2 1c31          .dw XT_DOCONDBRANCH
0009a3 09c0          DEST(PFA_NUMBER1)
                     ; if equal 1: mayba a trailing dot? --> double cell number
0009a4 1c38          .dw XT_DOLITERAL
0009a5 0001          .dw 1
0009a6 1fd4          .dw XT_EQUAL
0009a7 1c31          .dw XT_DOCONDBRANCH
0009a8 09b7          DEST(PFA_NUMBER2)
                 	; excatly one character is left
0009a9 1c93      	.dw XT_CFETCH
0009aa 1c38      	.dw XT_DOLITERAL
0009ab 002e      	.dw 46 ; .
0009ac 1fd4      	.dw XT_EQUAL
0009ad 1c31      	.dw XT_DOCONDBRANCH
0009ae 09b8      	DEST(PFA_NUMBER6)
                 	; its a double cell number
                         ; incorporate sign into number
0009af 1cf1      	.dw XT_R_FROM
0009b0 1c31              .dw XT_DOCONDBRANCH
0009b1 09b3      	DEST(PFA_NUMBER3)
0009b2 0d69              .dw XT_DNEGATE
                 PFA_NUMBER3:
0009b3 1c38      	.dw XT_DOLITERAL
0009b4 0002      	.dw 2
0009b5 1c2a      	.dw XT_DOBRANCH
0009b6 09c7      	DEST(PFA_NUMBER5)
                 PFA_NUMBER2:
0009b7 1cd4      	.dw XT_DROP
                 PFA_NUMBER6:
0009b8 0601      	.dw XT_2DROP
0009b9 1cf1      	.dw XT_R_FROM
0009ba 1cd4      	.dw XT_DROP
0009bb 1cf1              .dw XT_R_FROM
0009bc 05e3              .dw XT_BASE
0009bd 1c7c              .dw XT_STORE
0009be 1d4f      	.dw XT_ZERO
0009bf 1c1b      	.dw XT_EXIT
                 PFA_NUMBER1:
0009c0 0601          .dw XT_2DROP ; remove the address
                     ; incorporate sign into number
0009c1 1cf1          .dw XT_R_FROM
0009c2 1c31          .dw XT_DOCONDBRANCH
0009c3 09c5          DEST(PFA_NUMBER4)
0009c4 06da          .dw XT_NEGATE
                 PFA_NUMBER4:
0009c5 1c38          .dw XT_DOLITERAL
0009c6 0001          .dw 1
                 PFA_NUMBER5:
0009c7 1cf1          .dw XT_R_FROM
0009c8 05e3          .dw XT_BASE
0009c9 1c7c          .dw XT_STORE
0009ca 1d46          .dw XT_TRUE
0009cb 1c1b          .dw XT_EXIT
                 .include "words/q-sign.asm"
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 XT_QSIGN:
0009cc 1c01          .dw DO_COLON 
                 PFA_QSIGN:        ; ( c -- ) 
                 .endif
0009cd 1cca          .dw XT_OVER    ; ( -- addr len addr )
0009ce 1c93          .dw XT_CFETCH
0009cf 1c38          .dw XT_DOLITERAL
0009d0 002d          .dw '-'
0009d1 1fd4          .dw XT_EQUAL  ; ( -- addr len flag )
0009d2 1cac          .dw XT_DUP
0009d3 1cfa          .dw XT_TO_R
0009d4 1c31          .dw XT_DOCONDBRANCH
0009d5 09d9          DEST(PFA_NUMBERSIGN_DONE)
0009d6 1c38          .dw XT_DOLITERAL      ; skip sign character
0009d7 0001          .dw 1
0009d8 0a3d          .dw XT_SLASHSTRING
                 PFA_NUMBERSIGN_DONE:
0009d9 1cf1          .dw XT_R_FROM
0009da 1c1b          .dw XT_EXIT
                 .include "words/set-base.asm"
                 
                 ; Numeric IO
                 ; skip a numeric prefix character
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 XT_BASES:
0009db 1c4d          .dw PFA_DOCONSTANT
                 .endif
0009dc 000a
0009dd 0010
0009de 0002
0009df 000a          .dw 10,16,2,10 ; last one could a 8 instead.
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 XT_SET_BASE:
0009e0 1c01          .dw DO_COLON 
                 PFA_SET_BASE:        ; ( adr1 len1 -- adr2 len2 ) 
                 .endif
0009e1 1cca          .dw XT_OVER
0009e2 1c93          .dw XT_CFETCH
0009e3 1c38          .dw XT_DOLITERAL
0009e4 0023          .dw 35
0009e5 1d8e          .dw XT_MINUS
0009e6 1cac          .dw XT_DUP
0009e7 1d4f          .dw XT_ZERO
0009e8 1c38          .dw XT_DOLITERAL
0009e9 0004          .dw 4
0009ea 0716          .dw XT_WITHIN
0009eb 1c31          .dw XT_DOCONDBRANCH
0009ec 09f7          DEST(SET_BASE1)
                 	.if cpu_msp430==1
                 	.endif
0009ed 09db      	.dw XT_BASES
0009ee 1d98      	.dw XT_PLUS
0009ef 1fbb      	.dw XT_FETCHI
0009f0 05e3      	.dw XT_BASE
0009f1 1c7c      	.dw XT_STORE
0009f2 1c38      	.dw XT_DOLITERAL
0009f3 0001      	.dw 1
0009f4 0a3d      	.dw XT_SLASHSTRING
0009f5 1c2a      	.dw XT_DOBRANCH
0009f6 09f8      	DEST(SET_BASE2)
                 SET_BASE1:
0009f7 1cd4      	.dw XT_DROP
                 SET_BASE2:
0009f8 1c1b          .dw XT_EXIT 
                 
                 ; create bases 10 , 16 , 2 , 8 ,
                 ; : set-base 35 - dup 0 4 within if 
                 ;    bases + @i base ! 1 /string 
                 ;   else 
                 ;    drop
                 ;   then ;
                 .include "words/to-number.asm"
                 
                 ; Numeric IO
                 ; convert a string to a number  c-addr2/u2 is the unconverted string
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_TO_NUMBER:
0009f9 ff07          .dw $ff07
0009fa 6e3e
0009fb 6d75
0009fc 6562
0009fd 0072          .db ">number",0
0009fe 0980          .dw VE_HEAD
                     .set VE_HEAD = VE_TO_NUMBER
                 XT_TO_NUMBER:
0009ff 1c01          .dw DO_COLON
                 
                 .endif
                 
000a00 1cac
000a01 1c31      TONUM1: .DW XT_DUP,XT_DOCONDBRANCH
000a02 0a18              DEST(TONUM3)
000a03 1cca
000a04 1c93
000a05 07f2              .DW XT_OVER,XT_CFETCH,XT_DIGITQ
000a06 1d15
000a07 1c31              .DW XT_ZEROEQUAL,XT_DOCONDBRANCH
000a08 0a0b              DEST(TONUM2)
000a09 1cd4
000a0a 1c1b              .DW XT_DROP,XT_EXIT
000a0b 1cfa
000a0c 0d8e
000a0d 05e3
000a0e 1c74
000a0f 0124      TONUM2: .DW XT_TO_R,XT_2SWAP,XT_BASE,XT_FETCH,XT_UDSTAR
000a10 1cf1
000a11 011c
000a12 0d8e              .DW XT_R_FROM,XT_MPLUS,XT_2SWAP
000a13 1c38
000a14 0001
000a15 0a3d
000a16 1c2a              .DW XT_DOLITERAL,1,XT_SLASHSTRING,XT_DOBRANCH
000a17 0a00              DEST(TONUM1)
000a18 1c1b      TONUM3: .DW XT_EXIT
                 
                 ;C >NUMBER  ud adr u -- ud' adr' u'
                 ;C                      convert string to number
                 ;   BEGIN
                 ;   DUP WHILE
                 ;       OVER C@ DIGIT?
                 ;       0= IF DROP EXIT THEN
                 ;       >R 2SWAP BASE @ UD*
                 ;       R> M+ 2SWAP
                 ;       1 /STRING
                 ;   REPEAT ;
                 .include "words/parse.asm"
                 
                 ; String
                 ; in input buffer parse ccc delimited string by the delimiter char.
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_PARSE:
000a19 ff05          .dw $ff05
000a1a 6170
000a1b 7372
000a1c 0065          .db "parse",0
000a1d 09f9          .dw VE_HEAD
                     .set VE_HEAD = VE_PARSE
                 XT_PARSE:
000a1e 1c01          .dw DO_COLON
                 PFA_PARSE:
                 .endif
000a1f 1cfa          .dw XT_TO_R     ; ( -- )
000a20 0a33          .dw XT_SOURCE   ; ( -- addr len)
000a21 0611          .dw XT_TO_IN     ; ( -- addr len >in)
000a22 1c74          .dw XT_FETCH
000a23 0a3d          .dw XT_SLASHSTRING ; ( -- addr' len' )
                 
000a24 1cf1          .dw XT_R_FROM      ; ( -- addr' len' c)
000a25 0909          .dw XT_CSCAN       ; ( -- addr' len'')
000a26 1cac          .dw XT_DUP         ; ( -- addr' len'' len'')
000a27 1e2a          .dw XT_1PLUS
000a28 0611          .dw XT_TO_IN        ; ( -- addr' len'' len'' >in)
000a29 1e54          .dw XT_PLUSSTORE   ; ( -- addr' len')
000a2a 1c38          .dw XT_DOLITERAL
000a2b 0001          .dw 1
000a2c 0a3d          .dw XT_SLASHSTRING
000a2d 1c1b          .dw XT_EXIT
                 .include "words/source.asm"
                 
                 ; System
                 ; address and current length of the input buffer
                 VE_SOURCE:
000a2e ff06          .dw $FF06
000a2f 6f73
000a30 7275
000a31 6563          .db "source"
000a32 0a19          .dw VE_HEAD
                     .set VE_HEAD = VE_SOURCE
                 XT_SOURCE:
000a33 0c9b          .dw PFA_DODEFER1
                 PFA_SOURCE:
000a34 0016          .dw USER_SOURCE
000a35 0c64          .dw XT_UDEFERFETCH
000a36 0c70          .dw XT_UDEFERSTORE
                 
                 
                 .include "words/slash-string.asm"
                 
                 ; String
                 ; adjust string from addr1 to addr1+n, reduce length from u1 to u2 by n
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SLASHSTRING:
000a37 ff07          .dw $ff07
000a38 732f
000a39 7274
000a3a 6e69
000a3b 0067          .db "/string",0
000a3c 0a2e          .dw VE_HEAD
                     .set VE_HEAD = VE_SLASHSTRING
                 XT_SLASHSTRING:
000a3d 1c01          .dw DO_COLON
                 PFA_SLASHSTRING:
                 .endif
000a3e 1cdc          .dw XT_ROT
000a3f 1cca          .dw XT_OVER
000a40 1d98          .dw XT_PLUS
000a41 1cdc          .dw XT_ROT
000a42 1cdc          .dw XT_ROT
000a43 1d8e          .dw XT_MINUS
000a44 1c1b          .dw XT_EXIT
                 
                 .include "words/parse-name.asm"
                 
                 ; String
                 ; In the SOURCE buffer parse whitespace delimited string. Returns string address within SOURCE.
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 VE_PARSENAME:
000a45 ff0a          .dw $FF0A 
000a46 6170
000a47 7372
000a48 2d65
000a49 616e
000a4a 656d          .db "parse-name"
000a4b 0a37          .dw VE_HEAD
                     .set VE_HEAD = VE_PARSENAME
                 XT_PARSENAME:
000a4c 1c01          .dw DO_COLON 
                 PFA_PARSENAME:
                 .endif
000a4d 068a          .dw XT_BL
000a4e 0a50          .dw XT_SKIPSCANCHAR
000a4f 1c1b          .dw XT_EXIT 
                 
                 ; ( c -- addr2 len2 ) 
                 ; String
                 ; skips char and scan what's left in source for char
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 ;VE_SKIPSCANCHAR:
                 ;    .dw $FF0A 
                 ;    .db "skipscanchar"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_SKIPSCANCHAR
                 XT_SKIPSCANCHAR:
000a50 1c01          .dw DO_COLON
                 PFA_SKIPSCANCHAR:
                 .endif
000a51 1cfa          .dw XT_TO_R
000a52 0a33          .dw XT_SOURCE 
000a53 0611          .dw XT_TO_IN 
000a54 1c74          .dw XT_FETCH 
000a55 0a3d          .dw XT_SLASHSTRING 
                 
000a56 1d03          .dw XT_R_FETCH
000a57 08f1          .dw XT_CSKIP
000a58 1cf1          .dw XT_R_FROM
000a59 0909          .dw XT_CSCAN
                 
                     ; adjust >IN
000a5a 05f8          .dw XT_2DUP
000a5b 1d98          .dw XT_PLUS
000a5c 0a33          .dw XT_SOURCE 
000a5d 1cd4          .dw XT_DROP
000a5e 1d8e          .dw XT_MINUS
000a5f 0611          .dw XT_TO_IN
000a60 1c7c          .dw XT_STORE
000a61 1c1b          .dw XT_EXIT
                 .include "words/find-name.asm"
                 
                 ; Tools
                 ; search wordlists for an entry with the name from c-addr/len
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_FINDNAME:
000a62 ff09          .dw $ff09
000a63 6966
000a64 646e
000a65 6e2d
000a66 6d61
000a67 0065          .db "find-name",0
000a68 0a45          .dw VE_HEAD
                     .set VE_HEAD = VE_FINDNAME
                 XT_FINDNAME:
000a69 1c01          .dw DO_COLON
                 PFA_FINDNAME:
                 .endif
000a6a 1c38          .dw XT_DOLITERAL
000a6b 0a75          .dw XT_FINDNAMEA
000a6c 1c38          .dw XT_DOLITERAL
000a6d 003e          .dw CFG_ORDERLISTLEN
000a6e 0503          .dw XT_MAPSTACK
000a6f 1d15          .dw XT_ZEROEQUAL
000a70 1c31          .dw XT_DOCONDBRANCH
000a71 0a74          DEST(PFA_FINDNAME1)
000a72 0601            .dw XT_2DROP
000a73 1d4f            .dw XT_ZERO
                 PFA_FINDNAME1:
000a74 1c1b          .dw XT_EXIT
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 XT_FINDNAMEA:
000a75 1c01          .dw DO_COLON
                 PFA_FINDNAMEA:
                 .endif
000a76 1cfa          .dw XT_TO_R
000a77 05f8          .dw XT_2DUP
000a78 1cf1          .dw XT_R_FROM
000a79 0cad          .dw XT_SEARCH_WORDLIST
000a7a 1cac          .dw XT_DUP
000a7b 1c31          .dw XT_DOCONDBRANCH
000a7c 0a82          DEST(PFA_FINDNAMEA1)
000a7d 1cfa            .dw XT_TO_R
000a7e 1ceb            .dw XT_NIP
000a7f 1ceb            .dw XT_NIP
000a80 1cf1            .dw XT_R_FROM
000a81 1d46            .dw XT_TRUE
                 PFA_FINDNAMEA1:
000a82 1c1b          .dw XT_EXIT
                 
                 .include "words/quit.asm"
                 
                 ; System
                 ; main loop of amforth. accept - interpret in an endless loop
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_QUIT:
000a83 ff04          .dw $ff04
000a84 7571
000a85 7469          .db "quit"
000a86 0a62          .dw VE_HEAD
                     .set VE_HEAD = VE_QUIT
                 XT_QUIT:
000a87 1c01          .dw DO_COLON
                 PFA_QUIT:
                 .endif
                 PFA_QUIT1:
000a88 03b0
000a89 03b7
000a8a 1c7c          .dw XT_LP0,XT_LP,XT_STORE
000a8b 0b09          .dw XT_SP0
000a8c 1e85          .dw XT_SP_STORE
000a8d 0b16          .dw XT_RP0
000a8e 1e6f          .dw XT_RP_STORE
000a8f 0452          .dw XT_LBRACKET
                 
                 PFA_QUIT2:
000a90 05dd          .dw XT_STATE
000a91 1c74          .dw XT_FETCH
000a92 1d15          .dw XT_ZEROEQUAL
000a93 1c31          .dw XT_DOCONDBRANCH
000a94 0a96          DEST(PFA_QUIT4)
000a95 0ab3          .dw XT_PROMPTREADY
                 PFA_QUIT4:
000a96 0973          .dw XT_REFILL
000a97 1c31          .dw XT_DOCONDBRANCH
000a98 0a90          DEST(PFA_QUIT2)
000a99 1c38          .dw XT_DOLITERAL
000a9a 0b59          .dw XT_INTERPRET
000a9b 08c2          .dw XT_CATCH
000a9c 1cb4          .dw XT_QDUP
000a9d 1c31          .dw XT_DOCONDBRANCH
000a9e 0aa8          DEST(PFA_QUIT3)
000a9f 1cac      	.dw XT_DUP
000aa0 1c38      	.dw XT_DOLITERAL
000aa1 fffe      	.dw -2
000aa2 1d69      	.dw XT_LESS
000aa3 1c31      	.dw XT_DOCONDBRANCH
000aa4 0aa6      	DEST(PFA_QUIT5)
000aa5 0aba      	.dw XT_PROMPTERROR
                 PFA_QUIT5:
000aa6 1c2a      	.dw XT_DOBRANCH
000aa7 0a88      	DEST(PFA_QUIT1)
                 PFA_QUIT3:
000aa8 0aac          .dw XT_PROMPTOK
000aa9 1c2a          .dw XT_DOBRANCH
000aaa 0a90          DEST(PFA_QUIT2)
000aab 1c1b          .dw XT_EXIT ; never reached
                 
                 .include "words/prompt-ok.asm"
                 
                 ; System
                 ; send the READY prompt to the command line
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 ;VE_PROMPTOK:
                 ;    .dw $ff02
                 ;    .db "ok"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_PROMPTOK
                 XT_PROMPTOK:
000aac 1c01          .dw DO_COLON
                 PFA_PROMPTOK:
000aad 080c          .dw XT_DOSLITERAL
000aae 0003          .dw 3
000aaf 6f20
000ab0 006b          .db " ok",0
                 .endif
000ab1 083f          .dw XT_ITYPE
000ab2 1c1b          .dw XT_EXIT
                 .include "words/prompt-ready.asm"
                 
                 ; System
                 ; process the error prompt
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 ;VE_PROMPTRDY:
                 ;    .dw $ff04
                 ;    .db "p_er"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_PROMPTRDY
                 XT_PROMPTREADY:
000ab3 1c01          .dw DO_COLON
                 PFA_PROMPTREADY:
000ab4 080c          .dw XT_DOSLITERAL
000ab5 0002          .dw 2
000ab6 203e          .db "> "
                 .endif
000ab7 0874          .dw XT_CR
000ab8 083f          .dw XT_ITYPE
000ab9 1c1b          .dw XT_EXIT
                 .include "words/prompt-error.asm"
                 
                 ; System
                 ; process the error prompt
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 ;VE_PROMPTERROR:
                 ;    .dw $ff04
                 ;    .db "p_er"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_PROMPTERROR
                 XT_PROMPTERROR:
000aba 1c01          .dw DO_COLON
                 PFA_PROMPTERROR:
000abb 080c      	.dw XT_DOSLITERAL
000abc 0004          .dw 4
000abd 3f20
000abe 203f          .db " ?? "
                 .endif
000abf 083f          .dw XT_ITYPE
000ac0 05e3          .dw XT_BASE
000ac1 1c74          .dw XT_FETCH
000ac2 1cfa          .dw XT_TO_R
000ac3 0677          .dw XT_DECIMAL
000ac4 07c1          .dw XT_DOT
000ac5 0611          .dw XT_TO_IN
000ac6 1c74          .dw XT_FETCH
000ac7 07c1          .dw XT_DOT
000ac8 1cf1          .dw XT_R_FROM
000ac9 05e3          .dw XT_BASE
000aca 1c7c          .dw XT_STORE
000acb 1c1b          .dw XT_EXIT
                 .include "words/pause.asm"
                 
                 ; Multitasking
                 ; Fetch pause vector and execute it. may make a context/task switch
                 VE_PAUSE:
000acc ff05          .dw $ff05
000acd 6170
000ace 7375
000acf 0065          .db "pause",0
000ad0 0a83          .dw VE_HEAD
                     .set VE_HEAD = VE_PAUSE
                 XT_PAUSE:
000ad1 0c9b          .dw PFA_DODEFER1
                 PFA_PAUSE:
000ad2 0085          .dw ram_pause
000ad3 0c50          .dw XT_RDEFERFETCH
000ad4 0c5a          .dw XT_RDEFERSTORE
                 
                 .dseg
000085           ram_pause: .byte 2
                 .cseg
                 .include "words/cold.asm"
                 
                 ; System
                 ; start up amforth.
                 VE_COLD:
000ad5 ff04          .dw $ff04
000ad6 6f63
000ad7 646c          .db "cold"
000ad8 0acc          .dw VE_HEAD
                     .set VE_HEAD = VE_COLD
                 XT_COLD:
000ad9 0ada          .dw PFA_COLD
                 PFA_COLD:
000ada b6a4          in_ mcu_boot, MCUSR
000adb 2422          clr zerol
000adc 2433          clr zeroh
000add be24          out_ MCUSR, zerol
                     ; clear RAM
000ade e6e0          ldi zl, low(ramstart)
000adf e0f0          ldi zh, high(ramstart)
                 clearloop:
000ae0 9221          st Z+, zerol
000ae1 36e0          cpi zl, low(sram_size+ramstart)
000ae2 f7e9          brne clearloop
000ae3 30f4          cpi zh, high(sram_size+ramstart)
000ae4 f7d9          brne clearloop
                     ; init first user data area
                     ; allocate space for User Area
                 .dseg
000087           ram_user1: .byte SYSUSERSIZE + APPUSERSIZE
                 .cseg
000ae5 e8e7          ldi zl, low(ram_user1)
000ae6 e0f0          ldi zh, high(ram_user1)
000ae7 012f          movw upl, zl
                     ; init return stack pointer
000ae8 e50f          ldi temp0,low(rstackstart)
000ae9 bf0d          out_ SPL,temp0
000aea 8304          std Z+4, temp0
000aeb e014          ldi temp1,high(rstackstart)
000aec bf1e          out_ SPH,temp1
000aed 8315          std Z+5, temp1
                 
                     ; init parameter stack pointer
000aee e0cf          ldi yl,low(stackstart)
000aef 83c6          std Z+6, yl
000af0 e0d4          ldi yh,high(stackstart)
000af1 83d7          std Z+7, yh
                 
                     ; load Forth IP with starting word
000af2 efab          ldi XL, low(PFA_WARM)
000af3 e0ba          ldi XH, high(PFA_WARM)
                     ; its a far jump...
000af4 940c 1c05     jmp_ DO_NEXT
                 .include "words/warm.asm"
                 
                 ; System
                 ; initialize amforth further. executes turnkey operation and go to quit
                 VE_WARM:
000af6 ff04          .dw $ff04
000af7 6177
000af8 6d72          .db "warm"
000af9 0ad5          .dw VE_HEAD
                     .set VE_HEAD = VE_WARM
                 XT_WARM:
000afa 1c01          .dw DO_COLON
                 PFA_WARM:
000afb 0dd4          .dw XT_INITUSER
000afc 1c38          .dw XT_DOLITERAL
000afd 0c06          .dw XT_NOOP
000afe 1c38          .dw XT_DOLITERAL
000aff 0ad1          .dw XT_PAUSE
000b00 0c7b          .dw XT_DEFERSTORE
000b01 0452          .dw XT_LBRACKET
000b02 0692          .dw XT_TURNKEY
000b03 0a87          .dw XT_QUIT
000b04 1c1b          .dw XT_EXIT
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/sp0.asm"
                 
                 ; Stack
                 ; start address of the data stack
                 VE_SP0:
000b05 ff03          .dw $ff03
000b06 7073
000b07 0030          .db "sp0",0
000b08 0af6          .dw VE_HEAD
                     .set VE_HEAD = VE_SP0
                 XT_SP0:
000b09 1c6a          .dw PFA_DOVALUE1
                 PFA_SP0:
000b0a 0006          .dw USER_SP0
000b0b 0c64          .dw XT_UDEFERFETCH
000b0c 0c70          .dw XT_UDEFERSTORE
                 
                 ; ( -- addr) 
                 ; Stack
                 ; address of user variable to store top-of-stack for inactive tasks
                 VE_SP:
000b0d ff02          .dw $ff02
000b0e 7073          .db "sp"
000b0f 0b05          .dw VE_HEAD
                     .set VE_HEAD = VE_SP
                 XT_SP:
000b10 1c53          .dw PFA_DOUSER
                 PFA_SP:
000b11 0008          .dw USER_SP
                 .include "words/rp0.asm"
                 
                 ; Stack
                 ; start address of return stack
                 VE_RP0:
000b12 ff03          .dw $ff03
000b13 7072
000b14 0030          .db "rp0",0
000b15 0b0d          .dw VE_HEAD
                     .set VE_HEAD = VE_RP0
                 XT_RP0:
000b16 1c01          .dw DO_COLON
                 PFA_RP0:
000b17 0b1a          .dw XT_DORP0
000b18 1c74          .dw XT_FETCH
000b19 1c1b          .dw XT_EXIT
                 
                 ; ( -- addr) 
                 ; Stack
                 ; user variable of the address of the initial return stack
                 ;VE_DORP0:
                 ;    .dw $ff05
                 ;    .db "(rp0)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DORP0
                 XT_DORP0:
000b1a 1c53          .dw PFA_DOUSER
                 PFA_DORP0:
000b1b 0004          .dw USER_RP
                 .include "words/depth.asm"
                 
                 ; Stack
                 ; number of single-cell values contained in the data stack before n was placed on the stack.
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DEPTH:
000b1c ff05          .dw $ff05
000b1d 6564
000b1e 7470
000b1f 0068          .db "depth",0
000b20 0b12          .dw VE_HEAD
                     .set VE_HEAD = VE_DEPTH
                 XT_DEPTH:
000b21 1c01          .dw DO_COLON
                 PFA_DEPTH:
                 .endif
000b22 0b09          .dw XT_SP0
000b23 1e7c          .dw XT_SP_FETCH
000b24 1d8e          .dw XT_MINUS
000b25 1dff          .dw XT_2SLASH
000b26 1e30          .dw XT_1MINUS
000b27 1c1b          .dw XT_EXIT
                 .include "words/do-recognizer.asm"
                 
                 ; System
                 ; walk the recognizer stack
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DORECOGNIZER:
000b28 ff0d          .dw $ff0d
000b29 6f64
000b2a 722d
000b2b 6365
000b2c 676f
000b2d 696e
000b2e 657a
000b2f 0072          .db "do-recognizer",0
000b30 0b1c          .dw VE_HEAD
                     .set VE_HEAD = VE_DORECOGNIZER
                 XT_DORECOGNIZER:
000b31 1c01          .dw DO_COLON
                 PFA_DORECOGNIZER:
                 .endif
000b32 1c38          .dw XT_DOLITERAL
000b33 0b3d          .dw XT_DORECOGNIZER_A
000b34 1c38          .dw XT_DOLITERAL
000b35 0050          .dw CFG_RECOGNIZERLISTLEN
000b36 0503          .dw XT_MAPSTACK
000b37 1d15          .dw XT_ZEROEQUAL
000b38 1c31          .dw XT_DOCONDBRANCH
000b39 0b3c          DEST(PFA_DORECOGNIZER1)
000b3a 0601            .dw XT_2DROP
000b3b 0bd1            .dw XT_R_FAIL
                 PFA_DORECOGNIZER1:
000b3c 1c1b          .dw XT_EXIT
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 ; ( addr len XT -- addr len [ r:table -1 | 0 ] )
                 XT_DORECOGNIZER_A:
000b3d 1c01         .dw DO_COLON
                 PFA_DORECOGNIZER_A:
                 .endif
000b3e 1cdc         .dw XT_ROT  ; -- len xt addr
000b3f 1cdc         .dw XT_ROT  ; -- xt addr len
000b40 05f8         .dw XT_2DUP 
000b41 1f0d         .dw XT_2TO_R
000b42 1cdc         .dw XT_ROT  ; -- addr len xt
000b43 1c25         .dw XT_EXECUTE ; -- i*x r:foo | r:fail
000b44 1f1c         .dw XT_2R_FROM
000b45 1cdc         .dw XT_ROT
000b46 1cac         .dw XT_DUP
000b47 0bd1         .dw XT_R_FAIL
000b48 1fd4         .dw XT_EQUAL
000b49 1c31         .dw XT_DOCONDBRANCH
000b4a 0b4e         DEST(PFA_DORECOGNIZER_A1)
000b4b 1cd4           .dw XT_DROP
000b4c 1d4f           .dw XT_ZERO
000b4d 1c1b           .dw XT_EXIT
                 PFA_DORECOGNIZER_A1:
000b4e 1ceb         .dw XT_NIP 
000b4f 1ceb         .dw XT_NIP
000b50 1d46         .dw XT_TRUE
000b51 1c1b         .dw XT_EXIT
                 
                 ; : do-recognizer ( addr len -- i*x r:table|r:fail )
                 ;    \ ( addr len -- addr len 0 | i*x r:table -1 )
                 ;    [: rot rot 2dup 2>r rot execute 2r> rot 
                 ;          dup r:fail = ( -- addr len r:table f )
                 ;          if drop 0 else nip nip -1 then
                 ;    ;] 
                 ;    EE_RECOGNIZERLISTLEN map-stack ( -- i*x addr len r:table f )
                 ;    0= if \ a recognizer did the job, remove addr/len
                 ;     2drop r:fail 
                 ;    then
                 ;
                 .include "words/interpret.asm"
                 
                 ; System
                 ; Interpret SOURCE word by word.
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_INTERPRET:
000b52 ff09          .dw $ff09
000b53 6e69
000b54 6574
000b55 7072
000b56 6572
000b57 0074          .db "interpret",0
000b58 0b28          .dw VE_HEAD
                     .set VE_HEAD = VE_INTERPRET
                 XT_INTERPRET:
000b59 1c01          .dw DO_COLON
                 .endif
                 PFA_INTERPRET:
000b5a 0a4c          .dw XT_PARSENAME ; ( -- addr len )
000b5b 1cac          .dw XT_DUP   ; ( -- addr len flag)
000b5c 1c31          .dw XT_DOCONDBRANCH
000b5d 0b69          DEST(PFA_INTERPRET2)
000b5e 0b31            .dw XT_DORECOGNIZER
000b5f 05dd            .dw XT_STATE
000b60 1c74            .dw XT_FETCH
000b61 1c31            .dw XT_DOCONDBRANCH
000b62 0b64          DEST(PFA_INTERPRET1)
000b63 0c33            .dw XT_ICELLPLUS   ; we need the compile action
                 PFA_INTERPRET1:
000b64 1fbb            .dw XT_FETCHI
000b65 1c25            .dw XT_EXECUTE
000b66 0bde            .dw XT_QSTACK
000b67 1c2a          .dw XT_DOBRANCH
000b68 0b5a          DEST(PFA_INTERPRET)
                 PFA_INTERPRET2:
000b69 0601          .dw XT_2DROP
000b6a 1c1b          .dw XT_EXIT
                 .include "words/r-intnumber.asm"
                 
                 ; Interpreter
                 ; Method table for single cell integers
                 
                 
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_R_NUM:
000b6b ff05          .dw $ff05
000b6c 3a72
000b6d 756e
000b6e 006d          .db "r:num",0
000b6f 0b52          .dw VE_HEAD
                     .set VE_HEAD = VE_R_NUM
                 XT_R_NUM:
000b70 1c4d          .dw PFA_DOCONSTANT
                 PFA_R_NUM:
                 .endif
000b71 0c06          .dw XT_NOOP    ; interpret
000b72 02d0          .dw XT_LITERAL ; compile
000b73 0b7d          .dw XT_FAILNUM ; postpone
                 
                 ; ( -- addr )
                 ; Interpreter
                 ; Method table for double cell integers
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_R_DNUM:
000b74 ff06          .dw $ff06
000b75 3a72
000b76 6e64
000b77 6d75          .db "r:dnum"
000b78 0b6b          .dw VE_HEAD
                     .set VE_HEAD = VE_R_DNUM
                 XT_R_DNUM:
000b79 1c4d          .dw PFA_DOCONSTANT
                 PFA_R_DNUM:
                 .endif
000b7a 0c06          .dw XT_NOOP     ; interpret
000b7b 1fc8          .dw XT_2LITERAL ; compile
000b7c 0b83          .dw XT_FAILDNUM ; postpone
                 
                 ; ( -- addr )
                 ; Interpreter
                 ; Method to print a number and throw exception "invalid postpone"
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 ;VE_FAILNUM:
                 ;    .dw $ff06
                 ;    .db "fail:i"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_FAILNUM
                 XT_FAILNUM:
000b7d 1c01          .dw DO_COLON
                 PFA_FAILNUM:
                 .endif
000b7e 07c1          .dw XT_DOT
000b7f 1c38          .dw XT_DOLITERAL
000b80 ffd0          .dw -48
000b81 08d8          .dw XT_THROW
000b82 1c1b          .dw XT_EXIT
                 
                 ; ( -- addr )
                 ; Interpreter
                 ; Method to print a double cell number and throw exception "invalid postpone"
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 VE_FAILDNUM:
                 ;    .dw $ff06
                 ;    .db "fail:d"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_FAILDNUM
                 XT_FAILDNUM:
000b83 1c01          .dw DO_COLON
                 PFA_FAILDNUM:
                 .endif
000b84 07b9          .dw XT_DDOT
000b85 1c38          .dw XT_DOLITERAL
000b86 ffd0          .dw -48
000b87 08d8          .dw XT_THROW
000b88 1c1b          .dw XT_EXIT
                 
                 ; ( addr len -- f )
                 ; Interpreter
                 ; recognizer for integer numbers
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 VE_REC_NUM:
000b89 ff07          .dw $ff07
000b8a 6572
000b8b 3a63
000b8c 756e
000b8d 006d          .db "rec:num",0
000b8e 0b74          .dw VE_HEAD
                     .set VE_HEAD = VE_REC_NUM
                 XT_REC_NUM:
000b8f 1c01          .dw DO_COLON
                 PFA_REC_NUM:
                 .endif
                     ; try converting to a number
000b90 0985          .dw XT_NUMBER
000b91 1c31          .dw XT_DOCONDBRANCH
000b92 0b9c          DEST(PFA_REC_NONUMBER)
000b93 1c38          .dw XT_DOLITERAL
000b94 0001          .dw 1
000b95 1fd4          .dw XT_EQUAL
000b96 1c31          .dw XT_DOCONDBRANCH
000b97 0b9a          DEST(PFA_REC_INTNUM2)
000b98 0b70            .dw XT_R_NUM
000b99 1c1b            .dw XT_EXIT
                 PFA_REC_INTNUM2:
000b9a 0b79            .dw XT_R_DNUM
000b9b 1c1b            .dw XT_EXIT
                 PFA_REC_NONUMBER:
000b9c 0bd1          .dw XT_R_FAIL
000b9d 1c1b          .dw XT_EXIT
                 .include "words/r-word.asm"
                 
                 ; Interpreter
                 ; search for a word
                 .if cpu_msp430==1
                 .endif
                 .if cpu_avr8==1
                 VE_REC_WORD:
000b9e ff08          .dw $ff08
000b9f 6572
000ba0 3a63
000ba1 6f77
000ba2 6472          .db "rec:word"
000ba3 0b89          .dw VE_HEAD
                     .set VE_HEAD = VE_REC_WORD
                 XT_REC_WORD:
000ba4 1c01          .dw DO_COLON
                 PFA_REC_WORD:
                 .endif
000ba5 0a69          .DW XT_FINDNAME
000ba6 1cac          .dw XT_DUP
000ba7 1d15          .dw XT_ZEROEQUAL
000ba8 1c31          .dw XT_DOCONDBRANCH
000ba9 0bad          DEST(PFA_REC_WORD_FOUND)
000baa 1cd4              .dw XT_DROP
000bab 0bd1      	.dw XT_R_FAIL
000bac 1c1b      	.dw XT_EXIT
                 PFA_REC_WORD_FOUND:
000bad 0bb4          .dw XT_R_WORD
                 
000bae 1c1b          .dw XT_EXIT
                 
                 ; ( -- addr )
                 ; Interpreter
                 ; actions to handle execution tokens and their flags
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_R_WORD:
000baf ff06          .dw $ff06
000bb0 3a72
000bb1 6f77
000bb2 6472          .db "r:word"
000bb3 0b9e          .dw VE_HEAD
                     .set VE_HEAD = VE_R_WORD
                 XT_R_WORD:
000bb4 1c4d          .dw PFA_DOCONSTANT
                 PFA_R_WORD:
                 .endif
000bb5 0bb8          .dw XT_R_WORD_INTERPRET
000bb6 0bbc          .dw XT_R_WORD_COMPILE
000bb7 0bc4          .dw XT_R_WORD_POSTPONE
                 
                 ; ( XT flags -- )
                 ; Interpreter
                 ; interpret method for WORD recognizer
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 XT_R_WORD_INTERPRET:
000bb8 1c01          .dw DO_COLON
                 PFA_R_WORD_INTERPRET:
                 .endif
000bb9 1cd4          .dw XT_DROP ; the flags are in the way
000bba 1c25          .dw XT_EXECUTE
000bbb 1c1b          .dw XT_EXIT
                 
                 ; ( XT flags -- )
                 ; Interpreter
                 ; Compile method for WORD recognizer
                 .if cpu_msp430==1
                 .endif
                 .if cpu_avr8==1
                 XT_R_WORD_COMPILE:
000bbc 1c01          .dw DO_COLON
                 PFA_R_WORD_COMPILE:
                 .endif
000bbd 1d1c          .dw XT_ZEROLESS
000bbe 1c31          .dw XT_DOCONDBRANCH
000bbf 0bc2          DEST(PFA_R_WORD_COMPILE1)
000bc0 02ba      	.dw XT_COMMA
000bc1 1c1b              .dw XT_EXIT
                 PFA_R_WORD_COMPILE1:
000bc2 1c25              .dw XT_EXECUTE
000bc3 1c1b          .dw XT_EXIT
                 
                 ; ( XT flags -- )
                 ; Interpreter
                 ; Postpone method for WORD recognizer
                 .if cpu_msp430==1
                 .endif
                 .if cpu_avr8==1
                 XT_R_WORD_POSTPONE:
000bc4 1c01          .dw DO_COLON
                 PFA_R_WORD_POSTPONE:
                 .endif
000bc5 1d1c          .dw XT_ZEROLESS
000bc6 1c31          .dw XT_DOCONDBRANCH
000bc7 0bca          DEST(PFA_R_WORD_POSTPONE1)
000bc8 02af            .dw XT_COMPILE
000bc9 02af            .dw XT_COMPILE
                 PFA_R_WORD_POSTPONE1:
000bca 02ba          .dw XT_COMMA
000bcb 1c1b          .dw XT_EXIT
                 .include "words/r-fail.asm"
                 
                 ; Interpreter
                 ; there is no parser for this recognizer, this is the default and failsafe part
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_R_FAIL:
000bcc ff06          .dw $ff06
000bcd 3a72
000bce 6166
000bcf 6c69          .db "r:fail"
000bd0 0baf          .dw VE_HEAD
                     .set VE_HEAD = VE_R_FAIL
                 XT_R_FAIL:
000bd1 1c4d          .dw PFA_DOCONSTANT
                 PFA_R_FAIL:
                 .endif
000bd2 0bd5          .dw XT_FAIL  ; interpret
000bd3 0bd5          .dw XT_FAIL  ; compile
000bd4 0bd5          .dw XT_FAIL  ; postpone
                 
                 ; ( addr len -- )
                 ; Interpreter
                 ; default failure action: throw exception -13.
                 .if cpu_msp430==1
                 .endif
                 .if cpu_avr8==1
                 ;VE_FAIL:
                 ;    .dw $ff04
                 ;    .db "fail"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_FAIL
                 XT_FAIL:
000bd5 1c01          .dw DO_COLON
                 PFA_FAIL:
                 .endif
000bd6 1c38          .dw XT_DOLITERAL
000bd7 fff3          .dw -13
000bd8 08d8          .dw XT_THROW
                 
                 .include "words/q-stack.asm"
                 
                 ; Tools
                 ; check data stack depth and exit to quit if underrun
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_QSTACK:
000bd9 ff06          .dw $ff06
000bda 733f
000bdb 6174
000bdc 6b63          .db "?stack"
000bdd 0bcc          .dw VE_HEAD
                     .set VE_HEAD = VE_QSTACK
                 XT_QSTACK:
000bde 1c01          .dw DO_COLON
                 PFA_QSTACK:
                 .endif
000bdf 0b21          .dw XT_DEPTH
000be0 1d1c          .dw XT_ZEROLESS
000be1 1c31          .dw XT_DOCONDBRANCH
000be2 0be6          DEST(PFA_QSTACK1)
000be3 1c38            .dw XT_DOLITERAL
000be4 fffc            .dw -4
000be5 08d8            .dw XT_THROW
                 PFA_QSTACK1:
000be6 1c1b          .dw XT_EXIT
                 .include "words/ver.asm"
                 
                 ; Tools
                 ; print the version string
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DOT_VER:
000be7 ff03          .dw $ff03
000be8 6576
../../common\words/ver.asm(12): warning: .cseg .db misalignment - padding zero byte
000be9 0072          .db "ver"
000bea 0bd9          .dw VE_HEAD
                     .set VE_HEAD = VE_DOT_VER
                 XT_DOT_VER:
000beb 1c01          .dw DO_COLON
                 PFA_DOT_VER:
                 .endif
000bec 059f          .dw XT_ENV_FORTHNAME
000bed 083f          .dw XT_ITYPE
000bee 0881          .dw XT_SPACE
000bef 05e3          .dw XT_BASE
000bf0 1c74          .dw XT_FETCH
                 
000bf1 05ad          .dw XT_ENV_FORTHVERSION
000bf2 0677          .dw XT_DECIMAL
000bf3 0deb          .dw XT_S2D
000bf4 075d          .dw XT_L_SHARP
000bf5 0765          .dw XT_SHARP
000bf6 1c38          .dw XT_DOLITERAL
000bf7 002e          .dw '.'
000bf8 074e          .dw XT_HOLD
000bf9 077b          .dw XT_SHARP_S
000bfa 0786          .dw XT_SHARP_G
000bfb 089a          .dw XT_TYPE
000bfc 05e3          .dw XT_BASE
000bfd 1c7c          .dw XT_STORE
000bfe 0881          .dw XT_SPACE
000bff 05b5          .dw XT_ENV_CPU
000c00 083f          .dw XT_ITYPE
                 
000c01 1c1b          .dw XT_EXIT
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/noop.asm"
                 
                 ; Tools
                 ; do nothing
                 VE_NOOP:
000c02 ff04          .dw $ff04
000c03 6f6e
000c04 706f          .db "noop"
000c05 0be7          .dw VE_HEAD
                     .set VE_HEAD = VE_NOOP
                 XT_NOOP:
000c06 0c07          .dw PFA_NOOP
                 PFA_NOOP:
000c07 940c 1c05     jmp_ DO_NEXT
                 .include "words/unused.asm"
                 
                 ; Tools
                 ; Amount of available RAM (incl. PAD)
                 VE_UNUSED:
000c09 ff06          .dw $ff06
000c0a 6e75
000c0b 7375
000c0c 6465          .db "unused"
000c0d 0c02          .dw VE_HEAD
                     .set VE_HEAD = VE_UNUSED
                 XT_UNUSED:
000c0e 1c01          .dw DO_COLON
                 PFA_UNUSED:
000c0f 1e7c          .dw XT_SP_FETCH
000c10 0658          .dw XT_HERE
000c11 1d8e          .dw XT_MINUS
000c12 1c1b          .dw XT_EXIT
                 
                 .include "words/to.asm"
                 
                 ; Tools
                 ; store the TOS to the named value (eeprom cell)
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_TO:
000c13 0002          .dw $0002
000c14 6f74          .db "to"
000c15 0c09          .dw VE_HEAD
                     .set VE_HEAD = VE_TO
                 XT_TO:
000c16 1c01          .dw DO_COLON
                 PFA_TO:
                 .endif
000c17 08a9          .dw XT_TICK
000c18 0df4          .dw XT_TO_BODY
000c19 05dd          .dw XT_STATE
000c1a 1c74          .dw XT_FETCH
000c1b 1c31          .dw XT_DOCONDBRANCH
000c1c 0c27          DEST(PFA_TO1)
000c1d 02af          .dw XT_COMPILE
000c1e 0c21          .dw XT_DOTO
000c1f 02ba          .dw XT_COMMA
000c20 1c1b          .dw XT_EXIT
                 
                 ; ( n -- ) (R: IP -- IP+1)
                 ; Tools
                 ; runtime portion of to
                 ;VE_DOTO:
                 ;    .dw $ff04
                 ;    .db "(to)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOTO
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 XT_DOTO:
000c21 1c01          .dw DO_COLON
                 PFA_DOTO:
                 .endif
000c22 1cf1          .dw XT_R_FROM
000c23 1cac          .dw XT_DUP
000c24 0c33          .dw XT_ICELLPLUS
000c25 1cfa          .dw XT_TO_R
000c26 1fbb          .dw XT_FETCHI
                 PFA_TO1:
000c27 1cac          .dw XT_DUP
000c28 0c33          .dw XT_ICELLPLUS
000c29 0c33          .dw XT_ICELLPLUS
000c2a 1fbb          .dw XT_FETCHI
000c2b 1c25          .dw XT_EXECUTE
000c2c 1c1b          .dw XT_EXIT
                 .include "words/i-cellplus.asm"
                 
                 ; Compiler
                 ; skip to the next cell in flash
                 VE_ICELLPLUS:
000c2d ff07          .dw $FF07
000c2e 2d69
000c2f 6563
000c30 6c6c
000c31 002b          .db "i-cell+",0
000c32 0c13          .dw VE_HEAD
                     .set VE_HEAD = VE_ICELLPLUS
                 XT_ICELLPLUS:
000c33 1c01          .dw DO_COLON
                 PFA_ICELLPLUS:
000c34 1e2a          .dw XT_1PLUS
000c35 1c1b          .dw XT_EXIT
                 
                 .include "words/edefer-fetch.asm"
                 
                 ; System
                 ; does the real defer@ for eeprom defers
                 VE_EDEFERFETCH:
000c36 ff07          .dw $ff07
000c37 6445
000c38 6665
000c39 7265
000c3a 0040          .db "Edefer@",0
000c3b 0c2d          .dw VE_HEAD
                     .set VE_HEAD = VE_EDEFERFETCH
                 XT_EDEFERFETCH:
000c3c 1c01          .dw DO_COLON
                 PFA_EDEFERFETCH:
000c3d 1fbb          .dw XT_FETCHI
000c3e 1f4e          .dw XT_FETCHE
000c3f 1c1b          .dw XT_EXIT
                 .include "words/edefer-store.asm"
                 
                 ; System
                 ; does the real defer! for eeprom defers
                 VE_EDEFERSTORE:
000c40 ff07          .dw $ff07
000c41 6445
000c42 6665
000c43 7265
000c44 0021          .db "Edefer!",0
000c45 0c36          .dw VE_HEAD
                     .set VE_HEAD = VE_EDEFERSTORE
                 XT_EDEFERSTORE:
000c46 1c01          .dw DO_COLON
                 PFA_EDEFERSTORE:
000c47 1fbb          .dw XT_FETCHI
000c48 1f2a          .dw XT_STOREE
000c49 1c1b          .dw XT_EXIT
                 .include "words/rdefer-fetch.asm"
                 
                 ; System
                 ; The defer@ for ram defers
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_RDEFERFETCH:
000c4a ff07          .dw $ff07
000c4b 6452
000c4c 6665
000c4d 7265
000c4e 0040          .db "Rdefer@",0
000c4f 0c40          .dw VE_HEAD
                     .set VE_HEAD = VE_RDEFERFETCH
                 XT_RDEFERFETCH:
000c50 1c01          .dw DO_COLON
                 PFA_RDEFERFETCH:
                 .endif
000c51 1fbb          .dw XT_FETCHI
000c52 1c74          .dw XT_FETCH
000c53 1c1b          .dw XT_EXIT
                 .include "words/rdefer-store.asm"
                 
                 ; System
                 ; The defer! for ram defers
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_RDEFERSTORE:
000c54 ff07          .dw $ff07
000c55 6452
000c56 6665
000c57 7265
000c58 0021          .db "Rdefer!",0
000c59 0c4a          .dw VE_HEAD
                     .set VE_HEAD = VE_RDEFERSTORE
                 XT_RDEFERSTORE:
000c5a 1c01          .dw DO_COLON
                 PFA_RDEFERSTORE:
                 .endif
000c5b 1fbb          .dw XT_FETCHI
000c5c 1c7c          .dw XT_STORE
000c5d 1c1b          .dw XT_EXIT
                 
                 .include "words/udefer-fetch.asm"
                 
                 ; System
                 ; does the real defer@ for user based defers
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_UDEFERFETCH:
000c5e ff07          .dw $ff07
000c5f 6455
000c60 6665
000c61 7265
000c62 0040          .db "Udefer@",0
000c63 0c54          .dw VE_HEAD
                     .set VE_HEAD = VE_UDEFERFETCH
                 XT_UDEFERFETCH:
000c64 1c01          .dw DO_COLON
                 PFA_UDEFERFETCH:
                 .endif
000c65 1fbb          .dw XT_FETCHI
000c66 1ef1          .dw XT_UP_FETCH
000c67 1d98          .dw XT_PLUS
000c68 1c74          .dw XT_FETCH
000c69 1c1b          .dw XT_EXIT
                 .include "words/udefer-store.asm"
                 
                 ; System
                 ; does the real defer! for user based defers
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_UDEFERSTORE:
000c6a ff07          .dw $ff07
000c6b 6455
000c6c 6665
000c6d 7265
000c6e 0021          .db "Udefer!",0
000c6f 0c5e          .dw VE_HEAD
                     .set VE_HEAD = VE_UDEFERSTORE
                 XT_UDEFERSTORE:
000c70 1c01          .dw DO_COLON
                 PFA_UDEFERSTORE:
                 .endif
                 
000c71 1fbb          .dw XT_FETCHI
000c72 1ef1          .dw XT_UP_FETCH
000c73 1d98          .dw XT_PLUS
000c74 1c7c          .dw XT_STORE
000c75 1c1b          .dw XT_EXIT
                 
                 .include "words/defer-store.asm"
                 
                 ; System
                 ; stores xt1 as the xt to be executed when xt2 is called
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DEFERSTORE:
000c76 ff06          .dw $ff06
000c77 6564
000c78 6566
000c79 2172          .db "defer!"
000c7a 0c6a          .dw VE_HEAD
                     .set VE_HEAD = VE_DEFERSTORE
                 XT_DEFERSTORE:
000c7b 1c01          .dw DO_COLON
                 PFA_DEFERSTORE:
                 .endif
000c7c 0df4          .dw XT_TO_BODY
000c7d 1cac          .dw XT_DUP
000c7e 0c33          .dw XT_ICELLPLUS
000c7f 0c33          .dw XT_ICELLPLUS
000c80 1fbb          .dw XT_FETCHI
000c81 1c25          .dw XT_EXECUTE
000c82 1c1b          .dw XT_EXIT
                 
                 .include "words/defer-fetch.asm"
                 
                 ; System
                 ; returns the XT associated with the given XT
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DEFERFETCH:
000c83 ff06          .dw $ff06
000c84 6564
000c85 6566
000c86 4072          .db "defer@"
000c87 0c76          .dw VE_HEAD
                     .set VE_HEAD = VE_DEFERFETCH
                 XT_DEFERFETCH:
000c88 1c01          .dw DO_COLON
                 PFA_DEFERFETCH:
                 .endif
000c89 0df4          .dw XT_TO_BODY 
000c8a 1cac          .dw XT_DUP
000c8b 0c33          .dw XT_ICELLPLUS
000c8c 1fbb          .dw XT_FETCHI
000c8d 1c25          .dw XT_EXECUTE
000c8e 1c1b          .dw XT_EXIT
                 .include "words/do-defer.asm"
                 
                 ; System
                 ; runtime of defer
                 VE_DODEFER:
000c8f ff07          .dw $ff07
000c90 6428
000c91 6665
000c92 7265
000c93 0029          .db "(defer)", 0
000c94 0c83          .dw VE_HEAD
                     .set VE_HEAD = VE_DODEFER
                 XT_DODEFER:
000c95 1c01          .dw DO_COLON
                 PFA_DODEFER:
000c96 0289          .dw XT_DOCREATE
000c97 03ed          .dw XT_REVEAL
000c98 02af          .dw XT_COMPILE
000c99 0c9b          .dw PFA_DODEFER1
000c9a 1c1b          .dw XT_EXIT
                 PFA_DODEFER1:
000c9b 940e 0411     call_ DO_DODOES
000c9d 1cac          .dw XT_DUP
000c9e 0c33          .dw XT_ICELLPLUS
000c9f 1fbb          .dw XT_FETCHI
000ca0 1c25          .dw XT_EXECUTE 
000ca1 1c25          .dw XT_EXECUTE
000ca2 1c1b          .dw XT_EXIT
                 
                 ; : (defer) <builds does> dup i-cell+ @i execute execute ;
                 
                 
                 .include "words/search-wordlist.asm"
                 
                 ; Search Order
                 ; searches the word list wid for the word at c-addr/len
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SEARCH_WORDLIST:
000ca3 ff0f          .dw $ff0f
000ca4 6573
000ca5 7261
000ca6 6863
000ca7 772d
000ca8 726f
000ca9 6c64
000caa 7369
000cab 0074          .db "search-wordlist",0
000cac 0c8f          .dw VE_HEAD
                     .set VE_HEAD = VE_SEARCH_WORDLIST
                 XT_SEARCH_WORDLIST:
000cad 1c01          .dw DO_COLON
                 PFA_SEARCH_WORDLIST:
                 .endif
000cae 1cfa          .dw XT_TO_R
000caf 1d4f          .dw XT_ZERO
000cb0 1c38          .dw XT_DOLITERAL
000cb1 0cc2          .dw XT_ISWORD
000cb2 1cf1          .dw XT_R_FROM
000cb3 0cdf          .dw XT_TRAVERSEWORDLIST
000cb4 1cac          .dw XT_DUP
000cb5 1d15          .dw XT_ZEROEQUAL
000cb6 1c31          .dw XT_DOCONDBRANCH
000cb7 0cbc          DEST(PFA_SEARCH_WORDLIST1)
000cb8 0601             .dw XT_2DROP
000cb9 1cd4             .dw XT_DROP
000cba 1d4f             .dw XT_ZERO
000cbb 1c1b             .dw XT_EXIT
                 PFA_SEARCH_WORDLIST1:
                       ; ... get the XT ...
000cbc 1cac            .dw XT_DUP
000cbd 0d06            .dw XT_NFA2CFA
                       ; .. and get the header flag
000cbe 1cbf            .dw XT_SWAP
000cbf 015a            .dw XT_NAME2FLAGS
000cc0 0147            .dw XT_IMMEDIATEQ
000cc1 1c1b          .dw XT_EXIT
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 XT_ISWORD:
000cc2 1c01          .dw DO_COLON
                 PFA_ISWORD:
                 .endif
                     ; ( c-addr len 0 nt -- c-addr len 0 true| nt false )
000cc3 1cfa          .dw XT_TO_R
000cc4 1cd4          .dw XT_DROP
000cc5 05f8          .dw XT_2DUP
000cc6 1d03          .dw XT_R_FETCH  ; -- addr len addr len nt
000cc7 0cfa          .dw XT_NAME2STRING
000cc8 0d10          .dw XT_ICOMPARE      ; (-- addr len f )
000cc9 1c31          .dw XT_DOCONDBRANCH
000cca 0cd0          DEST(PFA_ISWORD3)
                       ; not now
000ccb 1cf1            .dw XT_R_FROM
000ccc 1cd4            .dw XT_DROP
000ccd 1d4f            .dw XT_ZERO
000cce 1d46            .dw XT_TRUE         ; maybe next word
000ccf 1c1b            .dw XT_EXIT
                 PFA_ISWORD3:
                       ; we found the word, now clean up iteration data ...
000cd0 0601            .dw XT_2DROP
000cd1 1cf1            .dw XT_R_FROM
000cd2 1d4f            .dw XT_ZERO       ; finish traverse-wordlist
000cd3 1c1b            .dw XT_EXIT
                 .include "words/traverse-wordlist.asm"
                 
                 ; Tools Ext (2012)
                 ; call the xt for every member of the wordlist wid until xt returns false
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_TRAVERSEWORDLIST:
000cd4 ff11          .dw $ff11
000cd5 7274
000cd6 7661
000cd7 7265
000cd8 6573
000cd9 772d
000cda 726f
000cdb 6c64
000cdc 7369
000cdd 0074          .db "traverse-wordlist",0
000cde 0ca3          .dw VE_HEAD
                     .set VE_HEAD = VE_TRAVERSEWORDLIST
                 XT_TRAVERSEWORDLIST:
000cdf 1c01          .dw DO_COLON
                 PFA_TRAVERSEWORDLIST:
                 
                 .endif
000ce0 1f4e          .dw XT_FETCHE
                 PFA_TRAVERSEWORDLIST1:
000ce1 1cac          .dw XT_DUP           ; ( -- xt nt nt )
000ce2 1c31          .dw XT_DOCONDBRANCH  ; ( -- nt ) is nfa = counted string
000ce3 0cf0          DEST(PFA_TRAVERSEWORDLIST2)
000ce4 05f8          .dw XT_2DUP
000ce5 1f0d          .dw XT_2TO_R
000ce6 1cbf          .dw XT_SWAP
000ce7 1c25          .dw XT_EXECUTE
000ce8 1f1c          .dw XT_2R_FROM
000ce9 1cdc          .dw XT_ROT
000cea 1c31          .dw XT_DOCONDBRANCH
000ceb 0cf0          DEST(PFA_TRAVERSEWORDLIST2)
000cec 056a          .dw XT_NFA2LFA
000ced 1fbb          .dw XT_FETCHI
000cee 1c2a          .dw XT_DOBRANCH      ; ( -- addr )
000cef 0ce1          DEST(PFA_TRAVERSEWORDLIST1)       ; ( -- addr )
                 PFA_TRAVERSEWORDLIST2:
000cf0 0601          .dw XT_2DROP
000cf1 1c1b          .dw XT_EXIT
                 
                 ; : traverse-wordlist ( i*x xt wid -- i*x' ) 
                 ;        begin @ dup 
                 ;        while 
                 ;          2dup 2>r 
                 ;          cell + swap execute ( i*x nt -- i*x' f ) 
                 ;          2r> rot 
                 ;        while repeat then 2drop ; 
                 .include "words/name2string.asm"
                 
                 ; Tools Ext (2012)
                 ; get a (flash) string from a name token nt
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_NAME2STRING:
000cf2 ff0b          .dw $ff0b
000cf3 616e
000cf4 656d
000cf5 733e
000cf6 7274
000cf7 6e69
000cf8 0067          .db "name>string",0
000cf9 0cd4          .dw VE_HEAD
                     .set VE_HEAD = VE_NAME2STRING
                 XT_NAME2STRING:
000cfa 1c01          .dw DO_COLON
                 PFA_NAME2STRING:
                 
                 .endif
000cfb 086b          .dw XT_ICOUNT   ; ( -- addr n )
000cfc 1c38          .dw XT_DOLITERAL
000cfd 00ff          .dw 255
000cfe 1e0e          .dw XT_AND      ; mask immediate bit
000cff 1c1b          .dw XT_EXIT
                 .include "words/nfa2cfa.asm"
                 
                 ; Tools
                 ; get the XT from a name token
                 VE_NFA2CFA:
000d00 ff07          .dw $ff07
000d01 666e
000d02 3e61
000d03 6663
../../avr8\words/nfa2cfa.asm(6): warning: .cseg .db misalignment - padding zero byte
000d04 0061          .db "nfa>cfa"
000d05 0cf2          .dw VE_HEAD
                     .set VE_HEAD = VE_NFA2CFA
                 XT_NFA2CFA:
000d06 1c01          .dw DO_COLON
                 PFA_NFA2CFA:
000d07 056a          .dw XT_NFA2LFA ; skip to link field
000d08 1e2a          .dw XT_1PLUS   ; next is the execution token
000d09 1c1b          .dw XT_EXIT
                 .include "words/icompare.asm"
                 
                 ; Tools
                 ; compares string in RAM with string in flash. f is zero if equal like COMPARE
                 VE_ICOMPARE:
000d0a ff08          .dw $ff08
000d0b 6369
000d0c 6d6f
000d0d 6170
000d0e 6572          .db "icompare"
000d0f 0d00          .dw VE_HEAD
                     .set VE_HEAD = VE_ICOMPARE
                 XT_ICOMPARE:
000d10 1c01          .dw DO_COLON
                 PFA_ICOMPARE:
000d11 1cfa          .dw XT_TO_R    ; ( -- r-addr r-len f-addr)
000d12 1cca          .dw XT_OVER    ; ( -- r-addr r-len f-addr r-len)
000d13 1cf1          .dw XT_R_FROM  ; ( -- r-addr r-len f-addr r-len f-len )
000d14 1d0e          .dw XT_NOTEQUAL ; ( -- r-addr r-len f-addr flag )
000d15 1c31          .dw XT_DOCONDBRANCH
000d16 0d1b          .dw PFA_ICOMPARE_SAMELEN
000d17 0601            .dw XT_2DROP
000d18 1cd4            .dw XT_DROP
000d19 1d46            .dw XT_TRUE
000d1a 1c1b            .dw XT_EXIT
                 PFA_ICOMPARE_SAMELEN:
000d1b 1cbf          .dw XT_SWAP ; ( -- r-addr f-addr len )
000d1c 1d4f          .dw XT_ZERO
000d1d 0379          .dw XT_QDOCHECK
000d1e 1c31          .dw XT_DOCONDBRANCH
000d1f 0d3e          .dw PFA_ICOMPARE_DONE
000d20 1e8a          .dw XT_DODO
                 PFA_ICOMPARE_LOOP:
                     ; ( r-addr f-addr --)
000d21 1cca          .dw XT_OVER
000d22 1c74          .dw XT_FETCH
                 .if WANT_IGNORECASE == 1
                 .endif
000d23 1cca          .dw XT_OVER
000d24 1fbb          .dw XT_FETCHI ; ( -- r-addr f-addr r-cc f- cc)
                 .if WANT_IGNORECASE == 1
                 .endif
                     ; flash strings are zero-padded at the last cell
                     ; that means: if the flash cell is less $0100, than mask the
                     ; high byte in the ram cell
000d25 1cac          .dw XT_DUP
                     ;.dw XT_BYTESWAP
000d26 1c38          .dw XT_DOLITERAL
000d27 0100          .dw $100
000d28 1d57          .dw XT_ULESS
000d29 1c31          .dw XT_DOCONDBRANCH
000d2a 0d2f          .dw PFA_ICOMPARE_LASTCELL
000d2b 1cbf          .dw XT_SWAP
000d2c 1c38          .dw XT_DOLITERAL
000d2d 00ff          .dw $00FF
000d2e 1e0e          .dw XT_AND  ; the final swap can be omitted
                 PFA_ICOMPARE_LASTCELL:
000d2f 1d0e          .dw XT_NOTEQUAL
000d30 1c31          .dw XT_DOCONDBRANCH
000d31 0d36          .dw PFA_ICOMPARE_NEXTLOOP
000d32 0601          .dw XT_2DROP
000d33 1d46          .dw XT_TRUE
000d34 1ec3          .dw XT_UNLOOP
000d35 1c1b          .dw XT_EXIT
                 PFA_ICOMPARE_NEXTLOOP:
000d36 1e2a          .dw XT_1PLUS
000d37 1cbf          .dw XT_SWAP
000d38 05f0          .dw XT_CELLPLUS
000d39 1cbf          .dw XT_SWAP
000d3a 1c38          .dw XT_DOLITERAL
000d3b 0002          .dw 2
000d3c 1ea9          .dw XT_DOPLUSLOOP
000d3d 0d21          .dw PFA_ICOMPARE_LOOP
                 PFA_ICOMPARE_DONE:
000d3e 0601          .dw XT_2DROP
000d3f 1d4f          .dw XT_ZERO
000d40 1c1b          .dw XT_EXIT
                 
                 .if WANT_IGNORECASE == 1
                 .endif
                 
                 .include "words/star.asm"
                 
                 ; Arithmetics
                 ; multiply routine
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_STAR:
000d41 ff01          .dw $ff01
000d42 002a          .db "*",0
000d43 0d0a          .dw VE_HEAD
                     .set VE_HEAD = VE_STAR
                 XT_STAR:
000d44 1c01          .dw DO_COLON
                 PFA_STAR:
                 .endif
                 
000d45 1da1          .dw XT_MSTAR
000d46 1cd4          .dw XT_DROP
000d47 1c1b          .dw XT_EXIT
                 .include "words/j.asm"
                 
                 ; Compiler
                 ; loop counter of outer loop
                 VE_J:
000d48 ff01          .dw $FF01
000d49 006a          .db "j",0
000d4a 0d41          .dw VE_HEAD
                     .set VE_HEAD = VE_J
                 XT_J:
000d4b 1c01          .dw DO_COLON
                 PFA_J:
000d4c 1e65          .dw XT_RP_FETCH
000d4d 1c38          .dw XT_DOLITERAL
000d4e 0007          .dw 7
000d4f 1d98          .dw XT_PLUS
000d50 1c74          .dw XT_FETCH
000d51 1e65          .dw XT_RP_FETCH
000d52 1c38          .dw XT_DOLITERAL
000d53 0009          .dw 9
000d54 1d98          .dw XT_PLUS
000d55 1c74          .dw XT_FETCH
000d56 1d98          .dw XT_PLUS
000d57 1c1b          .dw XT_EXIT
                 
                 .include "words/dabs.asm"
                 
                 ; Arithmetics
                 ; double cell absolute value
                 VE_DABS:
000d58 ff04          .dw $ff04
000d59 6164
000d5a 7362          .db "dabs"
000d5b 0d48          .dw VE_HEAD
                     .set VE_HEAD = VE_DABS
                 XT_DABS:
000d5c 1c01          .dw DO_COLON
                 PFA_DABS:
000d5d 1cac          .dw XT_DUP
000d5e 1d1c          .dw XT_ZEROLESS
000d5f 1c31          .dw XT_DOCONDBRANCH
000d60 0d62          .dw PFA_DABS1
000d61 0d69          .dw XT_DNEGATE
                 PFA_DABS1:
000d62 1c1b          .dw XT_EXIT
                 ; : dabs      ( ud1 -- +d2 ) dup 0< if dnegate then ;
                 .include "words/dnegate.asm"
                 
                 ; Arithmetics
                 ; double cell negation
                 VE_DNEGATE:
000d63 ff07          .dw $ff07
000d64 6e64
000d65 6765
000d66 7461
000d67 0065          .db "dnegate",0
000d68 0d58          .dw VE_HEAD
                     .set VE_HEAD = VE_DNEGATE
                 XT_DNEGATE:
000d69 1c01          .dw DO_COLON
                 PFA_DNEGATE:
000d6a 01cb          .dw XT_DINVERT
000d6b 1c38          .dw XT_DOLITERAL
000d6c 0001          .dw 1
000d6d 1d4f          .dw XT_ZERO
000d6e 01a3          .dw XT_DPLUS
000d6f 1c1b          .dw XT_EXIT
                 ; : dnegate   ( ud1 -- ud2 ) dinvert 1. d+ ;
                 .include "words/cmove.asm"
                 
                 ; Memory
                 ; copy data in RAM, from lower to higher addresses
                 VE_CMOVE:
000d70 ff05          .dw $ff05
000d71 6d63
000d72 766f
000d73 0065          .db "cmove",0
000d74 0d63          .dw VE_HEAD
                     .set VE_HEAD  = VE_CMOVE
                 XT_CMOVE:
000d75 0d76          .dw PFA_CMOVE
                 PFA_CMOVE:
000d76 93bf          push xh
000d77 93af          push xl
000d78 91e9          ld zl, Y+
000d79 91f9          ld zh, Y+ ; addr-to
000d7a 91a9          ld xl, Y+
000d7b 91b9          ld xh, Y+ ; addr-from
000d7c 2f09          mov temp0, tosh
000d7d 2b08          or temp0, tosl
000d7e f021          brbs 1, PFA_CMOVE1
                 PFA_CMOVE2:
000d7f 911d          ld temp1, X+
000d80 9311          st Z+, temp1
000d81 9701          sbiw tosl, 1
000d82 f7e1          brbc 1, PFA_CMOVE2
                 PFA_CMOVE1:
000d83 91af          pop xl
000d84 91bf          pop xh
000d85 9189
000d86 9199          loadtos
000d87 940c 1c05     jmp_ DO_NEXT
                 .include "words/2swap.asm"
                 
                 ; Stack
                 ; Exchange the two top cell pairs
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_2SWAP:
000d89 ff05          .dw $ff05
000d8a 7332
000d8b 6177
000d8c 0070          .db "2swap",0
000d8d 0d70          .dw VE_HEAD
                     .set VE_HEAD = VE_2SWAP
                 XT_2SWAP:
000d8e 1c01          .dw DO_COLON
                 PFA_2SWAP:
                 
                 .endif
000d8f 1cdc          .dw XT_ROT
000d90 1cfa          .dw XT_TO_R
000d91 1cdc          .dw XT_ROT
000d92 1cf1          .dw XT_R_FROM
000d93 1c1b          .dw XT_EXIT
                 
                 .include "words/tib.asm"
                 
                 ; System Variable
                 ; terminal input buffer address
                 VE_TIB:
000d94 ff03          .dw $ff03
000d95 6974
000d96 0062          .db "tib",0
000d97 0d89          .dw VE_HEAD
                     .set VE_HEAD = VE_TIB
                 XT_TIB:
000d98 1c43          .dw PFA_DOVARIABLE
                 PFA_TIB:
000d99 00ad          .dw ram_tib
                     
                 .dseg
0000ad           ram_tib: .byte TIBSIZE
                 .cseg
                 ; ( -- f ) 
                 ; System
                 ; refills the input buffer
                 VE_REFILLTIB:
000d9a ff0a          .dw $ff0a
000d9b 6572
000d9c 6966
000d9d 6c6c
000d9e 742d
000d9f 6269          .db "refill-tib"
000da0 0d94          .dw VE_HEAD
                     .set VE_HEAD = VE_REFILLTIB
                 XT_REFILLTIB:
000da1 1c01          .dw DO_COLON
                 PFA_REFILLTIB:
000da2 0d98          .dw XT_TIB
000da3 1c38          .dw XT_DOLITERAL
000da4 005a          .dw TIBSIZE
000da5 0929          .dw XT_ACCEPT
000da6 0617          .dw XT_NUMBERTIB
000da7 1c7c          .dw XT_STORE
000da8 1d4f          .dw XT_ZERO
000da9 0611          .dw XT_TO_IN
000daa 1c7c          .dw XT_STORE
000dab 1d46          .dw XT_TRUE ; -1
000dac 1c1b          .dw XT_EXIT
                 
                 ; ( -- addr n ) 
                 ; System
                 ; address and current length of the input buffer
                 VE_SOURCETIB:
000dad ff0a          .dw $FF0A
000dae 6f73
000daf 7275
000db0 6563
000db1 742d
000db2 6269          .db "source-tib"
000db3 0d9a          .dw VE_HEAD
                     .set VE_HEAD = VE_SOURCETIB
                 XT_SOURCETIB:
000db4 1c01          .dw DO_COLON
                 PFA_SOURCETIB:
000db5 0d98          .dw XT_TIB
000db6 0617          .dw XT_NUMBERTIB
000db7 1c74          .dw XT_FETCH
000db8 1c1b          .dw XT_EXIT
                 
                 .include "words/init-user.asm"
                 
                 ; Tools
                 ; copy len cells from eeprom to ram
                 VE_EE2RAM:
000db9 ff06        .dw $ff06
000dba 6565
000dbb 723e
000dbc 6d61        .db "ee>ram"
000dbd 0dad        .dw VE_HEAD
                   .set VE_HEAD = VE_EE2RAM
                 XT_EE2RAM:
000dbe 1c01        .dw DO_COLON
                 PFA_EE2RAM:          ; ( -- )
000dbf 1d4f          .dw XT_ZERO
000dc0 1e8a          .dw XT_DODO
                 PFA_EE2RAM_1:
                     ; ( -- e-addr r-addr )
000dc1 1cca          .dw XT_OVER
000dc2 1f4e          .dw XT_FETCHE
000dc3 1cca          .dw XT_OVER
000dc4 1c7c          .dw XT_STORE
000dc5 05f0          .dw XT_CELLPLUS
000dc6 1cbf          .dw XT_SWAP
000dc7 05f0          .dw XT_CELLPLUS
000dc8 1cbf          .dw XT_SWAP
000dc9 1eb8          .dw XT_DOLOOP
000dca 0dc1          .dw PFA_EE2RAM_1
                 PFA_EE2RAM_2:
000dcb 0601          .dw XT_2DROP
000dcc 1c1b          .dw XT_EXIT
                 
                 ; ( -- )
                 ; Tools
                 ; setup the default user area from eeprom
                 VE_INITUSER:
000dcd ff09        .dw $ff09
000dce 6e69
000dcf 7469
000dd0 752d
000dd1 6573
000dd2 0072        .db "init-user",0
000dd3 0db9        .dw VE_HEAD
                   .set VE_HEAD = VE_INITUSER
                 XT_INITUSER:
000dd4 1c01        .dw DO_COLON
                 PFA_INITUSER:          ; ( -- )
000dd5 1c38          .dw XT_DOLITERAL
000dd6 0060          .dw EE_INITUSER
000dd7 1ef1          .dw XT_UP_FETCH
000dd8 1c38          .dw XT_DOLITERAL
000dd9 001c          .dw SYSUSERSIZE
000dda 1dff          .dw XT_2SLASH
000ddb 0dbe          .dw XT_EE2RAM
000ddc 1c1b          .dw XT_EXIT
                 .include "words/bounds.asm"
                 
                 ; Tools
                 ; convert a string to an address range
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_BOUNDS:
000ddd ff06          .dw $ff06
000dde 6f62
000ddf 6e75
000de0 7364          .db "bounds"
000de1 0dcd          .dw VE_HEAD
                     .set VE_HEAD = VE_BOUNDS
                 XT_BOUNDS:
000de2 1c01          .dw DO_COLON
                 PFA_BOUNDS:
                 .endif
000de3 1cca          .dw XT_OVER
000de4 1d98          .dw XT_PLUS
000de5 1cbf          .dw XT_SWAP
000de6 1c1b          .dw XT_EXIT
                 .include "words/s-to-d.asm"
                 
                 ; Conversion
                 ; extend (signed) single cell value to double cell
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_S2D:
000de7 ff03          .dw $ff03
000de8 3e73
000de9 0064          .db "s>d",0
000dea 0ddd          .dw VE_HEAD
                     .set VE_HEAD = VE_S2D
                 XT_S2D:
000deb 1c01          .dw DO_COLON
                 PFA_S2D:
                 .endif
000dec 1cac          .dw XT_DUP
000ded 1d1c          .dw XT_ZEROLESS
000dee 1c1b          .dw XT_EXIT
                 .include "words/to-body.asm"
                 
                 ; Core
                 ; get body from XT
                 VE_TO_BODY:
000def ff05          .dw $ff05
000df0 623e
000df1 646f
000df2 0079          .db ">body",0
000df3 0de7          .dw VE_HEAD
                     .set VE_HEAD = VE_TO_BODY
                 XT_TO_BODY:
000df4 1e2b          .dw PFA_1PLUS
                 .else
                 .endif
                 .include "dict_appl.inc"
                 
                 ; they may be moved to the core dictionary if needed
                 .include "words/dot-s.asm"
                 
                 ; Tools
                 ; stack dump
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DOTS:
000df5 ff02          .dw $ff02
000df6 732e          .db ".s"
000df7 0def          .dw VE_HEAD
                     .set VE_HEAD = VE_DOTS
                 XT_DOTS:
000df8 1c01          .dw DO_COLON
                 PFA_DOTS:
                 .endif
000df9 0b21          .dw XT_DEPTH
000dfa 01e1          .dw XT_UDOT
000dfb 0881          .dw XT_SPACE
000dfc 0b21          .dw XT_DEPTH
000dfd 1d4f          .dw XT_ZERO
000dfe 0379          .dw XT_QDOCHECK
000dff 1c31          .dw XT_DOCONDBRANCH
000e00 0e07          DEST(PFA_DOTS2)
000e01 1e8a          .dw XT_DODO
                 PFA_DOTS1:
000e02 1e9b          .dw XT_I
000e03 0254          .dw XT_PICK
000e04 01e1          .dw XT_UDOT
000e05 1eb8          .dw XT_DOLOOP
000e06 0e02          DEST(PFA_DOTS1)
                 PFA_DOTS2:
000e07 1c1b          .dw XT_EXIT
                 .include "words/spirw.asm"
                 
                 ; MCU
                 ; SPI exchange of 1 byte
                 VE_SPIRW:
000e08 ff06          .dw $ff06
000e09 2163
000e0a 7340
000e0b 6970          .db "c!@spi"
000e0c 0df5          .dw VE_HEAD
                     .set VE_HEAD  = VE_SPIRW
                 XT_SPIRW:
000e0d 0e0e          .dw PFA_SPIRW
                 PFA_SPIRW:
000e0e d003          rcall do_spirw
000e0f 2799          clr tosh
000e10 940c 1c05     jmp_ DO_NEXT
                 
                 do_spirw:
000e12 b98f          out_ SPDR, tosl
                 do_spirw1:
000e13 b10e          in_ temp0, SPSR
000e14 7f08          cbr temp0,7
000e15 b90e          out_ SPSR, temp0
000e16 b10e          in_ temp0, SPSR
000e17 ff07          sbrs temp0, 7
000e18 cffa          rjmp do_spirw1   ; wait until complete
000e19 b18f          in_ tosl, SPDR
000e1a 9508          ret
                 .include "words/n-spi.asm"
                 
                 ; MCU
                 ; read len bytes from SPI to addr
                 VE_N_SPIR:
000e1b ff05          .dw $ff05
000e1c 406e
000e1d 7073
000e1e 0069          .db "n@spi",0
000e1f 0e08          .dw VE_HEAD
                     .set VE_HEAD  = VE_N_SPIR
                 XT_N_SPIR:
000e20 0e21          .dw PFA_N_SPIR
                 PFA_N_SPIR:
000e21 018c          movw temp0, tosl
000e22 9189
000e23 9199          loadtos
000e24 01fc          movw zl, tosl
000e25 01c8          movw tosl, temp0
                 PFA_N_SPIR_LOOP:
000e26 b82f          out_ SPDR, zerol
                 PFA_N_SPIR_LOOP1:
000e27 b12e          in_ temp2, SPSR
000e28 ff27          sbrs temp2, SPIF
000e29 cffd          rjmp PFA_N_SPIR_LOOP1
000e2a b12f          in_ temp2, SPDR
000e2b 9321          st Z+, temp2
000e2c 9701          sbiw tosl, 1
000e2d f7c1          brne PFA_N_SPIR_LOOP
000e2e 9189
000e2f 9199          loadtos
000e30 940c 1c05     jmp_ DO_NEXT
                 
                 ; ( addr len -- ) 
                 ; MCU
                 ; write len bytes to SPI from addr
                 VE_N_SPIW:
000e32 ff05          .dw $ff05
000e33 216e
000e34 7073
000e35 0069          .db "n!spi",0
000e36 0e1b          .dw VE_HEAD
                     .set VE_HEAD  = VE_N_SPIW
                 XT_N_SPIW:
000e37 0e38          .dw PFA_N_SPIW
                 PFA_N_SPIW:
000e38 018c          movw temp0, tosl
000e39 9189
000e3a 9199          loadtos
000e3b 01fc          movw zl, tosl
000e3c 01c8          movw tosl, temp0
                 PFA_N_SPIW_LOOP:
000e3d 9121          ld temp2, Z+
000e3e b92f          out_ SPDR, temp2
                 PFA_N_SPIW_LOOP1:
000e3f b12e          in_ temp2, SPSR
000e40 ff27          sbrs temp2, SPIF
000e41 cffd          rjmp PFA_N_SPIW_LOOP1
000e42 b12f          in_ temp2, SPDR ; ignore the data
000e43 9701          sbiw tosl, 1
000e44 f7c1          brne PFA_N_SPIW_LOOP
000e45 9189
000e46 9199          loadtos
000e47 940c 1c05     jmp_ DO_NEXT
                 .include "words/applturnkey.asm"
                 
                 ; R( -- )
                 ; application specific turnkey action
                 VE_APPLTURNKEY:
000e49 ff0b          .dw $ff0b
000e4a 7061
000e4b 6c70
000e4c 7574
000e4d 6e72
000e4e 656b
000e4f 0079          .db "applturnkey",0
000e50 0e32          .dw VE_HEAD
                     .set VE_HEAD = VE_APPLTURNKEY
                 XT_APPLTURNKEY:
000e51 1c01          .dw DO_COLON
                 PFA_APPLTURNKEY:
000e52 00a9          .dw XT_USART
000e53 0212          .dw XT_INTON
000e54 0beb          .dw XT_DOT_VER
000e55 0881          .dw XT_SPACE
000e56 05d2          .dw XT_F_CPU
000e57 1c38          .dw XT_DOLITERAL
000e58 03e8          .dw 1000
000e59 1dbd          .dw XT_UMSLASHMOD
000e5a 1cbf          .dw XT_SWAP
000e5b 1cd4          .dw XT_DROP
000e5c 0677          .dw XT_DECIMAL
000e5d 07c1          .dw XT_DOT
000e5e 080c          .dw XT_DOSLITERAL
000e5f 0004          .dw 4
000e60 486b
000e61 207a          .db "kHz "
000e62 083f          .dw XT_ITYPE
000e63 1c1b          .dw XT_EXIT
                 .include "dict/compiler2.inc"
                 
                 ; included almost independently from each other
                 ; on a include-per-use basis
                 ;
                 .if DICT_COMPILER2 == 0
                 .set DICT_COMPILER2 = 1
                 
                 .include "words/set-current.asm"
                 
                 ; Search Order
                 ; set current word list to the given word list wid
                 VE_SET_CURRENT:
000e64 ff0b          .dw $ff0b
000e65 6573
000e66 2d74
000e67 7563
000e68 7272
000e69 6e65
000e6a 0074          .db "set-current",0
000e6b 0e49          .dw VE_HEAD
                     .set VE_HEAD = VE_SET_CURRENT
                 XT_SET_CURRENT:
000e6c 1c01          .dw DO_COLON
                 PFA_SET_CURRENT:
000e6d 1c38          .dw XT_DOLITERAL
000e6e 003a          .dw EE_CURRENT
000e6f 1f2a          .dw XT_STOREE
000e70 1c1b          .dw XT_EXIT
                 .include "words/wordlist.asm"
                 
                 ; Search Order
                 ; create a new, empty wordlist
                 VE_WORDLIST:
000e71 ff08          .dw $ff08
000e72 6f77
000e73 6472
000e74 696c
000e75 7473          .db "wordlist"
000e76 0e64          .dw VE_HEAD
                     .set VE_HEAD = VE_WORDLIST
                 XT_WORDLIST:
000e77 1c01          .dw DO_COLON
                 PFA_WORDLIST:
000e78 0650          .dw XT_EHERE
000e79 1d4f          .dw XT_ZERO
000e7a 1cca          .dw XT_OVER
000e7b 1f2a          .dw XT_STOREE
000e7c 1cac          .dw XT_DUP
000e7d 05f0          .dw XT_CELLPLUS
000e7e 0c21          .dw XT_DOTO
000e7f 0651          .dw PFA_EHERE
000e80 1c1b          .dw XT_EXIT
                 
                 .include "words/only.asm"
                 
                 ; Search Order
                 ; replace the order list with the system default list
                 VE_ONLY:
000e81 ff04          .dw $ff04
000e82 6e6f
000e83 796c          .db "only"
000e84 0e71          .dw VE_HEAD
                     .set VE_HEAD = VE_ONLY
                 XT_ONLY:
000e85 1c01          .dw DO_COLON
                 PFA_ONLY:
000e86 1c38          .dw XT_DOLITERAL
000e87 003c          .dw EE_FORTHWORDLIST
000e88 1c38          .dw XT_DOLITERAL
000e89 0001          .dw 1
000e8a 0ea0          .dw XT_SET_ORDER
000e8b 1c1b          .dw XT_EXIT
                 .include "words/forth-wordlist.asm"
                 
                 ; Search Order
                 ; get the system default word list
                 VE_FORTH_WORDLIST:
000e8c ff0e          .dw $ff0e
000e8d 6f66
000e8e 7472
000e8f 2d68
000e90 6f77
000e91 6472
000e92 696c
000e93 7473          .db "forth-wordlist"
000e94 0e81          .dw VE_HEAD
                     .set VE_HEAD = VE_FORTH_WORDLIST
                 XT_FORTH_WORDLIST:
000e95 1c6a          .dw PFA_DOVALUE1
                 PFA_FORTH_WORDLIST:
000e96 0038          .dw EE_WL_FORTH
000e97 0c3c          .dw XT_EDEFERFETCH
000e98 0c46          .dw XT_EDEFERSTORE
                 .include "words/set-order.asm"
                 
                 ; Search Order
                 ; replace the search order list
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SET_ORDER:
000e99 ff09          .dw $ff09
000e9a 6573
000e9b 2d74
000e9c 726f
000e9d 6564
000e9e 0072          .db "set-order",0
000e9f 0e8c          .dw VE_HEAD
                     .set VE_HEAD = VE_SET_ORDER
                 XT_SET_ORDER:
000ea0 1c01          .dw DO_COLON
                 PFA_SET_ORDER:
                 .endif
000ea1 1c38          .dw XT_DOLITERAL
000ea2 003e          .dw CFG_ORDERLISTLEN
000ea3 04ec          .dw XT_SET_STACK
000ea4 1c1b          .dw XT_EXIT
                 
                 .include "words/set-recognizer.asm"
                 
                 ; Interpreter
                 ; replace the recognizer list
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SET_RECOGNIZERS:
000ea5 ff0f          .dw $ff0f
000ea6 6573
000ea7 2d74
000ea8 6572
000ea9 6f63
000eaa 6e67
000eab 7a69
000eac 7265
000ead 0073          .db "set-recognizers",0
000eae 0e99          .dw VE_HEAD
                     .set VE_HEAD = VE_SET_RECOGNIZERS
                 XT_SET_RECOGNIZERS:
000eaf 1c01          .dw DO_COLON
                 PFA_SET_RECOGNIZERS:
                 .endif
000eb0 1c38          .dw XT_DOLITERAL
000eb1 0050          .dw CFG_RECOGNIZERLISTLEN
000eb2 04ec          .dw XT_SET_STACK
000eb3 1c1b          .dw XT_EXIT
                 
                 .include "words/get-recognizer.asm"
                 
                 ; Interpreter
                 ; Get the current recognizer list
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_GET_RECOGNIZERS:
000eb4 ff0f          .dw $ff0f
000eb5 6567
000eb6 2d74
000eb7 6572
000eb8 6f63
000eb9 6e67
000eba 7a69
000ebb 7265
000ebc 0073          .db "get-recognizers",0
000ebd 0ea5          .dw VE_HEAD
                     .set VE_HEAD = VE_GET_RECOGNIZERS
                 XT_GET_RECOGNIZERS:
000ebe 1c01          .dw DO_COLON
                 PFA_GET_RECOGNIZERS:
                 .endif
000ebf 1c38          .dw XT_DOLITERAL
000ec0 0050          .dw CFG_RECOGNIZERLISTLEN
000ec1 04cb          .dw XT_GET_STACK
000ec2 1c1b          .dw XT_EXIT
                 .include "words/code.asm"
                 
                 ; Compiler
                 ; create named entry in the dictionary, XT is the data field
                 VE_CODE:
000ec3 ff04          .dw $ff04
000ec4 6f63
000ec5 6564          .db "code"
000ec6 0eb4          .dw VE_HEAD
                     .set VE_HEAD = VE_CODE
                 XT_CODE:
000ec7 1c01          .dw DO_COLON
                 PFA_CODE:
000ec8 0289          .dw XT_DOCREATE
000ec9 03ed          .dw XT_REVEAL
000eca 0647          .dw XT_DP
000ecb 0c33          .dw XT_ICELLPLUS
000ecc 02ba          .dw XT_COMMA
000ecd 1c1b          .dw XT_EXIT
                 .include "words/end-code.asm"
                 
                 ; Compiler
                 ; finish a code definition
                 VE_ENDCODE:
000ece ff08          .dw $ff08
000ecf 6e65
000ed0 2d64
000ed1 6f63
000ed2 6564          .db "end-code"
000ed3 0ec3          .dw VE_HEAD
                     .set VE_HEAD = VE_ENDCODE
                 XT_ENDCODE:
000ed4 1c01          .dw DO_COLON
                 PFA_ENDCODE:
000ed5 02af          .dw XT_COMPILE
000ed6 940c          .dw $940c
000ed7 02af          .dw XT_COMPILE
000ed8 1c05          .dw DO_NEXT
000ed9 1c1b          .dw XT_EXIT
                 .include "words/marker.asm"
                 
                 ; System Value
                 ; The eeprom address until which MARKER saves and restores the eeprom data.
                 VE_MARKER:
000eda ff08          .dw $ff08
000edb 6d28
000edc 7261
000edd 656b
000ede 2972          .db "(marker)"
000edf 0ece          .dw VE_HEAD
                     .set VE_HEAD = VE_MARKER
                 XT_MARKER:
000ee0 1c6a          .dw PFA_DOVALUE1
                 PFA_MARKER:
000ee1 005e          .dw EE_MARKER
000ee2 0c3c          .dw XT_EDEFERFETCH
000ee3 0c46          .dw XT_EDEFERSTORE
                 .include "words/postpone.asm"
                 
                 ; Compiler
                 ; Append the compilation semantics of "name" to the dictionary
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_POSTPONE:
000ee4 0008          .dw $0008
000ee5 6f70
000ee6 7473
000ee7 6f70
000ee8 656e          .db "postpone"
000ee9 0eda          .dw VE_HEAD
                     .set VE_HEAD = VE_POSTPONE
                 XT_POSTPONE:
000eea 1c01          .dw DO_COLON
                 PFA_POSTPONE:
                 .endif
000eeb 0a4c          .dw XT_PARSENAME
000eec 0b31          .dw XT_DORECOGNIZER
000eed 0c33          .dw XT_ICELLPLUS 
000eee 0c33          .dw XT_ICELLPLUS
000eef 1fbb          .dw XT_FETCHI
000ef0 1c25          .dw XT_EXECUTE
000ef1 1c1b          .dw XT_EXIT
                 .endif
                 .include "words/2r_fetch.asm"
                 
                 ; Stack
                 ; fetch content of TOR
                 VE_2R_FETCH:
000ef2 ff03          .dw $ff03
000ef3 7232
000ef4 0040          .db "2r@",0
000ef5 0ee4          .dw VE_HEAD
                     .set VE_HEAD = VE_2R_FETCH
                 XT_2R_FETCH:
000ef6 0ef7          .dw PFA_2R_FETCH
                 PFA_2R_FETCH:
000ef7 939a
000ef8 938a          savetos
000ef9 91ef          pop zl
000efa 91ff          pop zh
000efb 918f          pop tosl
000efc 919f          pop tosh
000efd 939f          push tosh
000efe 938f          push tosl
000eff 93ff          push zh
000f00 93ef          push zl
000f01 939a
000f02 938a          savetos
000f03 01cf          movw tosl, zl
000f04 940c 1c05     jmp_ DO_NEXT
                 
                 .set DPSTART = pc
                 .if(pc>AMFORTH_RO_SEG)
                 .endif
                 
                 .org AMFORTH_RO_SEG
                 .include "amforth-interpreter.asm"
                 
                 
                 DO_COLON:
001c01 93bf          push XH
001c02 93af          push XL          ; PUSH IP
001c03 01db          movw XL, wl
001c04 9611          adiw xl, 1
                 DO_NEXT:
001c05 f06e          brts DO_INTERRUPT
001c06 01fd          movw zl, XL        ; READ IP
001c07 0fee
001c08 1fff
001c09 9165
001c0a 9175          readflashcell wl, wh
001c0b 9611          adiw XL, 1        ; INC IP
                 
                 DO_EXECUTE:
001c0c 01fb          movw zl, wl
001c0d 0fee
001c0e 1fff
001c0f 9105
001c10 9115          readflashcell temp0,temp1
001c11 01f8          movw zl, temp0
001c12 9409          ijmp
                 
                 DO_INTERRUPT:
                     ; here we deal with interrupts the forth way
001c13 94e8          clt
001c14 e460          ldi wl, LOW(XT_ISREXEC)
001c15 e072          ldi wh, HIGH(XT_ISREXEC)
001c16 cff5          rjmp DO_EXECUTE
                 .include "dict/nrww.inc"
                 
                 ; section together with the forth inner interpreter
                 
                 .include "words/exit.asm"
                 
                 ; Compiler
                 ; end of current colon word
                 VE_EXIT:
001c17 ff04          .dw $ff04
001c18 7865
001c19 7469          .db "exit"
001c1a 0ef2          .dw VE_HEAD
                     .set VE_HEAD = VE_EXIT
                 XT_EXIT:
001c1b 1c1c          .dw PFA_EXIT
                 PFA_EXIT:
001c1c 91af          pop XL
001c1d 91bf          pop XH
001c1e cfe6          jmp_ DO_NEXT
                 .include "words/execute.asm"
                 
                 ; System
                 ; execute XT
                 VE_EXECUTE:
001c1f ff07          .dw $ff07
001c20 7865
001c21 6365
001c22 7475
001c23 0065          .db "execute",0
001c24 1c17          .dw VE_HEAD
                     .set VE_HEAD = VE_EXECUTE
                 XT_EXECUTE:
001c25 1c26          .dw PFA_EXECUTE
                 PFA_EXECUTE:
001c26 01bc          movw wl, tosl
001c27 9189
001c28 9199          loadtos
001c29 cfe2          jmp_ DO_EXECUTE
                 .include "words/dobranch.asm"
                 
                 ; System
                 ; runtime of branch
                 ;VE_DOBRANCH:
                 ;    .dw $ff08
                 ;    .db "(branch)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOBRANCH
                 XT_DOBRANCH:
001c2a 1c2b          .dw PFA_DOBRANCH
                 PFA_DOBRANCH:
001c2b 01fd          movw zl, XL
001c2c 0fee
001c2d 1fff
001c2e 91a5
001c2f 91b5          readflashcell XL,XH
001c30 cfd4          jmp_ DO_NEXT
                 .include "words/docondbranch.asm"
                 
                 ; System
                 ; runtime of ?branch
                 ;VE_DOCONDBRANCH:
                 ;    .dw $ff09
                 ;    .db "(?branch)"
                 ;    .dw  VE_HEAD
                 ;    .set VE_HEAD = VE_DOCONDBRANCH
                 XT_DOCONDBRANCH:
001c31 1c32          .dw PFA_DOCONDBRANCH
                 PFA_DOCONDBRANCH:
001c32 2b98          or tosh, tosl
001c33 9189
001c34 9199          loadtos
001c35 f3a9          brbs 1, PFA_DOBRANCH ; 1 is z flag; if tos is zero (false), do the branch
001c36 9611          adiw XL, 1
001c37 cfcd          jmp_ DO_NEXT
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/doliteral.asm"
                 
                 ; System
                 ; runtime of literal
                 ;VE_DOLITERAL:
                 ;    .dw $ff09
                 ;    .db "(literal)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOLITERAL
                 XT_DOLITERAL:
001c38 1c39          .dw PFA_DOLITERAL
                 PFA_DOLITERAL:
001c39 939a
001c3a 938a          savetos
001c3b 01fd          movw zl, xl
001c3c 0fee
001c3d 1fff
001c3e 9185
001c3f 9195          readflashcell tosl,tosh
001c40 9611          adiw xl, 1
001c41 cfc3          jmp_ DO_NEXT
                 
                 .include "words/dovariable.asm"
                 
                 ; System
                 ; puts content of parameter field (1 cell) to TOS
                 ;VE_DOVARIABLE:
                 ;    .dw $ff0a
                 ;    .db "(variable)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOVARIABLE
                 XT_DOVARIABLE:
001c42 1c43          .dw PFA_DOVARIABLE
                 PFA_DOVARIABLE:
001c43 939a
001c44 938a          savetos
001c45 01fb          movw zl, wl
001c46 9631          adiw zl,1
001c47 0fee
001c48 1fff
001c49 9185
001c4a 9195          readflashcell tosl,tosh
001c4b cfb9          jmp_ DO_NEXT
                 .include "words/doconstant.asm"
                 
                 ; System
                 ; place data field address on TOS
                 ;VE_DOCONSTANT:
                 ;    .dw $ff0a
                 ;    .db "(constant)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOCONSTANT
                 XT_DOCONSTANT:
001c4c 1c4d          .dw PFA_DOCONSTANT
                 PFA_DOCONSTANT:
001c4d 939a
001c4e 938a          savetos
001c4f 01cb          movw tosl, wl
001c50 9601          adiw tosl, 1
001c51 cfb3          jmp_ DO_NEXT
                 .include "words/douser.asm"
                 
                 ; System
                 ; runtime part of user
                 ;VE_DOUSER:
                 ;    .dw $ff06
                 ;    .db "(user)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOUSER
                 XT_DOUSER:
001c52 1c53          .dw PFA_DOUSER
                 PFA_DOUSER:
001c53 939a
001c54 938a          savetos
001c55 01fb          movw zl, wl
001c56 9631          adiw zl, 1
001c57 0fee
001c58 1fff
001c59 9185
001c5a 9195          readflashcell tosl,tosh
001c5b 0d84          add tosl, upl
001c5c 1d95          adc tosh, uph
001c5d cfa7          jmp_ DO_NEXT
                 .include "words/do-value.asm"
                 
                 ; System
                 ; runtime of value
                 VE_DOVALUE:
001c5e ff07          .dw $ff07
001c5f 7628
001c60 6c61
001c61 6575
001c62 0029          .db "(value)", 0
001c63 1c1f          .dw VE_HEAD
                     .set VE_HEAD = VE_DOVALUE
                 XT_DOVALUE:
001c64 1c01          .dw DO_COLON
                 PFA_DOVALUE:
001c65 0289          .dw XT_DOCREATE
001c66 03ed          .dw XT_REVEAL
001c67 02af          .dw XT_COMPILE
001c68 1c6a          .dw PFA_DOVALUE1
001c69 1c1b          .dw XT_EXIT
                 PFA_DOVALUE1:
001c6a 940e 0411     call_ DO_DODOES
001c6c 1cac          .dw XT_DUP
001c6d 0c33          .dw XT_ICELLPLUS
001c6e 1fbb          .dw XT_FETCHI
001c6f 1c25          .dw XT_EXECUTE
001c70 1c1b          .dw XT_EXIT
                 
                 ; : (value) <builds does> dup icell+ @i execute ;
                 .include "words/fetch.asm"
                 
                 ; Memory
                 ; read 1 cell from RAM address
                 VE_FETCH:
001c71 ff01          .dw $ff01
001c72 0040          .db "@",0
001c73 1c5e          .dw VE_HEAD
                     .set VE_HEAD = VE_FETCH
                 XT_FETCH:
001c74 1c75          .dw PFA_FETCH
                 PFA_FETCH:
                 .if WANT_UNIFIED == 1
                 .endif
                 PFA_FETCHRAM:
001c75 01fc          movw zl, tosl
                     ; low byte is read before the high byte
001c76 9181          ld tosl, z+
001c77 9191          ld tosh, z+
001c78 cf8c          jmp_ DO_NEXT
                 .if WANT_UNIFIED == 1
                 .endif
                 .include "words/store.asm"
                 
                 ; Memory
                 ; write n to RAM memory at addr, low byte first
                 VE_STORE:
001c79 ff01          .dw $ff01
001c7a 0021          .db "!",0
001c7b 1c71          .dw VE_HEAD
                     .set VE_HEAD = VE_STORE
                 XT_STORE:
001c7c 1c7d          .dw PFA_STORE
                 PFA_STORE:
                 .if WANT_UNIFIED == 1
                 .endif
                 PFA_STORERAM:
001c7d 01fc          movw zl, tosl
001c7e 9189
001c7f 9199          loadtos
                     ; the high byte is written before the low byte
001c80 8391          std Z+1, tosh
001c81 8380          std Z+0, tosl
001c82 9189
001c83 9199          loadtos
001c84 cf80          jmp_ DO_NEXT
                 .if WANT_UNIFIED == 1
                 .endif
                 .include "words/cstore.asm"
                 
                 ; Memory
                 ; store a single byte to RAM address
                 VE_CSTORE:
001c85 ff02          .dw $ff02
001c86 2163          .db "c!"
001c87 1c79          .dw VE_HEAD
                     .set VE_HEAD = VE_CSTORE
                 XT_CSTORE:
001c88 1c89          .dw PFA_CSTORE
                 PFA_CSTORE:
001c89 01fc          movw zl, tosl
001c8a 9189
001c8b 9199          loadtos
001c8c 8380          st Z, tosl
001c8d 9189
001c8e 9199          loadtos
001c8f cf75          jmp_ DO_NEXT
                 .include "words/cfetch.asm"
                 
                 ; Memory
                 ; fetch a single byte from memory mapped locations
                 VE_CFETCH:
001c90 ff02          .dw $ff02
001c91 4063          .db "c@"
001c92 1c85          .dw VE_HEAD
                     .set VE_HEAD  = VE_CFETCH
                 XT_CFETCH:
001c93 1c94          .dw PFA_CFETCH
                 PFA_CFETCH:
001c94 01fc          movw zl, tosl
001c95 2799          clr tosh
001c96 8180          ld tosl, Z
001c97 cf6d          jmp_ DO_NEXT
                 .include "words/fetch-u.asm"
                 
                 ; Memory
                 ; read 1 cell from USER area
                 VE_FETCHU:
001c98 ff02          .dw $ff02
001c99 7540          .db "@u"
001c9a 1c90          .dw VE_HEAD
                     .set VE_HEAD = VE_FETCHU
                 XT_FETCHU:
001c9b 1c01          .dw DO_COLON
                 PFA_FETCHU:
001c9c 1ef1          .dw XT_UP_FETCH
001c9d 1d98          .dw XT_PLUS
001c9e 1c74          .dw XT_FETCH
001c9f 1c1b          .dw XT_EXIT
                 .include "words/store-u.asm"
                 
                 ; Memory
                 ; write n to USER area at offset
                 VE_STOREU:
001ca0 ff02          .dw $ff02
001ca1 7521          .db "!u"
001ca2 1c98          .dw VE_HEAD
                     .set VE_HEAD = VE_STOREU
                 XT_STOREU:
001ca3 1c01          .dw DO_COLON
                 PFA_STOREU:
001ca4 1ef1          .dw XT_UP_FETCH
001ca5 1d98          .dw XT_PLUS
001ca6 1c7c          .dw XT_STORE
001ca7 1c1b          .dw XT_EXIT
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/dup.asm"
                 
                 ; Stack
                 ; duplicate TOS
                 VE_DUP:
001ca8 ff03          .dw $ff03
001ca9 7564
001caa 0070          .db "dup",0
001cab 1ca0          .dw VE_HEAD
                     .set VE_HEAD = VE_DUP
                 XT_DUP:
001cac 1cad          .dw PFA_DUP
                 PFA_DUP:
001cad 939a
001cae 938a          savetos
001caf cf55          jmp_ DO_NEXT
                 .include "words/qdup.asm"
                 
                 ; Stack
                 ; duplicate TOS if non-zero
                 VE_QDUP:
001cb0 ff04          .dw $ff04
001cb1 643f
001cb2 7075          .db "?dup"
001cb3 1ca8          .dw VE_HEAD
                     .set VE_HEAD = VE_QDUP
                 XT_QDUP:
001cb4 1cb5          .dw PFA_QDUP
                 PFA_QDUP:
001cb5 2f08          mov temp0, tosl
001cb6 2b09          or temp0, tosh
001cb7 f011          breq PFA_QDUP1
001cb8 939a
001cb9 938a          savetos
                 PFA_QDUP1:
001cba cf4a          jmp_ DO_NEXT
                 .include "words/swap.asm"
                 
                 ; Stack
                 ; swaps the two top level stack cells
                 VE_SWAP:
001cbb ff04          .dw $ff04
001cbc 7773
001cbd 7061          .db "swap"
001cbe 1cb0          .dw VE_HEAD
                     .set VE_HEAD = VE_SWAP
                 XT_SWAP:
001cbf 1cc0          .dw PFA_SWAP
                 PFA_SWAP:
001cc0 018c          movw temp0, tosl
001cc1 9189
001cc2 9199          loadtos
001cc3 931a          st -Y, temp1
001cc4 930a          st -Y, temp0
001cc5 cf3f          jmp_ DO_NEXT
                 .include "words/over.asm"
                 
                 ; Stack
                 ; Place a copy of x1 on top of the stack
                 VE_OVER:
001cc6 ff04          .dw $ff04
001cc7 766f
001cc8 7265          .db "over"
001cc9 1cbb          .dw VE_HEAD
                     .set VE_HEAD = VE_OVER
                 XT_OVER:
001cca 1ccb          .dw PFA_OVER
                 PFA_OVER:
001ccb 939a
001ccc 938a          savetos
001ccd 818a          ldd tosl, Y+2
001cce 819b          ldd tosh, Y+3
                 
001ccf cf35          jmp_ DO_NEXT
                 .include "words/drop.asm"
                 
                 ; Stack
                 ; drop TOS
                 VE_DROP:
001cd0 ff04          .dw $ff04
001cd1 7264
001cd2 706f          .db "drop"
001cd3 1cc6          .dw VE_HEAD
                     .set VE_HEAD = VE_DROP
                 XT_DROP:
001cd4 1cd5          .dw PFA_DROP
                 PFA_DROP:
001cd5 9189
001cd6 9199          loadtos
001cd7 cf2d          jmp_ DO_NEXT
                 .include "words/rot.asm"
                 
                 ; Stack
                 ; rotate the three top level cells
                 VE_ROT:
001cd8 ff03          .dw $ff03
001cd9 6f72
001cda 0074          .db "rot",0
001cdb 1cd0          .dw VE_HEAD
                     .set VE_HEAD = VE_ROT
                 XT_ROT:
001cdc 1cdd          .dw PFA_ROT
                 PFA_ROT:
001cdd 018c          movw temp0, tosl
001cde 9129          ld temp2, Y+
001cdf 9139          ld temp3, Y+ 
001ce0 9189
001ce1 9199          loadtos
                         
001ce2 933a          st -Y, temp3
001ce3 932a          st -Y, temp2
001ce4 931a          st -Y, temp1
001ce5 930a          st -Y, temp0
                 
001ce6 cf1e          jmp_ DO_NEXT
                 .include "words/nip.asm"
                 
                 ; Stack
                 ; Remove Second of Stack
                 VE_NIP:
001ce7 ff03          .dw $ff03
001ce8 696e
001ce9 0070          .db "nip",0
001cea 1cd8          .dw VE_HEAD
                     .set VE_HEAD = VE_NIP
                 XT_NIP:
001ceb 1cec          .dw PFA_NIP
                 PFA_NIP:
001cec 9622          adiw yl, 2
001ced cf17          jmp_ DO_NEXT
                 ;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/r_from.asm"
                 
                 ; Stack
                 ; move TOR to TOS
                 VE_R_FROM:
001cee ff02          .dw $ff02
001cef 3e72          .db "r>"
001cf0 1ce7          .dw VE_HEAD
                     .set VE_HEAD = VE_R_FROM
                 XT_R_FROM:
001cf1 1cf2          .dw PFA_R_FROM
                 PFA_R_FROM:
001cf2 939a
001cf3 938a          savetos
001cf4 918f          pop tosl
001cf5 919f          pop tosh
001cf6 cf0e          jmp_ DO_NEXT
                 .include "words/to_r.asm"
                 
                 ; Stack
                 ; move TOS to TOR
                 VE_TO_R:
001cf7 ff02          .dw $ff02
001cf8 723e          .db ">r"
001cf9 1cee          .dw VE_HEAD
                     .set VE_HEAD = VE_TO_R
                 XT_TO_R:
001cfa 1cfb          .dw PFA_TO_R
                 PFA_TO_R:
001cfb 939f          push tosh
001cfc 938f          push tosl
001cfd 9189
001cfe 9199          loadtos
001cff cf05          jmp_ DO_NEXT
                 .include "words/r_fetch.asm"
                 
                 ; Stack
                 ; fetch content of TOR
                 VE_R_FETCH:
001d00 ff02          .dw $ff02
001d01 4072          .db "r@"
001d02 1cf7          .dw VE_HEAD
                     .set VE_HEAD = VE_R_FETCH
                 XT_R_FETCH:
001d03 1d04          .dw PFA_R_FETCH
                 PFA_R_FETCH:
001d04 939a
001d05 938a          savetos
001d06 918f          pop tosl
001d07 919f          pop tosh
001d08 939f          push tosh
001d09 938f          push tosl
001d0a cefa          jmp_ DO_NEXT
                 
                 
                 .include "words/not-equal.asm"
                 
                 ; Compare
                 ; true if n1 is not equal to n2
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_NOTEQUAL:
001d0b ff02          .dw $ff02
001d0c 3e3c          .db "<>"
001d0d 1d00          .dw VE_HEAD
                     .set VE_HEAD = VE_NOTEQUAL
                 XT_NOTEQUAL:
001d0e 1c01          .dw DO_COLON
                 PFA_NOTEQUAL:
                 .endif
                 
001d0f 1fd4
001d10 1d15
001d11 1c1b          .DW XT_EQUAL,XT_ZEROEQUAL,XT_EXIT
                 .include "words/equalzero.asm"
                 
                 ; Compare
                 ; compare with 0 (zero)
                 VE_ZEROEQUAL:
001d12 ff02          .dw $ff02
001d13 3d30          .db "0="
001d14 1d0b          .dw VE_HEAD
                     .set VE_HEAD = VE_ZEROEQUAL
                 XT_ZEROEQUAL:
001d15 1d16          .dw PFA_ZEROEQUAL
                 PFA_ZEROEQUAL:
001d16 2b98          or tosh, tosl
001d17 f5d1          brne PFA_ZERO1
001d18 c030          rjmp PFA_TRUE1
                 .include "words/lesszero.asm"
                 
                 ; Compare
                 ; compare with zero
                 VE_ZEROLESS:
001d19 ff02          .dw $ff02
001d1a 3c30          .db "0<"
001d1b 1d12          .dw VE_HEAD
                     .set VE_HEAD = VE_ZEROLESS
                 XT_ZEROLESS:
001d1c 1d1d          .dw PFA_ZEROLESS
                 PFA_ZEROLESS:
001d1d fd97          sbrc tosh,7
001d1e c02a          rjmp PFA_TRUE1
001d1f c032          rjmp PFA_ZERO1
                 .include "words/greaterzero.asm"
                 
                 ; Compare
                 ; true if n1 is greater than 0
                 VE_GREATERZERO:
001d20 ff02          .dw $ff02
001d21 3e30          .db "0>"
001d22 1d19          .dw VE_HEAD
                     .set VE_HEAD = VE_GREATERZERO
                 XT_GREATERZERO:
001d23 1d24          .dw PFA_GREATERZERO
                 PFA_GREATERZERO:
001d24 1582          cp tosl, zerol
001d25 0593          cpc tosh, zeroh
001d26 f15c          brlt PFA_ZERO1
001d27 f151          brbs 1, PFA_ZERO1
001d28 c020          rjmp PFA_TRUE1
                 .include "words/d-greaterzero.asm"
                 
                 ; Compare
                 ; compares if a double double cell number is greater 0
                 VE_DGREATERZERO:
001d29 ff03          .dw $ff03
001d2a 3064
001d2b 003e          .db "d0>",0
001d2c 1d20          .dw VE_HEAD
                     .set VE_HEAD = VE_DGREATERZERO
                 XT_DGREATERZERO:
001d2d 1d2e          .dw PFA_DGREATERZERO
                 PFA_DGREATERZERO:
001d2e 1582          cp tosl, zerol
001d2f 0593          cpc tosh, zeroh
001d30 9189
001d31 9199          loadtos
001d32 0582          cpc tosl, zerol
001d33 0593          cpc tosh, zeroh
001d34 f0ec          brlt PFA_ZERO1
001d35 f0e1          brbs 1, PFA_ZERO1
001d36 c012          rjmp PFA_TRUE1
                 .include "words/d-lesszero.asm"
                 
                 ; Compare
                 ; compares if a double double cell number is less than 0
                 VE_DXT_ZEROLESS:
001d37 ff03          .dw $ff03
001d38 3064
001d39 003c          .db "d0<",0
001d3a 1d29          .dw VE_HEAD
                     .set VE_HEAD = VE_DXT_ZEROLESS
                 XT_DXT_ZEROLESS:
001d3b 1d3c          .dw PFA_DXT_ZEROLESS
                 PFA_DXT_ZEROLESS:
001d3c 9622          adiw Y,2
001d3d fd97          sbrc tosh,7
001d3e 940c 1d49     jmp PFA_TRUE1
001d40 940c 1d52     jmp PFA_ZERO1
                 
                 .include "words/true.asm"
                 
                 ; Arithmetics
                 ; leaves the value -1 (true) on TOS
                 VE_TRUE:
001d42 ff04          .dw $ff04
001d43 7274
001d44 6575          .db "true"
001d45 1d37          .dw VE_HEAD
                     .set VE_HEAD = VE_TRUE
                 XT_TRUE:
001d46 1d47          .dw PFA_TRUE
                 PFA_TRUE:
001d47 939a
001d48 938a          savetos
                 PFA_TRUE1:
001d49 ef8f          ser tosl
001d4a ef9f          ser tosh
001d4b ceb9          jmp_ DO_NEXT
                 .include "words/zero.asm"
                 
                 ; Arithmetics
                 ; place a value 0 on TOS
                 VE_ZERO:
001d4c ff01          .dw $ff01
001d4d 0030          .db "0",0
001d4e 1d42          .dw VE_HEAD
                     .set VE_HEAD = VE_ZERO
                 XT_ZERO:
001d4f 1d50          .dw PFA_ZERO
                 PFA_ZERO:
001d50 939a
001d51 938a          savetos
                 PFA_ZERO1:
001d52 01c1          movw tosl, zerol
001d53 ceb1          jmp_ DO_NEXT
                 .include "words/uless.asm"
                 
                 ; Compare
                 ; true if u1 < u2 (unsigned)
                 VE_ULESS:
001d54 ff02          .dw $ff02
001d55 3c75          .db "u<"
001d56 1d4c          .dw VE_HEAD
                     .set VE_HEAD = VE_ULESS
                 XT_ULESS:
001d57 1d58          .dw PFA_ULESS
                 PFA_ULESS:
001d58 9129          ld temp2, Y+
001d59 9139          ld temp3, Y+
001d5a 1782          cp tosl, temp2
001d5b 0793          cpc tosh, temp3
001d5c f3a8          brlo PFA_ZERO1
001d5d f3a1          brbs 1, PFA_ZERO1
001d5e cfea          jmp_ PFA_TRUE1
                 .include "words/u-greater.asm"
                 
                 ; Compare
                 ; true if u1 > u2 (unsigned)
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_UGREATER:
001d5f ff02          .dw $ff02
001d60 3e75          .db "u>"
001d61 1d54          .dw VE_HEAD
                     .set VE_HEAD = VE_UGREATER
                 XT_UGREATER:
001d62 1c01          .dw DO_COLON
                 PFA_UGREATER:
                 .endif
001d63 1cbf          .DW XT_SWAP
001d64 1d57          .dw XT_ULESS
001d65 1c1b          .dw XT_EXIT
                 .include "words/less.asm"
                 
                 ; Compare
                 ; true if n1 is less than n2
                     VE_LESS:
001d66 ff01          .dw $ff01
001d67 003c          .db "<",0
001d68 1d5f          .dw VE_HEAD
                     .set VE_HEAD = VE_LESS
                 XT_LESS:
001d69 1d6a          .dw PFA_LESS
                 PFA_LESS:
001d6a 9129          ld temp2, Y+
001d6b 9139          ld temp3, Y+
001d6c 1728          cp temp2, tosl
001d6d 0739          cpc temp3, tosh
                 PFA_LESSDONE:
001d6e f71c          brge PFA_ZERO1
001d6f cfd9          rjmp PFA_TRUE1
                 .include "words/greater.asm"
                 
                 ; Compare
                 ; flag is true if n1 is greater than n2
                 VE_GREATER:
001d70 ff01          .dw $ff01
001d71 003e          .db ">",0
001d72 1d66          .dw VE_HEAD
                     .set VE_HEAD = VE_GREATER
                 XT_GREATER:
001d73 1d74          .dw PFA_GREATER
                 PFA_GREATER:
001d74 9129          ld temp2, Y+
001d75 9139          ld temp3, Y+
001d76 1728          cp temp2, tosl
001d77 0739          cpc temp3, tosh
                 PFA_GREATERDONE:
001d78 f2cc          brlt PFA_ZERO1
001d79 f2c1          brbs 1, PFA_ZERO1
001d7a cfce          rjmp PFA_TRUE1
                 
                 .include "words/log2.asm"
                 
                 ; Arithmetics
                 ; logarithm to base 2 or highest set bitnumber
                 VE_LOG2:
001d7b ff04          .dw $ff04
001d7c 6f6c
001d7d 3267          .db "log2"
001d7e 1d70          .dw VE_HEAD
                     .set VE_HEAD = VE_LOG2
                 XT_LOG2:
001d7f 1d80          .dw PFA_LOG2
                 PFA_LOG2:
001d80 01fc          movw zl, tosl
001d81 2799          clr tosh
001d82 e180          ldi tosl, 16
                 PFA_LOG2_1:
001d83 958a          dec tosl
001d84 f022          brmi PFA_LOG2_2 ; wrong data
001d85 0fee          lsl  zl
001d86 1fff          rol  zh
001d87 f7d8          brcc PFA_LOG2_1
001d88 ce7c          jmp_ DO_NEXT
                 
                 PFA_LOG2_2:
001d89 959a          dec tosh
001d8a ce7a          jmp_ DO_NEXT
                 .include "words/minus.asm"
                 
                 ; Arithmetics
                 ; subtract n2 from n1
                 VE_MINUS:
001d8b ff01          .dw $ff01
001d8c 002d          .db "-",0
001d8d 1d7b          .dw VE_HEAD
                     .set VE_HEAD = VE_MINUS
                 XT_MINUS:
001d8e 1d8f          .dw PFA_MINUS
                 PFA_MINUS:
001d8f 9109          ld temp0, Y+
001d90 9119          ld temp1, Y+
001d91 1b08          sub temp0, tosl
001d92 0b19          sbc temp1, tosh
001d93 01c8          movw tosl, temp0
001d94 ce70          jmp_ DO_NEXT
                 .include "words/plus.asm"
                 
                 ; Arithmetics
                 ; add n1 and n2
                 VE_PLUS:
001d95 ff01          .dw $ff01
001d96 002b          .db "+",0
001d97 1d8b          .dw VE_HEAD
                     .set VE_HEAD = VE_PLUS
                 XT_PLUS:
001d98 1d99          .dw PFA_PLUS
                 PFA_PLUS:
001d99 9109          ld temp0, Y+
001d9a 9119          ld temp1, Y+
001d9b 0f80          add tosl, temp0
001d9c 1f91          adc tosh, temp1
001d9d ce67          jmp_ DO_NEXT
                 .include "words/mstar.asm"
                 
                 ; Arithmetics
                 ; multiply 2 cells to a double cell
                 VE_MSTAR:
001d9e ff02          .dw $ff02
001d9f 2a6d          .db "m*"
001da0 1d95          .dw VE_HEAD
                     .set VE_HEAD = VE_MSTAR
                 XT_MSTAR:
001da1 1da2          .dw PFA_MSTAR
                 PFA_MSTAR:
001da2 018c          movw temp0, tosl
001da3 9189
001da4 9199          loadtos
001da5 019c          movw temp2, tosl
                     ; high cell ah*bh
001da6 0231          muls temp3, temp1
001da7 0170          movw temp4, r0
                     ; low cell  al*bl
001da8 9f20          mul  temp2, temp0
001da9 01c0          movw tosl, r0
                     ; signed ah*bl
001daa 0330          mulsu temp3, temp0
001dab 08f3          sbc   temp5, zeroh
001dac 0d90          add   tosh,  r0
001dad 1ce1          adc   temp4, r1
001dae 1cf3          adc   temp5, zeroh
                     
                     ; signed al*bh
001daf 0312          mulsu temp1, temp2
001db0 08f3          sbc   temp5, zeroh
001db1 0d90          add   tosh,  r0
001db2 1ce1          adc   temp4, r1
001db3 1cf3          adc   temp5, zeroh
                 
001db4 939a
001db5 938a          savetos
001db6 01c7          movw tosl, temp4
001db7 ce4d          jmp_ DO_NEXT
                 .include "words/umslashmod.asm"
                 
                 ; Arithmetics
                 ; unsigned division ud / u2 with remainder
                 VE_UMSLASHMOD:
001db8 ff06          .dw $ff06
001db9 6d75
001dba 6d2f
001dbb 646f          .db "um/mod"
001dbc 1d9e          .dw VE_HEAD
                     .set VE_HEAD = VE_UMSLASHMOD
                 XT_UMSLASHMOD:
001dbd 1dbe          .dw PFA_UMSLASHMOD
                 PFA_UMSLASHMOD:
001dbe 017c          movw temp4, tosl
                 
001dbf 9129          ld temp2, Y+
001dc0 9139          ld temp3, Y+
                   
001dc1 9109          ld temp0, Y+
001dc2 9119          ld temp1, Y+
                 
                 ;; unsigned 32/16 -> 16r16 divide
                 
                 PFA_UMSLASHMODmod:
                 
                   ; set loop counter
001dc3 e140          ldi temp6,$10
                 
                 PFA_UMSLASHMODmod_loop:
                     ; shift left, saving high bit
001dc4 2755          clr temp7
001dc5 0f00          lsl temp0
001dc6 1f11          rol temp1
001dc7 1f22          rol temp2
001dc8 1f33          rol temp3
001dc9 1f55          rol temp7
                 
                   ; try subtracting divisor
001dca 152e          cp temp2, temp4
001dcb 053f          cpc temp3, temp5
001dcc 0552          cpc temp7,zerol
                 
001dcd f018          brcs PFA_UMSLASHMODmod_loop_control
                 
                 PFA_UMSLASHMODmod_subtract:
                     ; dividend is large enough
                     ; do the subtraction for real
                     ; and set lowest bit
001dce 9503          inc temp0
001dcf 192e          sub temp2, temp4
001dd0 093f          sbc temp3, temp5
                 
                 PFA_UMSLASHMODmod_loop_control:
001dd1 954a          dec  temp6
001dd2 f789          brne PFA_UMSLASHMODmod_loop
                 
                 PFA_UMSLASHMODmod_done:
                     ; put remainder on stack
001dd3 933a          st -Y,temp3
001dd4 932a          st -Y,temp2
                 
                     ; put quotient on stack
001dd5 01c8          movw tosl, temp0
001dd6 ce2e          jmp_ DO_NEXT
                 .include "words/umstar.asm"
                 
                 ; Arithmetics
                 ; multiply 2 unsigned cells to a double cell
                 VE_UMSTAR:
001dd7 ff03          .dw $ff03
001dd8 6d75
001dd9 002a          .db "um*",0
001dda 1db8          .dw VE_HEAD
                     .set VE_HEAD = VE_UMSTAR
                 XT_UMSTAR:
001ddb 1ddc          .dw PFA_UMSTAR
                 PFA_UMSTAR:
001ddc 018c          movw temp0, tosl
001ddd 9189
001dde 9199          loadtos
                     ; result: (temp3*temp1)* 65536 + (temp3*temp0 + temp1*temp2) * 256 + (temp0 * temp2)
                     ; low bytes
001ddf 9f80          mul tosl,temp0
001de0 01f0          movw zl, r0
001de1 2722          clr temp2
001de2 2733          clr temp3
                     ; middle bytes
001de3 9f90          mul tosh, temp0
001de4 0df0          add zh, r0
001de5 1d21          adc temp2, r1
001de6 1d33          adc temp3, zeroh
                         
001de7 9f81          mul tosl, temp1
001de8 0df0          add zh, r0
001de9 1d21          adc temp2, r1
001dea 1d33          adc temp3, zeroh
                     
001deb 9f91          mul tosh, temp1
001dec 0d20          add temp2, r0
001ded 1d31          adc temp3, r1
001dee 01cf          movw tosl, zl
001def 939a
001df0 938a          savetos
001df1 01c9          movw tosl, temp2
001df2 ce12          jmp_ DO_NEXT
                 
                 .include "words/invert.asm"
                 
                 ; Arithmetics
                 ; 1-complement of TOS
                 VE_INVERT:
001df3 ff06          .dw $ff06
001df4 6e69
001df5 6576
001df6 7472          .db "invert"
001df7 1dd7          .dw VE_HEAD
                     .set VE_HEAD = VE_INVERT
                 XT_INVERT:
001df8 1df9          .dw PFA_INVERT
                 PFA_INVERT:
001df9 9580          com tosl
001dfa 9590          com tosh
001dfb ce09          jmp_ DO_NEXT
                 .include "words/2slash.asm"
                 
                 ; Arithmetics
                 ; arithmetic shift right
                 VE_2SLASH:
001dfc ff02          .dw $ff02
001dfd 2f32          .db "2/"
001dfe 1df3          .dw VE_HEAD
                     .set VE_HEAD = VE_2SLASH
                 XT_2SLASH:
001dff 1e00          .dw PFA_2SLASH
                 PFA_2SLASH:
001e00 9595          asr tosh
001e01 9587          ror tosl
001e02 ce02          jmp_ DO_NEXT
                 .include "words/2star.asm"
                 
                 ; Arithmetics
                 ; arithmetic shift left, filling with zero
                 VE_2STAR:
001e03 ff02          .dw $ff02
001e04 2a32          .db "2*"
001e05 1dfc          .dw VE_HEAD
                     .set VE_HEAD = VE_2STAR
                 XT_2STAR:
001e06 1e07          .dw PFA_2STAR
                 PFA_2STAR:
001e07 0f88          lsl tosl
001e08 1f99          rol tosh
001e09 cdfb          jmp_ DO_NEXT
                 .include "words/and.asm"
                 
                 ; Logic
                 ; bitwise and
                 VE_AND:
001e0a ff03          .dw $ff03
001e0b 6e61
001e0c 0064          .db "and",0
001e0d 1e03          .dw VE_HEAD
                     .set VE_HEAD = VE_AND
                 XT_AND:
001e0e 1e0f          .dw PFA_AND
                 PFA_AND:
001e0f 9109          ld temp0, Y+
001e10 9119          ld temp1, Y+
001e11 2380          and tosl, temp0
001e12 2391          and tosh, temp1
001e13 cdf1          jmp_ DO_NEXT
                 .include "words/or.asm"
                 
                 ; Logic
                 ; logical or
                 VE_OR:
001e14 ff02          .dw $ff02
001e15 726f          .db "or"
001e16 1e0a          .dw VE_HEAD
                     .set VE_HEAD = VE_OR
                 XT_OR:
001e17 1e18          .dw PFA_OR
                 PFA_OR:
001e18 9109          ld temp0, Y+
001e19 9119          ld temp1, Y+
001e1a 2b80          or tosl, temp0
001e1b 2b91          or tosh, temp1
001e1c cde8          jmp_ DO_NEXT
                 
                 .include "words/xor.asm"
                 
                 ; Logic
                 ; exclusive or
                 VE_XOR:
001e1d ff03          .dw $ff03
001e1e 6f78
001e1f 0072          .db "xor",0
001e20 1e14          .dw VE_HEAD
                     .set VE_HEAD = VE_XOR
                 XT_XOR:
001e21 1e22          .dw PFA_XOR
                 PFA_XOR:
001e22 9109          ld temp0, Y+
001e23 9119          ld temp1, Y+
001e24 2780          eor tosl, temp0
001e25 2791          eor tosh, temp1
001e26 cdde          jmp_ DO_NEXT
                 
                 .include "words/1plus.asm"
                 
                 ; Arithmetics
                 ; optimized increment
                 VE_1PLUS:
001e27 ff02          .dw $ff02
001e28 2b31          .db "1+"
001e29 1e1d          .dw VE_HEAD
                     .set VE_HEAD = VE_1PLUS
                 XT_1PLUS:
001e2a 1e2b          .dw PFA_1PLUS
                 PFA_1PLUS:
001e2b 9601          adiw tosl,1
001e2c cdd8          jmp_ DO_NEXT
                 .include "words/1minus.asm"
                 
                 ; Arithmetics
                 ; optimized decrement
                 VE_1MINUS:
001e2d ff02          .dw $ff02 
001e2e 2d31          .db "1-"
001e2f 1e27          .dw VE_HEAD
                     .set VE_HEAD = VE_1MINUS
                 XT_1MINUS:
001e30 1e31          .dw PFA_1MINUS
                 PFA_1MINUS:
001e31 9701          sbiw tosl, 1
001e32 cdd2          jmp_ DO_NEXT
                 .include "words/lshift.asm"
                 
                 ; Arithmetics
                 ; logically shift n1 left n2 times
                 VE_LSHIFT:
001e33 ff06          .dw $ff06
001e34 736c
001e35 6968
001e36 7466          .db "lshift"
001e37 1e2d          .dw VE_HEAD
                     .set VE_HEAD = VE_LSHIFT
                 XT_LSHIFT:
001e38 1e39          .dw PFA_LSHIFT
                 PFA_LSHIFT:
001e39 01fc          movw zl, tosl
001e3a 9189
001e3b 9199          loadtos
                 PFA_LSHIFT1:
001e3c 9731          sbiw zl, 1
001e3d f01a          brmi PFA_LSHIFT2
001e3e 0f88          lsl tosl
001e3f 1f99          rol tosh
001e40 cffb          rjmp PFA_LSHIFT1
                 PFA_LSHIFT2:
001e41 cdc3          jmp_ DO_NEXT
                 
                 .include "words/rshift.asm"
                 
                 ; Arithmetics
                 ; shift n1 n2-times logically right
                 VE_RSHIFT:
001e42 ff06          .dw $ff06
001e43 7372
001e44 6968
001e45 7466          .db "rshift"
001e46 1e33          .dw VE_HEAD
                     .set VE_HEAD = VE_RSHIFT
                 XT_RSHIFT:
001e47 1e48          .dw PFA_RSHIFT
                 PFA_RSHIFT:
001e48 01fc          movw zl, tosl
001e49 9189
001e4a 9199          loadtos
                 PFA_RSHIFT1:
001e4b 9731          sbiw zl, 1
001e4c f01a          brmi PFA_RSHIFT2
001e4d 9596          lsr tosh
001e4e 9587          ror tosl
001e4f cffb          rjmp PFA_RSHIFT1
                 PFA_RSHIFT2:
001e50 cdb4          jmp_ DO_NEXT
                 
                 .include "words/plusstore.asm"
                 
                 ; Arithmetics
                 ; add n to content of RAM address a-addr
                 VE_PLUSSTORE:
001e51 ff02          .dw $ff02
001e52 212b          .db "+!"
001e53 1e42          .dw VE_HEAD
                     .set VE_HEAD = VE_PLUSSTORE
                 XT_PLUSSTORE:
001e54 1e55          .dw PFA_PLUSSTORE
                 PFA_PLUSSTORE:
001e55 01fc          movw zl, tosl
001e56 9189
001e57 9199          loadtos
001e58 8120          ldd temp2, Z+0
001e59 8131          ldd temp3, Z+1
001e5a 0f82          add tosl, temp2
001e5b 1f93          adc tosh, temp3
001e5c 8380          std Z+0, tosl
001e5d 8391          std Z+1, tosh
001e5e 9189
001e5f 9199          loadtos
001e60 cda4          jmp_ DO_NEXT
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/rpfetch.asm"
                 
                 ; Stack
                 ; current return stack pointer address
                 VE_RP_FETCH:
001e61 ff03          .dw $ff03
001e62 7072
001e63 0040          .db "rp@",0
001e64 1e51          .dw VE_HEAD
                     .set VE_HEAD = VE_RP_FETCH
                 XT_RP_FETCH:
001e65 1e66          .dw PFA_RP_FETCH
                 PFA_RP_FETCH:
001e66 939a
001e67 938a          savetos
001e68 b78d          in tosl, SPL
001e69 b79e          in tosh, SPH
001e6a cd9a          jmp_ DO_NEXT
                 .include "words/rpstore.asm"
                 
                 ; Stack
                 ; set return stack pointer
                 VE_RP_STORE:
001e6b ff03          .dw $ff03
001e6c 7072
001e6d 0021          .db "rp!",0
001e6e 1e61          .dw VE_HEAD
                     .set VE_HEAD = VE_RP_STORE
                 XT_RP_STORE:
001e6f 1e70          .dw PFA_RP_STORE
                 PFA_RP_STORE:
001e70 b72f          in temp2, SREG
001e71 94f8          cli
001e72 bf8d          out SPL, tosl
001e73 bf9e          out SPH, tosh
001e74 bf2f          out SREG, temp2
001e75 9189
001e76 9199          loadtos
001e77 cd8d          jmp_ DO_NEXT
                 .include "words/spfetch.asm"
                 
                 ; Stack
                 ; current data stack pointer
                 VE_SP_FETCH:
001e78 ff03          .dw $ff03
001e79 7073
001e7a 0040          .db "sp@",0
001e7b 1e6b          .dw VE_HEAD
                     .set VE_HEAD = VE_SP_FETCH
                 XT_SP_FETCH:
001e7c 1e7d          .dw PFA_SP_FETCH
                 PFA_SP_FETCH:
001e7d 939a
001e7e 938a          savetos
001e7f 01ce          movw tosl, yl
001e80 cd84          jmp_ DO_NEXT
                 .include "words/spstore.asm"
                 
                 ; Stack
                 ; set data stack pointer to addr
                 VE_SP_STORE:
001e81 ff03          .dw $ff03
001e82 7073
001e83 0021          .db "sp!",0
001e84 1e78          .dw VE_HEAD
                     .set VE_HEAD = VE_SP_STORE
                 XT_SP_STORE:
001e85 1e86          .dw PFA_SP_STORE
                 PFA_SP_STORE:
001e86 01ec          movw yl, tosl
001e87 9189
001e88 9199          loadtos
001e89 cd7b          jmp_ DO_NEXT
                 
                 .include "words/dodo.asm"
                 
                 ; System
                 ; runtime of do
                 ;VE_DODO:
                 ;    .dw $ff04
                 ;    .db "(do)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DODO
                 XT_DODO:
001e8a 1e8b          .dw PFA_DODO
                 PFA_DODO:
001e8b 9129          ld temp2, Y+
001e8c 9139          ld temp3, Y+  ; limit
                 PFA_DODO1:
001e8d e8e0          ldi zl, $80
001e8e 0f3e          add temp3, zl
001e8f 1b82          sub  tosl, temp2
001e90 0b93          sbc  tosh, temp3
                 
001e91 933f          push temp3
001e92 932f          push temp2    ; limit  ( --> limit + $8000)
001e93 939f          push tosh
001e94 938f          push tosl     ; start -> index ( --> index - (limit - $8000)
001e95 9189
001e96 9199          loadtos
001e97 cd6d          jmp_ DO_NEXT
                 .include "words/i.asm"
                 
                 ; Compiler
                 ; current loop counter
                 VE_I:
001e98 ff01          .dw $FF01
001e99 0069          .db "i",0
001e9a 1e81          .dw VE_HEAD
                     .set VE_HEAD = VE_I
                 XT_I:
001e9b 1e9c          .dw PFA_I
                 PFA_I:
001e9c 939a
001e9d 938a          savetos
001e9e 918f          pop tosl
001e9f 919f          pop tosh  ; index
001ea0 91ef          pop zl
001ea1 91ff          pop zh    ; limit
001ea2 93ff          push zh
001ea3 93ef          push zl
001ea4 939f          push tosh
001ea5 938f          push tosl
001ea6 0f8e          add tosl, zl
001ea7 1f9f          adc tosh, zh
001ea8 cd5c          jmp_ DO_NEXT
                 .include "words/doplusloop.asm"
                 
                 ; System
                 ; runtime of +loop
                 ;VE_DOPLUSLOOP:
                 ;    .dw $ff07
                 ;    .db "(+loop)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOPLUSLOOP
                 XT_DOPLUSLOOP:
001ea9 1eaa          .dw PFA_DOPLUSLOOP
                 PFA_DOPLUSLOOP:
001eaa 91ef          pop zl
001eab 91ff          pop zh
001eac 0fe8          add zl, tosl
001ead 1ff9          adc zh, tosh
001eae 9189
001eaf 9199          loadtos
001eb0 f01b          brvs PFA_DOPLUSLOOP_LEAVE
                     ; next cycle
                 PFA_DOPLUSLOOP_NEXT:
                     ; next iteration
001eb1 93ff          push zh
001eb2 93ef          push zl
001eb3 cd77          rjmp PFA_DOBRANCH ; read next cell from dictionary and jump to its destination
                 PFA_DOPLUSLOOP_LEAVE:
001eb4 910f          pop  temp0
001eb5 911f          pop  temp1  ; remove limit
001eb6 9611          adiw xl, 1  ; skip branch-back address
001eb7 cd4d          jmp_ DO_NEXT
                 .include "words/doloop.asm"
                 
                 ; System
                 ; runtime of loop
                 ;VE_DOLOOP:
                 ;    .dw $ff06
                 ;    .db "(loop)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOLOOP
                 XT_DOLOOP:
001eb8 1eb9          .dw PFA_DOLOOP
                 PFA_DOLOOP:
001eb9 91ef          pop zl
001eba 91ff          pop zh
001ebb 9631          adiw zl,1
001ebc f3bb          brvs PFA_DOPLUSLOOP_LEAVE
001ebd cff3          jmp_ PFA_DOPLUSLOOP_NEXT
                 .include "words/unloop.asm"
                 
                 ; Compiler
                 ; remove loop-sys, exit the loop and continue execution after it
                 VE_UNLOOP:
001ebe ff06          .dw $ff06
001ebf 6e75
001ec0 6f6c
001ec1 706f          .db "unloop"
001ec2 1e98          .dw VE_HEAD
                     .set VE_HEAD = VE_UNLOOP
                 XT_UNLOOP:
001ec3 1ec4          .dw PFA_UNLOOP
                 PFA_UNLOOP:
001ec4 911f          pop temp1
001ec5 910f          pop temp0
001ec6 911f          pop temp1
001ec7 910f          pop temp0
001ec8 cd3c          jmp_ DO_NEXT
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 
                 .include "words/cmove_g.asm"
                 
                 ; Memory
                 ; copy data in RAM from higher to lower addresses.
                 VE_CMOVE_G:
001ec9 ff06          .dw $ff06
001eca 6d63
001ecb 766f
001ecc 3e65          .db "cmove>"
001ecd 1ebe          .dw VE_HEAD
                     .set VE_HEAD  = VE_CMOVE_G
                 XT_CMOVE_G:
001ece 1ecf          .dw PFA_CMOVE_G
                 PFA_CMOVE_G:
001ecf 93bf          push xh
001ed0 93af          push xl
001ed1 91e9          ld zl, Y+
001ed2 91f9          ld zh, Y+ ; addr-to
001ed3 91a9          ld xl, Y+
001ed4 91b9          ld xh, Y+ ; addr-from
001ed5 2f09          mov temp0, tosh
001ed6 2b08          or temp0, tosl
001ed7 f041          brbs 1, PFA_CMOVE_G1
001ed8 0fe8          add zl, tosl
001ed9 1ff9          adc zh, tosh
001eda 0fa8          add xl, tosl
001edb 1fb9          adc xh, tosh
                 PFA_CMOVE_G2:
001edc 911e          ld temp1, -X
001edd 9312          st -Z, temp1
001ede 9701          sbiw tosl, 1
001edf f7e1          brbc 1, PFA_CMOVE_G2
                 PFA_CMOVE_G1:
001ee0 91af          pop xl
001ee1 91bf          pop xh
001ee2 9189
001ee3 9199          loadtos
001ee4 cd20          jmp_ DO_NEXT
                 .include "words/byteswap.asm"
                 
                 ; Arithmetics
                 ; exchange the bytes of the TOS
                 VE_BYTESWAP:
001ee5 ff02          .dw $ff02
001ee6 3c3e          .db "><"
001ee7 1ec9          .dw VE_HEAD
                     .set VE_HEAD = VE_BYTESWAP
                 XT_BYTESWAP:
001ee8 1ee9          .dw PFA_BYTESWAP
                 PFA_BYTESWAP:
001ee9 2f09          mov temp0, tosh
001eea 2f98          mov tosh, tosl
001eeb 2f80          mov tosl, temp0
001eec cd18          jmp_ DO_NEXT
                 .include "words/up.asm"
                 
                 ; System Variable
                 ; get user area pointer
                 VE_UP_FETCH:
001eed ff03          .dw $ff03
001eee 7075
001eef 0040          .db "up@",0
001ef0 1ee5          .dw VE_HEAD
                     .set VE_HEAD = VE_UP_FETCH
                 XT_UP_FETCH:
001ef1 1ef2          .dw PFA_UP_FETCH
                 PFA_UP_FETCH:
001ef2 939a
001ef3 938a          savetos
001ef4 01c2          movw tosl, upl
001ef5 cd0f          jmp_ DO_NEXT
                 
                 ; ( addr -- ) 
                 ; System Variable
                 ; set user area pointer
                 VE_UP_STORE:
001ef6 ff03          .dw $ff03
001ef7 7075
001ef8 0021          .db "up!",0
001ef9 1eed          .dw VE_HEAD
                     .set VE_HEAD = VE_UP_STORE
                 XT_UP_STORE:
001efa 1efb          .dw PFA_UP_STORE
                 PFA_UP_STORE:
001efb 012c          movw upl, tosl
001efc 9189
001efd 9199          loadtos
001efe cd06          jmp_ DO_NEXT
                 .include "words/1ms.asm"
                 
                 ; Time
                 ; busy waits (almost) exactly 1 millisecond
                 VE_1MS:
001eff ff03          .dw $ff03
001f00 6d31
001f01 0073          .db "1ms",0
001f02 1ef6          .dw VE_HEAD
                     .set VE_HEAD = VE_1MS
                 XT_1MS:
001f03 1f04          .dw PFA_1MS
                 PFA_1MS:
001f04 ede0
001f05 e0f7
001f06 9731
001f07 f7f1          delay 1000
001f08 ccfc          jmp_ DO_NEXT
                 .include "words/2to_r.asm"
                 
                 ; Stack
                 ; move DTOS to TOR
                 VE_2TO_R:
001f09 ff03          .dw $ff03
001f0a 3e32
001f0b 0072          .db "2>r",0
001f0c 1eff          .dw VE_HEAD
                     .set VE_HEAD = VE_2TO_R
                 XT_2TO_R:
001f0d 1f0e          .dw PFA_2TO_R
                 PFA_2TO_R:
001f0e 01fc          movw zl, tosl
001f0f 9189
001f10 9199          loadtos
001f11 939f          push tosh
001f12 938f          push tosl
001f13 93ff          push zh
001f14 93ef          push zl
001f15 9189
001f16 9199          loadtos
001f17 cced          jmp_ DO_NEXT
                 .include "words/2r_from.asm"
                 
                 ; Stack
                 ; move DTOR to TOS
                 VE_2R_FROM:
001f18 ff03          .dw $ff03
001f19 7232
001f1a 003e          .db "2r>",0
001f1b 1f09          .dw VE_HEAD
                     .set VE_HEAD = VE_2R_FROM
                 XT_2R_FROM:
001f1c 1f1d          .dw PFA_2R_FROM
                 PFA_2R_FROM:
001f1d 939a
001f1e 938a          savetos
001f1f 91ef          pop zl
001f20 91ff          pop zh
001f21 918f          pop tosl
001f22 919f          pop tosh
001f23 939a
001f24 938a          savetos
001f25 01cf          movw tosl, zl
001f26 ccde          jmp_ DO_NEXT
                 
                 .include "words/store-e.asm"
                 
                 ; Memory
                 ; write n (2bytes) to eeprom address
                 VE_STOREE:
001f27 ff02          .dw $ff02
001f28 6521          .db "!e"
001f29 1f18          .dw VE_HEAD
                     .set VE_HEAD = VE_STOREE
                 XT_STOREE:
001f2a 1f2b          .dw PFA_STOREE
                 PFA_STOREE:
                 .if WANT_UNIFIED == 1
                 .endif
                 PFA_STOREE0:
001f2b 01fc          movw zl, tosl
001f2c 9189
001f2d 9199          loadtos
001f2e b72f          in_ temp2, SREG
001f2f 94f8          cli
001f30 d028          rcall PFA_FETCHE2
001f31 b30d          in_  temp0, EEDR
001f32 1708          cp temp0,tosl
001f33 f009          breq PFA_STOREE3
001f34 d00b          rcall PFA_STOREE1
                 PFA_STOREE3:
001f35 9631          adiw zl,1
001f36 d022          rcall PFA_FETCHE2
001f37 b30d          in_  temp0, EEDR
001f38 1709          cp temp0,tosh
001f39 f011          breq PFA_STOREE4
001f3a 2f89          mov tosl, tosh
001f3b d004          rcall PFA_STOREE1
                 PFA_STOREE4:
001f3c bf2f          out_ SREG, temp2
001f3d 9189
001f3e 9199          loadtos
001f3f ccc5          jmp_ DO_NEXT
                     
                 PFA_STOREE1:
001f40 99e1          sbic EECR, EEPE
001f41 cffe          rjmp PFA_STOREE1
                 
                 PFA_STOREE2: ; estore_wait_low_spm:
001f42 b707          in_ temp0, SPMCSR
001f43 fd00          sbrc temp0,SPMEN
001f44 cffd          rjmp PFA_STOREE2
                 
001f45 bbff          out_ EEARH,zh
001f46 bbee          out_ EEARL,zl
001f47 bb8d          out_ EEDR, tosl
001f48 9ae2          sbi EECR,EEMPE
001f49 9ae1          sbi EECR,EEPE
                 
001f4a 9508          ret
                 .if WANT_UNIFIED == 1
                 .endif
                 .include "words/fetch-e.asm"
                 
                 ; Memory
                 ; read 1 cell from eeprom
                 VE_FETCHE:
001f4b ff02          .dw $ff02
001f4c 6540          .db "@e"
001f4d 1f27          .dw VE_HEAD
                     .set VE_HEAD = VE_FETCHE
                 XT_FETCHE:
001f4e 1f4f          .dw PFA_FETCHE
                 PFA_FETCHE:
                 .if WANT_UNIFIED == 1
                 .endif
                 PFA_FETCHE1:
001f4f b72f          in_ temp2, SREG
001f50 94f8          cli
001f51 01fc          movw zl, tosl
001f52 d006          rcall PFA_FETCHE2
001f53 b38d          in_ tosl, EEDR
                 
001f54 9631          adiw zl,1
                 
001f55 d003          rcall PFA_FETCHE2
001f56 b39d          in_  tosh, EEDR
001f57 bf2f          out_ SREG, temp2
001f58 ccac          jmp_ DO_NEXT
                 
                 PFA_FETCHE2:
001f59 99e1          sbic EECR, EEPE
001f5a cffe          rjmp PFA_FETCHE2
                 
001f5b bbff          out_ EEARH,zh
001f5c bbee          out_ EEARL,zl
                 
001f5d 9ae0          sbi EECR,EERE
001f5e 9508          ret
                 
                 .if WANT_UNIFIED == 1
                 .endif
                 .include "words/store-i.asm"
                 
                 ; System Value
                 ; Deferred action to write a single 16bit cell to flash
                 VE_STOREI:
001f5f ff02          .dw $ff02
001f60 6921          .db "!i"
001f61 1f4b          .dw VE_HEAD
                     .set VE_HEAD = VE_STOREI
                 XT_STOREI:
001f62 0c9b          .dw PFA_DODEFER1
                 PFA_STOREI:
001f63 0034          .dw EE_STOREI
001f64 0c3c          .dw XT_EDEFERFETCH
001f65 0c46          .dw XT_EDEFERSTORE
                 .if FLASHEND > $10000
                 .else
                   .include "words/store-i_nrww.asm"
                 
                 ; Memory
                 ; writes n to flash memory using assembly code (code to be placed in boot loader section)
                 VE_DO_STOREI_NRWW:
001f66 ff09          .dw $ff09
001f67 2128
001f68 2d69
001f69 726e
001f6a 7777
001f6b 0029          .db "(!i-nrww)",0
001f6c 1f5f          .dw VE_HEAD
                     .set VE_HEAD = VE_DO_STOREI_NRWW
                 XT_DO_STOREI:
001f6d 1f6e          .dw PFA_DO_STOREI_NRWW
                 PFA_DO_STOREI_NRWW:
                   ; store status register
001f6e b71f        in temp1,SREG
001f6f 931f        push temp1
001f70 94f8        cli
                 
001f71 019c        movw temp2, tosl ; save the (word) address
001f72 9189
001f73 9199        loadtos          ; get the new value for the flash cell
001f74 93af        push xl
001f75 93bf        push xh
001f76 93cf        push yl
001f77 93df        push yh
001f78 d009        rcall DO_STOREI_atmega
001f79 91df        pop yh
001f7a 91cf        pop yl
001f7b 91bf        pop xh
001f7c 91af        pop xl
                   ; finally clear the stack
001f7d 9189
001f7e 9199        loadtos
001f7f 911f        pop temp1
                   ; restore status register (and interrupt enable flag)
001f80 bf1f        out SREG,temp1
                 
001f81 cc83        jmp_ DO_NEXT
                 
                 ; 
                 DO_STOREI_atmega:
                   ; write data to temp page buffer
                   ; use the values in tosl/tosh at the
                   ; appropiate place
001f82 d011        rcall pageload
                 
                   ; erase page if needed
                   ; it is needed if a bit goes from 0 to 1
001f83 94e0        com temp4
001f84 94f0        com temp5
001f85 218e        and tosl, temp4
001f86 219f        and tosh, temp5
001f87 2b98        or tosh, tosl
001f88 f021        breq DO_STOREI_writepage 
001f89 94b3          inc erase_counter
001f8a 01f9          movw zl, temp2
001f8b e002          ldi temp0,(1<<PGERS)
001f8c d020          rcall dospm
                 
                 DO_STOREI_writepage:
                   ; write page
001f8d 01f9        movw zl, temp2
001f8e e004        ldi temp0,(1<<PGWRT)
001f8f d01d        rcall dospm
                 
                   ; reenable RWW section
001f90 01f9        movw zl, temp2
001f91 e100        ldi temp0,(1<<RWWSRE)
001f92 d01a        rcall dospm
001f93 9508        ret
                 
                 ; load the desired page
                 .equ pagemask = ~ ( PAGESIZE - 1 )
                 pageload:
001f94 01f9        movw zl, temp2
                   ; get the beginning of page
001f95 7ce0        andi zl,low(pagemask)
001f96 7fff        andi zh,high(pagemask)
001f97 01ef        movw y, z
                   ; loop counter (in words)
001f98 e4a0        ldi xl,low(pagesize)
001f99 e0b0        ldi xh,high(pagesize)
                 pageload_loop:
                   ; we need the current flash value anyways
001f9a 01fe        movw z, y
001f9b 0fee
001f9c 1fff
001f9d 9145
001f9e 9155        readflashcell temp6, temp7 ; destroys Z
                   ; now check: if Z points to the same cell as temp2/3, we want the new data
001f9f 01fe        movw z, y
001fa0 17e2        cp zl, temp2
001fa1 07f3        cpc zh, temp3
001fa2 f011        breq pageload_newdata
001fa3 010a          movw r0, temp6
001fa4 c002          rjmp pageload_cont
                 pageload_newdata:
001fa5 017a          movw temp4, temp6
001fa6 010c          movw r0, tosl
                 pageload_cont:
001fa7 2700        clr temp0
001fa8 d004        rcall dospm
001fa9 9621        adiw y, 1
001faa 9711        sbiw x, 1
001fab f771        brne pageload_loop
                 
                 pageload_done:
001fac 9508        ret
                 
                 
                 ;; dospm
                 ;;
                 ;; execute spm instruction
                 ;;   temp0 holds the value for SPMCR
                 
                 dospm:
                 dospm_wait_ee:
001fad 99e1        sbic EECR, EEPE
001fae cffe        rjmp dospm_wait_ee
                 dospm_wait_spm:
001faf b717        in_  temp1, SPMCSR
001fb0 fd10        sbrc temp1, SPMEN
001fb1 cffd        rjmp dospm_wait_spm
                 
                   ; turn the word addres into a byte address
001fb2 0fee
001fb3 1fff        writeflashcell
                   ; execute spm
001fb4 6001        ori temp0, (1<<SPMEN)
001fb5 bf07        out_ SPMCSR,temp0
001fb6 95e8        spm
001fb7 9508        ret
                 .endif
                 .include "words/fetch-i.asm"
                 
                 ; Memory
                 ; read 1 cell from flash
                 VE_FETCHI:
001fb8 ff02          .dw $ff02
001fb9 6940          .db "@i"
001fba 1f66          .dw VE_HEAD
                     .set VE_HEAD = VE_FETCHI
                 XT_FETCHI:
001fbb 1fbc          .dw PFA_FETCHI
                 PFA_FETCHI:
001fbc 01fc          movw zl, tosl
001fbd 0fee
001fbe 1fff
001fbf 9185
001fc0 9195          readflashcell tosl,tosh
001fc1 cc43          jmp_ DO_NEXT
                 
                 .if AMFORTH_NRWW_SIZE>8000
                 .elif AMFORTH_NRWW_SIZE>4000
                 .elif AMFORTH_NRWW_SIZE>2000
                 .include "dict/core_2k.inc"
                 
                 .else
                 .endif
                 ; now colon words
                 ;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/2literal.asm"
                 
                 ; Compiler
                 ; compile a cell pair literal in colon definitions
                 VE_2LITERAL:
001fc2 0008          .dw $0008
001fc3 6c32
001fc4 7469
001fc5 7265
001fc6 6c61          .db "2literal"
001fc7 1fb8          .dw VE_HEAD
                     .set VE_HEAD = VE_2LITERAL
                 XT_2LITERAL:
001fc8 1c01          .dw DO_COLON
                 PFA_2LITERAL:
001fc9 1cbf          .dw XT_SWAP
001fca 02af          .dw XT_COMPILE
001fcb 1c38          .dw XT_DOLITERAL
001fcc 02ba          .dw XT_COMMA
001fcd 02af          .dw XT_COMPILE
001fce 1c38          .dw XT_DOLITERAL
001fcf 02ba          .dw XT_COMMA
                     
001fd0 1c1b          .dw XT_EXIT
                 .include "words/equal.asm"
                 
                 ; Compare
                 ; compares two values for equality
                 VE_EQUAL:
001fd1 ff01          .dw $ff01
001fd2 003d          .db "=",0
001fd3 1fc2          .dw VE_HEAD
                     .set VE_HEAD = VE_EQUAL
                 XT_EQUAL:
001fd4 1c01          .dw DO_COLON
                 PFA_EQUAL:
001fd5 1d8e          .dw XT_MINUS
001fd6 1d15          .dw XT_ZEROEQUAL
001fd7 1c1b          .dw XT_EXIT
                 .include "words/num-constants.asm"
                 
                 .endif
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_ONE:
001fd8 ff01          .dw $ff01
001fd9 0031          .db "1",0
001fda 1fd1          .dw VE_HEAD
                     .set VE_HEAD = VE_ONE
                 XT_ONE:
001fdb 1c43          .dw PFA_DOVARIABLE
                 PFA_ONE:
                 .endif
001fdc 0001              .DW 1
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_TWO:
001fdd ff01          .dw $ff01
001fde 0032          .db "2",0
001fdf 1fd8          .dw VE_HEAD
                     .set VE_HEAD = VE_TWO
                 XT_TWO:
001fe0 1c43          .dw PFA_DOVARIABLE
                 PFA_TWO:
                 .endif
001fe1 0002              .DW 2
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_MINUSONE:
001fe2 ff02          .dw $ff02
001fe3 312d          .db "-1"
001fe4 1fdd          .dw VE_HEAD
                     .set VE_HEAD = VE_MINUSONE
                 XT_MINUSONE:
001fe5 1c43          .dw PFA_DOVARIABLE
                 PFA_MINUSONE:
                 .endif
001fe6 ffff              .DW -1
                 .include "dict_appl_core.inc"
                 
                 ; do not delete it!
                 
                 .set flashlast = pc
                 .if (pc>FLASHEND)
                 .endif
                 
                 .dseg
                 ; define a label for the 1st free ram address
                 HERESTART:
                 .eseg
                 .include "amforth-eeprom.inc"
00002a ff ff     
                 EE_DP:
00002c 06 0f         .dw DPSTART      ; Dictionary Pointer
                 EE_HERE:
00002e 07 01         .dw HERESTART    ; Memory Allocation
                 EE_EHERE:
000030 7e 00         .dw EHERESTART     ; EEProm Memory Allocation
                 EE_TURNKEY:
000032 51 0e         .dw XT_APPLTURNKEY  ; TURNKEY
                 EE_STOREI:
000034 6d 1f         .dw XT_DO_STOREI  ; Store a cell into flash
                 
                 EE_ENVIRONMENT:
000036 c4 05         .dw VE_ENVHEAD   ; environmental queries
                 EE_WL_FORTH:
000038 3c 00         .dw EE_FORTHWORDLIST; forth-wordlist
                 EE_CURRENT:
00003a 3c 00         .dw EE_FORTHWORDLIST
                 EE_FORTHWORDLIST:
00003c e2 1f         .dw VE_HEAD      ; pre-defined (compiled in) wordlist
                 CFG_ORDERLISTLEN:
00003e 01 00         .dw 1
                 CFG_ORDERLIST: ; list of wordlist id, exactly numwordlist entries
000040 3c 00         .dw EE_FORTHWORDLIST      ; get/set-order
000042               .byte  (NUMWORDLISTS-1)*CELLSIZE ; one slot is already used
                 CFG_RECOGNIZERLISTLEN:
000050 02 00         .dw 2
                 CFG_RECOGNIZERLIST:
000052 a4 0b         .dw XT_REC_WORD
000054 8f 0b         .dw XT_REC_NUM
000056               .byte  (NUMRECOGNIZERS-2)*CELLSIZE ; two slots are already used
                 
                 EE_WLSCOPE:
00005a 2b 05         .dw XT_GET_CURRENT  ; default wordlist scope
                 
                 ; LEAVE stack is between data stack and return stack.
                 EE_LP0:
00005c 10 04         .dw stackstart+1
                 
                 ; MARKER saves everything up to here. Nothing beyond gets saved
                 EE_MARKER:
00005e 5e 00         .dw EE_MARKER
                 
                 ; default user area
                 EE_INITUSER:
000060 00 00         .dw 0  ; USER_STATE
000062 00 00         .dw 0  ; USER_FOLLOWER
000064 5f 04         .dw rstackstart  ; USER_RP
000066 0f 04         .dw stackstart   ; USER_SP0
000068 0f 04         .dw stackstart   ; USER_SP
                     
00006a 00 00         .dw 0  ; USER_HANDLER
00006c 0a 00         .dw 10 ; USER_BASE
                     
00006e 85 00         .dw XT_TX  ; USER_EMIT
000070 93 00         .dw XT_TXQ ; USER_EMITQ
000072 5b 00         .dw XT_RX  ; USER_KEY
000074 75 00         .dw XT_RXQ ; USER_KEYQ
000076 b4 0d         .dw XT_SOURCETIB ; USER_SKEY
000078 00 00         .dw 0            ; USER_G_IN
00007a a1 0d         .dw XT_REFILLTIB ; USER_REFILL  
                 
                 ; calculate baud rate error
                 .equ UBRR_VAL   = ((F_CPU+BAUD*8)/(BAUD*16)-1)  ; smart round
                 .equ BAUD_REAL  = (F_CPU/(16*(UBRR_VAL+1)))     ; effective baud rate
                 .equ BAUD_ERROR = ((BAUD_REAL*1000)/BAUD-1000)  ; error in pro mille
                 
                 .if ((BAUD_ERROR>BAUD_MAXERROR) || (BAUD_ERROR<-BAUD_MAXERROR))       
                 .endif
                 EE_UBRRVAL:
00007c 0c 00         .dw UBRR_VAL     ; BAUDRATE
                 ; 1st free address in EEPROM.
                 EHERESTART:
                 .cseg


RESOURCE USE INFORMATION
------------------------

Notice:
The register and instruction counts are symbol table hit counts,
and hence implicitly used resources are not counted, eg, the
'lpm' instruction without operands implicitly uses r0 and z,
none of which are counted.

x,y,z are separate entities in the symbol table and are
counted separately from r26..r31 here.

.dseg memory usage only counts static data declared with .byte

"ATmega16" register use summary:
r0 :  20 r1 :   5 r2 :   9 r3 :  11 r4 :   4 r5 :   1 r6 :   0 r7 :   0 
r8 :   0 r9 :   0 r10:   1 r11:   1 r12:   0 r13:   0 r14:  22 r15:  20 
r16:  83 r17:  56 r18:  61 r19:  37 r20:  13 r21:  11 r22:  11 r23:   3 
r24: 201 r25: 139 r26:  39 r27:  21 r28:   7 r29:   4 r30:  83 r31:  45 
x  :   4 y  : 205 z  :  48 
Registers used: 29 out of 35 (82.9%)

"ATmega16" instruction use summary:
.lds  :   0 .sts  :   0 adc   :  21 add   :  16 adiw  :  18 and   :   4 
andi  :   3 asr   :   2 bclr  :   0 bld   :   0 brbc  :   2 brbs  :   7 
brcc  :   3 brcs  :   1 break :   0 breq  :   6 brge  :   1 brhc  :   0 
brhs  :   0 brid  :   0 brie  :   0 brlo  :   1 brlt  :   3 brmi  :   3 
brne  :  19 brpl  :   1 brsh  :   0 brtc  :   0 brts  :   1 brvc  :   0 
brvs  :   2 bset  :   0 bst   :   0 call  :   2 cbi   :   7 cbr   :   1 
clc   :   2 clh   :   0 cli   :   7 cln   :   0 clr   :  12 cls   :   0 
clt   :   1 clv   :   0 clz   :   0 com   :  16 cp    :  10 cpc   :  10 
cpi   :   2 cpse  :   0 dec   :   8 eor   :   3 fmul  :   0 fmuls :   0 
fmulsu:   0 icall :   0 ijmp  :   1 in    :  26 inc   :   3 jmp   :  26 
ld    : 138 ldd   :   4 ldi   :  39 lds   :   2 lpm   :  16 lsl   :  14 
lsr   :   1 mov   :  10 movw  :  70 mul   :   5 muls  :   1 mulsu :   2 
neg   :   0 nop   :   0 or    :   9 ori   :   2 out   :  23 pop   :  48 
push  :  42 rcall :  34 ret   :   7 reti  :   2 rjmp  :  93 rol   :  23 
ror   :   6 sbc   :   9 sbci  :   3 sbi   :   8 sbic  :   3 sbis  :   0 
sbiw  :  16 sbr   :   0 sbrc  :   5 sbrs  :   7 sec   :   1 seh   :   0 
sei   :   1 sen   :   0 ser   :   4 ses   :   0 set   :   2 sev   :   0 
sez   :   0 sleep :   0 spm   :   2 st    :  74 std   :   8 sts   :   3 
sub   :   6 subi  :   3 swap  :   0 tst   :   1 wdr   :   0 
Instructions used: 77 out of 113 (68.1%)

"ATmega16" memory use summary [bytes]:
Segment   Begin    End      Code   Data   Used    Size   Use%
---------------------------------------------------------------
[.cseg] 0x000000 0x003fce   2060   9588  11648   16384  71.1%
[.dseg] 0x000060 0x000107      0    167    167    1024  16.3%
[.eseg] 0x000000 0x00007e      0    126    126     512  24.6%

Assembly complete, 0 errors, 5 warnings
