
AVRASM ver. 2.1.52  p1284-16.asm Fri Jul 10 18:43:17 2015

p1284-16.asm(5): Including file '../../avr8\preamble.inc'
../../avr8\preamble.inc(2): Including file '../../avr8\macros.asm'
../../avr8\macros.asm(6): Including file '../../avr8\user.inc'
../../avr8\preamble.inc(6): Including file '../../avr8/devices/atmega1284p\device.asm'
../../avr8/devices/atmega1284p\device.asm(5): Including file '../../avr8/Atmel/Appnotes2\m1284Pdef.inc'
p1284-16.asm(14): Including file '../../avr8\drivers/usart_0.asm'
../../avr8\drivers/usart_0.asm(32): Including file '../../avr8\drivers/usart_common.asm'
../../avr8\drivers/usart_common.asm(5): Including file '../../avr8\drivers/usart-isr-rx.asm'
../../avr8\drivers/usart_common.asm(17): Including file '../../avr8\words/usart-tx-poll.asm'
../../avr8\drivers/usart_common.asm(22): Including file '../../avr8\words/ubrr.asm'
../../avr8\drivers/usart_common.asm(23): Including file '../../avr8\words/usart.asm'
p1284-16.asm(19): Including file '../../avr8\drivers/1wire.asm'
p1284-16.asm(21): Including file '../../avr8\amforth.asm'
../../avr8\amforth.asm(12): Including file '../../avr8\drivers/generic-isr.asm'
../../avr8\amforth.asm(14): Including file '../../avr8\dict/rww.inc'
../../avr8\dict/rww.inc(1): Including file '../../avr8\words/mplus.asm'
../../avr8\dict/rww.inc(2): Including file '../../common\words/ud-star.asm'
../../avr8\dict/rww.inc(3): Including file '../../common\words/umax.asm'
../../avr8\dict/rww.inc(4): Including file '../../common\words/umin.asm'
../../avr8\dict/rww.inc(5): Including file '../../avr8\words/immediate-q.asm'
../../avr8\dict/rww.inc(6): Including file '../../avr8\words/name2flags.asm'
../../avr8\dict/rww.inc(7): Including file '../../common\words/name2interpret.asm'
../../avr8\dict/rww.inc(8): Including file '../../common\words/name2compile.asm'
../../avr8\dict/rww.inc(11): Including file '../../avr8\dict/appl_8k.inc'
../../avr8\dict/appl_8k.inc(1): Including file '../../avr8\dict/compiler1.inc'
../../avr8\dict/compiler1.inc(2): Including file '../../avr8\words/docreate.asm'
../../avr8\dict/compiler1.inc(3): Including file '../../common\words/backslash.asm'
../../avr8\dict/compiler1.inc(4): Including file '../../common\words/l-paren.asm'
../../avr8\dict/compiler1.inc(6): Including file '../../common\words/compile.asm'
../../avr8\dict/compiler1.inc(7): Including file '../../avr8\words/comma.asm'
../../avr8\dict/compiler1.inc(8): Including file '../../common\words/brackettick.asm'
../../avr8\dict/compiler1.inc(11): Including file '../../common\words/literal.asm'
../../avr8\dict/compiler1.inc(12): Including file '../../common\words/sliteral.asm'
../../avr8\dict/compiler1.inc(13): Including file '../../avr8\words/g-mark.asm'
../../avr8\dict/compiler1.inc(14): Including file '../../avr8\words/g-resolve.asm'
../../avr8\dict/compiler1.inc(15): Including file '../../avr8\words/l_mark.asm'
../../avr8\dict/compiler1.inc(16): Including file '../../avr8\words/l_resolve.asm'
../../avr8\dict/compiler1.inc(18): Including file '../../common\words/ahead.asm'
../../avr8\dict/compiler1.inc(19): Including file '../../common\words/if.asm'
../../avr8\dict/compiler1.inc(20): Including file '../../common\words/else.asm'
../../avr8\dict/compiler1.inc(21): Including file '../../common\words/then.asm'
../../avr8\dict/compiler1.inc(22): Including file '../../common\words/begin.asm'
../../avr8\dict/compiler1.inc(23): Including file '../../common\words/while.asm'
../../avr8\dict/compiler1.inc(24): Including file '../../common\words/repeat.asm'
../../avr8\dict/compiler1.inc(25): Including file '../../common\words/until.asm'
../../avr8\dict/compiler1.inc(26): Including file '../../common\words/again.asm'
../../avr8\dict/compiler1.inc(27): Including file '../../common\words/do.asm'
../../avr8\dict/compiler1.inc(28): Including file '../../common\words/loop.asm'
../../avr8\dict/compiler1.inc(29): Including file '../../common\words/plusloop.asm'
../../avr8\dict/compiler1.inc(30): Including file '../../common\words/leave.asm'
../../avr8\dict/compiler1.inc(31): Including file '../../common\words/qdo.asm'
../../avr8\dict/compiler1.inc(32): Including file '../../common\words/endloop.asm'
../../avr8\dict/compiler1.inc(34): Including file '../../common\words/l-from.asm'
../../avr8\dict/compiler1.inc(35): Including file '../../common\words/to-l.asm'
../../avr8\dict/compiler1.inc(36): Including file '../../avr8\words/lp0.asm'
../../avr8\dict/compiler1.inc(37): Including file '../../avr8\words/lp.asm'
../../avr8\dict/compiler1.inc(39): Including file '../../avr8\words/create.asm'
../../avr8\dict/compiler1.inc(40): Including file '../../avr8\words/header.asm'
../../avr8\dict/compiler1.inc(41): Including file '../../avr8\words/wlscope.asm'
../../avr8\dict/compiler1.inc(42): Including file '../../avr8\words/reveal.asm'
../../avr8\dict/compiler1.inc(43): Including file '../../avr8\words/latest.asm'
../../avr8\dict/compiler1.inc(44): Including file '../../avr8\words/does.asm'
../../avr8\dict/compiler1.inc(45): Including file '../../common\words/colon.asm'
../../avr8\dict/compiler1.inc(46): Including file '../../avr8\words/colon-noname.asm'
../../avr8\dict/compiler1.inc(47): Including file '../../common\words/semicolon.asm'
../../avr8\dict/compiler1.inc(48): Including file '../../common\words/right-bracket.asm'
../../avr8\dict/compiler1.inc(49): Including file '../../common\words/left-bracket.asm'
../../avr8\dict/compiler1.inc(50): Including file '../../common\words/variable.asm'
../../avr8\dict/compiler1.inc(51): Including file '../../common\words/constant.asm'
../../avr8\dict/compiler1.inc(52): Including file '../../avr8\words/user.asm'
../../avr8\dict/compiler1.inc(54): Including file '../../avr8\words/recurse.asm'
../../avr8\dict/compiler1.inc(55): Including file '../../avr8\words/immediate.asm'
../../avr8\dict/compiler1.inc(57): Including file '../../common\words/bracketchar.asm'
../../avr8\dict/compiler1.inc(58): Including file '../../common\words/abort-string.asm'
../../avr8\dict/compiler1.inc(59): Including file '../../common\words/abort.asm'
../../avr8\dict/compiler1.inc(60): Including file '../../common\words/q-abort.asm'
../../avr8\dict/compiler1.inc(62): Including file '../../common\words/get-stack.asm'
../../avr8\dict/compiler1.inc(63): Including file '../../common\words/set-stack.asm'
../../avr8\dict/compiler1.inc(64): Including file '../../common\words/map-stack.asm'
../../avr8\dict/compiler1.inc(65): Including file '../../avr8\words/get-current.asm'
../../avr8\dict/compiler1.inc(66): Including file '../../common\words/get-order.asm'
../../avr8\dict/compiler1.inc(68): Including file '../../avr8\words/compare.asm'
../../avr8\dict/compiler1.inc(69): Including file '../../avr8\words/nfa2lfa.asm'
../../avr8\amforth.asm(15): Including file 'dict_appl.inc'
dict_appl.inc(3): Including file '../../common\words/dot-s.asm'
dict_appl.inc(4): Including file '../../avr8\words/spirw.asm'
dict_appl.inc(5): Including file '../../avr8\words/n-spi.asm'
dict_appl.inc(6): Including file 'words/applturnkey.asm'
dict_appl.inc(7): Including file '../../avr8\dict/compiler2.inc'
../../avr8\dict/compiler2.inc(8): Including file '../../avr8\words/set-current.asm'
../../avr8\dict/compiler2.inc(9): Including file '../../avr8\words/wordlist.asm'
../../avr8\dict/compiler2.inc(11): Including file '../../avr8\words/only.asm'
../../avr8\dict/compiler2.inc(12): Including file '../../avr8\words/forth-wordlist.asm'
../../avr8\dict/compiler2.inc(13): Including file '../../common\words/set-order.asm'
../../avr8\dict/compiler2.inc(14): Including file '../../common\words/set-recognizer.asm'
../../avr8\dict/compiler2.inc(15): Including file '../../common\words/get-recognizer.asm'
../../avr8\dict/compiler2.inc(16): Including file '../../avr8\words/code.asm'
../../avr8\dict/compiler2.inc(17): Including file '../../avr8\words/end-code.asm'
../../avr8\dict/compiler2.inc(18): Including file '../../avr8\words/marker.asm'
../../avr8\dict/compiler2.inc(19): Including file '../../common\words/postpone.asm'
dict_appl.inc(8): Including file '../../avr8\words/2r_fetch.asm'
../../avr8\amforth.asm(23): Including file '../../avr8\amforth-interpreter.asm'
../../avr8\amforth.asm(24): Including file '../../avr8\dict/nrww.inc'
../../avr8\dict/nrww.inc(4): Including file '../../avr8\words/exit.asm'
../../avr8\dict/nrww.inc(5): Including file '../../avr8\words/execute.asm'
../../avr8\dict/nrww.inc(6): Including file '../../avr8\words/dobranch.asm'
../../avr8\dict/nrww.inc(7): Including file '../../avr8\words/docondbranch.asm'
../../avr8\dict/nrww.inc(10): Including file '../../avr8\words/doliteral.asm'
../../avr8\dict/nrww.inc(11): Including file '../../avr8\words/dovariable.asm'
../../avr8\dict/nrww.inc(12): Including file '../../avr8\words/doconstant.asm'
../../avr8\dict/nrww.inc(13): Including file '../../avr8\words/douser.asm'
../../avr8\dict/nrww.inc(14): Including file '../../avr8\words/do-value.asm'
../../avr8\dict/nrww.inc(15): Including file '../../avr8\words/fetch.asm'
../../avr8\dict/nrww.inc(16): Including file '../../avr8\words/store.asm'
../../avr8\dict/nrww.inc(17): Including file '../../avr8\words/cstore.asm'
../../avr8\dict/nrww.inc(18): Including file '../../avr8\words/cfetch.asm'
../../avr8\dict/nrww.inc(19): Including file '../../avr8\words/fetch-u.asm'
../../avr8\dict/nrww.inc(20): Including file '../../avr8\words/store-u.asm'
../../avr8\dict/nrww.inc(23): Including file '../../avr8\words/dup.asm'
../../avr8\dict/nrww.inc(24): Including file '../../avr8\words/qdup.asm'
../../avr8\dict/nrww.inc(25): Including file '../../avr8\words/swap.asm'
../../avr8\dict/nrww.inc(26): Including file '../../avr8\words/over.asm'
../../avr8\dict/nrww.inc(27): Including file '../../avr8\words/drop.asm'
../../avr8\dict/nrww.inc(28): Including file '../../avr8\words/rot.asm'
../../avr8\dict/nrww.inc(29): Including file '../../avr8\words/nip.asm'
../../avr8\dict/nrww.inc(31): Including file '../../avr8\words/r_from.asm'
../../avr8\dict/nrww.inc(32): Including file '../../avr8\words/to_r.asm'
../../avr8\dict/nrww.inc(33): Including file '../../avr8\words/r_fetch.asm'
../../avr8\dict/nrww.inc(36): Including file '../../common\words/not-equal.asm'
../../avr8\dict/nrww.inc(37): Including file '../../avr8\words/equalzero.asm'
../../avr8\dict/nrww.inc(38): Including file '../../avr8\words/lesszero.asm'
../../avr8\dict/nrww.inc(39): Including file '../../avr8\words/greaterzero.asm'
../../avr8\dict/nrww.inc(40): Including file '../../avr8\words/d-greaterzero.asm'
../../avr8\dict/nrww.inc(41): Including file '../../avr8\words/d-lesszero.asm'
../../avr8\dict/nrww.inc(43): Including file '../../avr8\words/true.asm'
../../avr8\dict/nrww.inc(44): Including file '../../avr8\words/zero.asm'
../../avr8\dict/nrww.inc(45): Including file '../../avr8\words/uless.asm'
../../avr8\dict/nrww.inc(46): Including file '../../common\words/u-greater.asm'
../../avr8\dict/nrww.inc(47): Including file '../../avr8\words/less.asm'
../../avr8\dict/nrww.inc(48): Including file '../../avr8\words/greater.asm'
../../avr8\dict/nrww.inc(50): Including file '../../avr8\words/log2.asm'
../../avr8\dict/nrww.inc(51): Including file '../../avr8\words/minus.asm'
../../avr8\dict/nrww.inc(52): Including file '../../avr8\words/plus.asm'
../../avr8\dict/nrww.inc(53): Including file '../../avr8\words/mstar.asm'
../../avr8\dict/nrww.inc(54): Including file '../../avr8\words/umslashmod.asm'
../../avr8\dict/nrww.inc(55): Including file '../../avr8\words/umstar.asm'
../../avr8\dict/nrww.inc(57): Including file '../../avr8\words/invert.asm'
../../avr8\dict/nrww.inc(58): Including file '../../avr8\words/2slash.asm'
../../avr8\dict/nrww.inc(59): Including file '../../avr8\words/2star.asm'
../../avr8\dict/nrww.inc(60): Including file '../../avr8\words/and.asm'
../../avr8\dict/nrww.inc(61): Including file '../../avr8\words/or.asm'
../../avr8\dict/nrww.inc(62): Including file '../../avr8\words/xor.asm'
../../avr8\dict/nrww.inc(64): Including file '../../avr8\words/1plus.asm'
../../avr8\dict/nrww.inc(65): Including file '../../avr8\words/1minus.asm'
../../avr8\dict/nrww.inc(66): Including file '../../avr8\words/lshift.asm'
../../avr8\dict/nrww.inc(67): Including file '../../avr8\words/rshift.asm'
../../avr8\dict/nrww.inc(68): Including file '../../avr8\words/plusstore.asm'
../../avr8\dict/nrww.inc(70): Including file '../../avr8\words/rpfetch.asm'
../../avr8\dict/nrww.inc(71): Including file '../../avr8\words/rpstore.asm'
../../avr8\dict/nrww.inc(72): Including file '../../avr8\words/spfetch.asm'
../../avr8\dict/nrww.inc(73): Including file '../../avr8\words/spstore.asm'
../../avr8\dict/nrww.inc(75): Including file '../../avr8\words/dodo.asm'
../../avr8\dict/nrww.inc(76): Including file '../../avr8\words/i.asm'
../../avr8\dict/nrww.inc(77): Including file '../../avr8\words/doplusloop.asm'
../../avr8\dict/nrww.inc(78): Including file '../../avr8\words/doloop.asm'
../../avr8\dict/nrww.inc(79): Including file '../../avr8\words/unloop.asm'
../../avr8\dict/nrww.inc(83): Including file '../../avr8\words/cmove_g.asm'
../../avr8\dict/nrww.inc(84): Including file '../../avr8\words/byteswap.asm'
../../avr8\dict/nrww.inc(85): Including file '../../avr8\words/up.asm'
../../avr8\dict/nrww.inc(86): Including file '../../avr8\words/1ms.asm'
../../avr8\dict/nrww.inc(87): Including file '../../avr8\words/2to_r.asm'
../../avr8\dict/nrww.inc(88): Including file '../../avr8\words/2r_from.asm'
../../avr8\dict/nrww.inc(90): Including file '../../avr8\words/store-e.asm'
../../avr8\dict/nrww.inc(91): Including file '../../avr8\words/fetch-e.asm'
../../avr8\dict/nrww.inc(92): Including file '../../avr8\words/store-i.asm'
../../avr8\dict/nrww.inc(96): Including file '../../avr8\words/store-i_nrww.asm'
../../avr8\dict/nrww.inc(98): Including file '../../avr8\words/fetch-i.asm'
../../avr8\dict/nrww.inc(101): Including file '../../avr8\dict/core_8k.inc'
../../avr8\dict/core_8k.inc(2): Including file '../../avr8\words/n_to_r.asm'
../../avr8\dict/core_8k.inc(3): Including file '../../avr8\words/n_r_from.asm'
../../avr8\dict/core_8k.inc(5): Including file '../../avr8\words/d-2star.asm'
../../avr8\dict/core_8k.inc(6): Including file '../../avr8\words/d-2slash.asm'
../../avr8\dict/core_8k.inc(7): Including file '../../avr8\words/d-plus.asm'
../../avr8\dict/core_8k.inc(8): Including file '../../avr8\words/d-minus.asm'
../../avr8\dict/core_8k.inc(9): Including file '../../avr8\words/d-invert.asm'
../../avr8\dict/core_8k.inc(10): Including file '../../avr8\words/d-equal.asm'
../../avr8\dict/core_8k.inc(11): Including file '../../common\words/u-dot.asm'
../../avr8\dict/core_8k.inc(12): Including file '../../common\words/u-dot-r.asm'
../../avr8\dict/core_8k.inc(14): Including file '../../common\words/show-wordlist.asm'
../../avr8\dict/core_8k.inc(15): Including file '../../avr8\words/words.asm'
../../avr8\dict/core_8k.inc(16): Including file '../../avr8\dict/interrupt.inc'
../../avr8\dict/interrupt.inc(2): Including file '../../avr8\words/int-on.asm'
../../avr8\dict/interrupt.inc(3): Including file '../../avr8\words/int-off.asm'
../../avr8\dict/interrupt.inc(4): Including file '../../avr8\words/int-store.asm'
../../avr8\dict/interrupt.inc(5): Including file '../../avr8\words/int-fetch.asm'
../../avr8\dict/interrupt.inc(6): Including file '../../avr8\words/int-trap.asm'
../../avr8\dict/interrupt.inc(8): Including file '../../avr8\words/isr-exec.asm'
../../avr8\dict/interrupt.inc(9): Including file '../../avr8\words/isr-end.asm'
../../avr8\dict/core_8k.inc(18): Including file '../../common\words/pick.asm'
../../avr8\dict/core_8k.inc(19): Including file '../../common\words/dot-quote.asm'
../../avr8\dict/core_8k.inc(20): Including file '../../common\words/squote.asm'
../../avr8\dict/core_8k.inc(22): Including file '../../avr8\words/fill.asm'
../../avr8\dict/core_8k.inc(24): Including file '../../avr8\words/environment.asm'
../../avr8\dict/core_8k.inc(25): Including file '../../avr8\words/env-wordlists.asm'
../../avr8\dict/core_8k.inc(26): Including file '../../avr8\words/env-slashpad.asm'
../../avr8\dict/core_8k.inc(27): Including file '../../avr8\words/env-slashhold.asm'
../../avr8\dict/core_8k.inc(28): Including file '../../common\words/env-forthname.asm'
../../avr8\dict/core_8k.inc(29): Including file '../../common\words/env-forthversion.asm'
../../avr8\dict/core_8k.inc(30): Including file '../../common\words/env-cpu.asm'
../../avr8\dict/core_8k.inc(31): Including file '../../avr8\words/env-mcuinfo.asm'
../../avr8\dict/core_8k.inc(32): Including file '../../avr8\words/env-usersize.asm'
../../avr8\dict/core_8k.inc(34): Including file '../../common\words/f_cpu.asm'
../../avr8\dict/core_8k.inc(35): Including file '../../avr8\words/state.asm'
../../avr8\dict/core_8k.inc(36): Including file '../../common\words/base.asm'
../../avr8\dict/core_8k.inc(38): Including file '../../avr8\words/cells.asm'
../../avr8\dict/core_8k.inc(39): Including file '../../avr8\words/cellplus.asm'
../../avr8\dict/core_8k.inc(41): Including file '../../common\words/2dup.asm'
../../avr8\dict/core_8k.inc(42): Including file '../../common\words/2drop.asm'
../../avr8\dict/core_8k.inc(44): Including file '../../common\words/tuck.asm'
../../avr8\dict/core_8k.inc(46): Including file '../../common\words/to-in.asm'
../../avr8\dict/core_8k.inc(47): Including file '../../avr8\words/sharptib.asm'
../../avr8\dict/core_8k.inc(48): Including file '../../avr8\words/pad.asm'
../../avr8\dict/core_8k.inc(49): Including file '../../avr8\words/emit.asm'
../../avr8\dict/core_8k.inc(50): Including file '../../avr8\words/emitq.asm'
../../avr8\dict/core_8k.inc(51): Including file '../../avr8\words/key.asm'
../../avr8\dict/core_8k.inc(52): Including file '../../avr8\words/keyq.asm'
../../avr8\dict/core_8k.inc(54): Including file '../../avr8\words/dp.asm'
../../avr8\dict/core_8k.inc(55): Including file '../../avr8\words/ehere.asm'
../../avr8\dict/core_8k.inc(56): Including file '../../avr8\words/here.asm'
../../avr8\dict/core_8k.inc(57): Including file '../../avr8\words/allot.asm'
../../avr8\dict/core_8k.inc(59): Including file '../../common\words/bin.asm'
../../avr8\dict/core_8k.inc(60): Including file '../../common\words/decimal.asm'
../../avr8\dict/core_8k.inc(61): Including file '../../common\words/hex.asm'
../../avr8\dict/core_8k.inc(62): Including file '../../common\words/bl.asm'
../../avr8\dict/core_8k.inc(64): Including file '../../avr8\words/turnkey.asm'
../../avr8\dict/core_8k.inc(66): Including file '../../avr8\words/slashmod.asm'
../../avr8\dict/core_8k.inc(67): Including file '../../avr8\words/uslashmod.asm'
../../avr8\dict/core_8k.inc(68): Including file '../../avr8\words/negate.asm'
../../avr8\dict/core_8k.inc(69): Including file '../../common\words/slash.asm'
../../avr8\dict/core_8k.inc(70): Including file '../../common\words/mod.asm'
../../avr8\dict/core_8k.inc(71): Including file '../../avr8\words/abs.asm'
../../avr8\dict/core_8k.inc(72): Including file '../../common\words/min.asm'
../../avr8\dict/core_8k.inc(73): Including file '../../common\words/max.asm'
../../avr8\dict/core_8k.inc(74): Including file '../../common\words/within.asm'
../../avr8\dict/core_8k.inc(76): Including file '../../common\words/to-upper.asm'
../../avr8\dict/core_8k.inc(77): Including file '../../common\words/to-lower.asm'
../../avr8\dict/core_8k.inc(79): Including file '../../avr8\words/hld.asm'
../../avr8\dict/core_8k.inc(80): Including file '../../common\words/hold.asm'
../../avr8\dict/core_8k.inc(81): Including file '../../common\words/less-sharp.asm'
../../avr8\dict/core_8k.inc(82): Including file '../../common\words/sharp.asm'
../../avr8\dict/core_8k.inc(83): Including file '../../common\words/sharp-s.asm'
../../avr8\dict/core_8k.inc(84): Including file '../../common\words/sharp-greater.asm'
../../avr8\dict/core_8k.inc(85): Including file '../../common\words/sign.asm'
../../avr8\dict/core_8k.inc(86): Including file '../../common\words/d-dot-r.asm'
../../avr8\dict/core_8k.inc(87): Including file '../../common\words/dot-r.asm'
../../avr8\dict/core_8k.inc(88): Including file '../../common\words/d-dot.asm'
../../avr8\dict/core_8k.inc(89): Including file '../../common\words/dot.asm'
../../avr8\dict/core_8k.inc(90): Including file '../../common\words/ud-dot.asm'
../../avr8\dict/core_8k.inc(91): Including file '../../common\words/ud-dot-r.asm'
../../avr8\dict/core_8k.inc(92): Including file '../../common\words/ud-slash-mod.asm'
../../avr8\dict/core_8k.inc(93): Including file '../../common\words/digit-q.asm'
../../avr8\dict/core_8k.inc(95): Including file '../../avr8\words/do-sliteral.asm'
../../avr8\dict/core_8k.inc(96): Including file '../../avr8\words/scomma.asm'
../../avr8\dict/core_8k.inc(97): Including file '../../avr8\words/itype.asm'
../../avr8\dict/core_8k.inc(98): Including file '../../avr8\words/icount.asm'
../../avr8\dict/core_8k.inc(99): Including file '../../common\words/cr.asm'
../../avr8\dict/core_8k.inc(100): Including file '../../common\words/space.asm'
../../avr8\dict/core_8k.inc(101): Including file '../../common\words/spaces.asm'
../../avr8\dict/core_8k.inc(102): Including file '../../common\words/type.asm'
../../avr8\dict/core_8k.inc(103): Including file '../../common\words/tick.asm'
../../avr8\dict/core_8k.inc(105): Including file '../../common\words/handler.asm'
../../avr8\dict/core_8k.inc(106): Including file '../../common\words/catch.asm'
../../avr8\dict/core_8k.inc(107): Including file '../../common\words/throw.asm'
../../avr8\dict/core_8k.inc(109): Including file '../../common\words/cskip.asm'
../../avr8\dict/core_8k.inc(110): Including file '../../common\words/cscan.asm'
../../avr8\dict/core_8k.inc(111): Including file '../../common\words/accept.asm'
../../avr8\dict/core_8k.inc(112): Including file '../../avr8\words/refill.asm'
../../avr8\dict/core_8k.inc(113): Including file '../../common\words/char.asm'
../../avr8\dict/core_8k.inc(114): Including file '../../common\words/number.asm'
../../avr8\dict/core_8k.inc(115): Including file '../../common\words/q-sign.asm'
../../avr8\dict/core_8k.inc(116): Including file '../../common\words/set-base.asm'
../../avr8\dict/core_8k.inc(117): Including file '../../common\words/to-number.asm'
../../avr8\dict/core_8k.inc(118): Including file '../../common\words/parse.asm'
../../avr8\dict/core_8k.inc(119): Including file '../../avr8\words/source.asm'
../../avr8\dict/core_8k.inc(120): Including file '../../common\words/slash-string.asm'
../../avr8\dict/core_8k.inc(121): Including file '../../common\words/parse-name.asm'
../../avr8\dict/core_8k.inc(122): Including file '../../common\words/find-name.asm'
../../avr8\dict/core_8k.inc(124): Including file '../../common\words/prompt-ok.asm'
../../avr8\dict/core_8k.inc(125): Including file '../../common\words/prompt-ready.asm'
../../avr8\dict/core_8k.inc(126): Including file '../../common\words/prompt-error.asm'
../../avr8\dict/core_8k.inc(128): Including file '../../common\words/quit.asm'
../../avr8\dict/core_8k.inc(129): Including file '../../avr8\words/pause.asm'
../../avr8\dict/core_8k.inc(130): Including file '../../avr8\words/cold.asm'
../../avr8\dict/core_8k.inc(131): Including file '../../avr8\words/warm.asm'
../../avr8\dict/core_8k.inc(133): Including file '../../avr8\words/sp0.asm'
../../avr8\dict/core_8k.inc(134): Including file '../../avr8\words/rp0.asm'
../../avr8\dict/core_8k.inc(135): Including file '../../common\words/depth.asm'
../../avr8\dict/core_8k.inc(136): Including file '../../common\words/interpret.asm'
../../avr8\dict/core_8k.inc(137): Including file '../../common\words/do-recognizer.asm'
../../avr8\dict/core_8k.inc(138): Including file '../../common\words/r-intnumber.asm'
../../avr8\dict/core_8k.inc(139): Including file '../../common\words/r-word.asm'
../../avr8\dict/core_8k.inc(140): Including file '../../common\words/r-fail.asm'
../../avr8\dict/core_8k.inc(142): Including file '../../common\words/q-stack.asm'
../../avr8\dict/core_8k.inc(143): Including file '../../common\words/ver.asm'
../../avr8\dict/core_8k.inc(145): Including file '../../avr8\words/noop.asm'
../../avr8\dict/core_8k.inc(146): Including file '../../avr8\words/unused.asm'
../../avr8\dict/core_8k.inc(148): Including file '../../common\words/to.asm'
../../avr8\dict/core_8k.inc(149): Including file '../../avr8\words/i-cellplus.asm'
../../avr8\dict/core_8k.inc(151): Including file '../../avr8\words/edefer-fetch.asm'
../../avr8\dict/core_8k.inc(152): Including file '../../avr8\words/edefer-store.asm'
../../avr8\dict/core_8k.inc(153): Including file '../../common\words/rdefer-fetch.asm'
../../avr8\dict/core_8k.inc(154): Including file '../../common\words/rdefer-store.asm'
../../avr8\dict/core_8k.inc(155): Including file '../../common\words/udefer-fetch.asm'
../../avr8\dict/core_8k.inc(156): Including file '../../common\words/udefer-store.asm'
../../avr8\dict/core_8k.inc(157): Including file '../../common\words/defer-store.asm'
../../avr8\dict/core_8k.inc(158): Including file '../../common\words/defer-fetch.asm'
../../avr8\dict/core_8k.inc(159): Including file '../../avr8\words/do-defer.asm'
../../avr8\dict/core_8k.inc(161): Including file '../../common\words/search-wordlist.asm'
../../avr8\dict/core_8k.inc(162): Including file '../../common\words/traverse-wordlist.asm'
../../avr8\dict/core_8k.inc(163): Including file '../../common\words/name2string.asm'
../../avr8\dict/core_8k.inc(164): Including file '../../avr8\words/nfa2cfa.asm'
../../avr8\dict/core_8k.inc(165): Including file '../../avr8\words/icompare.asm'
../../avr8\dict/core_8k.inc(167): Including file '../../common\words/star.asm'
../../avr8\dict/core_8k.inc(168): Including file '../../avr8\words/j.asm'
../../avr8\dict/core_8k.inc(170): Including file '../../avr8\words/dabs.asm'
../../avr8\dict/core_8k.inc(171): Including file '../../avr8\words/dnegate.asm'
../../avr8\dict/core_8k.inc(172): Including file '../../avr8\words/cmove.asm'
../../avr8\dict/core_8k.inc(173): Including file '../../common\words/2swap.asm'
../../avr8\dict/core_8k.inc(175): Including file '../../avr8\words/tib.asm'
../../avr8\dict/core_8k.inc(177): Including file '../../avr8\words/init-user.asm'
../../avr8\dict/core_8k.inc(178): Including file '../../avr8\dict/compiler2.inc'
../../avr8\dict/core_8k.inc(179): Including file '../../common\words/bounds.asm'
../../avr8\dict/core_8k.inc(180): Including file '../../common\words/s-to-d.asm'
../../avr8\dict/core_8k.inc(181): Including file '../../avr8\words/to-body.asm'
../../avr8\dict/nrww.inc(111): Including file '../../avr8\words/2literal.asm'
../../avr8\dict/nrww.inc(112): Including file '../../avr8\words/equal.asm'
../../avr8\dict/nrww.inc(113): Including file '../../common\words/num-constants.asm'
../../avr8\amforth.asm(25): Including file 'dict_appl_core.inc'
../../avr8\amforth.asm(36): Including file '../../avr8\amforth-eeprom.inc'
                 
                 
                 ; file see ../template/template.asm. You may want to
                 ; copy that file to this one and edit it afterwards.
                 
                 .include "preamble.inc"
                 
                 .include "macros.asm"
                 
                 .set DICT_COMPILER2 = 0 ;
                 .set cpu_msp430 = 0
                 .set cpu_avr8   = 1
                 
                 .include "user.inc"
                 
                 ; 
                 
                 ; used by the multitasker
                 .set USER_STATE    = 0
                 .set USER_FOLLOWER = 2
                 
                 ; stackpointer, used by mulitasker
                 .set USER_RP      = 4
                 .set USER_SP0     = 6
                 .set USER_SP      = 8
                 
                 ; excpection handling
                 .set USER_HANDLER = 10
                 
                 ; numeric IO
                 .set USER_BASE  = 12
                 
                 ; character IO 
                 .set USER_EMIT  = 14
                 .set USER_EMITQ = 16
                 .set USER_KEY   = 18
                 .set USER_KEYQ  = 20
                 
                 .set USER_SOURCE  = 22
                 .set USER_TO_IN   = 24
                 .set USER_REFILL  = 26
                 
                 .set SYSUSERSIZE = 28
                 ; 
                 
                   .def zerol = r2
                   .def zeroh = r3
                   .def upl = r4
                   .def uph = r5
                 
                   .def al  = r6
                   .def ah  = r7
                   .def bl  = r8
                   .def bh  = r9
                 
                 ; internal
                   .def mcu_boot      = r10
                   .def erase_counter = r11
                 
                   .def temp4 = r14
                   .def temp5 = r15
                 
                   .def temp0 = r16
                   .def temp1 = r17
                   .def temp2 = r18
                   .def temp3 = r19
                 
                   .def temp6 = r20
                   .def temp7 = r21
                 
                   .def tosl = r24
                   .def tosh = r25
                 
                   .def wl = r22
                   .def wh = r23
                 
                 .macro loadtos
                     ld tosl, Y+
                     ld tosh, Y+
                 .endmacro
                 
                 .macro savetos
                     st -Y, tosh
                     st -Y, tosl
                 .endmacro
                 
                 .macro in_
                 .if (@1 < $40)
                   in @0,@1
                 .else
                   lds @0,@1
                 .endif
                 .endmacro
                 
                 .macro out_
                 .if (@0 < $40)
                   out @0,@1
                 .else
                   sts @0,@1
                 .endif
                 .endmacro
                 
                 .macro sbi_
                 .if (@0 < $40)
                   sbi @0,@1
                 .else
                   in_ @2,@0
                   ori @2,exp2(@1)
                   out_ @0,@2
                 .endif
                 .endmacro
                 
                 .macro cbi_
                 .if (@0 < $40)
                   cbi @0,@1
                 .else
                   in_ @2,@0
                   andi @2,~(exp2(@1))
                   out_ @0,@2
                 .endif
                 .endmacro
                 
                 .macro jmp_
                 	; a more flexible macro
                     .ifdef @0
                     .if (@0-pc > 2040) || (pc-@0>2040)
                 	jmp @0
                 	.else
                 	rjmp @0
                 	.endif
                 	.else
                 	jmp @0
                 	.endif
                 .endmacro
                 .macro call_
                 	; a more flexible macro
                     .ifdef @0
                     .if (@0-pc > 2040) || (pc-@0>2040)
                 	call @0
                 	.else
                 	rcall @0
                 	.endif
                 	.else
                 	call @0
                 	.endif
                 .endmacro
                 
                 ;               F_CPU
                 ;    µsec   16000000   14745600    8000000  1000000
                 ;    1            16      14,74          8        1
                 ;    10          160     147,45         80       10
                 ;    100        1600    1474,56        800      100
                 ;    1000      16000   14745,6        8000     1000
                 ;
                 ; cycles = µsec * f_cpu / 1e6
                 ; n_loops=cycles/5
                 ;
                 ;     cycles already used will be subtracted from the delay
                 ;     the waittime resolution is 1 cycle (delay from exact to +1 cycle)
                 ;     the maximum delay at 20MHz (50ns/clock) is 38350ns
                 ;     waitcount register must specify an immediate register
                 ;
                 ; busy waits a specfied amount of microseconds
                 .macro   delay
                       .set cycles = ( ( @0 * F_CPU ) / 1000000 )
                       .if (cycles > ( 256 * 255 * 4 + 2))
                         .error "MACRO delay - too many cycles to burn"
                       .else
                         .if (cycles > 6)
                           .set  loop_cycles = (cycles / 4)      
                           ldi   zl,low(loop_cycles)
                           ldi   zh,high(loop_cycles)
                           sbiw  Z, 1
                           brne  pc-1
                           .set  cycles = (cycles - (loop_cycles * 4))
                         .endif
                         .if (cycles > 0)
                           .if   (cycles & 4)
                             rjmp  pc+1
                             rjmp  pc+1
                           .endif
                           .if   (cycles & 2)
                             rjmp  pc+1
                           .endif
                           .if   (cycles & 1)
                             nop
                           .endif
                         .endif
                       .endif
                 .endmacro
                 
                 ; portability macros, they come from the msp430 branches
                 
                 .macro DEST
                     .dw @0
                 .endm
                 
                 ; controller specific file selected via include
                 ; directory definition when calling the assembler (-I)
                 .include "device.asm"
                 
                 ; generated automatically, do not edit
                 
                 .list
                 
                 .equ ramstart =  256
                 .equ CELLSIZE = 2
                 .macro readflashcell
                 	clr temp7
                 	lsl zl
                 	rol zh
                 	rol temp7
                 	out_ RAMPZ, temp7
                 	elpm @0, Z+
                 	elpm @1, Z+
                 .endmacro
                 .macro writeflashcell
                 	clr temp7
                 	lsl zl
                 	rol zh
                 	rol temp7
                 	out_ RAMPZ, temp7
                 .endmacro
                 .set WANT_ANALOG_COMPARATOR = 0
                 .set WANT_USART0 = 0
                 .set WANT_PORTA = 0
                 .set WANT_PORTB = 0
                 .set WANT_PORTC = 0
                 .set WANT_PORTD = 0
                 .set WANT_TIMER_COUNTER_0 = 0
                 .set WANT_TIMER_COUNTER_1 = 0
                 .set WANT_TIMER_COUNTER_2 = 0
                 .set WANT_TIMER_COUNTER_3 = 0
                 .set WANT_BOOT_LOAD = 0
                 .set WANT_EXTERNAL_INTERRUPT = 0
                 .set WANT_AD_CONVERTER = 0
                 .set WANT_JTAG = 0
                 .set WANT_EEPROM = 0
                 .set WANT_TWI = 0
                 .set WANT_USART1 = 0
                 .set WANT_SPI = 0
                 .set WANT_WATCHDOG = 0
                 .set WANT_CPU = 0
                 .equ intvecsize = 2 ; please verify; flash size: 131072 bytes
                 .equ pclen = 2 ; please verify
                 .overlap
                 .org 2
000002 d127      	 rcall isr ; External Interrupt Request 0
                 .org 4
000004 d125      	 rcall isr ; External Interrupt Request 1
                 .org 6
000006 d123      	 rcall isr ; External Interrupt Request 2
                 .org 8
000008 d121      	 rcall isr ; Pin Change Interrupt Request 0
                 .org 10
00000a d11f      	 rcall isr ; Pin Change Interrupt Request 1
                 .org 12
00000c d11d      	 rcall isr ; Pin Change Interrupt Request 2
                 .org 14
00000e d11b      	 rcall isr ; Pin Change Interrupt Request 3
                 .org 16
000010 d119      	 rcall isr ; Watchdog Time-out Interrupt
                 .org 18
000012 d117      	 rcall isr ; Timer/Counter2 Compare Match A
                 .org 20
000014 d115      	 rcall isr ; Timer/Counter2 Compare Match B
                 .org 22
000016 d113      	 rcall isr ; Timer/Counter2 Overflow
                 .org 24
000018 d111      	 rcall isr ; Timer/Counter1 Capture Event
                 .org 26
00001a d10f      	 rcall isr ; Timer/Counter1 Compare Match A
                 .org 28
00001c d10d      	 rcall isr ; Timer/Counter1 Compare Match B
                 .org 30
00001e d10b      	 rcall isr ; Timer/Counter1 Overflow
                 .org 32
000020 d109      	 rcall isr ; Timer/Counter0 Compare Match A
                 .org 34
000022 d107      	 rcall isr ; Timer/Counter0 Compare Match B
                 .org 36
000024 d105      	 rcall isr ; Timer/Counter0 Overflow
                 .org 38
000026 d103      	 rcall isr ; SPI Serial Transfer Complete
                 .org 40
000028 d101      	 rcall isr ; USART0, Rx Complete
                 .org 42
00002a d0ff      	 rcall isr ; USART0 Data register Empty
                 .org 44
00002c d0fd      	 rcall isr ; USART0, Tx Complete
                 .org 46
00002e d0fb      	 rcall isr ; Analog Comparator
                 .org 48
000030 d0f9      	 rcall isr ; ADC Conversion Complete
                 .org 50
000032 d0f7      	 rcall isr ; EEPROM Ready
                 .org 52
000034 d0f5      	 rcall isr ; 2-wire Serial Interface
                 .org 54
000036 d0f3      	 rcall isr ; Store Program Memory Read
                 .org 56
000038 d0f1      	 rcall isr ; USART1 RX complete
                 .org 58
00003a d0ef      	 rcall isr ; USART1 Data Register Empty
                 .org 60
00003c d0ed      	 rcall isr ; USART1 TX complete
                 .org 62
00003e d0eb      	 rcall isr ; Timer/Counter3 Capture Event
                 .org 64
000040 d0e9      	 rcall isr ; Timer/Counter3 Compare Match A
                 .org 66
000042 d0e7      	 rcall isr ; Timer/Counter3 Compare Match B
                 .org 68
000044 d0e5      	 rcall isr ; Timer/Counter3 Overflow
                 .equ INTVECTORS = 35
                 .nooverlap
                 
                 ; compatability layer (maybe empty)
                 
                 ; controller data area, environment query mcu-info
                 mcu_info:
                 mcu_ramsize:
000045 4000      	.dw 16384
                 mcu_eepromsize:
000046 1000      	.dw 4096
                 mcu_maxdp:
000047 ffff      	.dw 65535 
                 mcu_numints:
000048 0023      	.dw 35
                 mcu_name:
000049 000b      	.dw 11
00004a 5441
00004b 656d
00004c 6167
00004d 3231
00004e 3438
00004f 0050      	.db "ATmega1284P",0
                 .set codestart=pc
                 
                 ; some defaults, change them in your application master file
                 ; see template.asm for an example
                 
                 .set AMFORTH_RO_SEG = NRWW_START_ADDR
                 
                 ; receiving is asynchron, so an interrupt queue is useful.
                 .set WANT_ISR_RX = 1
                 
                 ; case insensitve dictionary lookup.
                 .set WANT_IGNORECASE = 0
                 
                 ; map all memories to one address space. Details in the
                 ; technical guide
                 .set WANT_UNIFIED = 0
                 
                 ; terminal input buffer
                 .set TIBSIZE  = 90    ; ANS94 needs at least 80 characters per line
                 
                 ; USER variables *in addition* to system ones
                 .set APPUSERSIZE = 10  ; size of application specific user area in bytes
                 
                 ; addresses of various data segments
                 .set rstackstart = RAMEND      ; start address of return stack, grows downward
                 .set stackstart  = RAMEND - 80 ; start address of data stack, grows downward
                 ; change only if you know what to you do
                 .set NUMWORDLISTS = 8 ; number of word lists in the searh order, at least 8
                 .set NUMRECOGNIZERS = 4 ; total number of recognizers, two are always used.
                 
                 ; 10 per mille (1 per cent) is ok.
                 .set BAUD = 38400
                 .set BAUD_MAXERROR = 10
                 
                 ; Dictionary setup
                 .set VE_HEAD = $0000
                 .set VE_ENVHEAD = $0000
                 
                 
                 .set AMFORTH_RO_SEG = NRWW_START_ADDR+1
                 
                 ; cpu clock in hertz
                 .equ F_CPU = 16000000
                 .set BAUD_MAXERROR = 30
                 .equ TIMER_INT = OVF2addr
                 
                 .include "drivers/usart_0.asm"
                 
                   .equ BAUDRATE_HIGH = UBRR0H
                   .equ USART_C = UCSR0C
                   .equ USART_B = UCSR0B
                   .equ USART_A = UCSR0A
                   .equ USART_DATA = UDR0
                   .ifndef URXCaddr
                   .equ URXCaddr = URXC0addr
                   .equ UDREaddr = UDRE0addr
                   .endif
                 
                 .equ bm_USART_RXRD = 1 << RXC0
                 .equ bm_USART_TXRD = 1 << UDRE0
                 .equ bm_ENABLE_TX  = 1 << TXEN0
                 .equ bm_ENABLE_RX  = 1 << RXEN0
                 .equ bm_ENABLE_INT_RX = 1<<RXCIE0
                 .equ bm_ENABLE_INT_TX = 1<<UDRIE0
                 
                 .equ bm_USARTC_en   = 0
                 .equ bm_ASYNC       = 0 << 6
                 .equ bm_SYNC        = 1 << 6
                 .equ bm_NO_PARITY   = 0 << 4
                 .equ bm_EVEN_PARITY = 2 << 4
                 .equ bm_ODD_PARITY  = 3 << 4
                 .equ bm_1STOPBIT    = 0 << 3
                 .equ bm_2STOPBIT    = 1 << 3
                 .equ bm_5BIT        = 0 << 1
                 .equ bm_6BIT        = 1 << 1
                 .equ bm_7BIT        = 2 << 1
                 .equ bm_8BIT        = 3 << 1
                 
                 .include "drivers/usart_common.asm"
                 
                 .set USART_C_VALUE = bm_ASYNC | bm_NO_PARITY | bm_1STOPBIT | bm_8BIT
                 .if WANT_ISR_RX == 1
                   .set USART_B_VALUE = bm_ENABLE_TX | bm_ENABLE_RX | bm_ENABLE_INT_RX
                   .include "drivers/usart-isr-rx.asm"
                 
                 
                 ; sizes have to be powers of 2!
                 .equ usart_rx_size = $10
                 .equ usart_rx_mask = usart_rx_size - 1
                 .dseg
000100           usart_rx_data: .byte usart_rx_size+2
000112           usart_rx_in: .byte 2
000114           usart_rx_out: .byte 2
                 
                 .cseg
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 ; forth code:
                 ; : rx-isr USART_DATA c@
                 ;    usart_rx_data usart_rx_in c@ dup >r
                 ;    + !
                 ;    r> 1+ usart_rx_mask and usart_rx_in c!
                 ; ;
                 ; setup with
                 ; ' rx-isr URXCaddr int!
                 usart_rx_isr:
000050 93af        push xl
000051 b7af        in xl, SREG
000052 93af        push xl
000053 93bf        push xh
000054 93ef        push zl
000055 93ff        push zh
                 
000056 91b0 00c6   lds xh, USART_DATA
                 usart_rx_store:
000058 91a0 0112   lds xl, usart_rx_in
00005a e0e0        ldi zl, low(usart_rx_data)
00005b e0f1        ldi zh, high(usart_rx_data)
00005c 0fea        add zl, xl
00005d 1df3        adc zh, zeroh
00005e 83b0        st Z, xh
                 
00005f 95a3        inc xl
000060 70af        andi xl,usart_rx_mask
                 
000061 93a0 0112   sts usart_rx_in, xl
                 
                 usart_rx_isr_finish:
000063 91ff        pop zh
000064 91ef        pop zl
000065 91bf        pop xh
000066 91af        pop xl
000067 bfaf        out SREG, xl
000068 91af        pop xl
000069 9518        reti
                 
                 .set usartpc = pc
                 .org URXCaddr
000028 c027        jmp_ usart_rx_isr
                 .org usartpc
                 
                 
                 ; ( -- ) Hardware Access
                 ; R( --)
                 ; initialize usart
                 ;VE_USART_INIT_RX:
                 ;  .dw $ff06
                 ;  .db "+usart"
                 ;  .dw VE_HEAD
                 ;  .set VE_HEAD = VE_USART_INIT_RX
                 XT_USART_INIT_RX_ISR:
00006a f001        .dw DO_COLON
                 PFA_USART_INIT_RX_ISR:          ; ( -- )
00006b f161        .dw XT_ZERO
00006c f041        .dw XT_DOLITERAL
00006d 0112        .dw usart_rx_in
00006e f09a        .dw XT_CSTORE
00006f f161        .dw XT_ZERO
000070 f041        .dw XT_DOLITERAL
000071 0114        .dw usart_rx_out
000072 f09a        .dw XT_CSTORE
                 
000073 f021        .dw XT_EXIT
                 
                 ; ( -- c)
                 ; MCU
                 ; get 1 character from input queue, wait if needed using interrupt driver
                 VE_RX_ISR:
000074 ff06          .dw $ff06
000075 7872
000076 692d
000077 7273          .db "rx-isr"
000078 0000          .dw VE_HEAD
                     .set VE_HEAD = VE_RX_ISR
                 XT_RX_ISR:
000079 f001          .dw DO_COLON
                 PFA_RX_ISR:
00007a 0093        .dw XT_RXQ_ISR
00007b f03a        .dw XT_DOCONDBRANCH
00007c 007a        .dw PFA_RX_ISR
00007d f041        .dw XT_DOLITERAL
00007e 0114        .dw usart_rx_out
00007f f0a5        .dw XT_CFETCH
000080 f0be        .dw XT_DUP
000081 f23c        .dw XT_1PLUS
000082 f041        .dw XT_DOLITERAL
000083 000f        .dw usart_rx_mask
000084 f220        .dw XT_AND
000085 f041        .dw XT_DOLITERAL
000086 0114        .dw usart_rx_out
000087 f09a        .dw XT_CSTORE
000088 f041        .dw XT_DOLITERAL
000089 0100        .dw usart_rx_data
00008a f1aa        .dw XT_PLUS
00008b f0a5        .dw XT_CFETCH
00008c f021        .dw XT_EXIT
                 
                 ; ( -- f)  
                 ; MCU
                 ; check if unread characters are in the input queue using interrupt driver
                 VE_RXQ_ISR:
00008d ff07          .dw $ff07
00008e 7872
00008f 2d3f
000090 7369
000091 0072          .db "rx?-isr",0
000092 0074          .dw VE_HEAD
                     .set VE_HEAD = VE_RXQ_ISR
                 XT_RXQ_ISR:
000093 f001          .dw DO_COLON
                 PFA_RXQ_ISR:
000094 fa57        .dw XT_PAUSE
000095 f041        .dw XT_DOLITERAL
000096 0114        .dw usart_rx_out
000097 f0a5        .dw XT_CFETCH
000098 f041        .dw XT_DOLITERAL
000099 0112        .dw usart_rx_in
00009a f0a5        .dw XT_CFETCH
00009b f120        .dw XT_NOTEQUAL
00009c f021        .dw XT_EXIT
                   .set XT_RX  = XT_RX_ISR
                   .set XT_RXQ = XT_RXQ_ISR
                   .set XT_USART_INIT_RX = XT_USART_INIT_RX_ISR
                 .else
                 .endif
                 
                 .include "words/usart-tx-poll.asm"
                 
                 ; MCU
                 ; check availability and send one character to the terminal using register poll
                 VE_TX_POLL:
00009d ff07          .dw $ff07
00009e 7874
00009f 702d
0000a0 6c6f
0000a1 006c          .db "tx-poll",0
0000a2 008d          .dw VE_HEAD
                     .set VE_HEAD = VE_TX_POLL
                 XT_TX_POLL:
0000a3 f001          .dw DO_COLON
                 PFA_TX_POLL:
                   ; wait for data ready
0000a4 00b1        .dw XT_TXQ_POLL
0000a5 f03a        .dw XT_DOCONDBRANCH
0000a6 00a4        .dw PFA_TX_POLL
                   ; send to usart
0000a7 f041        .dw XT_DOLITERAL
0000a8 00c6        .dw USART_DATA
0000a9 f09a        .dw XT_CSTORE
0000aa f021        .dw XT_EXIT
                 
                 ; ( -- f) MCU
                 ; MCU
                 ; check if a character can be send using register poll
                 VE_TXQ_POLL:
0000ab ff08          .dw $ff08
0000ac 7874
0000ad 2d3f
0000ae 6f70
0000af 6c6c          .db "tx?-poll"
0000b0 009d          .dw VE_HEAD
                     .set VE_HEAD = VE_TXQ_POLL
                 XT_TXQ_POLL:
0000b1 f001          .dw DO_COLON
                 PFA_TXQ_POLL:
0000b2 fa57        .dw XT_PAUSE
0000b3 f041        .dw XT_DOLITERAL
0000b4 00c0        .dw USART_A
0000b5 f0a5        .dw XT_CFETCH
0000b6 f041        .dw XT_DOLITERAL
0000b7 0020        .dw bm_USART_TXRD
0000b8 f220        .dw XT_AND
0000b9 f021        .dw XT_EXIT
                 .set XT_TX  = XT_TX_POLL
                 .set XT_TXQ = XT_TXQ_POLL
                 .set XT_USART_INIT_TX = 0
                 
                 .include "words/ubrr.asm"
                 
                 ; MCU
                 ; returns usart UBRR settings
                 VE_UBRR:
0000ba ff04        .dw $ff04
0000bb 6275
0000bc 7272        .db "ubrr"
0000bd 00ab        .dw VE_HEAD
                   .set VE_HEAD = VE_UBRR
                 XT_UBRR:
0000be f07c        .dw PFA_DOVALUE1
                 PFA_UBRR:          ; ( -- )
0000bf 0098        .dw EE_UBRRVAL
0000c0 fbc2        .dw XT_EDEFERFETCH
0000c1 fbcc        .dw XT_EDEFERSTORE
                 .include "words/usart.asm"
                 
                 ; MCU
                 ; initialize usart
                 VE_USART:
0000c2 ff06        .dw $ff06
0000c3 752b
0000c4 6173
0000c5 7472        .db "+usart"
0000c6 00ba        .dw VE_HEAD
                   .set VE_HEAD = VE_USART
                 XT_USART:
0000c7 f001        .dw DO_COLON
                 PFA_USART:          ; ( -- )
                 
0000c8 f041        .dw XT_DOLITERAL
0000c9 0098        .dw USART_B_VALUE
0000ca f041        .dw XT_DOLITERAL
0000cb 00c1        .dw USART_B
0000cc f09a        .dw XT_CSTORE
                 
0000cd f041        .dw XT_DOLITERAL
0000ce 0006        .dw USART_C_VALUE
0000cf f041        .dw XT_DOLITERAL
0000d0 00c2        .dw USART_C | bm_USARTC_en
0000d1 f09a        .dw XT_CSTORE
                 
0000d2 00be        .dw XT_UBRR
0000d3 f0be        .dw XT_DUP
0000d4 f2fa        .dw XT_BYTESWAP
0000d5 f041        .dw XT_DOLITERAL
0000d6 00c5        .dw BAUDRATE_HIGH
0000d7 f09a        .dw XT_CSTORE
0000d8 f041        .dw XT_DOLITERAL
0000d9 00c4        .dw BAUDRATE_LOW
0000da f09a        .dw XT_CSTORE
                 .if XT_USART_INIT_RX!=0
0000db 006a        .dw XT_USART_INIT_RX
                 .endif
                 .if XT_USART_INIT_TX!=0
                 .endif
                 
0000dc f021        .dw XT_EXIT
                 
                 ; settings for 1wire interface
                 .equ OW_PORT=PORTB
                 .EQU OW_BIT=4
                 .include "drivers/1wire.asm"
                 
                 ;   B. J. Rodriguez (MSP 430)
                 ;   Matthias Trute (AVR Atmega)
                 ; COPYRIGHT
                 ;   (c) 2012 Bradford J. Rodriguez for the 430 code and API
                 
                 ;  adapted 430 assembly code to AVR
                 ;  wishlist: 
                 ;     use a configurable pin at runtime, compatible with bitnames.frt
                 ;     no external pull up, no external power supply for devices
                 ;     ???
                 ;
                 ;.EQU OW_BIT=4
                 ;.equ OW_PORT=PORTE
                 .set OW_DDR=(OW_PORT-1)
                 .set OW_PIN=(OW_DDR-1)
                 
                 ;****f* 1W.RESET
                 ; NAME
                 ;   1W.RESET
                 ; SYNOPSIS
                 ;   1W.RESET ( -- f )  Initialize 1-wire devices; return true if present
                 ; DESCRIPTION
                 ;   This configures the port pin used by the 1-wire interface, and then
                 ;   sends an "initialize" sequence to the 1-wire devices.  If any device
                 ;   is present, it will be detected.
                 ;
                 ;   Timing, per DS18B20 data sheet:
                 ;   a) Output "0" (drive output low) for >480 usec.
                 ;   b) Output "1" (let output float).
                 ;   c) After 15 to 60 usec, device will drive pin low for 60 to 240 usec.
                 ;      So, wait 75 usec and sample input.
                 ;   d) Leave output high (floating) for at least 480 usec.
                 ;******
                 ; ( -- f )
                 ; Hardware
                 ; Initialize 1-wire devices; return true if present
                 VE_OW_RESET:
0000dd ff08          .dw $ff08
0000de 7731
0000df 722e
0000e0 7365
0000e1 7465          .db "1w.reset"
0000e2 00c2          .dw VE_HEAD
                     .set VE_HEAD = VE_OW_RESET
                 XT_OW_RESET:
0000e3 00e4          .dw PFA_OW_RESET
                 PFA_OW_RESET:
0000e4 939a
0000e5 938a          savetos
0000e6 2799          clr tosh
                     ; setup to output
0000e7 9a24          sbi OW_DDR, OW_BIT
                     ; Pull output low
0000e8 982c          cbi OW_PORT, OW_BIT
                     ; Delay >480 usec        
0000e9 e8e0
0000ea e0f7
0000eb 9731
0000ec f7f1          DELAY   480
                     ; Critical timing period, disable interrupts.
0000ed b71f          in temp1, SREG
0000ee 94f8          cli
                     ; Pull output high
0000ef 9a2c          sbi OW_PORT, OW_BIT
                     ; make pin input, sends "1"
0000f0 9824          cbi OW_DDR, OW_BIT 
0000f1 e0e0
0000f2 e0f1
0000f3 9731
0000f4 f7f1          DELAY   64 ; delayB
                     ; Sample input pin, set TOS if input is zero
0000f5 b183          in tosl, OW_PIN
0000f6 ff84          sbrs tosl, OW_BIT
0000f7 ef9f          ser  tosh
                     ; End critical timing period, enable interrupts
0000f8 bf1f          out SREG, temp1
                     ; release bus
0000f9 9824          cbi OW_DDR, OW_BIT
0000fa 982c          cbi OW_PORT, OW_BIT
                 
                     ; Delay rest of 480 usec 
0000fb e8e0
0000fc e0f6
0000fd 9731
0000fe f7f1          DELAY   416
                     ; we now have the result flag in TOS        
0000ff 2f89          mov tosl, tosh
000100 940c f005     jmp_ DO_NEXT
                     
                 ;****f* 1W.SLOT
                 ; NAME
                 ;   1W.SLOT
                 ; SYNOPSIS
                 ;   1W.SLOT ( c -- c' ) Write and read one bit to/from 1-wire.
                 ; DESCRIPTION
                 ;   The "touch byte" function is described in Dallas App Note 74.
                 ;   It outputs a byte to the 1-wire pin, LSB first, and reads back
                 ;   the state of the 1-wire pin after a suitable delay.
                 ;   To read a byte, output $FF and read the reply data.
                 ;   To write a byte, output that byte and discard the reply.
                 ;
                 ;   This function performs one bit of the "touch" operation --
                 ;   one read/write "slot" in Dallas jargon.  Perform this eight
                 ;   times in a row to get the "touch byte" function.
                 ;
                 ; PARAMETERS
                 ;   The input parameter is xxxxxxxxbbbbbbbo where
                 ;   'xxxxxxxx' are don't cares,
                 ;   'bbbbbbb' are bits to be shifted down, and
                 ;   'o' is the bit to be output in the slot.  This must be 1
                 ;   to create a read slot.
                 ;
                 ;   The returned value is xxxxxxxxibbbbbbb where
                 ;   'xxxxxxxx' are not known (the input shifted down 1 position),
                 ;   'i' is the bit read during the slot.  This has no meaning
                 ;   if it was a write slot.
                 ;   'bbbbbbb' are the 7 input bits, shifted down one position.
                 ;
                 ;   This peculiar parameter usage allows OWTOUCH to be written as
                 ;     OWSLOT OWSLOT OWSLOT OWSLOT OWSLOT OWSLOT OWSLOT OWSLOT 
                 ;
                 ; NOTES 
                 ;   Interrupts are disabled during each bit.
                 
                 ;   Timing, per DS18B20 data sheet:
                 ;   a) Output "0" for start period.  (> 1 us, < 15 us, typ. 6 us*)
                 ;   b) Output data bit (0 or 1), open drain 
                 ;   c) After MS from start of cycle, sample input (15 to 60 us, typ. 25 us*)
                 ;   d) After write-0 period from start of cycle, output "1" (>60 us)
                 ;   e) After recovery period, loop or return. (> 1 us)
                 ;   For writes, DS18B20 samples input 15 to 60 usec from start of cycle.
                 ;   * "Typical" values are per App Note 132 for a 300m cable length.
                 
                 ;   ---------        -------------------------------
                 ;            \      /                        /
                 ;             ------------------------------- 
                 ;            a      b          c             d     e
                 ;            |  6us |   19us   |    35us     | 2us |
                 ;******
                 ; ( c -- c' )
                 ; Hardware
                 ; Write and read one bit to/from 1-wire.
                 VE_OW_SLOT:
000102 ff07          .dw $ff07
000103 7731
000104 732e
000105 6f6c
000106 0074          .db "1w.slot",0
000107 00dd          .dw VE_HEAD
                     .set VE_HEAD = VE_OW_SLOT
                 XT_OW_SLOT:
000108 0109          .dw PFA_OW_SLOT
                 PFA_OW_SLOT:
                     ; pull low
000109 9a24          sbi OW_DDR, OW_BIT
00010a 982c          cbi OW_PORT, OW_BIT
                     ; disable interrupts
00010b b71f          in temp1, SREG
00010c 94f8          cli
00010d e1e8
00010e e0f0
00010f 9731
000110 f7f1          DELAY   6 ; DELAY A
                     ; check bit
000111 9488          clc
000112 9587          ror tosl
000113 f410          brcc PFA_OW_SLOT0 ; a 0 keeps the bus low
                       ; release bus, a 1 is written
000114 9824            cbi OW_DDR, OW_BIT
000115 9a2c            sbi OW_PORT, OW_BIT
                 PFA_OW_SLOT0:
                     ; sample the input (no action required if zero)
000116 e2e4
000117 e0f0
000118 9731
000119 f7f1          DELAY 9   ; wait DELAY E to sample
00011a b103          in temp0, OW_PIN
00011b fd04          sbrc temp0, OW_BIT
00011c 6880          ori tosl, $80
                 
00011d ecec
00011e e0f0
00011f 9731
000120 f7f1          DELAY   51 ; DELAY B
000121 9824          cbi OW_DDR, OW_BIT
000122 9a2c          sbi OW_PORT, OW_BIT ; release bus
000123 e0e8
000124 e0f0
000125 9731
000126 f7f1          delay 2
                     ; re-enable interrupts
000127 bf1f          out SREG, temp1
000128 940c f005     jmp_ DO_NEXT
                 
                 .include "amforth.asm"
                 
                 ;;;;
                 ;;;; GPL V2 (only)
                 
                 .set AMFORTH_NRWW_SIZE=(FLASHEND-AMFORTH_RO_SEG)*2
                 
                 .set corepc = pc
                 .org $0000
000000 940c fa60   jmp_ PFA_COLD
                 
                 .org corepc
                 .include "drivers/generic-isr.asm"
                 
                 .dseg
000116           intcur: .byte 1
                 .eseg
000000           intvec: .byte INTVECTORS * CELLSIZE
                 .cseg
                 
                 ; interrupt routine gets called (again) by rcall! This gives the
                 ; address of the int-vector on the stack.
                 isr:
00012a 920a          st -Y, r0
00012b b60f          in r0, SREG
00012c 920a          st -Y, r0
                 .if (pclen==3)
                 .endif
00012d 900f          pop r0
00012e 900f          pop r0          ; = intnum * intvectorsize + 1 (address following the rcall)
00012f 940a          dec r0
                 .if intvecsize == 1 ;
                 .endif
000130 9200 0116     sts intcur, r0
000132 9009          ld r0, Y+
000133 be0f          out SREG, r0
000134 9009          ld r0, Y+
000135 9468          set ; set the interrupt flag for the inner interpreter
000136 9508          ret ; returns the interrupt, the rcall stack frame is removed!
                 
                 ; lower part of the dictionary
                 .include "dict/rww.inc"
                 
                 
                 ; Arithmetics
                 ; add a number to a double cell
                 VE_MPLUS:
000137 ff02          .dw $ff02
000138 2b6d          .db "m+"
000139 0102          .dw VE_HEAD
                     .set VE_HEAD = VE_MPLUS
                 XT_MPLUS:
00013a f001          .dw DO_COLON
                 PFA_MPLUS:
00013b fd71          .dw XT_S2D
00013c f420          .dw XT_DPLUS
00013d f021          .dw XT_EXIT
                 .include "words/ud-star.asm"
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_UDSTAR:
00013e ff03          .dw $ff03
00013f 6475
../../common\words/ud-star.asm(9): warning: .cseg .db misalignment - padding zero byte
000140 002a          .db "ud*"
000141 0137          .dw VE_HEAD
                     .set VE_HEAD = VE_UDSTAR
                 XT_UDSTAR:
000142 f001          .dw DO_COLON
                 PFA_UDSTAR:
                 
                 .endif
                 ;Z UD*      ud1 d2 -- ud3      32*16->32 multiply
                 ;   XT_DUP >R UM* DROP  XT_SWAP R> UM* ROT + ;
                 
000143 f0be
000144 f10c
000145 f1ed
000146 f0e6              .DW XT_DUP,XT_TO_R,XT_UMSTAR,XT_DROP
000147 f0d1
000148 f103
000149 f1ed
00014a f0ee
00014b f1aa
00014c f021              .DW XT_SWAP,XT_R_FROM,XT_UMSTAR,XT_ROT,XT_PLUS,XT_EXIT
                 .include "words/umax.asm"
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_UMAX:
00014d ff04          .dw $ff04
00014e 6d75
00014f 7861          .db "umax"
000150 013e          .dw VE_HEAD
                     .set VE_HEAD = VE_UMAX
                 XT_UMAX:
000151 f001          .dw DO_COLON
                 PFA_UMAX:
                 .endif
                 
000152 f580
000153 f169              .DW XT_2DUP,XT_ULESS
000154 f03a      	.dw XT_DOCONDBRANCH
000155 0157      	 DEST(UMAX1)
000156 f0d1              .DW XT_SWAP
000157 f0e6      UMAX1:  .DW XT_DROP
000158 f021      	.dw XT_EXIT
                 .include "words/umin.asm"
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_UMIN:
000159 ff04          .dw $ff04
00015a 6d75
00015b 6e69          .db "umin"
00015c 014d          .dw VE_HEAD
                     .set VE_HEAD = VE_UMIN
                 XT_UMIN:
00015d f001          .dw DO_COLON
                 PFA_UMIN:
                 .endif
00015e f580
00015f f174              .DW XT_2DUP,XT_UGREATER
000160 f03a      	.dw XT_DOCONDBRANCH
000161 0163      	DEST(UMIN1)
000162 f0d1              .DW XT_SWAP
000163 f0e6      UMIN1:  .DW XT_DROP
000164 f021      	.dw XT_EXIT
                 .include "words/immediate-q.asm"
                 
                 ; Tools
                 ; get count information out of a counted string in flash
                 ;VE_IMMEDIATEQ:
                 ;    .dw $ff06
                 ;    .db "immediate?"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_IMMEDIATEQ
                 XT_IMMEDIATEQ:
000165 f001          .dw DO_COLON
                 PFA_IMMEDIATEQ:
000166 f041          .dw XT_DOLITERAL
000167 8000          .dw $8000
000168 f220          .dw XT_AND
000169 f127          .dw XT_ZEROEQUAL
00016a f03a          .dw XT_DOCONDBRANCH
00016b 016f          DEST(IMMEDIATEQ1)
00016c f041           .dw XT_DOLITERAL
00016d 0001           .dw 1
00016e f021           .dw XT_EXIT
                 IMMEDIATEQ1:
                     ; not immediate
00016f f158          .dw XT_TRUE
000170 f021          .dw XT_EXIT
                 .include "words/name2flags.asm"
                 
                 ; Tools
                 ; get the flags from a name token
                 VE_NAME2FLAGS:
000171 ff0a          .dw $ff0a
000172 616e
000173 656d
000174 663e
000175 616c
000176 7367          .db "name>flags"
000177 0159          .dw VE_HEAD
                     .set VE_HEAD = VE_NAME2FLAGS
                 XT_NAME2FLAGS:
000178 f001          .dw DO_COLON
                 PFA_NAME2FLAGS:
000179 f3d3          .dw XT_FETCHI ; skip to link field
00017a f041          .dw XT_DOLITERAL
00017b ff00          .dw $ff00
00017c f220          .dw XT_AND
00017d f021          .dw XT_EXIT
                 .include "words/name2interpret.asm"
                 
                 ; Tools (ext)
                 ; get the execution token from the name token
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_NAME2INTERPRET:
00017e ff0e          .dw $ff0e
00017f 616e
000180 656d
000181 693e
000182 746e
000183 7265
000184 7270
000185 7465          .db "name>interpret"
000186 0171          .dw VE_HEAD
                     .set VE_HEAD = VE_NAME2INTERPRET
                 XT_NAME2INTERPRET:
000187 f001          .dw DO_COLON
                 PFA_NAME2INTERPRET:
                 .endif
000188 fc8c          .dw XT_NFA2CFA
000189 f021          .dw XT_EXIT
                 .include "words/name2compile.asm"
                 
                 ; Tools (ext)
                 ; get the execution token from the name token in compile state
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_NAME2COMPILE:
00018a ff0c          .dw $ff0c
00018b 616e
00018c 656d
00018d 633e
00018e 6d6f
00018f 6970
000190 656c          .db "name>compile"
000191 017e          .dw VE_HEAD
                     .set VE_HEAD = VE_NAME2COMPILE
                 XT_NAME2COMPILE:
000192 f001          .dw DO_COLON
                 PFA_NAME2COMPILE:
                 .endif
000193 f0be          .dw XT_DUP
000194 fc8c          .dw XT_NFA2CFA
000195 f0d1          .dw XT_SWAP
000196 0178          .dw XT_NAME2FLAGS
000197 0165          .dw XT_IMMEDIATEQ
000198 f03a          .dw XT_DOCONDBRANCH
000199 019d          DEST(NAME2COMPILE1)
00019a f041      	.dw XT_DOLITERAL
00019b 01d7      	.dw XT_COMMA
00019c f021      	.dw XT_EXIT
                 NAME2COMPILE1:
00019d f041      	.dw XT_DOLITERAL
00019e f02b      	.dw XT_EXECUTE
00019f f021          .dw XT_EXIT
                 
                 .if AMFORTH_NRWW_SIZE > 8000
                 .include "dict/appl_8k.inc"
                 
                 
                 .include "words/docreate.asm"
                 
                 ; Compiler
                 ; parse the input and create an empty vocabulary entry without XT and data field (PF)
                 VE_DOCREATE:
0001a0 ff08          .dw $ff08
0001a1 6328
0001a2 6572
0001a3 7461
0001a4 2965          .db "(create)"
0001a5 018a          .dw VE_HEAD
                     .set VE_HEAD = VE_DOCREATE
                 XT_DOCREATE:
0001a6 f001          .dw DO_COLON
                 PFA_DOCREATE:
0001a7 f9d2          .dw XT_PARSENAME
0001a8 0301          .dw XT_WLSCOPE
0001a9 f0be          .dw XT_DUP
0001aa f10c          .dw XT_TO_R
0001ab 02e6          .dw XT_HEADER
0001ac f103          .dw XT_R_FROM
                 .dseg
000117           COLON_SMUDGE: .byte 4
                 .cseg
0001ad f041          .dw XT_DOLITERAL
0001ae 0119          .dw COLON_SMUDGE+2
0001af f08e          .dw XT_STORE		; save wid
0001b0 f041          .dw XT_DOLITERAL
0001b1 0117          .dw COLON_SMUDGE+0
0001b2 f08e          .dw XT_STORE		; save NFA
                 
0001b3 f021          .dw XT_EXIT
                 .include "words/backslash.asm"
                 
                 ; Compiler
                 ; everything up to the end of the current line is a comment
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_BACKSLASH:
0001b4 0001          .dw $0001
0001b5 005c          .db $5c,0
0001b6 01a0          .dw VE_HEAD
                     .set VE_HEAD = VE_BACKSLASH
                 XT_BACKSLASH:
0001b7 f001          .dw DO_COLON
                 PFA_BACKSLASH:
                 .endif
0001b8 f9b9          .dw XT_SOURCE
0001b9 f0fd          .dw XT_NIP
0001ba f599          .dw XT_TO_IN
0001bb f08e          .dw XT_STORE
0001bc f021          .dw XT_EXIT
                 .include "words/l-paren.asm"
                 
                 ; Compiler
                 ; skip everything up to the closing bracket on the same line
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_LPAREN:
0001bd 0001          .dw $0001
0001be 0028          .db "(" ,0
0001bf 01b4          .dw VE_HEAD
                     .set VE_HEAD = VE_LPAREN
                 XT_LPAREN:
0001c0 f001          .dw DO_COLON
                 PFA_LPAREN:
                 .endif
0001c1 f041          .dw XT_DOLITERAL
0001c2 0029          .dw ')'
0001c3 f9a4          .dw XT_PARSE
0001c4 f589          .dw XT_2DROP
0001c5 f021          .dw XT_EXIT
                 
                 .include "words/compile.asm"
                 
                 ; Dictionary
                 ; read the following cell from the dictionary and append it to the current dictionary position.
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_COMPILE:
0001c6 ff07          .dw $ff07
0001c7 6f63
0001c8 706d
0001c9 6c69
0001ca 0065          .db "compile",0
0001cb 01bd          .dw  VE_HEAD
                     .set VE_HEAD = VE_COMPILE
                 XT_COMPILE:
0001cc f001          .dw DO_COLON
                 PFA_COMPILE:
                 .endif
0001cd f103          .dw XT_R_FROM
0001ce f0be          .dw XT_DUP
0001cf fbb9          .dw XT_ICELLPLUS
0001d0 f10c          .dw XT_TO_R
0001d1 f3d3          .dw XT_FETCHI
0001d2 01d7          .dw XT_COMMA
0001d3 f021          .dw XT_EXIT
                 .include "words/comma.asm"
                 
                 ; Dictionary
                 ; compile 16 bit into flash at DP
                 VE_COMMA:
0001d4 ff01          .dw $ff01
0001d5 002c          .db ',',0 ; ,
0001d6 01c6          .dw VE_HEAD
                     .set VE_HEAD = VE_COMMA
                 XT_COMMA:
0001d7 f001          .dw DO_COLON
                 PFA_COMMA:
0001d8 f5cf          .dw XT_DP
0001d9 f374          .dw XT_STOREI
0001da f5cf          .dw XT_DP
0001db f23c          .dw XT_1PLUS
0001dc fba7          .dw XT_DOTO
0001dd f5d0          .dw PFA_DP
0001de f021          .dw XT_EXIT
                 .include "words/brackettick.asm"
                 
                 ; Compiler
                 ; what ' does in the interpreter mode, do in colon definitions
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_BRACKETTICK:
0001df 0003          .dw $0003
0001e0 275b
0001e1 005d          .db "[']",0
0001e2 01d4          .dw VE_HEAD
                     .set VE_HEAD = VE_BRACKETTICK
                 XT_BRACKETTICK:
0001e3 f001          .dw DO_COLON
                 PFA_BRACKETTICK:
                 .endif
0001e4 f82f          .dw XT_TICK
0001e5 01ed          .dw XT_LITERAL
0001e6 f021          .dw XT_EXIT
                 
                 
                 .include "words/literal.asm"
                 
                 ; Compiler
                 ; compile a literal in colon defintions
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_LITERAL:
0001e7 0007          .dw $0007
0001e8 696c
0001e9 6574
0001ea 6172
0001eb 006c          .db "literal",0
0001ec 01df          .dw VE_HEAD
                     .set VE_HEAD = VE_LITERAL
                 XT_LITERAL:
0001ed f001          .dw DO_COLON
                 PFA_LITERAL:
                 .endif
0001ee 01cc              .DW XT_COMPILE
0001ef f041              .DW XT_DOLITERAL
0001f0 01d7              .DW XT_COMMA
0001f1 f021              .DW XT_EXIT
                 .include "words/sliteral.asm"
                 
                 ; String
                 ; compiles a string to flash, at runtime leaves ( -- flash-addr count) on stack
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SLITERAL:
0001f2 0008        .dw $0008
0001f3 6c73
0001f4 7469
0001f5 7265
0001f6 6c61        .db "sliteral"
0001f7 01e7        .dw VE_HEAD
                   .set VE_HEAD = VE_SLITERAL
                 XT_SLITERAL:
0001f8 f001          .dw DO_COLON
                 PFA_SLITERAL:
                 .endif
0001f9 01cc          .dw XT_COMPILE
0001fa f792          .dw XT_DOSLITERAL    ; ( -- addr n)
0001fb f7a0          .dw XT_SCOMMA
0001fc f021          .dw XT_EXIT
                 .include "words/g-mark.asm"
                 
                 ; Compiler
                 ; places current dictionary position for backward resolves
                 ;VE_GMARK:
                 ;    .dw $ff05
                 ;    .db ">mark"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_GMARK
                 XT_GMARK:
0001fd f001          .dw DO_COLON
                 PFA_GMARK:
0001fe f5cf          .dw XT_DP
0001ff 01cc          .dw XT_COMPILE
000200 ffff          .dw -1           ; ffff does not erase flash
000201 f021          .dw XT_EXIT
                 .include "words/g-resolve.asm"
                 
                 ; Compiler
                 ; resolve backward jumps
                 ;VE_GRESOLVE:
                 ;    .dw $ff08
                 ;    .db ">resolve"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_GRESOLVE
                 XT_GRESOLVE:
000202 f001          .dw DO_COLON
                 PFA_GRESOLVE:
000203 fb64          .dw XT_QSTACK
000204 f5cf          .dw XT_DP
000205 f0d1          .dw XT_SWAP
000206 f374          .dw XT_STOREI
000207 f021          .dw XT_EXIT
                 .include "words/l_mark.asm"
                 
                 ; Compiler
                 ; place destination for backward branch
                 ;VE_LMARK:
                 ;    .dw $ff05
                 ;    .db "<mark"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_LMARK
                 XT_LMARK:
000208 f001          .dw DO_COLON
                 PFA_LMARK:
000209 f5cf          .dw XT_DP
00020a f021          .dw XT_EXIT
                 .include "words/l_resolve.asm"
                 
                 ; Compiler
                 ; resolve backward branch
                 ;VE_LRESOLVE:
                 ;    .dw $ff08
                 ;    .db "<resolve"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_LRESOLVE
                 XT_LRESOLVE:
00020b f001          .dw DO_COLON
                 PFA_LRESOLVE:
00020c fb64          .dw XT_QSTACK
00020d 01d7          .dw XT_COMMA
00020e f021          .dw XT_EXIT
                 
                 .include "words/ahead.asm"
                 
                 ; Compiler
                 ; do a unconditional branch
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_AHEAD:
00020f 0005          .dw $0005
000210 6861
000211 6165
000212 0064          .db "ahead",0
000213 01f2          .dw VE_HEAD
                     .set VE_HEAD = VE_AHEAD
                 XT_AHEAD:
000214 f001          .dw DO_COLON
                 PFA_AHEAD:
                 .endif
000215 01cc          .dw XT_COMPILE
000216 f030          .dw XT_DOBRANCH
000217 01fd          .dw XT_GMARK
000218 f021          .dw XT_EXIT
                 .include "words/if.asm"
                 
                 ; Compiler
                 ; start conditional branch
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_IF:
000219 0002          .dw $0002
00021a 6669          .db "if"
00021b 020f          .dw VE_HEAD
                     .set VE_HEAD = VE_IF
                 XT_IF:
00021c f001          .dw DO_COLON
                 PFA_IF:
                 .endif
00021d 01cc          .dw XT_COMPILE
00021e f03a          .dw XT_DOCONDBRANCH
00021f 01fd          .dw XT_GMARK
000220 f021          .dw XT_EXIT
                 .include "words/else.asm"
                 
                 ; Compiler
                 ; resolve the forward reference and place a new unresolved forward reference
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_ELSE:
000221 0004          .dw $0004
000222 6c65
000223 6573          .db "else"
000224 0219          .dw VE_HEAD
                     .set VE_HEAD = VE_ELSE
                 XT_ELSE:
000225 f001          .dw DO_COLON
                 PFA_ELSE:
                 .endif
000226 01cc          .dw XT_COMPILE
000227 f030          .dw XT_DOBRANCH
000228 01fd          .dw XT_GMARK
000229 f0d1          .dw XT_SWAP
00022a 0202          .dw XT_GRESOLVE
00022b f021          .dw XT_EXIT
                 .include "words/then.asm"
                 
                 ; Compiler
                 ; finish if
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_THEN:
00022c 0004          .dw $0004
00022d 6874
00022e 6e65          .db "then"
00022f 0221          .dw VE_HEAD
                     .set VE_HEAD = VE_THEN
                 XT_THEN:
000230 f001          .dw DO_COLON
                 PFA_THEN:
                 .endif
000231 0202          .dw XT_GRESOLVE
000232 f021          .dw XT_EXIT
                 .include "words/begin.asm"
                 
                 ; Compiler
                 ; put the next location for a transfer of control onto the control flow stack
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_BEGIN:
000233 0005          .dw $0005
000234 6562
000235 6967
000236 006e          .db "begin",0
000237 022c          .dw VE_HEAD
                     .set VE_HEAD = VE_BEGIN
                 XT_BEGIN:
000238 f001          .dw DO_COLON
                 PFA_BEGIN:
                 .endif
000239 0208          .dw XT_LMARK
00023a f021          .dw XT_EXIT
                 .include "words/while.asm"
                 
                 ; Compiler
                 ; at runtime skip until repeat if non-true
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_WHILE:
00023b 0005          .dw $0005
00023c 6877
00023d 6c69
00023e 0065          .db "while",0
00023f 0233          .dw VE_HEAD
                     .set VE_HEAD = VE_WHILE
                 XT_WHILE:
000240 f001          .dw DO_COLON
                 PFA_WHILE:
                 .endif
000241 021c          .dw XT_IF
000242 f0d1          .dw XT_SWAP
000243 f021          .dw XT_EXIT
                 .include "words/repeat.asm"
                 
                 ; Compiler
                 ; continue execution at dest, resolve orig
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_REPEAT:
000244 0006          .dw $0006
000245 6572
000246 6570
000247 7461          .db "repeat"
000248 023b          .dw VE_HEAD
                     .set VE_HEAD = VE_REPEAT
                 XT_REPEAT:
000249 f001          .dw DO_COLON
                 PFA_REPEAT:
                 .endif
00024a 025d          .dw XT_AGAIN
00024b 0230          .dw XT_THEN
00024c f021          .dw XT_EXIT
                 .include "words/until.asm"
                 
                 ; Compiler
                 ; finish begin with conditional branch, leaves the loop if true flag at runtime
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_UNTIL:
00024d 0005          .dw $0005
00024e 6e75
00024f 6974
000250 006c          .db "until",0
000251 0244          .dw VE_HEAD
                     .set VE_HEAD = VE_UNTIL
                 XT_UNTIL:
000252 f001          .dw DO_COLON
                 PFA_UNTIL:
                 .endif
000253 f041          .dw XT_DOLITERAL
000254 f03a          .dw XT_DOCONDBRANCH
000255 01d7          .dw XT_COMMA
                 
000256 020b          .dw XT_LRESOLVE
000257 f021          .dw XT_EXIT
                 .include "words/again.asm"
                 
                 ; Compiler
                 ; compile a jump back to dest
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_AGAIN:
000258 0005          .dw $0005
000259 6761
00025a 6961
00025b 006e          .db "again",0
00025c 024d          .dw VE_HEAD
                     .set VE_HEAD = VE_AGAIN
                 XT_AGAIN:
00025d f001          .dw DO_COLON
                 PFA_AGAIN:
                 .endif
00025e 01cc          .dw XT_COMPILE
00025f f030          .dw XT_DOBRANCH
000260 020b          .dw XT_LRESOLVE
000261 f021          .dw XT_EXIT
                 .include "words/do.asm"
                 
                 ; Compiler
                 ; start do .. [+]loop
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DO:
000262 0002          .dw $0002
000263 6f64          .db "do"
000264 0258          .dw VE_HEAD
                     .set VE_HEAD = VE_DO
                 XT_DO:
000265 f001          .dw DO_COLON
                 PFA_DO:
                 
                 .endif
000266 01cc          .dw XT_COMPILE
000267 f29c          .dw XT_DODO
000268 0208          .dw XT_LMARK
000269 f161          .dw XT_ZERO
00026a 02c0          .dw XT_TO_L
00026b f021          .dw XT_EXIT
                 .include "words/loop.asm"
                 
                 ; Compiler
                 ; compile (loop) and resolve the backward branch
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_LOOP:
00026c 0004          .dw $0004
00026d 6f6c
00026e 706f          .db "loop"
00026f 0262          .dw VE_HEAD
                     .set VE_HEAD = VE_LOOP
                 XT_LOOP:
000270 f001          .dw DO_COLON
                 PFA_LOOP:
                 .endif
000271 01cc          .dw XT_COMPILE
000272 f2ca          .dw XT_DOLOOP
000273 02a7          .dw XT_ENDLOOP
000274 f021          .dw XT_EXIT
                 .include "words/plusloop.asm"
                 
                 ; Compiler
                 ; compile (+loop) and resolve branches
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_PLUSLOOP:
000275 0005          .dw $0005
000276 6c2b
000277 6f6f
000278 0070          .db "+loop",0
000279 026c          .dw VE_HEAD
                     .set VE_HEAD = VE_PLUSLOOP
                 XT_PLUSLOOP:
00027a f001          .dw DO_COLON
                 PFA_PLUSLOOP:
                 .endif
00027b 01cc          .dw XT_COMPILE
00027c f2bb          .dw XT_DOPLUSLOOP
00027d 02a7          .dw XT_ENDLOOP
00027e f021          .dw XT_EXIT
                 .include "words/leave.asm"
                 
                 ; Compiler
                 ; immediatly leave the current DO..LOOP
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_LEAVE:
00027f 0005         .dw $0005
000280 656c
000281 7661
000282 0065         .db "leave",0
000283 0275         .dw VE_HEAD
                    .set VE_HEAD = VE_LEAVE
                 XT_LEAVE:
000284 f001          .dw DO_COLON
                 PFA_LEAVE:
                 .endif
000285 01cc
000286 f2d5          .DW XT_COMPILE,XT_UNLOOP
000287 0214
000288 02c0
000289 f021          .DW XT_AHEAD,XT_TO_L,XT_EXIT
                 .include "words/qdo.asm"
                 
                 ; Compiler
                 ; start a ?do .. [+]loop control structure
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 VE_QDO:
00028a 0003          .dw $0003
00028b 643f
00028c 006f          .db "?do",0
00028d 027f          .dw VE_HEAD
                     .set VE_HEAD = VE_QDO
                 XT_QDO:
00028e f001          .dw DO_COLON
                 PFA_QDO:
                 .endif
00028f 01cc          .dw XT_COMPILE
000290 0296          .dw XT_QDOCHECK
000291 021c          .dw XT_IF
000292 0265          .dw XT_DO
000293 f0d1          .dw XT_SWAP    ; DO sets a 0 marker on the leave stack
000294 02c0          .dw XT_TO_L    ; then follows at the end.
000295 f021          .dw XT_EXIT
                 
                 ; there is no special runtime for ?do, the do runtime
                 ; gets wrapped with the sequence
                 ; ... ?do-check if do ..... loop then
                 ; with
                 ; : ?do-check ( n1 n2 -- n1 n2 true | false )
                 ;   2dup = dup >r if 2drop then r> invert ;
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 XT_QDOCHECK:
000296 f001          .dw DO_COLON
                 PFA_QDOCHECK:
                 .endif
000297 f580          .dw XT_2DUP
000298 fd8d          .dw XT_EQUAL
000299 f0be          .dw XT_DUP
00029a f10c          .dw XT_TO_R
00029b f03a          .dw XT_DOCONDBRANCH
00029c 029e          DEST(PFA_QDOCHECK1)
00029d f589          .dw XT_2DROP
                 PFA_QDOCHECK1:
00029e f103          .dw XT_R_FROM
00029f f20a          .dw XT_INVERT
0002a0 f021          .dw XT_EXIT
                 .include "words/endloop.asm"
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_ENDLOOP:
0002a1 ff07          .dw $ff07
0002a2 6e65
0002a3 6c64
0002a4 6f6f
0002a5 0070          .db "endloop",0
0002a6 028a          .dw VE_HEAD
                     .set VE_HEAD = VE_ENDLOOP
                 XT_ENDLOOP:
0002a7 f001          .dw DO_COLON
                 PFA_ENDLOOP:
                 .endif
                 ;Z ENDLOOP   adrs xt --   L: 0 a1 a2 .. aN --
                 ;   <resolve                backward loop
                 ;   BEGIN L> ?DUP WHILE POSTPONE THEN REPEAT ;
                 ;                                 resolve LEAVEs
                 ; This is a common factor of LOOP and +LOOP.
                 
0002a8 020b              .DW XT_LRESOLVE
0002a9 02b4
0002aa f0c6
0002ab f03a      LOOP1:  .DW XT_L_FROM,XT_QDUP,XT_DOCONDBRANCH
0002ac 02b0               DEST(LOOP2)
0002ad 0230              .DW XT_THEN
0002ae f030      	.dw XT_DOBRANCH
0002af 02a9               DEST(LOOP1)
0002b0 f021      LOOP2:  .DW XT_EXIT
                 ; leave address stack
                 .include "words/l-from.asm"
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_L_FROM:
0002b1 ff02          .dw $ff02
0002b2 3e6c          .db "l>"
0002b3 02a1          .dw VE_HEAD
                     .set VE_HEAD = VE_L_FROM
                 XT_L_FROM:
0002b4 f001          .dw DO_COLON
                 PFA_L_FROM:
                 
                 .endif
                 ;Z L>   -- x   L: x --      move from leave stack
                 ;   LP @ @  -2 LP +! ;
                 
0002b5 02d4          .dw XT_LP
0002b6 f086          .dw XT_FETCH
0002b7 f086          .dw XT_FETCH
0002b8 f041          .dw XT_DOLITERAL
0002b9 fffe          .dw -2
0002ba 02d4          .dw XT_LP
0002bb f266          .dw XT_PLUSSTORE
0002bc f021          .dw XT_EXIT
                 .include "words/to-l.asm"
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_TO_L:
0002bd ff02          .dw $ff02
0002be 6c3e          .db ">l"
0002bf 02b1          .dw VE_HEAD
                     .set VE_HEAD = VE_TO_L
                 XT_TO_L:
0002c0 f001          .dw DO_COLON
                 PFA_TO_L:
                 .endif
                 ;Z >L   x --   L: -- x        move to leave stack
                 ;   CELL LP +!  LP @ ! ;      (L stack grows up)
                 
0002c1 f041              .dw XT_DOLITERAL
0002c2 0002      	.dw 2
0002c3 02d4      	.dw XT_LP
0002c4 f266      	.dw XT_PLUSSTORE
0002c5 02d4      	.dw XT_LP
0002c6 f086      	.dw XT_FETCH
0002c7 f08e      	.dw XT_STORE
0002c8 f021      	.dw XT_EXIT
                 .include "words/lp0.asm"
                 
                 ; Stack
                 ; start address of leave stack
                 VE_LP0:
0002c9 ff03          .dw $ff03
0002ca 706c
0002cb 0030          .db "lp0",0
0002cc 02bd          .dw VE_HEAD
                     .set VE_HEAD = VE_LP0
                 XT_LP0:
0002cd f07c          .dw PFA_DOVALUE1
                 PFA_LP0:
0002ce 0078          .dw EE_LP0
0002cf fbc2          .dw XT_EDEFERFETCH
0002d0 fbcc          .dw XT_EDEFERSTORE
                 .include "words/lp.asm"
                 
                 ; System Variable
                 ; leave stack pointer
                 VE_LP:
0002d1 ff02          .dw $ff02
0002d2 706c          .db "lp"
0002d3 02c9          .dw VE_HEAD
                     .set VE_HEAD = VE_LP
                 XT_LP:
0002d4 f04f          .dw PFA_DOVARIABLE
                 PFA_LP:
0002d5 011b          .dw ram_lp
                 
                 .dseg
00011b           ram_lp: .byte 2
                 .cseg
                 
                 
                 .include "words/create.asm"
                 
                 ; Dictionary
                 ; create a dictionary header. XT is (constant), with the address of the data field of name
                 VE_CREATE:
0002d6 ff06          .dw $ff06
0002d7 7263
0002d8 6165
0002d9 6574          .db "create"
0002da 02d1          .dw VE_HEAD
                     .set VE_HEAD = VE_CREATE
                 XT_CREATE:
0002db f001          .dw DO_COLON
                 PFA_CREATE:
0002dc 01a6          .dw XT_DOCREATE
0002dd 030a          .dw XT_REVEAL
0002de 01cc          .dw XT_COMPILE
0002df f05c          .dw PFA_DOCONSTANT
0002e0 f021          .dw XT_EXIT
                 .include "words/header.asm"
                 
                 ; Compiler
                 ; creates the vocabulary header without XT and data field (PF) in the wordlist wid
                 VE_HEADER:
0002e1 ff06          .dw $ff06
0002e2 6568
0002e3 6461
0002e4 7265          .db "header"
0002e5 02d6          .dw VE_HEAD
                     .set VE_HEAD = VE_HEADER
                 XT_HEADER:
0002e6 f001          .dw DO_COLON
                 PFA_HEADER:
0002e7 f5cf          .dw XT_DP           ; the new Name Field
0002e8 f10c          .dw XT_TO_R
0002e9 f10c          .dw XT_TO_R		; ( R: NFA WID )
0002ea f0be          .dw XT_DUP    
0002eb f135          .dw XT_GREATERZERO 
0002ec f03a          .dw XT_DOCONDBRANCH
0002ed 02f8          .dw PFA_HEADER1
0002ee f0be          .dw XT_DUP
0002ef f041          .dw XT_DOLITERAL
0002f0 ff00          .dw $ff00           ; all flags are off (e.g. immediate)
0002f1 f229          .dw XT_OR
0002f2 f7a4          .dw XT_DOSCOMMA
                     ; make the link to the previous entry in this wordlist
0002f3 f103          .dw XT_R_FROM
0002f4 f360          .dw XT_FETCHE
0002f5 01d7          .dw XT_COMMA
0002f6 f103          .dw XT_R_FROM
0002f7 f021          .dw XT_EXIT
                 
                 PFA_HEADER1:
                     ; -16: attempt to use zero length string as a name
0002f8 f041          .dw XT_DOLITERAL
0002f9 fff0          .dw -16
0002fa f85e          .dw XT_THROW
                 
                 .include "words/wlscope.asm"
                 
                 ; Compiler
                 ; dynamically place a word in a wordlist. The word name may be changed.
                 VE_WLSCOPE:
0002fb ff07          .dw $ff07
0002fc 6c77
0002fd 6373
0002fe 706f
0002ff 0065          .db "wlscope",0
000300 02e1          .dw VE_HEAD
                     .set VE_HEAD = VE_WLSCOPE
                 XT_WLSCOPE:
000301 fc21          .dw PFA_DODEFER1
                 PFA_WLSCOPE:
000302 0076          .dw EE_WLSCOPE
000303 fbc2          .dw XT_EDEFERFETCH
000304 fbcc          .dw XT_EDEFERSTORE
                 
                 ; wlscope, "wordlist scope" ( addr len -- addr' len' wid ), is a deferred word
                 ; which enables the AmForth application to choose the wordlist ( wid ) for the
                 ; new voc entry based on the input ( addr len ) string. The name of the new voc
                 ; entry ( addr' len' ) may be different from the input string. Note that all
                 ; created voc entry types pass through the wlscope mechanism. The default
                 ; wlscope action passes the input string to the output without modification and
                 ; uses get-current to select the wid.
                 .include "words/reveal.asm"
                 
                 ; Dictionary
                 ; makes an entry in a wordlist visible, if not already done.
                 VE_REVEAL:
000305 ff06          .dw $ff06
000306 6572
000307 6576
000308 6c61          .db "reveal"
000309 02fb          .dw VE_HEAD
                     .set VE_HEAD = VE_REVEAL
                 XT_REVEAL:
00030a f001          .dw DO_COLON
                 PFA_REVEAL:
00030b f041          .dw XT_DOLITERAL
00030c 0117          .dw COLON_SMUDGE+0
00030d f086          .dw XT_FETCH
00030e f0c6          .dw XT_QDUP
00030f f03a          .dw XT_DOCONDBRANCH
000310 0319          .dw PFA_REVEAL1
                 ;
000311 f041          .dw XT_DOLITERAL
000312 0119          .dw COLON_SMUDGE+2
000313 f086          .dw XT_FETCH		; ( NFA WID )
000314 f33c          .dw XT_STOREE
                     ; prevent duplicate actions and cooperate with :noname
000315 f161          .dw XT_ZERO
000316 f041          .dw XT_DOLITERAL
000317 0117          .dw COLON_SMUDGE+0
000318 f08e          .dw XT_STORE
                 PFA_REVEAL1:
000319 f021          .dw XT_EXIT
                 .include "words/latest.asm"
                 
                 ; System Variable
                 ; system LATEST
                 VE_LATEST:
00031a ff06          .dw $ff06
00031b 616c
00031c 6574
00031d 7473          .db "latest"
00031e 0305          .dw VE_HEAD
                     .set VE_HEAD = VE_LATEST
                 XT_LATEST:
00031f f04f          .dw PFA_DOVARIABLE
                 PFA_LATEST:
000320 011d          .dw ram_LATEST
                 
                 .dseg
00011d           ram_LATEST: .byte 2
                 .cseg
                 .include "words/does.asm"
                 
                 ; Compiler
                 ; organize the XT replacement to call other colon code
                 VE_DOES:
000321 0005          .dw $0005
000322 6f64
000323 7365
000324 003e          .db "does>",0
000325 031a          .dw VE_HEAD
                     .set VE_HEAD = VE_DOES
                 XT_DOES:
000326 f001          .dw DO_COLON
                 PFA_DOES:
000327 01cc          .dw XT_COMPILE
000328 0339          .dw XT_DODOES
000329 01cc          .dw XT_COMPILE  ; create a code snippet to be used in an embedded XT
00032a 940e          .dw $940e       ; the address of this compiled
00032b 01cc          .dw XT_COMPILE  ; code will replace the XT of the 
00032c 032e          .dw DO_DODOES   ; word that CREATE created
00032d f021          .dw XT_EXIT     ; 
                 
                 DO_DODOES: ; ( -- PFA )
00032e 939a
00032f 938a          savetos
000330 01cb          movw tosl, wl
000331 9601          adiw tosl, 1
                     ; the following takes the address from a real uC-call
                 .if (pclen==3)
                 .endif
000332 917f          pop wh
000333 916f          pop wl
                 
000334 93bf          push XH
000335 93af          push XL
000336 01db          movw XL, wl
000337 940c f005     jmp_ DO_NEXT
                 
                 ; ( -- )
                 ; System
                 ; replace the XT written by CREATE to call the code that follows does>
                 ;VE_DODOES:
                 ;   .dw $ff07
                 ;   .db "(does>)"
                 ;   .set VE_HEAD = VE_DODOES
                 XT_DODOES:
000339 f001          .dw DO_COLON
                 PFA_DODOES:
00033a f103          .dw XT_R_FROM
00033b f041          .dw XT_DOLITERAL
00033c 0119          .dw COLON_SMUDGE+2
00033d f086          .dw XT_FETCH
00033e f360          .dw XT_FETCHE
00033f 0487          .dw XT_NFA2LFA
000340 f23c          .dw XT_1PLUS   ; lfa>xt
                 
000341 f374          .dw XT_STOREI
000342 f021          .dw XT_EXIT
                 .include "words/colon.asm"
                 
                 ; Compiler
                 ; create a named entry in the dictionary, XT is DO_COLON
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_COLON:
000343 ff01          .dw $ff01
000344 003a          .db ":",0
000345 0321          .dw VE_HEAD
                     .set VE_HEAD = VE_COLON
                 XT_COLON:
000346 f001          .dw DO_COLON
                 PFA_COLON:
                 .endif
000347 01a6          .dw XT_DOCREATE
000348 0351          .dw XT_COLONNONAME
000349 f0e6          .dw XT_DROP
00034a f021          .dw XT_EXIT
                 .include "words/colon-noname.asm"
                 
                 ; Compiler
                 ; create an unnamed entry in the dictionary, XT is DO_COLON
                 VE_COLONNONAME:
00034b ff07          .dw $ff07
00034c 6e3a
00034d 6e6f
00034e 6d61
00034f 0065          .db ":noname",0
000350 0343          .dw VE_HEAD
                     .set VE_HEAD = VE_COLONNONAME
                 XT_COLONNONAME:
000351 f001          .dw DO_COLON
                 PFA_COLONNONAME:
000352 f5cf          .dw XT_DP
000353 f0be          .dw XT_DUP
000354 031f          .dw XT_LATEST
000355 f08e          .dw XT_STORE
                 
000356 01cc          .dw XT_COMPILE
000357 f001          .dw DO_COLON
                 
000358 0366          .dw XT_RBRACKET
000359 f021          .dw XT_EXIT
                 .include "words/semicolon.asm"
                 
                 ; Compiler
                 ; finish colon defintion, compiles (exit) and returns to interpret state 
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 
                 VE_SEMICOLON:
00035a 0001          .dw $0001
00035b 003b          .db $3b,0
00035c 034b          .dw VE_HEAD
                     .set VE_HEAD = VE_SEMICOLON
                 XT_SEMICOLON:
00035d f001          .dw DO_COLON
                 PFA_SEMICOLON:
                 .endif
00035e 01cc          .dw XT_COMPILE
00035f f021          .dw XT_EXIT
000360 036f          .dw XT_LBRACKET
000361 030a          .dw XT_REVEAL
000362 f021          .dw XT_EXIT
                 .include "words/right-bracket.asm"
                 
                 ; Compiler
                 ; enter compiler mode
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_RBRACKET:
000363 ff01          .dw $ff01
000364 005d          .db "]",0
000365 035a          .dw VE_HEAD
                     .set VE_HEAD = VE_RBRACKET
                 XT_RBRACKET:
000366 f001          .dw DO_COLON
                 PFA_RBRACKET:
                 .endif
000367 f041          .dw XT_DOLITERAL
000368 0001          .dw 1
000369 f566          .dw XT_STATE
00036a f08e          .dw XT_STORE
00036b f021          .dw XT_EXIT
                 .include "words/left-bracket.asm"
                 
                 ; Compiler
                 ; enter interpreter mode
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_LBRACKET:
00036c 0001          .dw $0001
00036d 005b          .db "[",0
00036e 0363          .dw VE_HEAD
                     .set VE_HEAD = VE_LBRACKET
                 XT_LBRACKET:
00036f f001          .dw DO_COLON
                 PFA_LBRACKET:
                 .endif
000370 f161          .dw XT_ZERO
000371 f566          .dw XT_STATE
000372 f08e          .dw XT_STORE
000373 f021          .dw XT_EXIT
                 .include "words/variable.asm"
                 
                 ; Compiler
                 ; create a dictionary entry for a variable and allocate 1 cell RAM
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 VE_VARIABLE:
000374 ff08          .dw $ff08
000375 6176
000376 6972
000377 6261
000378 656c          .db "variable"
000379 036c          .dw VE_HEAD
                     .set VE_HEAD = VE_VARIABLE
                 XT_VARIABLE:
00037a f001          .dw DO_COLON
                 PFA_VARIABLE:
                 .endif
00037b f5e0          .dw XT_HERE
00037c 0387          .dw XT_CONSTANT
00037d f041          .dw XT_DOLITERAL
00037e 0002          .dw 2
00037f f5e9          .dw XT_ALLOT
000380 f021          .dw XT_EXIT
                 .include "words/constant.asm"
                 
                 ; Compiler
                 ; create a constant in the dictionary
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 VE_CONSTANT:
000381 ff08          .dw $ff08
000382 6f63
000383 736e
000384 6174
000385 746e          .db "constant"
000386 0374          .dw VE_HEAD
                     .set VE_HEAD = VE_CONSTANT
                 XT_CONSTANT:
000387 f001          .dw DO_COLON
                 PFA_CONSTANT:
                 .endif
000388 01a6          .dw XT_DOCREATE
000389 030a          .dw XT_REVEAL
00038a 01cc          .dw XT_COMPILE
00038b f04f          .dw PFA_DOVARIABLE
00038c 01d7          .dw XT_COMMA
00038d f021          .dw XT_EXIT
                 .include "words/user.asm"
                 
                 ; Compiler
                 ; create a dictionary entry for a user variable at offset n
                 VE_USER:
00038e ff04          .dw $ff04
00038f 7375
000390 7265          .db "user"
000391 0381          .dw VE_HEAD
                     .set VE_HEAD = VE_USER
                 XT_USER:
000392 f001          .dw DO_COLON
                 PFA_USER:
000393 01a6          .dw XT_DOCREATE
000394 030a          .dw XT_REVEAL
                 
000395 01cc          .dw XT_COMPILE
000396 f062          .dw PFA_DOUSER
000397 01d7          .dw XT_COMMA
000398 f021          .dw XT_EXIT
                 
                 .include "words/recurse.asm"
                 
                 ; Compiler
                 ; compile the XT of the word currently being defined into the dictionary
                 VE_RECURSE:
000399 0007          .dw $0007
00039a 6572
00039b 7563
00039c 7372
00039d 0065          .db "recurse",0
00039e 038e          .dw VE_HEAD
                     .set VE_HEAD = VE_RECURSE
                 XT_RECURSE:
00039f f001          .dw DO_COLON
                 PFA_RECURSE:
0003a0 031f          .dw XT_LATEST
0003a1 f086          .dw XT_FETCH
0003a2 01d7          .dw XT_COMMA
0003a3 f021          .dw XT_EXIT
                 .include "words/immediate.asm"
                 
                 ; Compiler
                 ; set immediate flag for the most recent word definition
                 VE_IMMEDIATE:
0003a4 ff09          .dw $ff09
0003a5 6d69
0003a6 656d
0003a7 6964
0003a8 7461
0003a9 0065          .db "immediate",0
0003aa 0399          .dw VE_HEAD
                     .set VE_HEAD = VE_IMMEDIATE
                 XT_IMMEDIATE:
0003ab f001          .dw DO_COLON
                 PFA_IMMEDIATE:
0003ac 0448          .dw XT_GET_CURRENT
0003ad f360          .dw XT_FETCHE
0003ae f0be          .dw XT_DUP
0003af f3d3          .dw XT_FETCHI
0003b0 f041          .dw XT_DOLITERAL
0003b1 7fff          .dw $7fff
0003b2 f220          .dw XT_AND
0003b3 f0d1          .dw XT_SWAP
0003b4 f374          .dw XT_STOREI
0003b5 f021          .dw XT_EXIT
                 
                 .include "words/bracketchar.asm"
                 
                 ; Tools
                 ; skip leading space delimites, place the first character of the word on the stack
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_BRACKETCHAR:
0003b6 0006          .dw $0006
0003b7 635b
0003b8 6168
0003b9 5d72          .db "[char]"
0003ba 03a4          .dw VE_HEAD
                     .set VE_HEAD = VE_BRACKETCHAR
                 XT_BRACKETCHAR:
0003bb f001          .dw DO_COLON
                 PFA_BRACKETCHAR:
                 .endif
0003bc 01cc          .dw XT_COMPILE
0003bd f041          .dw XT_DOLITERAL
0003be f901          .dw XT_CHAR
0003bf 01d7          .dw XT_COMMA
0003c0 f021          .dw XT_EXIT
                 .include "words/abort-string.asm"
                 
                 ;C         i*x x1 --       R: j*x --      x1<>0
                 ;   POSTPONE IS" POSTPONE ?ABORT ; IMMEDIATE
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_ABORTQUOTE:
0003c1 0006          .dw $0006
0003c2 6261
0003c3 726f
0003c4 2274          .db "abort",'"'
0003c5 03b6          .dw VE_HEAD
                     .set VE_HEAD = VE_ABORTQUOTE
                 XT_ABORTQUOTE:
0003c6 f001          .dw DO_COLON
                 PFA_ABORTQUOTE:
                 .endif
0003c7 f4dc          .dw XT_SQUOTE
0003c8 01cc          .dw XT_COMPILE
0003c9 03d9          .dw XT_QABORT
0003ca f021          .DW XT_EXIT
                 .include "words/abort.asm"
                 
                 ; Exceptions
                 ; send an exception -1
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_ABORT:
0003cb ff05          .dw $ff05
0003cc 6261
0003cd 726f
0003ce 0074          .db "abort",0
0003cf 03c1          .dw VE_HEAD
                     .set VE_HEAD = VE_ABORT
                 XT_ABORT:
0003d0 f001          .dw DO_COLON
                 PFA_ABORT:
                 .endif
0003d1 f041          .dw XT_DOLITERAL
0003d2 ffff          .dw -1
0003d3 f85e          .dw XT_THROW
                 .include "words/q-abort.asm"
                 
                 ;   ROT IF ITYPE ABORT THEN 2DROP ;
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_QABORT:
0003d4 ff06          .dw $ff06
0003d5 613f
0003d6 6f62
0003d7 7472          .db "?abort"
0003d8 03cb          .dw VE_HEAD
                     .set VE_HEAD = VE_QABORT
                 XT_QABORT:
0003d9 f001          .dw DO_COLON
                 PFA_QABORT:
                 
                 .endif
0003da f0ee
0003db f03a              .DW XT_ROT,XT_DOCONDBRANCH
0003dc 03df              DEST(QABO1)
0003dd f7c5
0003de 03d0              .DW XT_ITYPE,XT_ABORT
0003df f589
0003e0 f021      QABO1:  .DW XT_2DROP,XT_EXIT
                 
                 .include "words/get-stack.asm"
                 
                 ; Tools
                 ; Get a stack from EEPROM
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_GET_STACK:
0003e1 ff09          .dw $ff09
0003e2 6567
0003e3 2d74
0003e4 7473
0003e5 6361
0003e6 006b          .db "get-stack",0
0003e7 03d4          .dw VE_HEAD
                     .set VE_HEAD = VE_GET_STACK
                 XT_GET_STACK:
0003e8 f001          .dw DO_COLON
                 PFA_N_FETCH_E:
                 .endif
0003e9 f0be          .dw XT_DUP
0003ea f579          .dw XT_CELLPLUS
0003eb f0d1          .dw XT_SWAP
0003ec f360          .dw XT_FETCHE
0003ed f0be          .dw XT_DUP
0003ee f10c          .dw XT_TO_R
0003ef f161          .dw XT_ZERO
0003f0 f0d1          .dw XT_SWAP    ; go from bigger to smaller addresses
0003f1 0296          .dw XT_QDOCHECK
0003f2 f03a          .dw XT_DOCONDBRANCH
0003f3 03ff          DEST(PFA_N_FETCH_E2)
0003f4 f29c          .dw XT_DODO
                 PFA_N_FETCH_E1:
                     ; ( ee-addr )
0003f5 f2ad          .dw XT_I
0003f6 f242          .dw XT_1MINUS
0003f7 f573          .dw XT_CELLS ; ( -- ee-addr i*2 )
0003f8 f0dc          .dw XT_OVER  ; ( -- ee-addr i*2 ee-addr )
0003f9 f1aa          .dw XT_PLUS  ; ( -- ee-addr ee-addr+i
0003fa f360          .dw XT_FETCHE ;( -- ee-addr item_i )
0003fb f0d1          .dw XT_SWAP   ;( -- item_i ee-addr )
0003fc f158          .dw XT_TRUE  ; shortcut for -1
0003fd f2bb          .dw XT_DOPLUSLOOP
0003fe 03f5          DEST(PFA_N_FETCH_E1)
                 PFA_N_FETCH_E2:
0003ff f589          .dw XT_2DROP
000400 f103          .dw XT_R_FROM
000401 f021          .dw XT_EXIT
                 
                 .include "words/set-stack.asm"
                 
                 ; Tools
                 ; Write a stack to EEPROM
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SET_STACK:
000402 ff09          .dw $ff09
000403 6573
000404 2d74
000405 7473
000406 6361
000407 006b          .db "set-stack",0
000408 03e1          .dw VE_HEAD
                     .set VE_HEAD = VE_SET_STACK
                 XT_SET_STACK:
000409 f001          .dw DO_COLON
                 PFA_SET_STACK:
                 .endif
00040a f580          .dw XT_2DUP
00040b f33c          .dw XT_STOREE ; ( -- i_n .. i_0 n e-addr )
00040c f0d1          .dw XT_SWAP    
00040d f161          .dw XT_ZERO
00040e 0296          .dw XT_QDOCHECK
00040f f03a          .dw XT_DOCONDBRANCH
000410 0417          DEST(PFA_SET_STACK2)
000411 f29c          .dw XT_DODO
                 PFA_SET_STACK1:
000412 f579          .dw XT_CELLPLUS ; ( -- i_x e-addr )
000413 f591          .dw XT_TUCK      ; ( -- e-addr i_x e-addr
000414 f33c          .dw XT_STOREE
000415 f2ca          .dw XT_DOLOOP
000416 0412          DEST(PFA_SET_STACK1)
                 PFA_SET_STACK2:
000417 f0e6          .dw XT_DROP
000418 f021          .dw XT_EXIT
                 
                 .include "words/map-stack.asm"
                 
                 ; Tools
                 ; Iterate over a stack
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_MAPSTACK:
000419 ff09          .dw $ff09
00041a 616d
00041b 2d70
00041c 7473
00041d 6361
00041e 006b          .db "map-stack",0
00041f 0402          .dw VE_HEAD
                     .set VE_HEAD = VE_MAPSTACK
                 XT_MAPSTACK:
000420 f001          .dw DO_COLON
                 PFA_MAPSTACK:
                 .endif
000421 f0be          .dw XT_DUP
000422 f579          .dw XT_CELLPLUS
000423 f0d1          .dw XT_SWAP
000424 f360          .dw XT_FETCHE
000425 f573          .dw XT_CELLS
000426 fd68          .dw XT_BOUNDS
000427 0296          .dw XT_QDOCHECK
000428 f03a          .dw XT_DOCONDBRANCH
000429 043d          DEST(PFA_MAPSTACK3)
00042a f29c          .dw XT_DODO
                 PFA_MAPSTACK1:
00042b f2ad            .dw XT_I
00042c f360            .dw XT_FETCHE   ; -- i*x XT id
00042d f0d1            .dw XT_SWAP
00042e f10c            .dw XT_TO_R
00042f f115            .dw XT_R_FETCH
000430 f02b            .dw XT_EXECUTE  ; i*x id -- j*y true | i*x false
000431 f0c6            .dw XT_QDUP
000432 f03a            .dw XT_DOCONDBRANCH
000433 0438            DEST(PFA_MAPSTACK2)
000434 f103               .dw XT_R_FROM
000435 f0e6               .dw XT_DROP
000436 f2d5               .dw XT_UNLOOP
000437 f021               .dw XT_EXIT
                 PFA_MAPSTACK2:
000438 f103            .dw XT_R_FROM
000439 f041            .dw XT_DOLITERAL
00043a 0002            .dw 2
00043b f2bb            .dw XT_DOPLUSLOOP
00043c 042b            DEST(PFA_MAPSTACK1)
                 PFA_MAPSTACK3:
00043d f0e6          .dw XT_DROP
00043e f161          .dw XT_ZERO
00043f f021          .dw XT_EXIT
                 
                 ;
                 ; : map-stack ( i*x XT e-addr -- j*y )
                 ;     dup cell+ swap @e cells bounds ?do 
                 ;       ( -- i*x XT )
                 ;       i @e swap >r r@ execute
                 ;       ?dup if r> drop unloop exit then
                 ;       r>
                 ;     2 +loop drop 0
                 ;
                 .include "words/get-current.asm"
                 
                 ; Search Order
                 ; get the wid of the current compilation word list
                 VE_GET_CURRENT:
000440 ff0b          .dw $ff0b
000441 6567
000442 2d74
000443 7563
000444 7272
000445 6e65
000446 0074          .db "get-current",0
000447 0419          .dw VE_HEAD
                     .set VE_HEAD = VE_GET_CURRENT
                 XT_GET_CURRENT:
000448 f001          .dw DO_COLON
                 PFA_GET_CURRENT:
000449 f041          .dw XT_DOLITERAL
00044a 0056          .dw EE_CURRENT
00044b f360          .dw XT_FETCHE
00044c f021          .dw XT_EXIT
                 .include "words/get-order.asm"
                 
                 ; Search Order
                 ; Get the current search order word list
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_GET_ORDER:
00044d ff09          .dw $ff09
00044e 6567
00044f 2d74
000450 726f
000451 6564
000452 0072          .db "get-order",0
000453 0440          .dw VE_HEAD
                     .set VE_HEAD = VE_GET_ORDER
                 XT_GET_ORDER:
000454 f001          .dw DO_COLON
                 PFA_GET_ORDER:
                 .endif
000455 f041          .dw XT_DOLITERAL
000456 005a          .dw CFG_ORDERLISTLEN
000457 03e8          .dw XT_GET_STACK
000458 f021          .dw XT_EXIT
                 
                 .include "words/compare.asm"
                 
                 ; String
                 ; compares two strings in RAM
                 VE_COMPARE:
000459 ff07          .dw $ff07
00045a 6f63
00045b 706d
00045c 7261
00045d 0065          .db "compare",0
00045e 044d          .dw VE_HEAD
                     .set VE_HEAD = VE_COMPARE
                 XT_COMPARE:
00045f 0460          .dw PFA_COMPARE
                 PFA_COMPARE:
000460 93bf          push xh
000461 93af          push xl
000462 018c          movw temp0, tosl
000463 9189
000464 9199          loadtos
000465 01dc          movw xl, tosl
000466 9189
000467 9199          loadtos
000468 019c          movw temp2, tosl
000469 9189
00046a 9199          loadtos
00046b 01fc          movw zl, tosl
                 PFA_COMPARE_LOOP:
00046c 90ed          ld temp4, X+
00046d 90f1          ld temp5, Z+
00046e 14ef          cp temp4, temp5
00046f f451          brne PFA_COMPARE_NOTEQUAL
000470 950a          dec temp0
000471 f019          breq PFA_COMPARE_ENDREACHED2
000472 952a          dec temp2
000473 f7c1          brne PFA_COMPARE_LOOP
000474 c001          rjmp PFA_COMPARE_ENDREACHED
                 PFA_COMPARE_ENDREACHED2:
000475 952a          dec temp2
                 PFA_COMPARE_ENDREACHED:
000476 2b02          or temp0, temp2
000477 f411          brne PFA_COMPARE_CHECKLASTCHAR
000478 2788          clr tosl
000479 c002          rjmp PFA_COMPARE_DONE
                 PFA_COMPARE_CHECKLASTCHAR:
                 PFA_COMPARE_NOTEQUAL:
00047a ef8f          ser tosl
00047b c000          rjmp PFA_COMPARE_DONE
                 
                 PFA_COMPARE_DONE:
00047c 2f98          mov tosh, tosl
00047d 91af          pop xl
00047e 91bf          pop xh
00047f 940c f005     jmp_ DO_NEXT
                 .include "words/nfa2lfa.asm"
                 
                 ; System
                 ; get the link field address from the name field address
                 VE_NFA2LFA:
000481 ff07         .dw $ff07
000482 666e
000483 3e61
000484 666c
000485 0061         .db "nfa>lfa",0
000486 0459         .dw VE_HEAD
                    .set VE_HEAD = VE_NFA2LFA
                 XT_NFA2LFA:
000487 f001          .dw DO_COLON
                 PFA_NFA2LFA:
000488 fc80          .dw XT_NAME2STRING
000489 f23c          .dw XT_1PLUS
00048a f211          .dw XT_2SLASH
00048b f1aa          .dw XT_PLUS
00048c f021          .dw XT_EXIT
                 .elif AMFORTH_NRWW_SIZE > 4000
                 .elif AMFORTH_NRWW_SIZE > 2000
                 .else
                 .endif
                 .include "dict_appl.inc"
                 
                 ; they may be moved to the core dictionary if needed
                 .include "words/dot-s.asm"
                 
                 ; Tools
                 ; stack dump
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DOTS:
00048d ff02          .dw $ff02
00048e 732e          .db ".s"
00048f 0481          .dw VE_HEAD
                     .set VE_HEAD = VE_DOTS
                 XT_DOTS:
000490 f001          .dw DO_COLON
                 PFA_DOTS:
                 .endif
000491 faa7          .dw XT_DEPTH
000492 f45b          .dw XT_UDOT
000493 f807          .dw XT_SPACE
000494 faa7          .dw XT_DEPTH
000495 f161          .dw XT_ZERO
000496 0296          .dw XT_QDOCHECK
000497 f03a          .dw XT_DOCONDBRANCH
000498 049f          DEST(PFA_DOTS2)
000499 f29c          .dw XT_DODO
                 PFA_DOTS1:
00049a f2ad          .dw XT_I
00049b f4ca          .dw XT_PICK
00049c f45b          .dw XT_UDOT
00049d f2ca          .dw XT_DOLOOP
00049e 049a          DEST(PFA_DOTS1)
                 PFA_DOTS2:
00049f f021          .dw XT_EXIT
                 .include "words/spirw.asm"
                 
                 ; MCU
                 ; SPI exchange of 1 byte
                 VE_SPIRW:
0004a0 ff06          .dw $ff06
0004a1 2163
0004a2 7340
0004a3 6970          .db "c!@spi"
0004a4 048d          .dw VE_HEAD
                     .set VE_HEAD  = VE_SPIRW
                 XT_SPIRW:
0004a5 04a6          .dw PFA_SPIRW
                 PFA_SPIRW:
0004a6 d003          rcall do_spirw
0004a7 2799          clr tosh
0004a8 940c f005     jmp_ DO_NEXT
                 
                 do_spirw:
0004aa bd8e          out_ SPDR, tosl
                 do_spirw1:
0004ab b50d          in_ temp0, SPSR
0004ac 7f08          cbr temp0,7
0004ad bd0d          out_ SPSR, temp0
0004ae b50d          in_ temp0, SPSR
0004af ff07          sbrs temp0, 7
0004b0 cffa          rjmp do_spirw1   ; wait until complete
0004b1 b58e          in_ tosl, SPDR
0004b2 9508          ret
                 .include "words/n-spi.asm"
                 
                 ; MCU
                 ; read len bytes from SPI to addr
                 VE_N_SPIR:
0004b3 ff05          .dw $ff05
0004b4 406e
0004b5 7073
0004b6 0069          .db "n@spi",0
0004b7 04a0          .dw VE_HEAD
                     .set VE_HEAD  = VE_N_SPIR
                 XT_N_SPIR:
0004b8 04b9          .dw PFA_N_SPIR
                 PFA_N_SPIR:
0004b9 018c          movw temp0, tosl
0004ba 9189
0004bb 9199          loadtos
0004bc 01fc          movw zl, tosl
0004bd 01c8          movw tosl, temp0
                 PFA_N_SPIR_LOOP:
0004be bc2e          out_ SPDR, zerol
                 PFA_N_SPIR_LOOP1:
0004bf b52d          in_ temp2, SPSR
0004c0 ff27          sbrs temp2, SPIF
0004c1 cffd          rjmp PFA_N_SPIR_LOOP1
0004c2 b52e          in_ temp2, SPDR
0004c3 9321          st Z+, temp2
0004c4 9701          sbiw tosl, 1
0004c5 f7c1          brne PFA_N_SPIR_LOOP
0004c6 9189
0004c7 9199          loadtos
0004c8 940c f005     jmp_ DO_NEXT
                 
                 ; ( addr len -- ) 
                 ; MCU
                 ; write len bytes to SPI from addr
                 VE_N_SPIW:
0004ca ff05          .dw $ff05
0004cb 216e
0004cc 7073
0004cd 0069          .db "n!spi",0
0004ce 04b3          .dw VE_HEAD
                     .set VE_HEAD  = VE_N_SPIW
                 XT_N_SPIW:
0004cf 04d0          .dw PFA_N_SPIW
                 PFA_N_SPIW:
0004d0 018c          movw temp0, tosl
0004d1 9189
0004d2 9199          loadtos
0004d3 01fc          movw zl, tosl
0004d4 01c8          movw tosl, temp0
                 PFA_N_SPIW_LOOP:
0004d5 9121          ld temp2, Z+
0004d6 bd2e          out_ SPDR, temp2
                 PFA_N_SPIW_LOOP1:
0004d7 b52d          in_ temp2, SPSR
0004d8 ff27          sbrs temp2, SPIF
0004d9 cffd          rjmp PFA_N_SPIW_LOOP1
0004da b52e          in_ temp2, SPDR ; ignore the data
0004db 9701          sbiw tosl, 1
0004dc f7c1          brne PFA_N_SPIW_LOOP
0004dd 9189
0004de 9199          loadtos
0004df 940c f005     jmp_ DO_NEXT
                 .include "words/applturnkey.asm"
                 
                 ; R( -- )
                 ; application specific turnkey action
                 VE_APPLTURNKEY:
0004e1 ff0b          .dw $ff0b
0004e2 7061
0004e3 6c70
0004e4 7574
0004e5 6e72
0004e6 656b
0004e7 0079          .db "applturnkey",0
0004e8 04ca          .dw VE_HEAD
                     .set VE_HEAD = VE_APPLTURNKEY
                 XT_APPLTURNKEY:
0004e9 f001          .dw DO_COLON
                 PFA_APPLTURNKEY:
0004ea 00c7          .dw XT_USART
0004eb f48c          .dw XT_INTON
0004ec fb71          .dw XT_DOT_VER
0004ed f807          .dw XT_SPACE
0004ee f55b          .dw XT_F_CPU
0004ef f041          .dw XT_DOLITERAL
0004f0 03e8          .dw 1000
0004f1 f1cf          .dw XT_UMSLASHMOD
0004f2 f0d1          .dw XT_SWAP
0004f3 f0e6          .dw XT_DROP
0004f4 f5ff          .dw XT_DECIMAL
0004f5 f747          .dw XT_DOT
0004f6 f792          .dw XT_DOSLITERAL
0004f7 0004          .dw 4
0004f8 486b
0004f9 207a          .db "kHz "
0004fa f7c5          .dw XT_ITYPE
0004fb f021          .dw XT_EXIT
                 .include "dict/compiler2.inc"
                 
                 ; included almost independently from each other
                 ; on a include-per-use basis
                 ;
                 .if DICT_COMPILER2 == 0
                 .set DICT_COMPILER2 = 1
                 
                 .include "words/set-current.asm"
                 
                 ; Search Order
                 ; set current word list to the given word list wid
                 VE_SET_CURRENT:
0004fc ff0b          .dw $ff0b
0004fd 6573
0004fe 2d74
0004ff 7563
000500 7272
000501 6e65
000502 0074          .db "set-current",0
000503 04e1          .dw VE_HEAD
                     .set VE_HEAD = VE_SET_CURRENT
                 XT_SET_CURRENT:
000504 f001          .dw DO_COLON
                 PFA_SET_CURRENT:
000505 f041          .dw XT_DOLITERAL
000506 0056          .dw EE_CURRENT
000507 f33c          .dw XT_STOREE
000508 f021          .dw XT_EXIT
                 .include "words/wordlist.asm"
                 
                 ; Search Order
                 ; create a new, empty wordlist
                 VE_WORDLIST:
000509 ff08          .dw $ff08
00050a 6f77
00050b 6472
00050c 696c
00050d 7473          .db "wordlist"
00050e 04fc          .dw VE_HEAD
                     .set VE_HEAD = VE_WORDLIST
                 XT_WORDLIST:
00050f f001          .dw DO_COLON
                 PFA_WORDLIST:
000510 f5d8          .dw XT_EHERE
000511 f161          .dw XT_ZERO
000512 f0dc          .dw XT_OVER
000513 f33c          .dw XT_STOREE
000514 f0be          .dw XT_DUP
000515 f579          .dw XT_CELLPLUS
000516 fba7          .dw XT_DOTO
000517 f5d9          .dw PFA_EHERE
000518 f021          .dw XT_EXIT
                 
                 .include "words/only.asm"
                 
                 ; Search Order
                 ; replace the order list with the system default list
                 VE_ONLY:
000519 ff04          .dw $ff04
00051a 6e6f
00051b 796c          .db "only"
00051c 0509          .dw VE_HEAD
                     .set VE_HEAD = VE_ONLY
                 XT_ONLY:
00051d f001          .dw DO_COLON
                 PFA_ONLY:
00051e f041          .dw XT_DOLITERAL
00051f 0058          .dw EE_FORTHWORDLIST
000520 f041          .dw XT_DOLITERAL
000521 0001          .dw 1
000522 0538          .dw XT_SET_ORDER
000523 f021          .dw XT_EXIT
                 .include "words/forth-wordlist.asm"
                 
                 ; Search Order
                 ; get the system default word list
                 VE_FORTH_WORDLIST:
000524 ff0e          .dw $ff0e
000525 6f66
000526 7472
000527 2d68
000528 6f77
000529 6472
00052a 696c
00052b 7473          .db "forth-wordlist"
00052c 0519          .dw VE_HEAD
                     .set VE_HEAD = VE_FORTH_WORDLIST
                 XT_FORTH_WORDLIST:
00052d f07c          .dw PFA_DOVALUE1
                 PFA_FORTH_WORDLIST:
00052e 0054          .dw EE_WL_FORTH
00052f fbc2          .dw XT_EDEFERFETCH
000530 fbcc          .dw XT_EDEFERSTORE
                 .include "words/set-order.asm"
                 
                 ; Search Order
                 ; replace the search order list
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SET_ORDER:
000531 ff09          .dw $ff09
000532 6573
000533 2d74
000534 726f
000535 6564
000536 0072          .db "set-order",0
000537 0524          .dw VE_HEAD
                     .set VE_HEAD = VE_SET_ORDER
                 XT_SET_ORDER:
000538 f001          .dw DO_COLON
                 PFA_SET_ORDER:
                 .endif
000539 f041          .dw XT_DOLITERAL
00053a 005a          .dw CFG_ORDERLISTLEN
00053b 0409          .dw XT_SET_STACK
00053c f021          .dw XT_EXIT
                 
                 .include "words/set-recognizer.asm"
                 
                 ; Interpreter
                 ; replace the recognizer list
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SET_RECOGNIZERS:
00053d ff0f          .dw $ff0f
00053e 6573
00053f 2d74
000540 6572
000541 6f63
000542 6e67
000543 7a69
000544 7265
000545 0073          .db "set-recognizers",0
000546 0531          .dw VE_HEAD
                     .set VE_HEAD = VE_SET_RECOGNIZERS
                 XT_SET_RECOGNIZERS:
000547 f001          .dw DO_COLON
                 PFA_SET_RECOGNIZERS:
                 .endif
000548 f041          .dw XT_DOLITERAL
000549 006c          .dw CFG_RECOGNIZERLISTLEN
00054a 0409          .dw XT_SET_STACK
00054b f021          .dw XT_EXIT
                 
                 .include "words/get-recognizer.asm"
                 
                 ; Interpreter
                 ; Get the current recognizer list
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_GET_RECOGNIZERS:
00054c ff0f          .dw $ff0f
00054d 6567
00054e 2d74
00054f 6572
000550 6f63
000551 6e67
000552 7a69
000553 7265
000554 0073          .db "get-recognizers",0
000555 053d          .dw VE_HEAD
                     .set VE_HEAD = VE_GET_RECOGNIZERS
                 XT_GET_RECOGNIZERS:
000556 f001          .dw DO_COLON
                 PFA_GET_RECOGNIZERS:
                 .endif
000557 f041          .dw XT_DOLITERAL
000558 006c          .dw CFG_RECOGNIZERLISTLEN
000559 03e8          .dw XT_GET_STACK
00055a f021          .dw XT_EXIT
                 .include "words/code.asm"
                 
                 ; Compiler
                 ; create named entry in the dictionary, XT is the data field
                 VE_CODE:
00055b ff04          .dw $ff04
00055c 6f63
00055d 6564          .db "code"
00055e 054c          .dw VE_HEAD
                     .set VE_HEAD = VE_CODE
                 XT_CODE:
00055f f001          .dw DO_COLON
                 PFA_CODE:
000560 01a6          .dw XT_DOCREATE
000561 030a          .dw XT_REVEAL
000562 f5cf          .dw XT_DP
000563 fbb9          .dw XT_ICELLPLUS
000564 01d7          .dw XT_COMMA
000565 f021          .dw XT_EXIT
                 .include "words/end-code.asm"
                 
                 ; Compiler
                 ; finish a code definition
                 VE_ENDCODE:
000566 ff08          .dw $ff08
000567 6e65
000568 2d64
000569 6f63
00056a 6564          .db "end-code"
00056b 055b          .dw VE_HEAD
                     .set VE_HEAD = VE_ENDCODE
                 XT_ENDCODE:
00056c f001          .dw DO_COLON
                 PFA_ENDCODE:
00056d 01cc          .dw XT_COMPILE
00056e 940c          .dw $940c
00056f 01cc          .dw XT_COMPILE
000570 f005          .dw DO_NEXT
000571 f021          .dw XT_EXIT
                 .include "words/marker.asm"
                 
                 ; System Value
                 ; The eeprom address until which MARKER saves and restores the eeprom data.
                 VE_MARKER:
000572 ff08          .dw $ff08
000573 6d28
000574 7261
000575 656b
000576 2972          .db "(marker)"
000577 0566          .dw VE_HEAD
                     .set VE_HEAD = VE_MARKER
                 XT_MARKER:
000578 f07c          .dw PFA_DOVALUE1
                 PFA_MARKER:
000579 007a          .dw EE_MARKER
00057a fbc2          .dw XT_EDEFERFETCH
00057b fbcc          .dw XT_EDEFERSTORE
                 .include "words/postpone.asm"
                 
                 ; Compiler
                 ; Append the compilation semantics of "name" to the dictionary
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_POSTPONE:
00057c 0008          .dw $0008
00057d 6f70
00057e 7473
00057f 6f70
000580 656e          .db "postpone"
000581 0572          .dw VE_HEAD
                     .set VE_HEAD = VE_POSTPONE
                 XT_POSTPONE:
000582 f001          .dw DO_COLON
                 PFA_POSTPONE:
                 .endif
000583 f9d2          .dw XT_PARSENAME
000584 fad0          .dw XT_DORECOGNIZER
000585 fbb9          .dw XT_ICELLPLUS 
000586 fbb9          .dw XT_ICELLPLUS
000587 f3d3          .dw XT_FETCHI
000588 f02b          .dw XT_EXECUTE
000589 f021          .dw XT_EXIT
                 .endif
                 .include "words/2r_fetch.asm"
                 
                 ; Stack
                 ; fetch content of TOR
                 VE_2R_FETCH:
00058a ff03          .dw $ff03
00058b 7232
00058c 0040          .db "2r@",0
00058d 057c          .dw VE_HEAD
                     .set VE_HEAD = VE_2R_FETCH
                 XT_2R_FETCH:
00058e 058f          .dw PFA_2R_FETCH
                 PFA_2R_FETCH:
00058f 939a
000590 938a          savetos
000591 91ef          pop zl
000592 91ff          pop zh
000593 918f          pop tosl
000594 919f          pop tosh
000595 939f          push tosh
000596 938f          push tosl
000597 93ff          push zh
000598 93ef          push zl
000599 939a
00059a 938a          savetos
00059b 01cf          movw tosl, zl
00059c 940c f005     jmp_ DO_NEXT
                 
                 .set DPSTART = pc
                 .if(pc>AMFORTH_RO_SEG)
                 .endif
                 
                 .org AMFORTH_RO_SEG
                 .include "amforth-interpreter.asm"
                 
                 
                 DO_COLON:
00f001 93bf          push XH
00f002 93af          push XL          ; PUSH IP
00f003 01db          movw XL, wl
00f004 9611          adiw xl, 1
                 DO_NEXT:
00f005 f09e          brts DO_INTERRUPT
00f006 01fd          movw zl, XL        ; READ IP
00f007 2755
00f008 0fee
00f009 1fff
00f00a 1f55
00f00b bf5b
00f00c 9167
00f00d 9177          readflashcell wl, wh
00f00e 9611          adiw XL, 1        ; INC IP
                 
                 DO_EXECUTE:
00f00f 01fb          movw zl, wl
00f010 2755
00f011 0fee
00f012 1fff
00f013 1f55
00f014 bf5b
00f015 9107
00f016 9117          readflashcell temp0,temp1
00f017 01f8          movw zl, temp0
00f018 9409          ijmp
                 
                 DO_INTERRUPT:
                     ; here we deal with interrupts the forth way
00f019 94e8          clt
00f01a eb67          ldi wl, LOW(XT_ISREXEC)
00f01b ef74          ldi wh, HIGH(XT_ISREXEC)
00f01c cff2          rjmp DO_EXECUTE
                 .include "dict/nrww.inc"
                 
                 ; section together with the forth inner interpreter
                 
                 .include "words/exit.asm"
                 
                 ; Compiler
                 ; end of current colon word
                 VE_EXIT:
00f01d ff04          .dw $ff04
00f01e 7865
00f01f 7469          .db "exit"
00f020 058a          .dw VE_HEAD
                     .set VE_HEAD = VE_EXIT
                 XT_EXIT:
00f021 f022          .dw PFA_EXIT
                 PFA_EXIT:
00f022 91af          pop XL
00f023 91bf          pop XH
00f024 cfe0          jmp_ DO_NEXT
                 .include "words/execute.asm"
                 
                 ; System
                 ; execute XT
                 VE_EXECUTE:
00f025 ff07          .dw $ff07
00f026 7865
00f027 6365
00f028 7475
00f029 0065          .db "execute",0
00f02a f01d          .dw VE_HEAD
                     .set VE_HEAD = VE_EXECUTE
                 XT_EXECUTE:
00f02b f02c          .dw PFA_EXECUTE
                 PFA_EXECUTE:
00f02c 01bc          movw wl, tosl
00f02d 9189
00f02e 9199          loadtos
00f02f cfdf          jmp_ DO_EXECUTE
                 .include "words/dobranch.asm"
                 
                 ; System
                 ; runtime of branch
                 ;VE_DOBRANCH:
                 ;    .dw $ff08
                 ;    .db "(branch)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOBRANCH
                 XT_DOBRANCH:
00f030 f031          .dw PFA_DOBRANCH
                 PFA_DOBRANCH:
00f031 01fd          movw zl, XL
00f032 2755
00f033 0fee
00f034 1fff
00f035 1f55
00f036 bf5b
00f037 91a7
00f038 91b7          readflashcell XL,XH
00f039 cfcb          jmp_ DO_NEXT
                 .include "words/docondbranch.asm"
                 
                 ; System
                 ; runtime of ?branch
                 ;VE_DOCONDBRANCH:
                 ;    .dw $ff09
                 ;    .db "(?branch)"
                 ;    .dw  VE_HEAD
                 ;    .set VE_HEAD = VE_DOCONDBRANCH
                 XT_DOCONDBRANCH:
00f03a f03b          .dw PFA_DOCONDBRANCH
                 PFA_DOCONDBRANCH:
00f03b 2b98          or tosh, tosl
00f03c 9189
00f03d 9199          loadtos
00f03e f391          brbs 1, PFA_DOBRANCH ; 1 is z flag; if tos is zero (false), do the branch
00f03f 9611          adiw XL, 1
00f040 cfc4          jmp_ DO_NEXT
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/doliteral.asm"
                 
                 ; System
                 ; runtime of literal
                 ;VE_DOLITERAL:
                 ;    .dw $ff09
                 ;    .db "(literal)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOLITERAL
                 XT_DOLITERAL:
00f041 f042          .dw PFA_DOLITERAL
                 PFA_DOLITERAL:
00f042 939a
00f043 938a          savetos
00f044 01fd          movw zl, xl
00f045 2755
00f046 0fee
00f047 1fff
00f048 1f55
00f049 bf5b
00f04a 9187
00f04b 9197          readflashcell tosl,tosh
00f04c 9611          adiw xl, 1
00f04d cfb7          jmp_ DO_NEXT
                 
                 .include "words/dovariable.asm"
                 
                 ; System
                 ; puts content of parameter field (1 cell) to TOS
                 ;VE_DOVARIABLE:
                 ;    .dw $ff0a
                 ;    .db "(variable)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOVARIABLE
                 XT_DOVARIABLE:
00f04e f04f          .dw PFA_DOVARIABLE
                 PFA_DOVARIABLE:
00f04f 939a
00f050 938a          savetos
00f051 01fb          movw zl, wl
00f052 9631          adiw zl,1
00f053 2755
00f054 0fee
00f055 1fff
00f056 1f55
00f057 bf5b
00f058 9187
00f059 9197          readflashcell tosl,tosh
00f05a cfaa          jmp_ DO_NEXT
                 .include "words/doconstant.asm"
                 
                 ; System
                 ; place data field address on TOS
                 ;VE_DOCONSTANT:
                 ;    .dw $ff0a
                 ;    .db "(constant)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOCONSTANT
                 XT_DOCONSTANT:
00f05b f05c          .dw PFA_DOCONSTANT
                 PFA_DOCONSTANT:
00f05c 939a
00f05d 938a          savetos
00f05e 01cb          movw tosl, wl
00f05f 9601          adiw tosl, 1
00f060 cfa4          jmp_ DO_NEXT
                 .include "words/douser.asm"
                 
                 ; System
                 ; runtime part of user
                 ;VE_DOUSER:
                 ;    .dw $ff06
                 ;    .db "(user)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOUSER
                 XT_DOUSER:
00f061 f062          .dw PFA_DOUSER
                 PFA_DOUSER:
00f062 939a
00f063 938a          savetos
00f064 01fb          movw zl, wl
00f065 9631          adiw zl, 1
00f066 2755
00f067 0fee
00f068 1fff
00f069 1f55
00f06a bf5b
00f06b 9187
00f06c 9197          readflashcell tosl,tosh
00f06d 0d84          add tosl, upl
00f06e 1d95          adc tosh, uph
00f06f cf95          jmp_ DO_NEXT
                 .include "words/do-value.asm"
                 
                 ; System
                 ; runtime of value
                 VE_DOVALUE:
00f070 ff07          .dw $ff07
00f071 7628
00f072 6c61
00f073 6575
00f074 0029          .db "(value)", 0
00f075 f025          .dw VE_HEAD
                     .set VE_HEAD = VE_DOVALUE
                 XT_DOVALUE:
00f076 f001          .dw DO_COLON
                 PFA_DOVALUE:
00f077 01a6          .dw XT_DOCREATE
00f078 030a          .dw XT_REVEAL
00f079 01cc          .dw XT_COMPILE
00f07a f07c          .dw PFA_DOVALUE1
00f07b f021          .dw XT_EXIT
                 PFA_DOVALUE1:
00f07c 940e 032e     call_ DO_DODOES
00f07e f0be          .dw XT_DUP
00f07f fbb9          .dw XT_ICELLPLUS
00f080 f3d3          .dw XT_FETCHI
00f081 f02b          .dw XT_EXECUTE
00f082 f021          .dw XT_EXIT
                 
                 ; : (value) <builds does> dup icell+ @i execute ;
                 .include "words/fetch.asm"
                 
                 ; Memory
                 ; read 1 cell from RAM address
                 VE_FETCH:
00f083 ff01          .dw $ff01
00f084 0040          .db "@",0
00f085 f070          .dw VE_HEAD
                     .set VE_HEAD = VE_FETCH
                 XT_FETCH:
00f086 f087          .dw PFA_FETCH
                 PFA_FETCH:
                 .if WANT_UNIFIED == 1
                 .endif
                 PFA_FETCHRAM:
00f087 01fc          movw zl, tosl
                     ; low byte is read before the high byte
00f088 9181          ld tosl, z+
00f089 9191          ld tosh, z+
00f08a cf7a          jmp_ DO_NEXT
                 .if WANT_UNIFIED == 1
                 .endif
                 .include "words/store.asm"
                 
                 ; Memory
                 ; write n to RAM memory at addr, low byte first
                 VE_STORE:
00f08b ff01          .dw $ff01
00f08c 0021          .db "!",0
00f08d f083          .dw VE_HEAD
                     .set VE_HEAD = VE_STORE
                 XT_STORE:
00f08e f08f          .dw PFA_STORE
                 PFA_STORE:
                 .if WANT_UNIFIED == 1
                 .endif
                 PFA_STORERAM:
00f08f 01fc          movw zl, tosl
00f090 9189
00f091 9199          loadtos
                     ; the high byte is written before the low byte
00f092 8391          std Z+1, tosh
00f093 8380          std Z+0, tosl
00f094 9189
00f095 9199          loadtos
00f096 cf6e          jmp_ DO_NEXT
                 .if WANT_UNIFIED == 1
                 .endif
                 .include "words/cstore.asm"
                 
                 ; Memory
                 ; store a single byte to RAM address
                 VE_CSTORE:
00f097 ff02          .dw $ff02
00f098 2163          .db "c!"
00f099 f08b          .dw VE_HEAD
                     .set VE_HEAD = VE_CSTORE
                 XT_CSTORE:
00f09a f09b          .dw PFA_CSTORE
                 PFA_CSTORE:
00f09b 01fc          movw zl, tosl
00f09c 9189
00f09d 9199          loadtos
00f09e 8380          st Z, tosl
00f09f 9189
00f0a0 9199          loadtos
00f0a1 cf63          jmp_ DO_NEXT
                 .include "words/cfetch.asm"
                 
                 ; Memory
                 ; fetch a single byte from memory mapped locations
                 VE_CFETCH:
00f0a2 ff02          .dw $ff02
00f0a3 4063          .db "c@"
00f0a4 f097          .dw VE_HEAD
                     .set VE_HEAD  = VE_CFETCH
                 XT_CFETCH:
00f0a5 f0a6          .dw PFA_CFETCH
                 PFA_CFETCH:
00f0a6 01fc          movw zl, tosl
00f0a7 2799          clr tosh
00f0a8 8180          ld tosl, Z
00f0a9 cf5b          jmp_ DO_NEXT
                 .include "words/fetch-u.asm"
                 
                 ; Memory
                 ; read 1 cell from USER area
                 VE_FETCHU:
00f0aa ff02          .dw $ff02
00f0ab 7540          .db "@u"
00f0ac f0a2          .dw VE_HEAD
                     .set VE_HEAD = VE_FETCHU
                 XT_FETCHU:
00f0ad f001          .dw DO_COLON
                 PFA_FETCHU:
00f0ae f303          .dw XT_UP_FETCH
00f0af f1aa          .dw XT_PLUS
00f0b0 f086          .dw XT_FETCH
00f0b1 f021          .dw XT_EXIT
                 .include "words/store-u.asm"
                 
                 ; Memory
                 ; write n to USER area at offset
                 VE_STOREU:
00f0b2 ff02          .dw $ff02
00f0b3 7521          .db "!u"
00f0b4 f0aa          .dw VE_HEAD
                     .set VE_HEAD = VE_STOREU
                 XT_STOREU:
00f0b5 f001          .dw DO_COLON
                 PFA_STOREU:
00f0b6 f303          .dw XT_UP_FETCH
00f0b7 f1aa          .dw XT_PLUS
00f0b8 f08e          .dw XT_STORE
00f0b9 f021          .dw XT_EXIT
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/dup.asm"
                 
                 ; Stack
                 ; duplicate TOS
                 VE_DUP:
00f0ba ff03          .dw $ff03
00f0bb 7564
00f0bc 0070          .db "dup",0
00f0bd f0b2          .dw VE_HEAD
                     .set VE_HEAD = VE_DUP
                 XT_DUP:
00f0be f0bf          .dw PFA_DUP
                 PFA_DUP:
00f0bf 939a
00f0c0 938a          savetos
00f0c1 cf43          jmp_ DO_NEXT
                 .include "words/qdup.asm"
                 
                 ; Stack
                 ; duplicate TOS if non-zero
                 VE_QDUP:
00f0c2 ff04          .dw $ff04
00f0c3 643f
00f0c4 7075          .db "?dup"
00f0c5 f0ba          .dw VE_HEAD
                     .set VE_HEAD = VE_QDUP
                 XT_QDUP:
00f0c6 f0c7          .dw PFA_QDUP
                 PFA_QDUP:
00f0c7 2f08          mov temp0, tosl
00f0c8 2b09          or temp0, tosh
00f0c9 f011          breq PFA_QDUP1
00f0ca 939a
00f0cb 938a          savetos
                 PFA_QDUP1:
00f0cc cf38          jmp_ DO_NEXT
                 .include "words/swap.asm"
                 
                 ; Stack
                 ; swaps the two top level stack cells
                 VE_SWAP:
00f0cd ff04          .dw $ff04
00f0ce 7773
00f0cf 7061          .db "swap"
00f0d0 f0c2          .dw VE_HEAD
                     .set VE_HEAD = VE_SWAP
                 XT_SWAP:
00f0d1 f0d2          .dw PFA_SWAP
                 PFA_SWAP:
00f0d2 018c          movw temp0, tosl
00f0d3 9189
00f0d4 9199          loadtos
00f0d5 931a          st -Y, temp1
00f0d6 930a          st -Y, temp0
00f0d7 cf2d          jmp_ DO_NEXT
                 .include "words/over.asm"
                 
                 ; Stack
                 ; Place a copy of x1 on top of the stack
                 VE_OVER:
00f0d8 ff04          .dw $ff04
00f0d9 766f
00f0da 7265          .db "over"
00f0db f0cd          .dw VE_HEAD
                     .set VE_HEAD = VE_OVER
                 XT_OVER:
00f0dc f0dd          .dw PFA_OVER
                 PFA_OVER:
00f0dd 939a
00f0de 938a          savetos
00f0df 818a          ldd tosl, Y+2
00f0e0 819b          ldd tosh, Y+3
                 
00f0e1 cf23          jmp_ DO_NEXT
                 .include "words/drop.asm"
                 
                 ; Stack
                 ; drop TOS
                 VE_DROP:
00f0e2 ff04          .dw $ff04
00f0e3 7264
00f0e4 706f          .db "drop"
00f0e5 f0d8          .dw VE_HEAD
                     .set VE_HEAD = VE_DROP
                 XT_DROP:
00f0e6 f0e7          .dw PFA_DROP
                 PFA_DROP:
00f0e7 9189
00f0e8 9199          loadtos
00f0e9 cf1b          jmp_ DO_NEXT
                 .include "words/rot.asm"
                 
                 ; Stack
                 ; rotate the three top level cells
                 VE_ROT:
00f0ea ff03          .dw $ff03
00f0eb 6f72
00f0ec 0074          .db "rot",0
00f0ed f0e2          .dw VE_HEAD
                     .set VE_HEAD = VE_ROT
                 XT_ROT:
00f0ee f0ef          .dw PFA_ROT
                 PFA_ROT:
00f0ef 018c          movw temp0, tosl
00f0f0 9129          ld temp2, Y+
00f0f1 9139          ld temp3, Y+ 
00f0f2 9189
00f0f3 9199          loadtos
                         
00f0f4 933a          st -Y, temp3
00f0f5 932a          st -Y, temp2
00f0f6 931a          st -Y, temp1
00f0f7 930a          st -Y, temp0
                 
00f0f8 cf0c          jmp_ DO_NEXT
                 .include "words/nip.asm"
                 
                 ; Stack
                 ; Remove Second of Stack
                 VE_NIP:
00f0f9 ff03          .dw $ff03
00f0fa 696e
00f0fb 0070          .db "nip",0
00f0fc f0ea          .dw VE_HEAD
                     .set VE_HEAD = VE_NIP
                 XT_NIP:
00f0fd f0fe          .dw PFA_NIP
                 PFA_NIP:
00f0fe 9622          adiw yl, 2
00f0ff cf05          jmp_ DO_NEXT
                 ;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/r_from.asm"
                 
                 ; Stack
                 ; move TOR to TOS
                 VE_R_FROM:
00f100 ff02          .dw $ff02
00f101 3e72          .db "r>"
00f102 f0f9          .dw VE_HEAD
                     .set VE_HEAD = VE_R_FROM
                 XT_R_FROM:
00f103 f104          .dw PFA_R_FROM
                 PFA_R_FROM:
00f104 939a
00f105 938a          savetos
00f106 918f          pop tosl
00f107 919f          pop tosh
00f108 cefc          jmp_ DO_NEXT
                 .include "words/to_r.asm"
                 
                 ; Stack
                 ; move TOS to TOR
                 VE_TO_R:
00f109 ff02          .dw $ff02
00f10a 723e          .db ">r"
00f10b f100          .dw VE_HEAD
                     .set VE_HEAD = VE_TO_R
                 XT_TO_R:
00f10c f10d          .dw PFA_TO_R
                 PFA_TO_R:
00f10d 939f          push tosh
00f10e 938f          push tosl
00f10f 9189
00f110 9199          loadtos
00f111 cef3          jmp_ DO_NEXT
                 .include "words/r_fetch.asm"
                 
                 ; Stack
                 ; fetch content of TOR
                 VE_R_FETCH:
00f112 ff02          .dw $ff02
00f113 4072          .db "r@"
00f114 f109          .dw VE_HEAD
                     .set VE_HEAD = VE_R_FETCH
                 XT_R_FETCH:
00f115 f116          .dw PFA_R_FETCH
                 PFA_R_FETCH:
00f116 939a
00f117 938a          savetos
00f118 918f          pop tosl
00f119 919f          pop tosh
00f11a 939f          push tosh
00f11b 938f          push tosl
00f11c cee8          jmp_ DO_NEXT
                 
                 
                 .include "words/not-equal.asm"
                 
                 ; Compare
                 ; true if n1 is not equal to n2
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_NOTEQUAL:
00f11d ff02          .dw $ff02
00f11e 3e3c          .db "<>"
00f11f f112          .dw VE_HEAD
                     .set VE_HEAD = VE_NOTEQUAL
                 XT_NOTEQUAL:
00f120 f001          .dw DO_COLON
                 PFA_NOTEQUAL:
                 .endif
                 
00f121 fd8d
00f122 f127
00f123 f021          .DW XT_EQUAL,XT_ZEROEQUAL,XT_EXIT
                 .include "words/equalzero.asm"
                 
                 ; Compare
                 ; compare with 0 (zero)
                 VE_ZEROEQUAL:
00f124 ff02          .dw $ff02
00f125 3d30          .db "0="
00f126 f11d          .dw VE_HEAD
                     .set VE_HEAD = VE_ZEROEQUAL
                 XT_ZEROEQUAL:
00f127 f128          .dw PFA_ZEROEQUAL
                 PFA_ZEROEQUAL:
00f128 2b98          or tosh, tosl
00f129 f5d1          brne PFA_ZERO1
00f12a c030          rjmp PFA_TRUE1
                 .include "words/lesszero.asm"
                 
                 ; Compare
                 ; compare with zero
                 VE_ZEROLESS:
00f12b ff02          .dw $ff02
00f12c 3c30          .db "0<"
00f12d f124          .dw VE_HEAD
                     .set VE_HEAD = VE_ZEROLESS
                 XT_ZEROLESS:
00f12e f12f          .dw PFA_ZEROLESS
                 PFA_ZEROLESS:
00f12f fd97          sbrc tosh,7
00f130 c02a          rjmp PFA_TRUE1
00f131 c032          rjmp PFA_ZERO1
                 .include "words/greaterzero.asm"
                 
                 ; Compare
                 ; true if n1 is greater than 0
                 VE_GREATERZERO:
00f132 ff02          .dw $ff02
00f133 3e30          .db "0>"
00f134 f12b          .dw VE_HEAD
                     .set VE_HEAD = VE_GREATERZERO
                 XT_GREATERZERO:
00f135 f136          .dw PFA_GREATERZERO
                 PFA_GREATERZERO:
00f136 1582          cp tosl, zerol
00f137 0593          cpc tosh, zeroh
00f138 f15c          brlt PFA_ZERO1
00f139 f151          brbs 1, PFA_ZERO1
00f13a c020          rjmp PFA_TRUE1
                 .include "words/d-greaterzero.asm"
                 
                 ; Compare
                 ; compares if a double double cell number is greater 0
                 VE_DGREATERZERO:
00f13b ff03          .dw $ff03
00f13c 3064
00f13d 003e          .db "d0>",0
00f13e f132          .dw VE_HEAD
                     .set VE_HEAD = VE_DGREATERZERO
                 XT_DGREATERZERO:
00f13f f140          .dw PFA_DGREATERZERO
                 PFA_DGREATERZERO:
00f140 1582          cp tosl, zerol
00f141 0593          cpc tosh, zeroh
00f142 9189
00f143 9199          loadtos
00f144 0582          cpc tosl, zerol
00f145 0593          cpc tosh, zeroh
00f146 f0ec          brlt PFA_ZERO1
00f147 f0e1          brbs 1, PFA_ZERO1
00f148 c012          rjmp PFA_TRUE1
                 .include "words/d-lesszero.asm"
                 
                 ; Compare
                 ; compares if a double double cell number is less than 0
                 VE_DXT_ZEROLESS:
00f149 ff03          .dw $ff03
00f14a 3064
00f14b 003c          .db "d0<",0
00f14c f13b          .dw VE_HEAD
                     .set VE_HEAD = VE_DXT_ZEROLESS
                 XT_DXT_ZEROLESS:
00f14d f14e          .dw PFA_DXT_ZEROLESS
                 PFA_DXT_ZEROLESS:
00f14e 9622          adiw Y,2
00f14f fd97          sbrc tosh,7
00f150 940c f15b     jmp PFA_TRUE1
00f152 940c f164     jmp PFA_ZERO1
                 
                 .include "words/true.asm"
                 
                 ; Arithmetics
                 ; leaves the value -1 (true) on TOS
                 VE_TRUE:
00f154 ff04          .dw $ff04
00f155 7274
00f156 6575          .db "true"
00f157 f149          .dw VE_HEAD
                     .set VE_HEAD = VE_TRUE
                 XT_TRUE:
00f158 f159          .dw PFA_TRUE
                 PFA_TRUE:
00f159 939a
00f15a 938a          savetos
                 PFA_TRUE1:
00f15b ef8f          ser tosl
00f15c ef9f          ser tosh
00f15d cea7          jmp_ DO_NEXT
                 .include "words/zero.asm"
                 
                 ; Arithmetics
                 ; place a value 0 on TOS
                 VE_ZERO:
00f15e ff01          .dw $ff01
00f15f 0030          .db "0",0
00f160 f154          .dw VE_HEAD
                     .set VE_HEAD = VE_ZERO
                 XT_ZERO:
00f161 f162          .dw PFA_ZERO
                 PFA_ZERO:
00f162 939a
00f163 938a          savetos
                 PFA_ZERO1:
00f164 01c1          movw tosl, zerol
00f165 ce9f          jmp_ DO_NEXT
                 .include "words/uless.asm"
                 
                 ; Compare
                 ; true if u1 < u2 (unsigned)
                 VE_ULESS:
00f166 ff02          .dw $ff02
00f167 3c75          .db "u<"
00f168 f15e          .dw VE_HEAD
                     .set VE_HEAD = VE_ULESS
                 XT_ULESS:
00f169 f16a          .dw PFA_ULESS
                 PFA_ULESS:
00f16a 9129          ld temp2, Y+
00f16b 9139          ld temp3, Y+
00f16c 1782          cp tosl, temp2
00f16d 0793          cpc tosh, temp3
00f16e f3a8          brlo PFA_ZERO1
00f16f f3a1          brbs 1, PFA_ZERO1
00f170 cfea          jmp_ PFA_TRUE1
                 .include "words/u-greater.asm"
                 
                 ; Compare
                 ; true if u1 > u2 (unsigned)
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_UGREATER:
00f171 ff02          .dw $ff02
00f172 3e75          .db "u>"
00f173 f166          .dw VE_HEAD
                     .set VE_HEAD = VE_UGREATER
                 XT_UGREATER:
00f174 f001          .dw DO_COLON
                 PFA_UGREATER:
                 .endif
00f175 f0d1          .DW XT_SWAP
00f176 f169          .dw XT_ULESS
00f177 f021          .dw XT_EXIT
                 .include "words/less.asm"
                 
                 ; Compare
                 ; true if n1 is less than n2
                     VE_LESS:
00f178 ff01          .dw $ff01
00f179 003c          .db "<",0
00f17a f171          .dw VE_HEAD
                     .set VE_HEAD = VE_LESS
                 XT_LESS:
00f17b f17c          .dw PFA_LESS
                 PFA_LESS:
00f17c 9129          ld temp2, Y+
00f17d 9139          ld temp3, Y+
00f17e 1728          cp temp2, tosl
00f17f 0739          cpc temp3, tosh
                 PFA_LESSDONE:
00f180 f71c          brge PFA_ZERO1
00f181 cfd9          rjmp PFA_TRUE1
                 .include "words/greater.asm"
                 
                 ; Compare
                 ; flag is true if n1 is greater than n2
                 VE_GREATER:
00f182 ff01          .dw $ff01
00f183 003e          .db ">",0
00f184 f178          .dw VE_HEAD
                     .set VE_HEAD = VE_GREATER
                 XT_GREATER:
00f185 f186          .dw PFA_GREATER
                 PFA_GREATER:
00f186 9129          ld temp2, Y+
00f187 9139          ld temp3, Y+
00f188 1728          cp temp2, tosl
00f189 0739          cpc temp3, tosh
                 PFA_GREATERDONE:
00f18a f2cc          brlt PFA_ZERO1
00f18b f2c1          brbs 1, PFA_ZERO1
00f18c cfce          rjmp PFA_TRUE1
                 
                 .include "words/log2.asm"
                 
                 ; Arithmetics
                 ; logarithm to base 2 or highest set bitnumber
                 VE_LOG2:
00f18d ff04          .dw $ff04
00f18e 6f6c
00f18f 3267          .db "log2"
00f190 f182          .dw VE_HEAD
                     .set VE_HEAD = VE_LOG2
                 XT_LOG2:
00f191 f192          .dw PFA_LOG2
                 PFA_LOG2:
00f192 01fc          movw zl, tosl
00f193 2799          clr tosh
00f194 e180          ldi tosl, 16
                 PFA_LOG2_1:
00f195 958a          dec tosl
00f196 f022          brmi PFA_LOG2_2 ; wrong data
00f197 0fee          lsl  zl
00f198 1fff          rol  zh
00f199 f7d8          brcc PFA_LOG2_1
00f19a ce6a          jmp_ DO_NEXT
                 
                 PFA_LOG2_2:
00f19b 959a          dec tosh
00f19c ce68          jmp_ DO_NEXT
                 .include "words/minus.asm"
                 
                 ; Arithmetics
                 ; subtract n2 from n1
                 VE_MINUS:
00f19d ff01          .dw $ff01
00f19e 002d          .db "-",0
00f19f f18d          .dw VE_HEAD
                     .set VE_HEAD = VE_MINUS
                 XT_MINUS:
00f1a0 f1a1          .dw PFA_MINUS
                 PFA_MINUS:
00f1a1 9109          ld temp0, Y+
00f1a2 9119          ld temp1, Y+
00f1a3 1b08          sub temp0, tosl
00f1a4 0b19          sbc temp1, tosh
00f1a5 01c8          movw tosl, temp0
00f1a6 ce5e          jmp_ DO_NEXT
                 .include "words/plus.asm"
                 
                 ; Arithmetics
                 ; add n1 and n2
                 VE_PLUS:
00f1a7 ff01          .dw $ff01
00f1a8 002b          .db "+",0
00f1a9 f19d          .dw VE_HEAD
                     .set VE_HEAD = VE_PLUS
                 XT_PLUS:
00f1aa f1ab          .dw PFA_PLUS
                 PFA_PLUS:
00f1ab 9109          ld temp0, Y+
00f1ac 9119          ld temp1, Y+
00f1ad 0f80          add tosl, temp0
00f1ae 1f91          adc tosh, temp1
00f1af ce55          jmp_ DO_NEXT
                 .include "words/mstar.asm"
                 
                 ; Arithmetics
                 ; multiply 2 cells to a double cell
                 VE_MSTAR:
00f1b0 ff02          .dw $ff02
00f1b1 2a6d          .db "m*"
00f1b2 f1a7          .dw VE_HEAD
                     .set VE_HEAD = VE_MSTAR
                 XT_MSTAR:
00f1b3 f1b4          .dw PFA_MSTAR
                 PFA_MSTAR:
00f1b4 018c          movw temp0, tosl
00f1b5 9189
00f1b6 9199          loadtos
00f1b7 019c          movw temp2, tosl
                     ; high cell ah*bh
00f1b8 0231          muls temp3, temp1
00f1b9 0170          movw temp4, r0
                     ; low cell  al*bl
00f1ba 9f20          mul  temp2, temp0
00f1bb 01c0          movw tosl, r0
                     ; signed ah*bl
00f1bc 0330          mulsu temp3, temp0
00f1bd 08f3          sbc   temp5, zeroh
00f1be 0d90          add   tosh,  r0
00f1bf 1ce1          adc   temp4, r1
00f1c0 1cf3          adc   temp5, zeroh
                     
                     ; signed al*bh
00f1c1 0312          mulsu temp1, temp2
00f1c2 08f3          sbc   temp5, zeroh
00f1c3 0d90          add   tosh,  r0
00f1c4 1ce1          adc   temp4, r1
00f1c5 1cf3          adc   temp5, zeroh
                 
00f1c6 939a
00f1c7 938a          savetos
00f1c8 01c7          movw tosl, temp4
00f1c9 ce3b          jmp_ DO_NEXT
                 .include "words/umslashmod.asm"
                 
                 ; Arithmetics
                 ; unsigned division ud / u2 with remainder
                 VE_UMSLASHMOD:
00f1ca ff06          .dw $ff06
00f1cb 6d75
00f1cc 6d2f
00f1cd 646f          .db "um/mod"
00f1ce f1b0          .dw VE_HEAD
                     .set VE_HEAD = VE_UMSLASHMOD
                 XT_UMSLASHMOD:
00f1cf f1d0          .dw PFA_UMSLASHMOD
                 PFA_UMSLASHMOD:
00f1d0 017c          movw temp4, tosl
                 
00f1d1 9129          ld temp2, Y+
00f1d2 9139          ld temp3, Y+
                   
00f1d3 9109          ld temp0, Y+
00f1d4 9119          ld temp1, Y+
                 
                 ;; unsigned 32/16 -> 16r16 divide
                 
                 PFA_UMSLASHMODmod:
                 
                   ; set loop counter
00f1d5 e140          ldi temp6,$10
                 
                 PFA_UMSLASHMODmod_loop:
                     ; shift left, saving high bit
00f1d6 2755          clr temp7
00f1d7 0f00          lsl temp0
00f1d8 1f11          rol temp1
00f1d9 1f22          rol temp2
00f1da 1f33          rol temp3
00f1db 1f55          rol temp7
                 
                   ; try subtracting divisor
00f1dc 152e          cp temp2, temp4
00f1dd 053f          cpc temp3, temp5
00f1de 0552          cpc temp7,zerol
                 
00f1df f018          brcs PFA_UMSLASHMODmod_loop_control
                 
                 PFA_UMSLASHMODmod_subtract:
                     ; dividend is large enough
                     ; do the subtraction for real
                     ; and set lowest bit
00f1e0 9503          inc temp0
00f1e1 192e          sub temp2, temp4
00f1e2 093f          sbc temp3, temp5
                 
                 PFA_UMSLASHMODmod_loop_control:
00f1e3 954a          dec  temp6
00f1e4 f789          brne PFA_UMSLASHMODmod_loop
                 
                 PFA_UMSLASHMODmod_done:
                     ; put remainder on stack
00f1e5 933a          st -Y,temp3
00f1e6 932a          st -Y,temp2
                 
                     ; put quotient on stack
00f1e7 01c8          movw tosl, temp0
00f1e8 ce1c          jmp_ DO_NEXT
                 .include "words/umstar.asm"
                 
                 ; Arithmetics
                 ; multiply 2 unsigned cells to a double cell
                 VE_UMSTAR:
00f1e9 ff03          .dw $ff03
00f1ea 6d75
00f1eb 002a          .db "um*",0
00f1ec f1ca          .dw VE_HEAD
                     .set VE_HEAD = VE_UMSTAR
                 XT_UMSTAR:
00f1ed f1ee          .dw PFA_UMSTAR
                 PFA_UMSTAR:
00f1ee 018c          movw temp0, tosl
00f1ef 9189
00f1f0 9199          loadtos
                     ; result: (temp3*temp1)* 65536 + (temp3*temp0 + temp1*temp2) * 256 + (temp0 * temp2)
                     ; low bytes
00f1f1 9f80          mul tosl,temp0
00f1f2 01f0          movw zl, r0
00f1f3 2722          clr temp2
00f1f4 2733          clr temp3
                     ; middle bytes
00f1f5 9f90          mul tosh, temp0
00f1f6 0df0          add zh, r0
00f1f7 1d21          adc temp2, r1
00f1f8 1d33          adc temp3, zeroh
                         
00f1f9 9f81          mul tosl, temp1
00f1fa 0df0          add zh, r0
00f1fb 1d21          adc temp2, r1
00f1fc 1d33          adc temp3, zeroh
                     
00f1fd 9f91          mul tosh, temp1
00f1fe 0d20          add temp2, r0
00f1ff 1d31          adc temp3, r1
00f200 01cf          movw tosl, zl
00f201 939a
00f202 938a          savetos
00f203 01c9          movw tosl, temp2
00f204 ce00          jmp_ DO_NEXT
                 
                 .include "words/invert.asm"
                 
                 ; Arithmetics
                 ; 1-complement of TOS
                 VE_INVERT:
00f205 ff06          .dw $ff06
00f206 6e69
00f207 6576
00f208 7472          .db "invert"
00f209 f1e9          .dw VE_HEAD
                     .set VE_HEAD = VE_INVERT
                 XT_INVERT:
00f20a f20b          .dw PFA_INVERT
                 PFA_INVERT:
00f20b 9580          com tosl
00f20c 9590          com tosh
00f20d cdf7          jmp_ DO_NEXT
                 .include "words/2slash.asm"
                 
                 ; Arithmetics
                 ; arithmetic shift right
                 VE_2SLASH:
00f20e ff02          .dw $ff02
00f20f 2f32          .db "2/"
00f210 f205          .dw VE_HEAD
                     .set VE_HEAD = VE_2SLASH
                 XT_2SLASH:
00f211 f212          .dw PFA_2SLASH
                 PFA_2SLASH:
00f212 9595          asr tosh
00f213 9587          ror tosl
00f214 cdf0          jmp_ DO_NEXT
                 .include "words/2star.asm"
                 
                 ; Arithmetics
                 ; arithmetic shift left, filling with zero
                 VE_2STAR:
00f215 ff02          .dw $ff02
00f216 2a32          .db "2*"
00f217 f20e          .dw VE_HEAD
                     .set VE_HEAD = VE_2STAR
                 XT_2STAR:
00f218 f219          .dw PFA_2STAR
                 PFA_2STAR:
00f219 0f88          lsl tosl
00f21a 1f99          rol tosh
00f21b cde9          jmp_ DO_NEXT
                 .include "words/and.asm"
                 
                 ; Logic
                 ; bitwise and
                 VE_AND:
00f21c ff03          .dw $ff03
00f21d 6e61
00f21e 0064          .db "and",0
00f21f f215          .dw VE_HEAD
                     .set VE_HEAD = VE_AND
                 XT_AND:
00f220 f221          .dw PFA_AND
                 PFA_AND:
00f221 9109          ld temp0, Y+
00f222 9119          ld temp1, Y+
00f223 2380          and tosl, temp0
00f224 2391          and tosh, temp1
00f225 cddf          jmp_ DO_NEXT
                 .include "words/or.asm"
                 
                 ; Logic
                 ; logical or
                 VE_OR:
00f226 ff02          .dw $ff02
00f227 726f          .db "or"
00f228 f21c          .dw VE_HEAD
                     .set VE_HEAD = VE_OR
                 XT_OR:
00f229 f22a          .dw PFA_OR
                 PFA_OR:
00f22a 9109          ld temp0, Y+
00f22b 9119          ld temp1, Y+
00f22c 2b80          or tosl, temp0
00f22d 2b91          or tosh, temp1
00f22e cdd6          jmp_ DO_NEXT
                 
                 .include "words/xor.asm"
                 
                 ; Logic
                 ; exclusive or
                 VE_XOR:
00f22f ff03          .dw $ff03
00f230 6f78
00f231 0072          .db "xor",0
00f232 f226          .dw VE_HEAD
                     .set VE_HEAD = VE_XOR
                 XT_XOR:
00f233 f234          .dw PFA_XOR
                 PFA_XOR:
00f234 9109          ld temp0, Y+
00f235 9119          ld temp1, Y+
00f236 2780          eor tosl, temp0
00f237 2791          eor tosh, temp1
00f238 cdcc          jmp_ DO_NEXT
                 
                 .include "words/1plus.asm"
                 
                 ; Arithmetics
                 ; optimized increment
                 VE_1PLUS:
00f239 ff02          .dw $ff02
00f23a 2b31          .db "1+"
00f23b f22f          .dw VE_HEAD
                     .set VE_HEAD = VE_1PLUS
                 XT_1PLUS:
00f23c f23d          .dw PFA_1PLUS
                 PFA_1PLUS:
00f23d 9601          adiw tosl,1
00f23e cdc6          jmp_ DO_NEXT
                 .include "words/1minus.asm"
                 
                 ; Arithmetics
                 ; optimized decrement
                 VE_1MINUS:
00f23f ff02          .dw $ff02 
00f240 2d31          .db "1-"
00f241 f239          .dw VE_HEAD
                     .set VE_HEAD = VE_1MINUS
                 XT_1MINUS:
00f242 f243          .dw PFA_1MINUS
                 PFA_1MINUS:
00f243 9701          sbiw tosl, 1
00f244 cdc0          jmp_ DO_NEXT
                 .include "words/lshift.asm"
                 
                 ; Arithmetics
                 ; logically shift n1 left n2 times
                 VE_LSHIFT:
00f245 ff06          .dw $ff06
00f246 736c
00f247 6968
00f248 7466          .db "lshift"
00f249 f23f          .dw VE_HEAD
                     .set VE_HEAD = VE_LSHIFT
                 XT_LSHIFT:
00f24a f24b          .dw PFA_LSHIFT
                 PFA_LSHIFT:
00f24b 01fc          movw zl, tosl
00f24c 9189
00f24d 9199          loadtos
                 PFA_LSHIFT1:
00f24e 9731          sbiw zl, 1
00f24f f01a          brmi PFA_LSHIFT2
00f250 0f88          lsl tosl
00f251 1f99          rol tosh
00f252 cffb          rjmp PFA_LSHIFT1
                 PFA_LSHIFT2:
00f253 cdb1          jmp_ DO_NEXT
                 
                 .include "words/rshift.asm"
                 
                 ; Arithmetics
                 ; shift n1 n2-times logically right
                 VE_RSHIFT:
00f254 ff06          .dw $ff06
00f255 7372
00f256 6968
00f257 7466          .db "rshift"
00f258 f245          .dw VE_HEAD
                     .set VE_HEAD = VE_RSHIFT
                 XT_RSHIFT:
00f259 f25a          .dw PFA_RSHIFT
                 PFA_RSHIFT:
00f25a 01fc          movw zl, tosl
00f25b 9189
00f25c 9199          loadtos
                 PFA_RSHIFT1:
00f25d 9731          sbiw zl, 1
00f25e f01a          brmi PFA_RSHIFT2
00f25f 9596          lsr tosh
00f260 9587          ror tosl
00f261 cffb          rjmp PFA_RSHIFT1
                 PFA_RSHIFT2:
00f262 cda2          jmp_ DO_NEXT
                 
                 .include "words/plusstore.asm"
                 
                 ; Arithmetics
                 ; add n to content of RAM address a-addr
                 VE_PLUSSTORE:
00f263 ff02          .dw $ff02
00f264 212b          .db "+!"
00f265 f254          .dw VE_HEAD
                     .set VE_HEAD = VE_PLUSSTORE
                 XT_PLUSSTORE:
00f266 f267          .dw PFA_PLUSSTORE
                 PFA_PLUSSTORE:
00f267 01fc          movw zl, tosl
00f268 9189
00f269 9199          loadtos
00f26a 8120          ldd temp2, Z+0
00f26b 8131          ldd temp3, Z+1
00f26c 0f82          add tosl, temp2
00f26d 1f93          adc tosh, temp3
00f26e 8380          std Z+0, tosl
00f26f 8391          std Z+1, tosh
00f270 9189
00f271 9199          loadtos
00f272 cd92          jmp_ DO_NEXT
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/rpfetch.asm"
                 
                 ; Stack
                 ; current return stack pointer address
                 VE_RP_FETCH:
00f273 ff03          .dw $ff03
00f274 7072
00f275 0040          .db "rp@",0
00f276 f263          .dw VE_HEAD
                     .set VE_HEAD = VE_RP_FETCH
                 XT_RP_FETCH:
00f277 f278          .dw PFA_RP_FETCH
                 PFA_RP_FETCH:
00f278 939a
00f279 938a          savetos
00f27a b78d          in tosl, SPL
00f27b b79e          in tosh, SPH
00f27c cd88          jmp_ DO_NEXT
                 .include "words/rpstore.asm"
                 
                 ; Stack
                 ; set return stack pointer
                 VE_RP_STORE:
00f27d ff03          .dw $ff03
00f27e 7072
00f27f 0021          .db "rp!",0
00f280 f273          .dw VE_HEAD
                     .set VE_HEAD = VE_RP_STORE
                 XT_RP_STORE:
00f281 f282          .dw PFA_RP_STORE
                 PFA_RP_STORE:
00f282 b72f          in temp2, SREG
00f283 94f8          cli
00f284 bf8d          out SPL, tosl
00f285 bf9e          out SPH, tosh
00f286 bf2f          out SREG, temp2
00f287 9189
00f288 9199          loadtos
00f289 cd7b          jmp_ DO_NEXT
                 .include "words/spfetch.asm"
                 
                 ; Stack
                 ; current data stack pointer
                 VE_SP_FETCH:
00f28a ff03          .dw $ff03
00f28b 7073
00f28c 0040          .db "sp@",0
00f28d f27d          .dw VE_HEAD
                     .set VE_HEAD = VE_SP_FETCH
                 XT_SP_FETCH:
00f28e f28f          .dw PFA_SP_FETCH
                 PFA_SP_FETCH:
00f28f 939a
00f290 938a          savetos
00f291 01ce          movw tosl, yl
00f292 cd72          jmp_ DO_NEXT
                 .include "words/spstore.asm"
                 
                 ; Stack
                 ; set data stack pointer to addr
                 VE_SP_STORE:
00f293 ff03          .dw $ff03
00f294 7073
00f295 0021          .db "sp!",0
00f296 f28a          .dw VE_HEAD
                     .set VE_HEAD = VE_SP_STORE
                 XT_SP_STORE:
00f297 f298          .dw PFA_SP_STORE
                 PFA_SP_STORE:
00f298 01ec          movw yl, tosl
00f299 9189
00f29a 9199          loadtos
00f29b cd69          jmp_ DO_NEXT
                 
                 .include "words/dodo.asm"
                 
                 ; System
                 ; runtime of do
                 ;VE_DODO:
                 ;    .dw $ff04
                 ;    .db "(do)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DODO
                 XT_DODO:
00f29c f29d          .dw PFA_DODO
                 PFA_DODO:
00f29d 9129          ld temp2, Y+
00f29e 9139          ld temp3, Y+  ; limit
                 PFA_DODO1:
00f29f e8e0          ldi zl, $80
00f2a0 0f3e          add temp3, zl
00f2a1 1b82          sub  tosl, temp2
00f2a2 0b93          sbc  tosh, temp3
                 
00f2a3 933f          push temp3
00f2a4 932f          push temp2    ; limit  ( --> limit + $8000)
00f2a5 939f          push tosh
00f2a6 938f          push tosl     ; start -> index ( --> index - (limit - $8000)
00f2a7 9189
00f2a8 9199          loadtos
00f2a9 cd5b          jmp_ DO_NEXT
                 .include "words/i.asm"
                 
                 ; Compiler
                 ; current loop counter
                 VE_I:
00f2aa ff01          .dw $FF01
00f2ab 0069          .db "i",0
00f2ac f293          .dw VE_HEAD
                     .set VE_HEAD = VE_I
                 XT_I:
00f2ad f2ae          .dw PFA_I
                 PFA_I:
00f2ae 939a
00f2af 938a          savetos
00f2b0 918f          pop tosl
00f2b1 919f          pop tosh  ; index
00f2b2 91ef          pop zl
00f2b3 91ff          pop zh    ; limit
00f2b4 93ff          push zh
00f2b5 93ef          push zl
00f2b6 939f          push tosh
00f2b7 938f          push tosl
00f2b8 0f8e          add tosl, zl
00f2b9 1f9f          adc tosh, zh
00f2ba cd4a          jmp_ DO_NEXT
                 .include "words/doplusloop.asm"
                 
                 ; System
                 ; runtime of +loop
                 ;VE_DOPLUSLOOP:
                 ;    .dw $ff07
                 ;    .db "(+loop)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOPLUSLOOP
                 XT_DOPLUSLOOP:
00f2bb f2bc          .dw PFA_DOPLUSLOOP
                 PFA_DOPLUSLOOP:
00f2bc 91ef          pop zl
00f2bd 91ff          pop zh
00f2be 0fe8          add zl, tosl
00f2bf 1ff9          adc zh, tosh
00f2c0 9189
00f2c1 9199          loadtos
00f2c2 f01b          brvs PFA_DOPLUSLOOP_LEAVE
                     ; next cycle
                 PFA_DOPLUSLOOP_NEXT:
                     ; next iteration
00f2c3 93ff          push zh
00f2c4 93ef          push zl
00f2c5 cd6b          rjmp PFA_DOBRANCH ; read next cell from dictionary and jump to its destination
                 PFA_DOPLUSLOOP_LEAVE:
00f2c6 910f          pop  temp0
00f2c7 911f          pop  temp1  ; remove limit
00f2c8 9611          adiw xl, 1  ; skip branch-back address
00f2c9 cd3b          jmp_ DO_NEXT
                 .include "words/doloop.asm"
                 
                 ; System
                 ; runtime of loop
                 ;VE_DOLOOP:
                 ;    .dw $ff06
                 ;    .db "(loop)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOLOOP
                 XT_DOLOOP:
00f2ca f2cb          .dw PFA_DOLOOP
                 PFA_DOLOOP:
00f2cb 91ef          pop zl
00f2cc 91ff          pop zh
00f2cd 9631          adiw zl,1
00f2ce f3bb          brvs PFA_DOPLUSLOOP_LEAVE
00f2cf cff3          jmp_ PFA_DOPLUSLOOP_NEXT
                 .include "words/unloop.asm"
                 
                 ; Compiler
                 ; remove loop-sys, exit the loop and continue execution after it
                 VE_UNLOOP:
00f2d0 ff06          .dw $ff06
00f2d1 6e75
00f2d2 6f6c
00f2d3 706f          .db "unloop"
00f2d4 f2aa          .dw VE_HEAD
                     .set VE_HEAD = VE_UNLOOP
                 XT_UNLOOP:
00f2d5 f2d6          .dw PFA_UNLOOP
                 PFA_UNLOOP:
00f2d6 911f          pop temp1
00f2d7 910f          pop temp0
00f2d8 911f          pop temp1
00f2d9 910f          pop temp0
00f2da cd2a          jmp_ DO_NEXT
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 
                 .include "words/cmove_g.asm"
                 
                 ; Memory
                 ; copy data in RAM from higher to lower addresses.
                 VE_CMOVE_G:
00f2db ff06          .dw $ff06
00f2dc 6d63
00f2dd 766f
00f2de 3e65          .db "cmove>"
00f2df f2d0          .dw VE_HEAD
                     .set VE_HEAD  = VE_CMOVE_G
                 XT_CMOVE_G:
00f2e0 f2e1          .dw PFA_CMOVE_G
                 PFA_CMOVE_G:
00f2e1 93bf          push xh
00f2e2 93af          push xl
00f2e3 91e9          ld zl, Y+
00f2e4 91f9          ld zh, Y+ ; addr-to
00f2e5 91a9          ld xl, Y+
00f2e6 91b9          ld xh, Y+ ; addr-from
00f2e7 2f09          mov temp0, tosh
00f2e8 2b08          or temp0, tosl
00f2e9 f041          brbs 1, PFA_CMOVE_G1
00f2ea 0fe8          add zl, tosl
00f2eb 1ff9          adc zh, tosh
00f2ec 0fa8          add xl, tosl
00f2ed 1fb9          adc xh, tosh
                 PFA_CMOVE_G2:
00f2ee 911e          ld temp1, -X
00f2ef 9312          st -Z, temp1
00f2f0 9701          sbiw tosl, 1
00f2f1 f7e1          brbc 1, PFA_CMOVE_G2
                 PFA_CMOVE_G1:
00f2f2 91af          pop xl
00f2f3 91bf          pop xh
00f2f4 9189
00f2f5 9199          loadtos
00f2f6 cd0e          jmp_ DO_NEXT
                 .include "words/byteswap.asm"
                 
                 ; Arithmetics
                 ; exchange the bytes of the TOS
                 VE_BYTESWAP:
00f2f7 ff02          .dw $ff02
00f2f8 3c3e          .db "><"
00f2f9 f2db          .dw VE_HEAD
                     .set VE_HEAD = VE_BYTESWAP
                 XT_BYTESWAP:
00f2fa f2fb          .dw PFA_BYTESWAP
                 PFA_BYTESWAP:
00f2fb 2f09          mov temp0, tosh
00f2fc 2f98          mov tosh, tosl
00f2fd 2f80          mov tosl, temp0
00f2fe cd06          jmp_ DO_NEXT
                 .include "words/up.asm"
                 
                 ; System Variable
                 ; get user area pointer
                 VE_UP_FETCH:
00f2ff ff03          .dw $ff03
00f300 7075
00f301 0040          .db "up@",0
00f302 f2f7          .dw VE_HEAD
                     .set VE_HEAD = VE_UP_FETCH
                 XT_UP_FETCH:
00f303 f304          .dw PFA_UP_FETCH
                 PFA_UP_FETCH:
00f304 939a
00f305 938a          savetos
00f306 01c2          movw tosl, upl
00f307 ccfd          jmp_ DO_NEXT
                 
                 ; ( addr -- ) 
                 ; System Variable
                 ; set user area pointer
                 VE_UP_STORE:
00f308 ff03          .dw $ff03
00f309 7075
00f30a 0021          .db "up!",0
00f30b f2ff          .dw VE_HEAD
                     .set VE_HEAD = VE_UP_STORE
                 XT_UP_STORE:
00f30c f30d          .dw PFA_UP_STORE
                 PFA_UP_STORE:
00f30d 012c          movw upl, tosl
00f30e 9189
00f30f 9199          loadtos
00f310 ccf4          jmp_ DO_NEXT
                 .include "words/1ms.asm"
                 
                 ; Time
                 ; busy waits (almost) exactly 1 millisecond
                 VE_1MS:
00f311 ff03          .dw $ff03
00f312 6d31
00f313 0073          .db "1ms",0
00f314 f308          .dw VE_HEAD
                     .set VE_HEAD = VE_1MS
                 XT_1MS:
00f315 f316          .dw PFA_1MS
                 PFA_1MS:
00f316 eae0
00f317 e0ff
00f318 9731
00f319 f7f1          delay 1000
00f31a ccea          jmp_ DO_NEXT
                 .include "words/2to_r.asm"
                 
                 ; Stack
                 ; move DTOS to TOR
                 VE_2TO_R:
00f31b ff03          .dw $ff03
00f31c 3e32
00f31d 0072          .db "2>r",0
00f31e f311          .dw VE_HEAD
                     .set VE_HEAD = VE_2TO_R
                 XT_2TO_R:
00f31f f320          .dw PFA_2TO_R
                 PFA_2TO_R:
00f320 01fc          movw zl, tosl
00f321 9189
00f322 9199          loadtos
00f323 939f          push tosh
00f324 938f          push tosl
00f325 93ff          push zh
00f326 93ef          push zl
00f327 9189
00f328 9199          loadtos
00f329 ccdb          jmp_ DO_NEXT
                 .include "words/2r_from.asm"
                 
                 ; Stack
                 ; move DTOR to TOS
                 VE_2R_FROM:
00f32a ff03          .dw $ff03
00f32b 7232
00f32c 003e          .db "2r>",0
00f32d f31b          .dw VE_HEAD
                     .set VE_HEAD = VE_2R_FROM
                 XT_2R_FROM:
00f32e f32f          .dw PFA_2R_FROM
                 PFA_2R_FROM:
00f32f 939a
00f330 938a          savetos
00f331 91ef          pop zl
00f332 91ff          pop zh
00f333 918f          pop tosl
00f334 919f          pop tosh
00f335 939a
00f336 938a          savetos
00f337 01cf          movw tosl, zl
00f338 cccc          jmp_ DO_NEXT
                 
                 .include "words/store-e.asm"
                 
                 ; Memory
                 ; write n (2bytes) to eeprom address
                 VE_STOREE:
00f339 ff02          .dw $ff02
00f33a 6521          .db "!e"
00f33b f32a          .dw VE_HEAD
                     .set VE_HEAD = VE_STOREE
                 XT_STOREE:
00f33c f33d          .dw PFA_STOREE
                 PFA_STOREE:
                 .if WANT_UNIFIED == 1
                 .endif
                 PFA_STOREE0:
00f33d 01fc          movw zl, tosl
00f33e 9189
00f33f 9199          loadtos
00f340 b72f          in_ temp2, SREG
00f341 94f8          cli
00f342 d028          rcall PFA_FETCHE2
00f343 b500          in_  temp0, EEDR
00f344 1708          cp temp0,tosl
00f345 f009          breq PFA_STOREE3
00f346 d00b          rcall PFA_STOREE1
                 PFA_STOREE3:
00f347 9631          adiw zl,1
00f348 d022          rcall PFA_FETCHE2
00f349 b500          in_  temp0, EEDR
00f34a 1709          cp temp0,tosh
00f34b f011          breq PFA_STOREE4
00f34c 2f89          mov tosl, tosh
00f34d d004          rcall PFA_STOREE1
                 PFA_STOREE4:
00f34e bf2f          out_ SREG, temp2
00f34f 9189
00f350 9199          loadtos
00f351 ccb3          jmp_ DO_NEXT
                     
                 PFA_STOREE1:
00f352 99f9          sbic EECR, EEPE
00f353 cffe          rjmp PFA_STOREE1
                 
                 PFA_STOREE2: ; estore_wait_low_spm:
00f354 b707          in_ temp0, SPMCSR
00f355 fd00          sbrc temp0,SPMEN
00f356 cffd          rjmp PFA_STOREE2
                 
00f357 bdf2          out_ EEARH,zh
00f358 bde1          out_ EEARL,zl
00f359 bd80          out_ EEDR, tosl
00f35a 9afa          sbi EECR,EEMPE
00f35b 9af9          sbi EECR,EEPE
                 
00f35c 9508          ret
                 .if WANT_UNIFIED == 1
                 .endif
                 .include "words/fetch-e.asm"
                 
                 ; Memory
                 ; read 1 cell from eeprom
                 VE_FETCHE:
00f35d ff02          .dw $ff02
00f35e 6540          .db "@e"
00f35f f339          .dw VE_HEAD
                     .set VE_HEAD = VE_FETCHE
                 XT_FETCHE:
00f360 f361          .dw PFA_FETCHE
                 PFA_FETCHE:
                 .if WANT_UNIFIED == 1
                 .endif
                 PFA_FETCHE1:
00f361 b72f          in_ temp2, SREG
00f362 94f8          cli
00f363 01fc          movw zl, tosl
00f364 d006          rcall PFA_FETCHE2
00f365 b580          in_ tosl, EEDR
                 
00f366 9631          adiw zl,1
                 
00f367 d003          rcall PFA_FETCHE2
00f368 b590          in_  tosh, EEDR
00f369 bf2f          out_ SREG, temp2
00f36a cc9a          jmp_ DO_NEXT
                 
                 PFA_FETCHE2:
00f36b 99f9          sbic EECR, EEPE
00f36c cffe          rjmp PFA_FETCHE2
                 
00f36d bdf2          out_ EEARH,zh
00f36e bde1          out_ EEARL,zl
                 
00f36f 9af8          sbi EECR,EERE
00f370 9508          ret
                 
                 .if WANT_UNIFIED == 1
                 .endif
                 .include "words/store-i.asm"
                 
                 ; System Value
                 ; Deferred action to write a single 16bit cell to flash
                 VE_STOREI:
00f371 ff02          .dw $ff02
00f372 6921          .db "!i"
00f373 f35d          .dw VE_HEAD
                     .set VE_HEAD = VE_STOREI
                 XT_STOREI:
00f374 fc21          .dw PFA_DODEFER1
                 PFA_STOREI:
00f375 0050          .dw EE_STOREI
00f376 fbc2          .dw XT_EDEFERFETCH
00f377 fbcc          .dw XT_EDEFERSTORE
                 .if FLASHEND > $10000
                 .else
                   .include "words/store-i_nrww.asm"
                 
                 ; Memory
                 ; writes n to flash memory using assembly code (code to be placed in boot loader section)
                 VE_DO_STOREI_NRWW:
00f378 ff09          .dw $ff09
00f379 2128
00f37a 2d69
00f37b 726e
00f37c 7777
00f37d 0029          .db "(!i-nrww)",0
00f37e f371          .dw VE_HEAD
                     .set VE_HEAD = VE_DO_STOREI_NRWW
                 XT_DO_STOREI:
00f37f f380          .dw PFA_DO_STOREI_NRWW
                 PFA_DO_STOREI_NRWW:
                   ; store status register
00f380 b71f        in temp1,SREG
00f381 931f        push temp1
00f382 94f8        cli
                 
00f383 019c        movw temp2, tosl ; save the (word) address
00f384 9189
00f385 9199        loadtos          ; get the new value for the flash cell
00f386 93af        push xl
00f387 93bf        push xh
00f388 93cf        push yl
00f389 93df        push yh
00f38a d009        rcall DO_STOREI_atmega
00f38b 91df        pop yh
00f38c 91cf        pop yl
00f38d 91bf        pop xh
00f38e 91af        pop xl
                   ; finally clear the stack
00f38f 9189
00f390 9199        loadtos
00f391 911f        pop temp1
                   ; restore status register (and interrupt enable flag)
00f392 bf1f        out SREG,temp1
                 
00f393 cc71        jmp_ DO_NEXT
                 
                 ; 
                 DO_STOREI_atmega:
                   ; write data to temp page buffer
                   ; use the values in tosl/tosh at the
                   ; appropiate place
00f394 d011        rcall pageload
                 
                   ; erase page if needed
                   ; it is needed if a bit goes from 0 to 1
00f395 94e0        com temp4
00f396 94f0        com temp5
00f397 218e        and tosl, temp4
00f398 219f        and tosh, temp5
00f399 2b98        or tosh, tosl
00f39a f021        breq DO_STOREI_writepage 
00f39b 94b3          inc erase_counter
00f39c 01f9          movw zl, temp2
00f39d e002          ldi temp0,(1<<PGERS)
00f39e d023          rcall dospm
                 
                 DO_STOREI_writepage:
                   ; write page
00f39f 01f9        movw zl, temp2
00f3a0 e004        ldi temp0,(1<<PGWRT)
00f3a1 d020        rcall dospm
                 
                   ; reenable RWW section
00f3a2 01f9        movw zl, temp2
00f3a3 e100        ldi temp0,(1<<RWWSRE)
00f3a4 d01d        rcall dospm
00f3a5 9508        ret
                 
                 ; load the desired page
                 .equ pagemask = ~ ( PAGESIZE - 1 )
                 pageload:
00f3a6 01f9        movw zl, temp2
                   ; get the beginning of page
00f3a7 78e0        andi zl,low(pagemask)
00f3a8 7fff        andi zh,high(pagemask)
00f3a9 01ef        movw y, z
                   ; loop counter (in words)
00f3aa e8a0        ldi xl,low(pagesize)
00f3ab e0b0        ldi xh,high(pagesize)
                 pageload_loop:
                   ; we need the current flash value anyways
00f3ac 01fe        movw z, y
00f3ad 2755
00f3ae 0fee
00f3af 1fff
00f3b0 1f55
00f3b1 bf5b
00f3b2 9147
00f3b3 9157        readflashcell temp6, temp7 ; destroys Z
                   ; now check: if Z points to the same cell as temp2/3, we want the new data
00f3b4 01fe        movw z, y
00f3b5 17e2        cp zl, temp2
00f3b6 07f3        cpc zh, temp3
00f3b7 f011        breq pageload_newdata
00f3b8 010a          movw r0, temp6
00f3b9 c002          rjmp pageload_cont
                 pageload_newdata:
00f3ba 017a          movw temp4, temp6
00f3bb 010c          movw r0, tosl
                 pageload_cont:
00f3bc 2700        clr temp0
00f3bd d004        rcall dospm
00f3be 9621        adiw y, 1
00f3bf 9711        sbiw x, 1
00f3c0 f759        brne pageload_loop
                 
                 pageload_done:
00f3c1 9508        ret
                 
                 
                 ;; dospm
                 ;;
                 ;; execute spm instruction
                 ;;   temp0 holds the value for SPMCR
                 
                 dospm:
                 dospm_wait_ee:
00f3c2 99f9        sbic EECR, EEPE
00f3c3 cffe        rjmp dospm_wait_ee
                 dospm_wait_spm:
00f3c4 b717        in_  temp1, SPMCSR
00f3c5 fd10        sbrc temp1, SPMEN
00f3c6 cffd        rjmp dospm_wait_spm
                 
                   ; turn the word addres into a byte address
00f3c7 2755
00f3c8 0fee
00f3c9 1fff
00f3ca 1f55
00f3cb bf5b        writeflashcell
                   ; execute spm
00f3cc 6001        ori temp0, (1<<SPMEN)
00f3cd bf07        out_ SPMCSR,temp0
00f3ce 95e8        spm
00f3cf 9508        ret
                 .endif
                 .include "words/fetch-i.asm"
                 
                 ; Memory
                 ; read 1 cell from flash
                 VE_FETCHI:
00f3d0 ff02          .dw $ff02
00f3d1 6940          .db "@i"
00f3d2 f378          .dw VE_HEAD
                     .set VE_HEAD = VE_FETCHI
                 XT_FETCHI:
00f3d3 f3d4          .dw PFA_FETCHI
                 PFA_FETCHI:
00f3d4 01fc          movw zl, tosl
00f3d5 2755
00f3d6 0fee
00f3d7 1fff
00f3d8 1f55
00f3d9 bf5b
00f3da 9187
00f3db 9197          readflashcell tosl,tosh
00f3dc cc28          jmp_ DO_NEXT
                 
                 .if AMFORTH_NRWW_SIZE>8000
                 .include "dict/core_8k.inc"
                 
                 .include "words/n_to_r.asm"
                 
                 ; Stack
                 ; move n items from data stack to return stack
                 VE_N_TO_R:
00f3dd ff03          .dw $ff03
00f3de 3e6e
00f3df 0072          .db "n>r",0
00f3e0 f3d0          .dw VE_HEAD
                     .set VE_HEAD = VE_N_TO_R
                 XT_N_TO_R:
00f3e1 f3e2          .dw PFA_N_TO_R
                 PFA_N_TO_R:
00f3e2 01fc          movw zl, tosl
00f3e3 2f08          mov  temp0, tosl
                 PFA_N_TO_R1:
00f3e4 9189
00f3e5 9199          loadtos
00f3e6 939f          push tosh
00f3e7 938f          push tosl
00f3e8 950a          dec temp0
00f3e9 f7d1          brne PFA_N_TO_R1
00f3ea 93ef          push zl
00f3eb 93ff          push zh
00f3ec 9189
00f3ed 9199          loadtos
00f3ee cc16          jmp_ DO_NEXT
                 .include "words/n_r_from.asm"
                 
                 ; Stack
                 ; move n items from return stack to data stack
                 VE_N_R_FROM:
00f3ef ff03          .dw $ff03
00f3f0 726e
00f3f1 003e          .db "nr>",0
00f3f2 f3dd          .dw VE_HEAD
                     .set VE_HEAD = VE_N_R_FROM
                 XT_N_R_FROM:
00f3f3 f3f4          .dw PFA_N_R_FROM
                 PFA_N_R_FROM:
00f3f4 939a
00f3f5 938a          savetos
00f3f6 91ff          pop zh
00f3f7 91ef          pop zl
00f3f8 2f0e          mov  temp0, zl
                 PFA_N_R_FROM1:
00f3f9 918f          pop tosl
00f3fa 919f          pop tosh
00f3fb 939a
00f3fc 938a          savetos
00f3fd 950a          dec temp0
00f3fe f7d1          brne PFA_N_R_FROM1
00f3ff 01cf          movw tosl, zl
00f400 cc04          jmp_ DO_NEXT
                 
                 .include "words/d-2star.asm"
                 
                 ; Arithmetics
                 ; shift a double cell left
                 VE_D2STAR:
00f401 ff03          .dw $ff03
00f402 3264
00f403 002a          .db "d2*",0
00f404 f3ef          .dw VE_HEAD
                     .set VE_HEAD = VE_D2STAR
                 XT_D2STAR:
00f405 f406          .dw PFA_D2STAR
                 PFA_D2STAR:
00f406 9109          ld temp0, Y+
00f407 9119          ld temp1, Y+
00f408 0f00          lsl temp0
00f409 1f11          rol temp1
00f40a 1f88          rol tosl
00f40b 1f99          rol tosh
00f40c 931a          st -Y, temp1
00f40d 930a          st -Y, temp0
00f40e cbf6          jmp_ DO_NEXT
                 .include "words/d-2slash.asm"
                 
                 ; Arithmetics
                 ; shift a double cell value right
                 VE_D2SLASH:
00f40f ff03          .dw $ff03
00f410 3264
00f411 002f          .db "d2/",0
00f412 f401          .dw VE_HEAD
                     .set VE_HEAD = VE_D2SLASH
                 XT_D2SLASH:
00f413 f414          .dw PFA_D2SLASH
                 PFA_D2SLASH:
00f414 9109          ld temp0, Y+
00f415 9119          ld temp1, Y+
00f416 9595          asr tosh
00f417 9587          ror tosl
00f418 9517          ror temp1
00f419 9507          ror temp0
00f41a 931a          st -Y, temp1
00f41b 930a          st -Y, temp0
00f41c cbe8          jmp_ DO_NEXT
                 .include "words/d-plus.asm"
                 
                 ; Arithmetics
                 ; add 2 double cell values
                 VE_DPLUS:
00f41d ff02          .dw $ff02
00f41e 2b64          .db "d+"
00f41f f40f          .dw VE_HEAD
                     .set VE_HEAD = VE_DPLUS
                 XT_DPLUS:
00f420 f421          .dw PFA_DPLUS
                 PFA_DPLUS:
00f421 9129          ld temp2, Y+
00f422 9139          ld temp3, Y+
                 
00f423 90e9          ld temp4, Y+
00f424 90f9          ld temp5, Y+
00f425 9149          ld temp6, Y+
00f426 9159          ld temp7, Y+
                 
00f427 0f24          add temp2, temp6
00f428 1f35          adc temp3, temp7
00f429 1d8e          adc tosl, temp4
00f42a 1d9f          adc tosh, temp5
                     
00f42b 933a          st -Y, temp3
00f42c 932a          st -Y, temp2
00f42d cbd7          jmp_ DO_NEXT
                 .include "words/d-minus.asm"
                 
                 ; Arithmetics
                 ; subtract d2 from d1 
                 VE_DMINUS:
00f42e ff02          .dw $ff02
00f42f 2d64          .db "d-"
00f430 f41d          .dw VE_HEAD
                     .set VE_HEAD = VE_DMINUS
                 XT_DMINUS:
00f431 f432          .dw PFA_DMINUS
                 PFA_DMINUS:
00f432 9129          ld temp2, Y+
00f433 9139          ld temp3, Y+
                 
00f434 90e9          ld temp4, Y+
00f435 90f9          ld temp5, Y+
00f436 9149          ld temp6, Y+
00f437 9159          ld temp7, Y+
                 
00f438 1b42          sub temp6, temp2
00f439 0b53          sbc temp7, temp3
00f43a 0ae8          sbc temp4, tosl
00f43b 0af9          sbc temp5, tosh
                 
00f43c 935a          st -Y, temp7
00f43d 934a          st -Y, temp6
00f43e 01c7          movw tosl, temp4
00f43f cbc5          jmp_ DO_NEXT
                 .include "words/d-invert.asm"
                 
                 ; Arithmetics
                 ; invert all bits in the double cell value
                 VE_DINVERT:
00f440 ff07          .dw $ff07
00f441 6964
00f442 766e
00f443 7265
00f444 0074          .db "dinvert",0
00f445 f42e          .dw VE_HEAD
                     .set VE_HEAD = VE_DINVERT
                 XT_DINVERT:
00f446 f447          .dw PFA_DINVERT
                 PFA_DINVERT:
00f447 9109          ld temp0, Y+
00f448 9119          ld temp1, Y+
00f449 9580          com tosl
00f44a 9590          com tosh
00f44b 9500          com temp0
00f44c 9510          com temp1
00f44d 931a          st -Y, temp1
00f44e 930a          st -Y, temp0
00f44f cbb5          jmp_ DO_NEXT
                 .include "words/d-equal.asm"
                 
                 ; Compare
                 ; compares two double cell values
                 VE_DEQUAL:
00f450 ff02          .dw $ff02
00f451 3d64          .db "d="
00f452 f440          .dw VE_HEAD
                     .set VE_HEAD = VE_DEQUAL
                 XT_DEQUAL:
00f453 f001          .dw DO_COLON
                 PFA_DEQUAL:
00f454 f431          .dw XT_DMINUS
00f455 f229          .dw XT_OR
00f456 f127          .dw XT_ZEROEQUAL
00f457 f021          .dw XT_EXIT
                 .include "words/u-dot.asm"
                 
                 ; Numeric IO
                 ; unsigned PNO with single cell numbers
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_UDOT:
00f458 ff02          .dw $ff02
00f459 2e75          .db "u."
00f45a f450          .dw VE_HEAD
                     .set VE_HEAD = VE_UDOT
                 XT_UDOT:
00f45b f001          .dw DO_COLON
                 PFA_UDOT:
                 .endif
00f45c f161          .dw XT_ZERO
00f45d f74f          .dw XT_UDDOT
00f45e f021          .dw XT_EXIT
                 ; : u.        ( us -- )    0 ud. ;
                 .include "words/u-dot-r.asm"
                 
                 ; Numeric IO
                 ; unsigned PNO with single cells numbers, right aligned in width w
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 
                 VE_UDOTR:
00f45f ff03          .dw $ff03
00f460 2e75
00f461 0072          .db "u.r",0
00f462 f458          .dw VE_HEAD
                     .set VE_HEAD = VE_UDOTR
                 XT_UDOTR:
00f463 f001          .dw DO_COLON
                 PFA_UDOTR:
                 .endif
00f464 f161          .dw XT_ZERO
00f465 f0d1          .dw XT_SWAP
00f466 f758          .dw XT_UDDOTR
00f467 f021          .dw XT_EXIT
                 ; : u.r       ( s n -- )   0 swap ud.r ;
                 
                 .include "words/show-wordlist.asm"
                 
                 ; Tools
                 ; prints the name of the words in a wordlist
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SHOWWORDLIST:
00f468 ff0d          .dw $ff0d
00f469 6873
00f46a 776f
00f46b 772d
00f46c 726f
00f46d 6c64
00f46e 7369
00f46f 0074          .db "show-wordlist",0
00f470 f45f          .dw VE_HEAD
                     .set VE_HEAD = VE_SHOWWORDLIST
                 XT_SHOWWORDLIST:
00f471 f001          .dw DO_COLON
                 PFA_SHOWWORDLIST:
                 .endif
00f472 f041          .dw XT_DOLITERAL
00f473 f477          .dw XT_SHOWWORD
00f474 f0d1          .dw XT_SWAP
00f475 fc65          .dw XT_TRAVERSEWORDLIST
00f476 f021          .dw XT_EXIT
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 XT_SHOWWORD:
00f477 f001          .dw DO_COLON
                 PFA_SHOWWORD:
                 .endif
00f478 fc80          .dw XT_NAME2STRING
00f479 f7c5          .dw XT_ITYPE
00f47a f807          .dw XT_SPACE         ; ( -- addr n)
00f47b f158          .dw XT_TRUE
00f47c f021          .dw XT_EXIT
                 .include "words/words.asm"
                 
                 ; Tools
                 ; prints a list of all (visible) words in the dictionary
                 VE_WORDS:
00f47d ff05          .dw $ff05
00f47e 6f77
00f47f 6472
00f480 0073          .db "words",0
00f481 f468          .dw VE_HEAD
                     .set VE_HEAD = VE_WORDS
                 XT_WORDS:
00f482 f001          .dw DO_COLON
                 PFA_WORDS:
00f483 f041          .dw XT_DOLITERAL
00f484 005c          .dw CFG_ORDERLIST
00f485 f360          .dw XT_FETCHE
00f486 f471          .dw XT_SHOWWORDLIST
00f487 f021          .dw XT_EXIT
                 .include "dict/interrupt.inc"
                 
                 .include "words/int-on.asm"
                 
                 ; Interrupt
                 ; turns on all interrupts
                 VE_INTON:
00f488 ff04          .dw $ff04
00f489 692b
00f48a 746e          .db "+int"
00f48b f47d          .dw VE_HEAD
                     .set VE_HEAD = VE_INTON
                 XT_INTON:
00f48c f48d          .dw PFA_INTON
                 PFA_INTON:
00f48d 9478          sei
00f48e cb76          jmp_ DO_NEXT
                 .include "words/int-off.asm"
                 
                 ; Interrupt
                 ; turns off all interrupts 
                 VE_INTOFF:
00f48f ff04          .dw $ff04
00f490 692d
00f491 746e          .db "-int"
00f492 f488          .dw VE_HEAD
                     .set VE_HEAD = VE_INTOFF
                 XT_INTOFF:
00f493 f494          .dw PFA_INTOFF
                 PFA_INTOFF:
00f494 94f8          cli
00f495 cb6f          jmp_ DO_NEXT
                 .include "words/int-store.asm"
                 
                 ; Interrupt
                 ; stores XT as interrupt vector i
                 VE_INTSTORE:
00f496 ff04          .dw $ff04
00f497 6e69
00f498 2174          .db "int!"
00f499 f48f          .dw VE_HEAD
                     .set VE_HEAD = VE_INTSTORE
                 XT_INTSTORE:
00f49a f001          .dw DO_COLON
                 PFA_INTSTORE:
00f49b f041          .dw XT_DOLITERAL
00f49c 0000          .dw intvec
00f49d f1aa          .dw XT_PLUS
00f49e f33c          .dw XT_STOREE
00f49f f021          .dw XT_EXIT
                 .include "words/int-fetch.asm"
                 
                 ; Interrupt
                 ; fetches XT from interrupt vector i
                 VE_INTFETCH:
00f4a0 ff04          .dw $ff04
00f4a1 6e69
00f4a2 4074          .db "int@"
00f4a3 f496          .dw VE_HEAD
                     .set VE_HEAD = VE_INTFETCH
                 XT_INTFETCH:
00f4a4 f001          .dw DO_COLON
                 PFA_INTFETCH:
00f4a5 f041          .dw XT_DOLITERAL
00f4a6 0000          .dw intvec
00f4a7 f1aa          .dw XT_PLUS
00f4a8 f360          .dw XT_FETCHE
00f4a9 f021          .dw XT_EXIT
                 .include "words/int-trap.asm"
                 
                 ; Interrupt
                 ; trigger an interrupt
                 VE_INTTRAP:
00f4aa ff08          .dw $ff08
00f4ab 6e69
00f4ac 2d74
00f4ad 7274
00f4ae 7061          .db "int-trap"
00f4af f4a0          .dw VE_HEAD
                     .set VE_HEAD = VE_INTTRAP
                 XT_INTTRAP:
00f4b0 f4b1          .dw PFA_INTTRAP
                 PFA_INTTRAP:
00f4b1 9380 0116     sts intcur, tosl
00f4b3 9189
00f4b4 9199          loadtos
00f4b5 9468          set ; set the interrupt flag for the inner interpreter
00f4b6 cb4e          jmp_ DO_NEXT
                 
                 .include "words/isr-exec.asm"
                 
                 ; Interrupt
                 ; executes an interrupt service routine
                 ;VE_ISREXEC:
                 ;    .dw $ff08
                 ;    .db "isr-exec"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_ISREXEC
                 XT_ISREXEC:
00f4b7 f001          .dw DO_COLON
                 PFA_ISREXEC:
00f4b8 f041          .dw XT_DOLITERAL
00f4b9 0116          .dw intcur
00f4ba f0a5          .dw XT_CFETCH
00f4bb f041          .dw XT_DOLITERAL
00f4bc 0000          .dw intvec
00f4bd f1aa          .dw XT_PLUS
00f4be f360          .dw XT_FETCHE
00f4bf f02b          .dw XT_EXECUTE
00f4c0 f4c2          .dw XT_ISREND
00f4c1 f021          .dw XT_EXIT
                 .include "words/isr-end.asm"
                 
                 ; Interrupt
                 ; re-enables interrupts in an ISR
                 ;VE_ISREND:
                 ;    .dw $ff07
                 ;    .db "isr-end",0
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_ISREND
                 XT_ISREND:
00f4c2 f4c3          .dw PFA_ISREND
                 PFA_ISREND:
00f4c3 d001          rcall PFA_ISREND1 ; clear the interrupt flag for the controller
00f4c4 cb40          jmp_ DO_NEXT
                 PFA_ISREND1:
00f4c5 9518          reti
                 
                 .include "words/pick.asm"
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_PICK:
00f4c6 ff04          .dw $ff04
00f4c7 6970
00f4c8 6b63          .db "pick"
00f4c9 f4aa          .dw VE_HEAD
                     .set VE_HEAD = VE_PICK
                 XT_PICK:
00f4ca f001          .dw DO_COLON
                 PFA_PICK:
                 .endif
00f4cb f23c          .dw XT_1PLUS
00f4cc f573          .dw XT_CELLS
00f4cd f28e          .dw XT_SP_FETCH
00f4ce f1aa          .dw XT_PLUS
00f4cf f086          .dw XT_FETCH
00f4d0 f021          .dw XT_EXIT
                 .include "words/dot-quote.asm"
                 
                 ; Compiler
                 ; compiles string into dictionary to be printed at runtime
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 
                 VE_DOTSTRING:
00f4d1 0002          .dw $0002
00f4d2 222e          .db ".",$22
00f4d3 f4c6          .dw VE_HEAD
                     .set VE_HEAD = VE_DOTSTRING
                 XT_DOTSTRING:
00f4d4 f001          .dw DO_COLON
                 PFA_DOTSTRING:
                 .endif
00f4d5 f4dc          .dw XT_SQUOTE
00f4d6 01cc          .dw XT_COMPILE
00f4d7 f7c5          .dw XT_ITYPE
00f4d8 f021          .dw XT_EXIT
                 .include "words/squote.asm"
                 
                 ; Compiler
                 ; compiles a string to flash, at runtime leaves ( -- flash-addr count) on stack
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SQUOTE:
00f4d9 0002        .dw $0002
00f4da 2273        .db "s",$22
00f4db f4d1        .dw VE_HEAD
                   .set VE_HEAD = VE_SQUOTE
                 XT_SQUOTE:
00f4dc f001          .dw DO_COLON
                 PFA_SQUOTE:
                 .endif
00f4dd f041          .dw XT_DOLITERAL
00f4de 0022          .dw 34   ; 0x22 
00f4df f9a4          .dw XT_PARSE       ; ( -- addr n)
00f4e0 f566          .dw XT_STATE
00f4e1 f086          .dw XT_FETCH
00f4e2 f03a          .dw XT_DOCONDBRANCH
00f4e3 f4e5          DEST(PFA_SQUOTE1)
00f4e4 01f8            .dw XT_SLITERAL
                 PFA_SQUOTE1:
00f4e5 f021          .dw XT_EXIT
                 
                 .include "words/fill.asm"
                 
                 ; Memory
                 ; fill u bytes memory beginning at a-addr with character c
                 VE_FILL:
00f4e6 ff04          .dw $ff04
00f4e7 6966
00f4e8 6c6c          .db "fill"
00f4e9 f4d9          .dw VE_HEAD
                     .set VE_HEAD = VE_FILL
                 XT_FILL:
00f4ea f001          .dw DO_COLON
                 PFA_FILL:
00f4eb f0ee          .dw XT_ROT
00f4ec f0ee          .dw XT_ROT
00f4ed f0c6
00f4ee f03a          .dw XT_QDUP,XT_DOCONDBRANCH
00f4ef f4f7          DEST(PFA_FILL2)
00f4f0 fd68          .dw XT_BOUNDS
00f4f1 f29c          .dw XT_DODO
                 PFA_FILL1:
00f4f2 f0be          .dw XT_DUP
00f4f3 f2ad          .dw XT_I
00f4f4 f09a          .dw XT_CSTORE  ; ( -- c c-addr)
00f4f5 f2ca          .dw XT_DOLOOP
00f4f6 f4f2          .dw PFA_FILL1
                 PFA_FILL2:
00f4f7 f0e6          .dw XT_DROP
00f4f8 f021          .dw XT_EXIT
                 
                 .include "words/environment.asm"
                 
                 ; System Value
                 ; word list identifier of the environmental search list
                 VE_ENVIRONMENT:
00f4f9 ff0b          .dw $ff0b
00f4fa 6e65
00f4fb 6976
00f4fc 6f72
00f4fd 6d6e
00f4fe 6e65
00f4ff 0074          .db "environment",0
00f500 f4e6          .dw VE_HEAD
                     .set VE_HEAD = VE_ENVIRONMENT
                 XT_ENVIRONMENT:
00f501 f04f          .dw PFA_DOVARIABLE
                 PFA_ENVIRONMENT:
00f502 0052          .dw EE_ENVIRONMENT
                 .include "words/env-wordlists.asm"
                 
                 ; Environment
                 ; maximum number of wordlists in the dictionary search order
                 VE_ENVWORDLISTS:
00f503 ff09          .dw $ff09
00f504 6f77
00f505 6472
00f506 696c
00f507 7473
00f508 0073          .db "wordlists",0
00f509 0000          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENVWORDLISTS
                 XT_ENVWORDLISTS:
00f50a f001          .dw DO_COLON
                 PFA_ENVWORDLISTS:
00f50b f041          .dw XT_DOLITERAL
00f50c 0008          .dw NUMWORDLISTS
00f50d f021          .dw XT_EXIT
                 .include "words/env-slashpad.asm"
                 
                 ; Environment
                 ; Size of the PAD buffer in bytes
                 VE_ENVSLASHPAD:
00f50e ff04          .dw $ff04
00f50f 702f
00f510 6461          .db "/pad"
00f511 f503          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENVSLASHPAD
                 XT_ENVSLASHPAD:
00f512 f001          .dw DO_COLON
                 PFA_ENVSLASHPAD:
00f513 f28e          .dw XT_SP_FETCH
00f514 f5a5          .dw XT_PAD
00f515 f1a0          .dw XT_MINUS
00f516 f021          .dw XT_EXIT
                 .include "words/env-slashhold.asm"
                 
                 ; Environment
                 ; size of the pictured numeric output buffer in bytes
                 VE_ENVSLASHHOLD:
00f517 ff05          .dw $ff05
00f518 682f
00f519 6c6f
00f51a 0064          .db "/hold",0
00f51b f50e          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENVSLASHHOLD
                 XT_ENVSLASHHOLD:
00f51c f001          .dw DO_COLON
                 PFA_ENVSLASHHOLD:
00f51d f5a5          .dw XT_PAD
00f51e f5e0          .dw XT_HERE
00f51f f1a0          .dw XT_MINUS
00f520 f021          .dw XT_EXIT
                 .include "words/env-forthname.asm"
                 
                 ; Environment
                 ; flash address of the amforth name string
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_ENV_FORTHNAME:
00f521 ff0a          .dw $ff0a
00f522 6f66
00f523 7472
00f524 2d68
00f525 616e
00f526 656d          .db "forth-name"
00f527 f517          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENV_FORTHNAME
                 XT_ENV_FORTHNAME:
00f528 f001          .dw DO_COLON
                 PFA_EN_FORTHNAME:
00f529 f792          .dw XT_DOSLITERAL
00f52a 0007          .dw 7
                 .endif
00f52b 6d61
00f52c 6f66
00f52d 7472
../../common\words/env-forthname.asm(22): warning: .cseg .db misalignment - padding zero byte
00f52e 0068          .db "amforth"
                 .if cpu_msp430==1
                 .endif
00f52f f021          .dw XT_EXIT
                 .include "words/env-forthversion.asm"
                 
                 ; Environment
                 ; version number of amforth
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_ENV_FORTHVERSION:
00f530 ff07          .dw $ff07
00f531 6576
00f532 7372
00f533 6f69
00f534 006e          .db "version",0
00f535 f521          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENV_FORTHVERSION
                 XT_ENV_FORTHVERSION:
00f536 f001          .dw DO_COLON
                 PFA_EN_FORTHVERSION:
                 .endif
00f537 f041          .dw XT_DOLITERAL
00f538 003b          .dw 59
00f539 f021          .dw XT_EXIT
                 .include "words/env-cpu.asm"
                 
                 ; Environment
                 ; flash address of the CPU identification string
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_ENV_CPU:
00f53a ff03          .dw $ff03
00f53b 7063
00f53c 0075          .db "cpu",0
00f53d f530          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENV_CPU
                 XT_ENV_CPU:
00f53e f001          .dw DO_COLON
                 PFA_EN_CPU:
00f53f f041          .dw XT_DOLITERAL
00f540 0049          .dw mcu_name
00f541 f7f1          .dw XT_ICOUNT
                 .endif
00f542 f021          .dw XT_EXIT
                 .include "words/env-mcuinfo.asm"
                 
                 ; Environment
                 ; flash address of some CPU specific parameters
                 VE_ENV_MCUINFO:
00f543 ff08          .dw $ff08
00f544 636d
00f545 2d75
00f546 6e69
00f547 6f66          .db "mcu-info"
00f548 f53a          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENV_MCUINFO
                 XT_ENV_MCUINFO:
00f549 f001          .dw DO_COLON
                 PFA_EN_MCUINFO:
00f54a f041          .dw XT_DOLITERAL
00f54b 0045          .dw mcu_info
00f54c f021          .dw XT_EXIT
                 .include "words/env-usersize.asm"
                 
                 ; Environment
                 ; size of the USER area in bytes
                 VE_ENVUSERSIZE:
00f54d ff05          .dw $ff05
00f54e 752f
00f54f 6573
00f550 0072          .db "/user",0
00f551 f543          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENVUSERSIZE
                 XT_ENVUSERSIZE:
00f552 f001          .dw DO_COLON
                 PFA_ENVUSERSIZE:
00f553 f041          .dw XT_DOLITERAL
00f554 0026          .dw SYSUSERSIZE + APPUSERSIZE
00f555 f021          .dw XT_EXIT
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/f_cpu.asm"
                 
                 ; System
                 ; put the cpu frequency in Hz on stack
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_F_CPU:
00f556 ff05          .dw $ff05
00f557 5f66
00f558 7063
00f559 0075          .db "f_cpu",0
00f55a f4f9          .dw VE_HEAD
                     .set VE_HEAD = VE_F_CPU
                 XT_F_CPU:
00f55b f001          .dw DO_COLON
                 PFA_F_CPU:
                 .endif
00f55c f041          .dw XT_DOLITERAL
00f55d 2400          .dw (F_CPU % 65536)
00f55e f041          .dw XT_DOLITERAL
00f55f 00f4          .dw (F_CPU / 65536)
00f560 f021          .dw XT_EXIT
                 .include "words/state.asm"
                 
                 ; System Variable
                 ; system state
                 VE_STATE:
00f561 ff05          .dw $ff05
00f562 7473
00f563 7461
00f564 0065          .db "state",0
00f565 f556          .dw VE_HEAD
                     .set VE_HEAD = VE_STATE
                 XT_STATE:
00f566 f04f          .dw PFA_DOVARIABLE
                 PFA_STATE:
00f567 011f          .dw ram_state
                 
                 .dseg
00011f           ram_state: .byte 2
                 .include "words/base.asm"
                 
                 ; Numeric IO
                 ; location of the cell containing the number conversion radix
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_BASE:
00f568 ff04          .dw $ff04
00f569 6162
00f56a 6573          .db "base"
00f56b f561          .dw VE_HEAD
                     .set VE_HEAD = VE_BASE
                 XT_BASE:
00f56c f062          .dw PFA_DOUSER
                 PFA_BASE:
                 .endif
00f56d 000c          .dw USER_BASE
                 
                 .include "words/cells.asm"
                 
                 ; Arithmetics
                 ; n2 is the size in address units of n1 cells
                 VE_CELLS:
00f56e ff05          .dw $ff05
00f56f 6563
00f570 6c6c
00f571 0073          .db "cells",0
00f572 f568          .dw VE_HEAD
                     .set VE_HEAD = VE_CELLS
                 XT_CELLS:
00f573 f219          .dw PFA_2STAR
                 .include "words/cellplus.asm"
                 
                 ; Arithmetics
                 ; add the size of an address-unit to a-addr1
                 VE_CELLPLUS:
00f574 ff05          .dw $ff05
00f575 6563
00f576 6c6c
00f577 002b          .db "cell+",0
00f578 f56e          .dw VE_HEAD
                     .set VE_HEAD = VE_CELLPLUS
                 XT_CELLPLUS:
00f579 f57a          .dw PFA_CELLPLUS
                 PFA_CELLPLUS:
00f57a 9602          adiw tosl, CELLSIZE
00f57b ca89          jmp_ DO_NEXT
                 
                 .include "words/2dup.asm"
                 
                 ; Stack
                 ; Duplicate the 2 top elements
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_2DUP:
00f57c ff04          .dw $ff04
00f57d 6432
00f57e 7075          .db "2dup"
00f57f f574          .dw VE_HEAD
                     .set VE_HEAD = VE_2DUP
                 XT_2DUP:
00f580 f001          .dw DO_COLON
                 PFA_2DUP:
                 .endif
                 
00f581 f0dc          .dw XT_OVER
00f582 f0dc          .dw XT_OVER
00f583 f021          .dw XT_EXIT
                 .include "words/2drop.asm"
                 
                 ; Stack
                 ; Remove the 2 top elements
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_2DROP:
00f584 ff05          .dw $ff05
00f585 6432
00f586 6f72
00f587 0070          .db "2drop",0
00f588 f57c          .dw VE_HEAD
                     .set VE_HEAD = VE_2DROP
                 XT_2DROP:
00f589 f001          .dw DO_COLON
                 PFA_2DROP:
                 .endif
00f58a f0e6          .dw XT_DROP
00f58b f0e6          .dw XT_DROP
00f58c f021          .dw XT_EXIT
                 
                 .include "words/tuck.asm"
                 
                 ; Stack
                 ; Copy the first (top) stack item below the second stack item. 
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_TUCK:
00f58d ff04          .dw $ff04
00f58e 7574
00f58f 6b63          .db "tuck"
00f590 f584          .dw VE_HEAD
                     .set VE_HEAD = VE_TUCK
                 XT_TUCK:
00f591 f001          .dw DO_COLON
                 PFA_TUCK:
                 .endif
00f592 f0d1          .dw XT_SWAP
00f593 f0dc          .dw XT_OVER
00f594 f021          .dw XT_EXIT
                 
                 .include "words/to-in.asm"
                 
                 ; System Variable
                 ; pointer to current read position in input buffer
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_TO_IN:
00f595 ff03          .dw $ff03
00f596 693e
00f597 006e          .db ">in",0
00f598 f58d          .dw VE_HEAD
                     .set VE_HEAD = VE_TO_IN
                 XT_TO_IN:
00f599 f062          .dw PFA_DOUSER
                 PFA_TO_IN:
                 .endif
00f59a 0018          .dw USER_TO_IN
                 .include "words/sharptib.asm"
                 
                 ; System Variable
                 ; variable holding the number of characters in TIB
                 VE_NUMBERTIB:
00f59b ff04          .dw $ff04
00f59c 7423
00f59d 6269          .db "#tib"
00f59e f595          .dw VE_HEAD
                     .set VE_HEAD  = VE_NUMBERTIB
                 XT_NUMBERTIB:
00f59f f04f          .dw PFA_DOVARIABLE
                 PFA_NUMBERTIB:
00f5a0 0121          .dw ram_sharptib
                 
                 .dseg
000121           ram_sharptib: .byte 2
                 .cseg
                  
                 .include "words/pad.asm"
                 
                 ; System Variable
                 ; Address of the temporary scratch buffer.
                 VE_PAD:
00f5a1 ff03          .dw $ff03
00f5a2 6170
00f5a3 0064          .db "pad",0
00f5a4 f59b          .dw VE_HEAD
                     .set VE_HEAD = VE_PAD
                 XT_PAD:
00f5a5 f001          .dw DO_COLON
                 PFA_PAD:
00f5a6 f5e0          .dw XT_HERE
00f5a7 f041          .dw XT_DOLITERAL
00f5a8 0064          .dw 100
00f5a9 f1aa          .dw XT_PLUS
00f5aa f021          .dw XT_EXIT
                 .include "words/emit.asm"
                 
                 ; Character IO
                 ; fetch the emit vector and execute it. should emit a character from TOS
                 VE_EMIT:
00f5ab ff04          .dw $ff04
00f5ac 6d65
00f5ad 7469          .db "emit"
00f5ae f5a1          .dw VE_HEAD
                     .set VE_HEAD = VE_EMIT
                 XT_EMIT:
00f5af fc21          .dw PFA_DODEFER1
                 PFA_EMIT:
00f5b0 000e          .dw USER_EMIT
00f5b1 fbea          .dw XT_UDEFERFETCH
00f5b2 fbf6          .dw XT_UDEFERSTORE
                 .include "words/emitq.asm"
                 
                 ; Character IO
                 ; fetch emit? vector and execute it. should return the ready-to-send condition
                 VE_EMITQ:
00f5b3 ff05          .dw $ff05
00f5b4 6d65
00f5b5 7469
00f5b6 003f          .db "emit?",0
00f5b7 f5ab          .dw VE_HEAD
                     .set VE_HEAD = VE_EMITQ
                 XT_EMITQ:
00f5b8 fc21          .dw PFA_DODEFER1
                 PFA_EMITQ:
00f5b9 0010          .dw USER_EMITQ
00f5ba fbea          .dw XT_UDEFERFETCH
00f5bb fbf6          .dw XT_UDEFERSTORE
                 .include "words/key.asm"
                 
                 ; Character IO
                 ; fetch key vector and execute it, should leave a single character on TOS
                 VE_KEY:
00f5bc ff03          .dw $ff03
00f5bd 656b
00f5be 0079          .db "key",0
00f5bf f5b3          .dw VE_HEAD
                     .set VE_HEAD = VE_KEY
                 XT_KEY:
00f5c0 fc21          .dw PFA_DODEFER1
                 PFA_KEY:
00f5c1 0012          .dw USER_KEY
00f5c2 fbea          .dw XT_UDEFERFETCH
00f5c3 fbf6          .dw XT_UDEFERSTORE
                 .include "words/keyq.asm"
                 
                 ; Character IO
                 ; fetch key? vector and execute it. should turn on key sender, if it is disabled/stopped
                 VE_KEYQ:
00f5c4 ff04          .dw $ff04
00f5c5 656b
00f5c6 3f79          .db "key?"
00f5c7 f5bc          .dw VE_HEAD
                     .set VE_HEAD = VE_KEYQ
                 XT_KEYQ:
00f5c8 fc21          .dw PFA_DODEFER1
                 PFA_KEYQ:
00f5c9 0014          .dw USER_KEYQ
00f5ca fbea          .dw XT_UDEFERFETCH
00f5cb fbf6          .dw XT_UDEFERSTORE
                 
                 .include "words/dp.asm"
                 
                 ; System Value
                 ; address of the next free dictionary cell
                 VE_DP:
00f5cc ff02          .dw $ff02
00f5cd 7064          .db "dp"
00f5ce f5c4          .dw VE_HEAD
                     .set VE_HEAD = VE_DP
                 XT_DP:
00f5cf f07c          .dw PFA_DOVALUE1
                 PFA_DP:
00f5d0 0048          .dw EE_DP
00f5d1 fbc2          .dw XT_EDEFERFETCH
00f5d2 fbcc          .dw XT_EDEFERSTORE
                 .include "words/ehere.asm"
                 
                 ; System Value
                 ; address of the next free address in eeprom
                 VE_EHERE:
00f5d3 ff05          .dw $ff05
00f5d4 6865
00f5d5 7265
00f5d6 0065          .db "ehere",0
00f5d7 f5cc          .dw VE_HEAD
                     .set VE_HEAD = VE_EHERE
                 XT_EHERE:
00f5d8 f07c          .dw PFA_DOVALUE1
                 PFA_EHERE:
00f5d9 004c          .dw EE_EHERE
00f5da fbc2          .dw XT_EDEFERFETCH
00f5db fbcc          .dw XT_EDEFERSTORE
                 .include "words/here.asm"
                 
                 ; System Value
                 ; address of the next free data space (RAM) cell
                 VE_HERE:
00f5dc ff04          .dw $ff04
00f5dd 6568
00f5de 6572          .db "here"
00f5df f5d3          .dw VE_HEAD
                     .set VE_HEAD = VE_HERE
                 XT_HERE:
00f5e0 f07c          .dw PFA_DOVALUE1
                 PFA_HERE:
00f5e1 004a          .dw EE_HERE
00f5e2 fbc2          .dw XT_EDEFERFETCH
00f5e3 fbcc          .dw XT_EDEFERSTORE
                 .include "words/allot.asm"
                 
                 ; System
                 ; allocate or release memory in RAM
                 VE_ALLOT:
00f5e4 ff05          .dw $ff05
00f5e5 6c61
00f5e6 6f6c
00f5e7 0074          .db "allot",0
00f5e8 f5dc          .dw VE_HEAD
                     .set VE_HEAD = VE_ALLOT
                 XT_ALLOT:
00f5e9 f001          .dw DO_COLON
                 PFA_ALLOT:
00f5ea f5e0          .dw XT_HERE
00f5eb f1aa          .dw XT_PLUS
00f5ec fba7          .dw XT_DOTO
00f5ed f5e1          .dw PFA_HERE
00f5ee f021          .dw XT_EXIT
                 
                 .include "words/bin.asm"
                 
                 ; Numeric IO
                 ; set base for numeric conversion to 10
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_BIN:
00f5ef ff03          .dw $ff03
00f5f0 6962
00f5f1 006e          .db "bin",0
00f5f2 f5e4          .dw VE_HEAD
                     .set VE_HEAD = VE_BIN
                 XT_BIN:
00f5f3 f001          .dw DO_COLON
                 PFA_BIN:
                 .endif
00f5f4 f041          .dw XT_DOLITERAL
00f5f5 0002          .dw 2
00f5f6 f56c          .dw XT_BASE
00f5f7 f08e          .dw XT_STORE
00f5f8 f021          .dw XT_EXIT
                 .include "words/decimal.asm"
                 
                 ; Numeric IO
                 ; set base for numeric conversion to 10
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DECIMAL:
00f5f9 ff07          .dw $ff07
00f5fa 6564
00f5fb 6963
00f5fc 616d
00f5fd 006c          .db "decimal",0
00f5fe f5ef          .dw VE_HEAD
                     .set VE_HEAD = VE_DECIMAL
                 XT_DECIMAL:
00f5ff f001          .dw DO_COLON
                 PFA_DECIMAL:
                 .endif
00f600 f041          .dw XT_DOLITERAL
00f601 000a          .dw 10
00f602 f56c          .dw XT_BASE
00f603 f08e          .dw XT_STORE
00f604 f021          .dw XT_EXIT
                 .include "words/hex.asm"
                 
                 ; Numeric IO
                 ; set base for numeric conversion to 10
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_HEX:
00f605 ff03          .dw $ff03
00f606 6568
00f607 0078          .db "hex",0
00f608 f5f9          .dw VE_HEAD
                     .set VE_HEAD = VE_HEX
                 XT_HEX:
00f609 f001          .dw DO_COLON
                 PFA_HEX:
                 .endif
00f60a f041          .dw XT_DOLITERAL
00f60b 0010          .dw 16
00f60c f56c          .dw XT_BASE
00f60d f08e          .dw XT_STORE
00f60e f021          .dw XT_EXIT
                 .include "words/bl.asm"
                 
                 ; Character IO
                 ; put ascii code of the blank to the stack
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_BL:
00f60f ff02          .dw $ff02
00f610 6c62          .db "bl"
00f611 f605          .dw VE_HEAD
                     .set VE_HEAD = VE_BL
                 XT_BL:
00f612 f04f          .dw PFA_DOVARIABLE
                 PFA_BL:
                 .endif
00f613 0020          .dw 32
                 
                 .include "words/turnkey.asm"
                 
                 ; System Value
                 ; Deferred action during startup/reset
                 VE_TURNKEY:
00f614 ff07          .dw $ff07
00f615 7574
00f616 6e72
00f617 656b
00f618 0079          .db "turnkey",0
00f619 f60f          .dw VE_HEAD
                     .set VE_HEAD = VE_TURNKEY
                 XT_TURNKEY:
00f61a fc21          .dw PFA_DODEFER1
                 PFA_TURNKEY:
00f61b 004e          .dw EE_TURNKEY
00f61c fbc2          .dw XT_EDEFERFETCH
00f61d fbcc          .dw XT_EDEFERSTORE
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/slashmod.asm"
                 
                 ; Arithmetics
                 ; signed division n1/n2 with remainder and quotient
                 VE_SLASHMOD:
00f61e ff04          .dw $ff04
00f61f 6d2f
00f620 646f          .db "/mod"
00f621 f614          .dw VE_HEAD
                     .set VE_HEAD = VE_SLASHMOD
                 XT_SLASHMOD:
00f622 f623          .dw PFA_SLASHMOD
                 PFA_SLASHMOD:
00f623 019c          movw temp2, tosl
                     
00f624 9109          ld temp0, Y+
00f625 9119          ld temp1, Y+
                 
00f626 2f41          mov	temp6,temp1	;move dividend High to sign register
00f627 2743          eor	temp6,temp3	;xor divisor High with sign register
00f628 ff17          sbrs	temp1,7	;if MSB in dividend set
00f629 c004          rjmp	PFA_SLASHMOD_1
00f62a 9510          com	temp1		;    change sign of dividend
00f62b 9500          com	temp0		
00f62c 5f0f          subi	temp0,low(-1)
00f62d 4f1f          sbci	temp1,high(-1)
                 PFA_SLASHMOD_1:	
00f62e ff37          sbrs	temp3,7	;if MSB in divisor set
00f62f c004          rjmp	PFA_SLASHMOD_2
00f630 9530          com	temp3		;    change sign of divisor
00f631 9520          com	temp2		
00f632 5f2f          subi	temp2,low(-1)
00f633 4f3f          sbci	temp3,high(-1)
00f634 24ee      PFA_SLASHMOD_2:	clr	temp4	;clear remainder Low byte
00f635 18ff          sub	temp5,temp5;clear remainder High byte and carry
00f636 e151          ldi	temp7,17	;init loop counter
                 
00f637 1f00      PFA_SLASHMOD_3:	rol	temp0		;shift left dividend
00f638 1f11          rol	temp1
00f639 955a          dec	temp7		;decrement counter
00f63a f439          brne	PFA_SLASHMOD_5		;if done
00f63b ff47          sbrs	temp6,7		;    if MSB in sign register set
00f63c c004          rjmp	PFA_SLASHMOD_4
00f63d 9510          com	temp1	;        change sign of result
00f63e 9500          com	temp0
00f63f 5f0f          subi	temp0,low(-1)
00f640 4f1f          sbci	temp1,high(-1)
00f641 c00b      PFA_SLASHMOD_4:	rjmp PFA_SLASHMODmod_done			;    return
00f642 1cee      PFA_SLASHMOD_5:	rol	temp4	;shift dividend into remainder
00f643 1cff          rol	temp5
00f644 1ae2          sub	temp4,temp2	;remainder = remainder - divisor
00f645 0af3          sbc	temp5,temp3	;
00f646 f420          brcc	PFA_SLASHMOD_6		;if result negative
00f647 0ee2          add	temp4,temp2	;    restore remainder
00f648 1ef3          adc	temp5,temp3
00f649 9488          clc			;    clear carry to be shifted into result
00f64a cfec          rjmp	PFA_SLASHMOD_3		;else
00f64b 9408      PFA_SLASHMOD_6:	sec			;    set carry to be shifted into result
00f64c cfea          rjmp	PFA_SLASHMOD_3
                 
                 PFA_SLASHMODmod_done:
                     ; put remainder on stack
00f64d 92fa          st -Y,temp5
00f64e 92ea          st -Y,temp4
                 
                     ; put quotient on stack
00f64f 01c8          movw tosl, temp0
00f650 c9b4          jmp_ DO_NEXT
                 .include "words/uslashmod.asm"
                 
                 ; Arithmetics
                 ; unsigned division with remainder
                 VE_USLASHMOD:
00f651 ff05          .dw $ff05
00f652 2f75
00f653 6f6d
00f654 0064          .db "u/mod",0
00f655 f61e          .dw VE_HEAD
                     .set VE_HEAD = VE_USLASHMOD
                 XT_USLASHMOD:
00f656 f001          .dw DO_COLON
                 PFA_USLASHMOD:
00f657 f10c          .dw XT_TO_R
00f658 f161          .dw XT_ZERO
00f659 f103          .dw XT_R_FROM
00f65a f1cf          .dw XT_UMSLASHMOD
00f65b f021          .dw XT_EXIT
                 .include "words/negate.asm"
                 
                 ; Logic
                 ; 2-complement
                 VE_NEGATE:
00f65c ff06          .dw $ff06
00f65d 656e
00f65e 6167
00f65f 6574          .db "negate"
00f660 f651          .dw VE_HEAD
                     .set VE_HEAD = VE_NEGATE
                 XT_NEGATE:
00f661 f001          .dw DO_COLON
                 PFA_NEGATE:
00f662 f20a          .dw XT_INVERT
00f663 f23c          .dw XT_1PLUS
00f664 f021          .dw XT_EXIT
                 .include "words/slash.asm"
                 
                 ; Arithmetics
                 ; divide n1 by n2. giving the quotient
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 
                 VE_SLASH:
00f665 ff01          .dw $ff01
00f666 002f          .db "/",0
00f667 f65c          .dw VE_HEAD
                     .set VE_HEAD = VE_SLASH
                 XT_SLASH:
00f668 f001          .dw DO_COLON
                 PFA_SLASH:
                 .endif
00f669 f622          .dw XT_SLASHMOD
00f66a f0fd          .dw XT_NIP
00f66b f021          .dw XT_EXIT
                 
                 .include "words/mod.asm"
                 
                 ; Arithmetics
                 ; divide n1 by n2 giving the remainder n3
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 
                 VE_MOD:
00f66c ff03          .dw $ff03
00f66d 6f6d
00f66e 0064          .db "mod",0
00f66f f665          .dw VE_HEAD
                     .set VE_HEAD = VE_MOD
                 XT_MOD:
00f670 f001          .dw DO_COLON
                 PFA_MOD:
                 .endif
00f671 f622          .dw XT_SLASHMOD
00f672 f0e6          .dw XT_DROP
00f673 f021          .dw XT_EXIT
                 .include "words/abs.asm"
                 
                 ; Arithmetics
                 ; get the absolute value
                 VE_ABS:
00f674 ff03          .dw $ff03
00f675 6261
00f676 0073          .db "abs",0
00f677 f66c          .dw VE_HEAD
                     .set VE_HEAD = VE_ABS
                 XT_ABS:
00f678 f679          .dw PFA_ABS
                 PFA_ABS:
00f679 2399          tst tosh
00f67a f41a          brpl PFA_ABS1
00f67b 9580          com tosl
00f67c 9590          com tosh
00f67d 9601          adiw tosl, 1
                 PFA_ABS1:
00f67e c986          jmp_ do_next
                 .include "words/min.asm"
                 
                 ; Compare
                 ; compare two values leave the smaller one
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 
                 VE_MIN:
00f67f ff03          .dw $ff03
00f680 696d
00f681 006e          .db "min",0
00f682 f674          .dw VE_HEAD
                     .set VE_HEAD = VE_MIN
                 XT_MIN:
00f683 f001          .dw DO_COLON
                 PFA_MIN:
                 .endif
00f684 f580          .dw XT_2DUP
00f685 f185          .dw XT_GREATER
00f686 f03a          .dw XT_DOCONDBRANCH
00f687 f689          DEST(PFA_MIN1)
00f688 f0d1          .dw XT_SWAP
                 PFA_MIN1:
00f689 f0e6          .dw XT_DROP
00f68a f021          .dw XT_EXIT
                 .include "words/max.asm"
                 
                 ; Compare
                 ; compare two values, leave the bigger one
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_MAX:
00f68b ff03          .dw $ff03
00f68c 616d
00f68d 0078          .db "max",0
00f68e f67f          .dw VE_HEAD
                     .set VE_HEAD = VE_MAX
                 XT_MAX:
00f68f f001          .dw DO_COLON
                 PFA_MAX:
                 
                 .endif
00f690 f580          .dw XT_2DUP
00f691 f17b          .dw XT_LESS
00f692 f03a          .dw XT_DOCONDBRANCH
00f693 f695          DEST(PFA_MAX1)
00f694 f0d1          .dw XT_SWAP
                 PFA_MAX1:
00f695 f0e6          .dw XT_DROP
00f696 f021          .dw XT_EXIT
                 .include "words/within.asm"
                 
                 ; Compare
                 ; check if n is within min..max
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_WITHIN:
00f697 ff06          .dw $ff06
00f698 6977
00f699 6874
00f69a 6e69          .db "within"
00f69b f68b          .dw VE_HEAD
                     .set VE_HEAD = VE_WITHIN
                 XT_WITHIN:
00f69c f001          .dw DO_COLON
                 PFA_WITHIN:
                 .endif
00f69d f0dc          .dw XT_OVER
00f69e f1a0          .dw XT_MINUS
00f69f f10c          .dw XT_TO_R
00f6a0 f1a0          .dw XT_MINUS
00f6a1 f103          .dw XT_R_FROM
00f6a2 f169          .dw XT_ULESS
00f6a3 f021          .dw XT_EXIT
                 
                 .include "words/to-upper.asm"
                 
                 ; String
                 ; if c is a lowercase letter convert it to uppercase
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_TOUPPER:
00f6a4 ff07          .dw $ff07 
00f6a5 6f74
00f6a6 7075
00f6a7 6570
00f6a8 0072          .db "toupper",0
00f6a9 f697          .dw VE_HEAD
                     .set VE_HEAD = VE_TOUPPER
                 XT_TOUPPER:
00f6aa f001          .dw DO_COLON 
                 PFA_TOUPPER:
                 .endif
00f6ab f0be          .dw XT_DUP 
00f6ac f041          .dw XT_DOLITERAL 
00f6ad 0061          .dw 'a' 
00f6ae f041          .dw XT_DOLITERAL 
00f6af 007b          .dw 'z'+1
00f6b0 f69c          .dw XT_WITHIN 
00f6b1 f03a          .dw XT_DOCONDBRANCH
00f6b2 f6b6          DEST(PFA_TOUPPER0)
00f6b3 f041          .dw XT_DOLITERAL
00f6b4 00df          .dw 223 ; inverse of 0x20: 0xdf
00f6b5 f220          .dw XT_AND 
                 PFA_TOUPPER0:
00f6b6 f021          .dw XT_EXIT 
                 .include "words/to-lower.asm"
                 
                 ; String
                 ; if C is an uppercase letter convert it to lowercase
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 
                 VE_TOLOWER:
00f6b7 ff07          .dw $ff07
00f6b8 6f74
00f6b9 6f6c
00f6ba 6577
00f6bb 0072          .db "tolower",0
00f6bc f6a4          .dw VE_HEAD
                     .set VE_HEAD = VE_TOLOWER
                 XT_TOLOWER:
00f6bd f001          .dw DO_COLON
                 PFA_TOLOWER:
                 .endif
00f6be f0be          .dw XT_DUP
00f6bf f041          .dw XT_DOLITERAL
00f6c0 0041          .dw 'A'
00f6c1 f041          .dw XT_DOLITERAL
00f6c2 005b          .dw 'Z'+1
00f6c3 f69c          .dw XT_WITHIN
00f6c4 f03a          .dw XT_DOCONDBRANCH
00f6c5 f6c9          DEST(PFA_TOLOWER0)
00f6c6 f041          .dw XT_DOLITERAL
00f6c7 0020          .dw 32
00f6c8 f229          .dw XT_OR 
                 PFA_TOLOWER0:
00f6c9 f021          .dw XT_EXIT 
                 ;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/hld.asm"
                 
                 ; Numeric IO
                 ; pointer to current write position in the Pictured Numeric Output buffer
                 VE_HLD:
00f6ca ff03          .dw $ff03
00f6cb 6c68
00f6cc 0064          .db "hld",0
00f6cd f6b7          .dw VE_HEAD
                     .set VE_HEAD = VE_HLD
                 XT_HLD:
00f6ce f04f          .dw PFA_DOVARIABLE
                 PFA_HLD:
00f6cf 0123          .dw ram_hld
                 
                 .dseg
000123           ram_hld: .byte 2
                 .cseg
                 .include "words/hold.asm"
                 
                 ; Numeric IO
                 ; prepend character to pictured numeric output buffer
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_HOLD:
00f6d0 ff04          .dw $ff04
00f6d1 6f68
00f6d2 646c          .db "hold"
00f6d3 f6ca          .dw VE_HEAD
                     .set VE_HEAD = VE_HOLD
                 XT_HOLD:
00f6d4 f001          .dw DO_COLON
                 PFA_HOLD:
                 .endif
00f6d5 f6ce          .dw XT_HLD
00f6d6 f0be          .dw XT_DUP
00f6d7 f086          .dw XT_FETCH
00f6d8 f242          .dw XT_1MINUS
00f6d9 f0be          .dw XT_DUP
00f6da f10c          .dw XT_TO_R
00f6db f0d1          .dw XT_SWAP
00f6dc f08e          .dw XT_STORE
00f6dd f103          .dw XT_R_FROM
00f6de f09a          .dw XT_CSTORE
00f6df f021          .dw XT_EXIT
                 .include "words/less-sharp.asm" ; <#
                 
                 ; Numeric IO
                 ; initialize the pictured numeric output conversion process
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_L_SHARP:
00f6e0 ff02          .dw $ff02
00f6e1 233c          .db "<#"
00f6e2 f6d0          .dw VE_HEAD
                     .set VE_HEAD = VE_L_SHARP
                 XT_L_SHARP:
00f6e3 f001          .dw DO_COLON
                 PFA_L_SHARP:
                 .endif
00f6e4 f5a5          .dw XT_PAD
00f6e5 f6ce          .dw XT_HLD
00f6e6 f08e          .dw XT_STORE
00f6e7 f021          .dw XT_EXIT
                 .include "words/sharp.asm"
                 
                 ; Numeric IO
                 ; pictured numeric output: convert one digit
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 
                 VE_SHARP:
00f6e8 ff01          .dw $ff01
00f6e9 0023          .db "#",0
00f6ea f6e0          .dw VE_HEAD
                     .set VE_HEAD = VE_SHARP
                 XT_SHARP:
00f6eb f001          .dw DO_COLON
                 PFA_SHARP:
                 .endif
00f6ec f56c          .dw XT_BASE
00f6ed f086          .dw XT_FETCH
00f6ee f768          .dw XT_UDSLASHMOD
00f6ef f0ee          .dw XT_ROT
00f6f0 f041          .dw XT_DOLITERAL
00f6f1 0009          .dw 9
00f6f2 f0dc          .dw XT_OVER
00f6f3 f17b          .dw XT_LESS
00f6f4 f03a          .dw XT_DOCONDBRANCH
00f6f5 f6f9          DEST(PFA_SHARP1)
00f6f6 f041          .dw XT_DOLITERAL
00f6f7 0007          .dw 7
00f6f8 f1aa          .dw XT_PLUS
                 PFA_SHARP1:
00f6f9 f041          .dw XT_DOLITERAL
00f6fa 0030          .dw 48 ; ASCII 0
00f6fb f1aa          .dw XT_PLUS
00f6fc f6d4          .dw XT_HOLD
00f6fd f021          .dw XT_EXIT
                 ; : #    ( ud1 -- ud2 ) 
                 ;        base @ ud/mod rot 9 over < if 7 + then 30 + hold ; 
                 .include "words/sharp-s.asm"
                 
                 ; Numeric IO
                 ; pictured numeric output: convert all digits until 0 (zero) is reached
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SHARP_S:
00f6fe ff02          .dw $ff02
00f6ff 7323          .db "#s"
00f700 f6e8          .dw VE_HEAD
                     .set VE_HEAD = VE_SHARP_S
                 XT_SHARP_S:
00f701 f001          .dw DO_COLON
                 PFA_SHARP_S:
                 .endif
                 NUMS1:
00f702 f6eb          .dw XT_SHARP
00f703 f580          .dw XT_2DUP
00f704 f229          .dw XT_OR
00f705 f127          .dw XT_ZEROEQUAL
00f706 f03a          .dw XT_DOCONDBRANCH
00f707 f702          DEST(NUMS1) ; PFA_SHARP_S
00f708 f021          .dw XT_EXIT
                 .include "words/sharp-greater.asm" ; #>
                 
                 ; Numeric IO
                 ; Pictured Numeric Output: convert PNO buffer into an string
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SHARP_G:
00f709 ff02          .dw $ff02
00f70a 3e23          .db "#>"
00f70b f6fe          .dw VE_HEAD
                     .set VE_HEAD = VE_SHARP_G
                 XT_SHARP_G:
00f70c f001          .dw DO_COLON
                 PFA_SHARP_G:
                 .endif
00f70d f589          .dw XT_2DROP
00f70e f6ce          .dw XT_HLD
00f70f f086          .dw XT_FETCH
00f710 f5a5          .dw XT_PAD
00f711 f0dc          .dw XT_OVER
00f712 f1a0          .dw XT_MINUS
00f713 f021          .dw XT_EXIT
                 .include "words/sign.asm"
                 
                 ; Numeric IO
                 ; place a - in HLD if n is negative
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SIGN:
00f714 ff04          .dw $ff04
00f715 6973
00f716 6e67          .db "sign"
00f717 f709          .dw VE_HEAD
                     .set VE_HEAD = VE_SIGN
                 XT_SIGN:
00f718 f001          .dw DO_COLON
                 PFA_SIGN:
                 .endif
00f719 f12e          .dw XT_ZEROLESS
00f71a f03a          .dw XT_DOCONDBRANCH
00f71b f71f          DEST(PFA_SIGN1)
00f71c f041          .dw XT_DOLITERAL
00f71d 002d          .dw 45 ; ascii -
00f71e f6d4          .dw XT_HOLD
                 PFA_SIGN1:
00f71f f021          .dw XT_EXIT
                 .include "words/d-dot-r.asm"
                 
                 ; Numeric IO
                 ; singed PNO with double cell numbers, right aligned in width w
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DDOTR:
00f720 ff03          .dw $ff03
00f721 2e64
00f722 0072          .db "d.r",0
00f723 f714          .dw VE_HEAD
                     .set VE_HEAD = VE_DDOTR
                 XT_DDOTR:
00f724 f001          .dw DO_COLON
                 PFA_DDOTR:
                 
                 .endif
00f725 f10c          .dw XT_TO_R
00f726 f591          .dw XT_TUCK
00f727 fce2          .dw XT_DABS
00f728 f6e3          .dw XT_L_SHARP
00f729 f701          .dw XT_SHARP_S
00f72a f0ee          .dw XT_ROT
00f72b f718          .dw XT_SIGN
00f72c f70c          .dw XT_SHARP_G
00f72d f103          .dw XT_R_FROM
00f72e f0dc          .dw XT_OVER
00f72f f1a0          .dw XT_MINUS
00f730 f810          .dw XT_SPACES
00f731 f820          .dw XT_TYPE
00f732 f021          .dw XT_EXIT
                 ; : d.r       ( d n -- )
                 ;             >r swap over dabs <# #s rot sign #> r> over - spaces type ;
                 .include "words/dot-r.asm"
                 
                 ; Numeric IO
                 ; singed PNO with single cell numbers, right aligned in width w
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DOTR:
00f733 ff02          .dw $ff02
00f734 722e          .db ".r"
00f735 f720          .dw VE_HEAD
                     .set VE_HEAD = VE_DOTR
                 XT_DOTR:
00f736 f001          .dw DO_COLON
                 PFA_DOTR:
                 
                 .endif
00f737 f10c          .dw XT_TO_R
00f738 fd71          .dw XT_S2D
00f739 f103          .dw XT_R_FROM
00f73a f724          .dw XT_DDOTR
00f73b f021          .dw XT_EXIT
                 ; : .r        ( s n -- )  >r s>d r> d.r ;
                 .include "words/d-dot.asm"
                 
                 ; Numeric IO
                 ; singed PNO with double cell numbers
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DDOT:
00f73c ff02          .dw $ff02
00f73d 2e64          .db "d."
00f73e f733          .dw VE_HEAD
                     .set VE_HEAD = VE_DDOT
                 XT_DDOT:
00f73f f001          .dw DO_COLON
                 PFA_DDOT:
                 
                 .endif
00f740 f161          .dw XT_ZERO
00f741 f724          .dw XT_DDOTR
00f742 f807          .dw XT_SPACE
00f743 f021          .dw XT_EXIT
                 ; : d.        ( d -- )    0 d.r space ;
                 .include "words/dot.asm"
                 
                 ; Numeric IO
                 ; singed PNO with single cell numbers
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 
                 VE_DOT:
00f744 ff01          .dw $ff01
00f745 002e          .db ".",0
00f746 f73c          .dw VE_HEAD
                     .set VE_HEAD = VE_DOT
                 XT_DOT:
00f747 f001          .dw DO_COLON
                 PFA_DOT:
                 .endif
00f748 fd71          .dw XT_S2D
00f749 f73f          .dw XT_DDOT
00f74a f021          .dw XT_EXIT
                 ; : .         ( s -- )    s>d d. ; 
                 .include "words/ud-dot.asm"
                 
                 ; Numeric IO
                 ; unsigned PNO with double cell numbers
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_UDDOT:
00f74b ff03          .dw $ff03
00f74c 6475
00f74d 002e          .db "ud.",0
00f74e f744          .dw VE_HEAD
                     .set VE_HEAD = VE_UDDOT
                 XT_UDDOT:
00f74f f001          .dw DO_COLON
                 PFA_UDDOT:
                 .endif
00f750 f161          .dw XT_ZERO
00f751 f758          .dw XT_UDDOTR
00f752 f807          .dw XT_SPACE
00f753 f021          .dw XT_EXIT
                 .include "words/ud-dot-r.asm"
                 
                 ; Numeric IO
                 ; unsigned PNO with double cell numbers, right aligned in width w
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 
                 VE_UDDOTR:
00f754 ff04          .dw $ff04
00f755 6475
00f756 722e          .db "ud.r"
00f757 f74b          .dw VE_HEAD
                     .set VE_HEAD = VE_UDDOTR
                 XT_UDDOTR:
00f758 f001          .dw DO_COLON
                 PFA_UDDOTR:
                 .endif
00f759 f10c          .dw XT_TO_R
00f75a f6e3          .dw XT_L_SHARP
00f75b f701          .dw XT_SHARP_S
00f75c f70c          .dw XT_SHARP_G
00f75d f103          .dw XT_R_FROM
00f75e f0dc          .dw XT_OVER
00f75f f1a0          .dw XT_MINUS
00f760 f810          .dw XT_SPACES
00f761 f820          .dw XT_TYPE
00f762 f021          .dw XT_EXIT
                 .include "words/ud-slash-mod.asm"
                 
                 ; Arithmetics
                 ; unsigned double cell division with remainder
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_UDSLASHMOD:
00f763 ff06          .dw $ff06
00f764 6475
00f765 6d2f
00f766 646f          .db "ud/mod"
00f767 f754          .dw VE_HEAD
                     .set VE_HEAD = VE_UDSLASHMOD
                 XT_UDSLASHMOD:
00f768 f001          .dw DO_COLON
                 PFA_UDSLASHMOD:
                 .endif
00f769 f10c          .dw XT_TO_R
00f76a f161          .dw XT_ZERO
00f76b f115          .dw XT_R_FETCH
00f76c f1cf          .dw XT_UMSLASHMOD
00f76d f103          .dw XT_R_FROM
00f76e f0d1          .dw XT_SWAP
00f76f f10c          .dw XT_TO_R
00f770 f1cf          .dw XT_UMSLASHMOD
00f771 f103          .dw XT_R_FROM
00f772 f021          .dw XT_EXIT
                 .include "words/digit-q.asm"
                 
                 ; Numeric IO
                 ; tries to convert a character to a number, set flag accordingly
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DIGITQ:
00f773 ff06          .dw $ff06 
00f774 6964
00f775 6967
00f776 3f74          .db "digit?"
00f777 f763          .dw VE_HEAD
                     .set VE_HEAD = VE_DIGITQ
                 XT_DIGITQ:
00f778 f001          .dw DO_COLON 
                 PFA_DIGITQ:
                 .endif
00f779 f6aa          .dw XT_TOUPPER
00f77a f0be
00f77b f041
00f77c 0039
00f77d f185
00f77e f041
00f77f 0100          .DW XT_DUP,XT_DOLITERAL,57,XT_GREATER,XT_DOLITERAL,256
00f780 f220
00f781 f1aa
00f782 f0be
00f783 f041
00f784 0140
00f785 f185          .DW XT_AND,XT_PLUS,XT_DUP,XT_DOLITERAL,320,XT_GREATER
00f786 f041
00f787 0107
00f788 f220
00f789 f1a0
00f78a f041
00f78b 0030          .DW XT_DOLITERAL,263,XT_AND,XT_MINUS,XT_DOLITERAL,48
00f78c f1a0
00f78d f0be
00f78e f56c
00f78f f086
00f790 f169          .DW XT_MINUS,XT_DUP,XT_BASE,XT_FETCH,XT_ULESS
00f791 f021          .DW XT_EXIT
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/do-sliteral.asm"
                 
                 ; String
                 ; runtime portion of sliteral
                 ;VE_DOSLITERAL:
                 ;  .dw $ff0a
                 ;  .db "(sliteral)"
                 ;  .dw VE_HEAD
                 ;  .set VE_HEAD = VE_DOSLITERAL
                 XT_DOSLITERAL:
00f792 f001        .dw DO_COLON
                 PFA_DOSLITERAL:
00f793 f115        .dw XT_R_FETCH   ; ( -- addr )
00f794 f7f1        .dw XT_ICOUNT
00f795 f103        .dw XT_R_FROM
00f796 f0dc        .dw XT_OVER     ; ( -- addr' n addr n)
00f797 f23c        .dw XT_1PLUS
00f798 f211        .dw XT_2SLASH   ; ( -- addr' n addr k )
00f799 f1aa        .dw XT_PLUS     ; ( -- addr' n addr'' )
00f79a f23c        .dw XT_1PLUS
00f79b f10c        .dw XT_TO_R     ; ( -- )
00f79c f021        .dw XT_EXIT
                 .include "words/scomma.asm"
                 
                 ; Compiler
                 ; compiles a string from RAM to Flash
                 VE_SCOMMA:
00f79d ff02        .dw $ff02
00f79e 2c73        .db "s",$2c
00f79f f773        .dw VE_HEAD
                   .set VE_HEAD = VE_SCOMMA
                 XT_SCOMMA:
00f7a0 f001          .dw DO_COLON
                 PFA_SCOMMA:
00f7a1 f0be          .dw XT_DUP
00f7a2 f7a4          .dw XT_DOSCOMMA
00f7a3 f021          .dw XT_EXIT
                 
                 ; ( addr len len' -- ) 
                 ; Compiler
                 ; compiles a string from RAM to Flash
                 ;VE_DOSCOMMA:
                 ;  .dw $ff04
                 ;  .db "(s",$2c,")"
                 ;  .dw VE_HEAD
                 ;  .set VE_HEAD = VE_DOSCOMMA
                 XT_DOSCOMMA:
00f7a4 f001          .dw DO_COLON
                 PFA_DOSCOMMA:
00f7a5 01d7          .dw XT_COMMA
00f7a6 f0be          .dw XT_DUP   ; ( --addr len len)
00f7a7 f211          .dw XT_2SLASH ; ( -- addr len len/2
00f7a8 f591          .dw XT_TUCK   ; ( -- addr len/2 len len/2
00f7a9 f218          .dw XT_2STAR  ; ( -- addr len/2 len len'
00f7aa f1a0          .dw XT_MINUS  ; ( -- addr len/2 rem
00f7ab f10c          .dw XT_TO_R
00f7ac f161          .dw XT_ZERO
00f7ad 0296          .dw XT_QDOCHECK
00f7ae f03a          .dw XT_DOCONDBRANCH
00f7af f7b7          .dw PFA_SCOMMA2
00f7b0 f29c          .dw XT_DODO
                 PFA_SCOMMA1:
00f7b1 f0be          .dw XT_DUP         ; ( -- addr addr )
00f7b2 f086          .dw XT_FETCH       ; ( -- addr c1c2 )
00f7b3 01d7          .dw XT_COMMA       ; ( -- addr )
00f7b4 f579          .dw XT_CELLPLUS    ; ( -- addr+cell )
00f7b5 f2ca          .dw XT_DOLOOP
00f7b6 f7b1          .dw PFA_SCOMMA1
                 PFA_SCOMMA2:
00f7b7 f103          .dw XT_R_FROM
00f7b8 f135          .dw XT_GREATERZERO
00f7b9 f03a          .dw XT_DOCONDBRANCH
00f7ba f7be          .dw PFA_SCOMMA3
00f7bb f0be            .dw XT_DUP     ; well, tricky
00f7bc f0a5            .dw XT_CFETCH
00f7bd 01d7            .dw XT_COMMA
                 PFA_SCOMMA3:
00f7be f0e6          .dw XT_DROP        ; ( -- )
00f7bf f021          .dw XT_EXIT
                 .include "words/itype.asm"
                 
                 ; Tools
                 ; reads string from flash and prints it
                 VE_ITYPE:
00f7c0 ff05          .dw $ff05
00f7c1 7469
00f7c2 7079
00f7c3 0065          .db "itype",0
00f7c4 f79d          .dw VE_HEAD
                     .set VE_HEAD = VE_ITYPE
                 XT_ITYPE:
00f7c5 f001          .dw DO_COLON
                 PFA_ITYPE:
00f7c6 f0be          .dw XT_DUP    ; ( --addr len len)
00f7c7 f211          .dw XT_2SLASH ; ( -- addr len len/2
00f7c8 f591          .dw XT_TUCK   ; ( -- addr len/2 len len/2
00f7c9 f218          .dw XT_2STAR  ; ( -- addr len/2 len len'
00f7ca f1a0          .dw XT_MINUS  ; ( -- addr len/2 rem
00f7cb f10c          .dw XT_TO_R
00f7cc f161          .dw XT_ZERO
00f7cd 0296          .dw XT_QDOCHECK
00f7ce f03a          .dw XT_DOCONDBRANCH
00f7cf f7d9          .dw PFA_ITYPE2
00f7d0 f29c          .dw XT_DODO
                 PFA_ITYPE1:
00f7d1 f0be          .dw XT_DUP         ; ( -- addr addr )
00f7d2 f3d3          .dw XT_FETCHI      ; ( -- addr c1c2 )
00f7d3 f0be          .dw XT_DUP
00f7d4 f7e6          .dw XT_LOWEMIT
00f7d5 f7e2          .dw XT_HIEMIT
00f7d6 f23c          .dw XT_1PLUS    ; ( -- addr+cell )
00f7d7 f2ca          .dw XT_DOLOOP
00f7d8 f7d1          .dw PFA_ITYPE1
                 PFA_ITYPE2:
00f7d9 f103          .dw XT_R_FROM
00f7da f135          .dw XT_GREATERZERO
00f7db f03a          .dw XT_DOCONDBRANCH
00f7dc f7e0          .dw PFA_ITYPE3
00f7dd f0be            .dw XT_DUP     ; make sure the drop below has always something to do
00f7de f3d3            .dw XT_FETCHI
00f7df f7e6            .dw XT_LOWEMIT
                 PFA_ITYPE3:
00f7e0 f0e6          .dw XT_DROP
00f7e1 f021          .dw XT_EXIT
                 
                 ; ( w -- )
                 ; R( -- )
                 ; content of cell fetched on stack.
                 ;VE_HIEMIT:
                 ;    .dw $ff06
                 ;    .db "hiemit"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_HIEMIT
                 XT_HIEMIT:
00f7e2 f001          .dw DO_COLON
                 PFA_HIEMIT:
00f7e3 f2fa          .dw XT_BYTESWAP
00f7e4 f7e6          .dw XT_LOWEMIT
00f7e5 f021          .dw XT_EXIT
                 
                 ; ( w -- )
                 ; R( -- )
                 ; content of cell fetched on stack.
                 ;VE_LOWEMIT:
                 ;    .dw $ff07
                 ;    .db "lowemit"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_LOWEMIT
                 XT_LOWEMIT:
00f7e6 f001          .dw DO_COLON
                 PFA_LOWEMIT:
00f7e7 f041          .dw XT_DOLITERAL
00f7e8 00ff          .dw $00ff
00f7e9 f220          .dw XT_AND
00f7ea f5af          .dw XT_EMIT
00f7eb f021          .dw XT_EXIT
                 .include "words/icount.asm"
                 
                 ; Tools
                 ; get count information out of a counted string in flash
                 VE_ICOUNT:
00f7ec ff06          .dw $ff06
00f7ed 6369
00f7ee 756f
00f7ef 746e          .db "icount"
00f7f0 f7c0          .dw VE_HEAD
                     .set VE_HEAD = VE_ICOUNT
                 XT_ICOUNT:
00f7f1 f001          .dw DO_COLON
                 PFA_ICOUNT:
00f7f2 f0be          .dw XT_DUP
00f7f3 f23c          .dw XT_1PLUS
00f7f4 f0d1          .dw XT_SWAP
00f7f5 f3d3          .dw XT_FETCHI
00f7f6 f021          .dw XT_EXIT
                 .include "words/cr.asm"
                 
                 ; Character IO
                 ; cause subsequent output appear at the beginning of the next line
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_CR:
00f7f7 ff02          .dw 0xff02
00f7f8 7263          .db "cr"
00f7f9 f7ec          .dw VE_HEAD
                     .set VE_HEAD = VE_CR
                 XT_CR:
00f7fa f001          .dw DO_COLON
                 PFA_CR:
                 .endif
                 
00f7fb f041          .dw XT_DOLITERAL
00f7fc 000d          .dw 13
00f7fd f5af          .dw XT_EMIT
00f7fe f041          .dw XT_DOLITERAL
00f7ff 000a          .dw 10
00f800 f5af          .dw XT_EMIT
00f801 f021          .dw XT_EXIT
                 .include "words/space.asm"
                 
                 ; Character IO
                 ; emits a space (bl)
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SPACE:
00f802 ff05          .dw $ff05
00f803 7073
00f804 6361
00f805 0065          .db "space",0
00f806 f7f7          .dw VE_HEAD
                     .set VE_HEAD = VE_SPACE
                 XT_SPACE:
00f807 f001          .dw DO_COLON
                 PFA_SPACE:
                 .endif
00f808 f612          .dw XT_BL
00f809 f5af          .dw XT_EMIT
00f80a f021          .dw XT_EXIT
                 .include "words/spaces.asm"
                 
                 ; Character IO
                 ; emits n space(s) (bl)
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SPACES:
00f80b ff06          .dw $ff06
00f80c 7073
00f80d 6361
00f80e 7365          .db "spaces"
00f80f f802          .dw VE_HEAD
                     .set VE_HEAD = VE_SPACES
                 XT_SPACES:
00f810 f001          .dw DO_COLON
                 PFA_SPACES:
                 
                 .endif
                 ;C SPACES   n --            output n spaces
                 ;   BEGIN DUP 0> WHILE SPACE 1- REPEAT DROP ;
00f811 f161
00f812 f68f      	.DW XT_ZERO, XT_MAX
00f813 f0be
00f814 f03a      SPCS1:  .DW XT_DUP,XT_DOCONDBRANCH
00f815 f81a              DEST(SPCS2)
00f816 f807
00f817 f242
00f818 f030              .DW XT_SPACE,XT_1MINUS,XT_DOBRANCH
00f819 f813              DEST(SPCS1)
00f81a f0e6
00f81b f021      SPCS2:  .DW XT_DROP,XT_EXIT
                 .include "words/type.asm"
                 
                 ; Character IO
                 ; print a RAM based string
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_TYPE:
00f81c ff04          .dw $ff04
00f81d 7974
00f81e 6570          .db "type"
00f81f f80b          .dw VE_HEAD
                     .set VE_HEAD = VE_TYPE
                 XT_TYPE:
00f820 f001          .dw DO_COLON
                 PFA_TYPE:
                 
                 .endif
00f821 fd68          .dw XT_BOUNDS
00f822 0296          .dw XT_QDOCHECK
00f823 f03a          .dw XT_DOCONDBRANCH
00f824 f82b          DEST(PFA_TYPE2)
00f825 f29c          .dw XT_DODO
                 PFA_TYPE1:
00f826 f2ad          .dw XT_I
00f827 f0a5          .dw XT_CFETCH
00f828 f5af          .dw XT_EMIT
00f829 f2ca          .dw XT_DOLOOP
00f82a f826          DEST(PFA_TYPE1)
                 PFA_TYPE2:
00f82b f021          .dw XT_EXIT
                 .include "words/tick.asm"
                 
                 ; Dictionary
                 ; search dictionary for name, return XT or throw an exception -13
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_TICK:
00f82c ff01          .dw $ff01
00f82d 0027          .db "'",0
00f82e f81c          .dw VE_HEAD
                     .set VE_HEAD = VE_TICK
                 XT_TICK:
00f82f f001          .dw DO_COLON
                 PFA_TICK:
                 .endif
00f830 f9d2          .dw XT_PARSENAME
00f831 fad0          .dw XT_DORECOGNIZER
00f832 fb3a          .dw XT_R_WORD
00f833 fd8d          .dw XT_EQUAL
00f834 f03a          .dw XT_DOCONDBRANCH
00f835 f838          DEST(PFA_TICK1)
00f836 f0e6          .dw XT_DROP
00f837 f021          .dw XT_EXIT
                 PFA_TICK1:
00f838 f041          .dw XT_DOLITERAL
00f839 fff3          .dw -13
00f83a f85e          .dw XT_THROW
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/handler.asm"
                 
                 ; Exceptions
                 ; USER variable used by catch/throw
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_HANDLER:
00f83b ff07          .dw $ff07
00f83c 6168
00f83d 646e
00f83e 656c
00f83f 0072          .db "handler",0
00f840 f82c          .dw VE_HEAD
                     .set VE_HEAD = VE_HANDLER
                 XT_HANDLER:
00f841 f062          .dw PFA_DOUSER
                 PFA_HANDLER:
                 .endif
00f842 000a          .dw USER_HANDLER
                 .include "words/catch.asm"
                 
                 ; Exceptions
                 ; execute XT and check for exceptions.
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_CATCH:
00f843 ff05          .dw $ff05
00f844 6163
00f845 6374
00f846 0068          .db "catch",0
00f847 f83b          .dw VE_HEAD
                     .set VE_HEAD = VE_CATCH
                 XT_CATCH:
00f848 f001          .dw DO_COLON
                 PFA_CATCH:
                 .endif
                 
                     ; sp@ >r
00f849 f28e          .dw XT_SP_FETCH
00f84a f10c          .dw XT_TO_R
                     ; handler @ >r
00f84b f841          .dw XT_HANDLER
00f84c f086          .dw XT_FETCH
00f84d f10c          .dw XT_TO_R
                     ; rp@ handler !
00f84e f277          .dw XT_RP_FETCH
00f84f f841          .dw XT_HANDLER
00f850 f08e          .dw XT_STORE
00f851 f02b          .dw XT_EXECUTE
                     ; r> handler !
00f852 f103          .dw XT_R_FROM
00f853 f841          .dw XT_HANDLER
00f854 f08e          .dw XT_STORE
00f855 f103          .dw XT_R_FROM
00f856 f0e6          .dw XT_DROP
00f857 f161          .dw XT_ZERO
00f858 f021          .dw XT_EXIT
                 .include "words/throw.asm"
                 
                 ; Exceptions
                 ; throw an exception
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_THROW:
00f859 ff05          .dw $ff05
00f85a 6874
00f85b 6f72
00f85c 0077          .db "throw",0
00f85d f843          .dw VE_HEAD
                     .set VE_HEAD = VE_THROW
                 XT_THROW:
00f85e f001          .dw DO_COLON
                 PFA_THROW:
                 .endif
00f85f f0be          .dw XT_DUP
00f860 f127          .dw XT_ZEROEQUAL
00f861 f03a          .dw XT_DOCONDBRANCH
00f862 f865          DEST(PFA_THROW1)
00f863 f0e6      	.dw XT_DROP
00f864 f021      	.dw XT_EXIT
                 PFA_THROW1:
00f865 f841          .dw XT_HANDLER
00f866 f086          .dw XT_FETCH
00f867 f281          .dw XT_RP_STORE
00f868 f103          .dw XT_R_FROM
00f869 f841          .dw XT_HANDLER
00f86a f08e          .dw XT_STORE
00f86b f103          .dw XT_R_FROM
00f86c f0d1          .dw XT_SWAP
00f86d f10c          .dw XT_TO_R
00f86e f297          .dw XT_SP_STORE
00f86f f0e6          .dw XT_DROP
00f870 f103          .dw XT_R_FROM    
00f871 f021          .dw XT_EXIT
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/cskip.asm"
                 
                 ; String
                 ; skips leading occurancies in string at addr1/n1 leaving addr2/n2 pointing to the 1st non-c character
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_CSKIP:
00f872 ff05          .dw $ff05
00f873 7363
00f874 696b
00f875 0070          .db "cskip",0
00f876 f859          .dw VE_HEAD
                     .set VE_HEAD = VE_CSKIP
                 XT_CSKIP:
00f877 f001          .dw DO_COLON
                 PFA_CSKIP:
                 .endif
00f878 f10c          .dw XT_TO_R           ; ( -- addr1 n1 )
                 PFA_CSKIP1:
00f879 f0be          .dw XT_DUP            ; ( -- addr' n' n' )
00f87a f03a          .dw XT_DOCONDBRANCH   ; ( -- addr' n')
00f87b f887          DEST(PFA_CSKIP2)
00f87c f0dc          .dw XT_OVER           ; ( -- addr' n' addr' )
00f87d f0a5          .dw XT_CFETCH         ; ( -- addr' n' c' )
00f87e f115          .dw XT_R_FETCH        ; ( -- addr' n' c' c )
00f87f fd8d          .dw XT_EQUAL          ; ( -- addr' n' f )
00f880 f03a          .dw XT_DOCONDBRANCH   ; ( -- addr' n')
00f881 f887          DEST(PFA_CSKIP2)
00f882 f041          .dw XT_DOLITERAL
00f883 0001          .dw 1
00f884 f9c3          .dw XT_SLASHSTRING
00f885 f030          .dw XT_DOBRANCH
00f886 f879          DEST(PFA_CSKIP1)
                 PFA_CSKIP2:
00f887 f103          .dw XT_R_FROM
00f888 f0e6          .dw XT_DROP           ; ( -- addr2 n2)
00f889 f021          .dw XT_EXIT
                 .include "words/cscan.asm"
                 
                 ; String
                 ; Scan string at addr1/n1 for the first occurance of c, leaving addr1/n2, char at n2 is first non-c character
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_CSCAN:
00f88a ff05          .dw $ff05
00f88b 7363
00f88c 6163
../../common\words/cscan.asm(12): warning: .cseg .db misalignment - padding zero byte
00f88d 006e          .db "cscan"
00f88e f872          .dw VE_HEAD
                     .set VE_HEAD = VE_CSCAN
                 XT_CSCAN:
00f88f f001          .dw DO_COLON
                 PFA_CSCAN:
                 .endif
00f890 f10c          .dw XT_TO_R
00f891 f0dc          .dw XT_OVER
                 PFA_CSCAN1:
00f892 f0be          .dw XT_DUP
00f893 f0a5          .dw XT_CFETCH
00f894 f115          .dw XT_R_FETCH
00f895 fd8d          .dw XT_EQUAL
00f896 f127          .dw XT_ZEROEQUAL
00f897 f03a          .dw XT_DOCONDBRANCH
00f898 f8a4          DEST(PFA_CSCAN2)
00f899 f0d1            .dw XT_SWAP
00f89a f242            .dw XT_1MINUS
00f89b f0d1            .dw XT_SWAP
00f89c f0dc            .dw XT_OVER
00f89d f12e            .dw XT_ZEROLESS ; not negative
00f89e f127            .dw XT_ZEROEQUAL
00f89f f03a            .dw XT_DOCONDBRANCH
00f8a0 f8a4            DEST(PFA_CSCAN2)
00f8a1 f23c              .dw XT_1PLUS
00f8a2 f030              .dw XT_DOBRANCH
00f8a3 f892              DEST(PFA_CSCAN1)
                 PFA_CSCAN2:
00f8a4 f0fd          .dw XT_NIP
00f8a5 f0dc          .dw XT_OVER
00f8a6 f1a0          .dw XT_MINUS
00f8a7 f103          .dw XT_R_FROM
00f8a8 f0e6          .dw XT_DROP
00f8a9 f021          .dw XT_EXIT
                 
                 ; : my-cscan ( addr len c -- addr len' )
                 ;    >r over ( -- addr len addr )
                 ;    begin
                 ;      dup c@ r@ <> while
                 ;       swap 1- swap over 0 >=  while
                 ;        1+ 
                 ;     repeat then
                 ;     nip over - r> drop 
                 ; ;
                 .include "words/accept.asm"
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_ACCEPT:
00f8aa ff06          .dw $ff06
00f8ab 6361
00f8ac 6563
00f8ad 7470          .db "accept"
00f8ae f88a          .dw VE_HEAD
                     .set VE_HEAD = VE_ACCEPT
                 XT_ACCEPT:
00f8af f001          .dw DO_COLON
                 PFA_ACCEPT:
                 
                 .endif
00f8b0 f0dc
00f8b1 f1aa
00f8b2 f242
00f8b3 f0dc              .DW XT_OVER,XT_PLUS,XT_1MINUS,XT_OVER
00f8b4 f5c0
00f8b5 f0be
00f8b6 f8e9
00f8b7 f127
00f8b8 f03a      ACC1:   .DW XT_KEY,XT_DUP,XT_CRLFQ,XT_ZEROEQUAL,XT_DOCONDBRANCH
00f8b9 f8db              DEST(ACC5)
00f8ba f0be
00f8bb f041
00f8bc 0008
00f8bd fd8d
00f8be f03a              .DW XT_DUP,XT_DOLITERAL,8,XT_EQUAL,XT_DOCONDBRANCH
00f8bf f8d2              DEST(ACC3)
00f8c0 f0e6
00f8c1 f0ee
00f8c2 f580
00f8c3 f185
00f8c4 f10c
00f8c5 f0ee
00f8c6 f0ee
00f8c7 f103
00f8c8 f03a              .DW XT_DROP,XT_ROT,XT_2DUP,XT_GREATER,XT_TO_R,XT_ROT,XT_ROT,XT_R_FROM,XT_DOCONDBRANCH
00f8c9 f8d0      	DEST(ACC6)
00f8ca f8e1
00f8cb f242
00f8cc f10c
00f8cd f0dc
00f8ce f103
00f8cf 0151      	.DW XT_BS,XT_1MINUS,XT_TO_R,XT_OVER,XT_R_FROM,XT_UMAX
                 ACC6:
00f8d0 f030              .DW XT_DOBRANCH
00f8d1 f8d9              DEST(ACC4)
00f8d2 f0be
00f8d3 f5af
00f8d4 f0dc
00f8d5 f09a
00f8d6 f23c
00f8d7 f0dc
00f8d8 015d      ACC3:   .DW XT_DUP,XT_EMIT,XT_OVER,XT_CSTORE,XT_1PLUS,XT_OVER,XT_UMIN
00f8d9 f030      ACC4:   .DW XT_DOBRANCH
00f8da f8b4              DEST(ACC1)
00f8db f0e6
00f8dc f0fd
00f8dd f0d1
00f8de f1a0
00f8df f7fa
00f8e0 f021      ACC5:   .DW XT_DROP,XT_NIP,XT_SWAP,XT_MINUS,XT_CR,XT_EXIT
                 
                 
                 ; ( --  ) 
                 ; System
                 ; send a backspace character to overwrite the current char
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 ;VE_BS:
                 ;    .dw $ff02
                 ;    .db "bs"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_BS
                 XT_BS:
00f8e1 f001          .dw DO_COLON
                 .endif
00f8e2 f041          .dw XT_DOLITERAL
00f8e3 0008          .dw 8
00f8e4 f0be          .dw XT_DUP
00f8e5 f5af          .dw XT_EMIT
00f8e6 f807          .dw XT_SPACE
00f8e7 f5af          .dw XT_EMIT
00f8e8 f021          .dw XT_EXIT
                 
                 
                 ; ( c -- f ) 
                 ; System
                 ; is the character a line end character?
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 ;VE_CRLFQ:
                 ;    .dw $ff02
                 ;    .db "crlf?"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_CRLFQ
                 XT_CRLFQ:
00f8e9 f001          .dw DO_COLON
                 .endif
00f8ea f0be          .dw XT_DUP
00f8eb f041          .dw XT_DOLITERAL
00f8ec 000d          .dw 13
00f8ed fd8d          .dw XT_EQUAL
00f8ee f0d1          .dw XT_SWAP
00f8ef f041          .dw XT_DOLITERAL
00f8f0 000a          .dw 10
00f8f1 fd8d          .dw XT_EQUAL
00f8f2 f229          .dw XT_OR
00f8f3 f021          .dw XT_EXIT
                 .include "words/refill.asm"
                 
                 ; System
                 ; refills the input buffer
                 VE_REFILL:
00f8f4 ff06          .dw $ff06
00f8f5 6572
00f8f6 6966
00f8f7 6c6c          .db "refill"
00f8f8 f8aa          .dw VE_HEAD
                     .set VE_HEAD = VE_REFILL
                 XT_REFILL:
00f8f9 fc21          .dw PFA_DODEFER1
                 PFA_REFILL:
00f8fa 001a          .dw USER_REFILL
00f8fb fbea          .dw XT_UDEFERFETCH
00f8fc fbf6          .dw XT_UDEFERSTORE
                 
                 .include "words/char.asm"
                 
                 ; Tools
                 ; copy the first character of the next word onto the stack
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_CHAR:
00f8fd ff04          .dw $ff04
00f8fe 6863
00f8ff 7261          .db "char"
00f900 f8f4          .dw VE_HEAD
                     .set VE_HEAD = VE_CHAR
                 XT_CHAR:
00f901 f001          .dw DO_COLON
                 PFA_CHAR:
                 .endif
00f902 f9d2          .dw XT_PARSENAME
00f903 f0e6          .dw XT_DROP
00f904 f0a5          .dw XT_CFETCH
00f905 f021          .dw XT_EXIT
                 .include "words/number.asm"
                 
                 ; Numeric IO
                 ; convert a string at addr to a number
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_NUMBER:
00f906 ff06          .dw $ff06
00f907 756e
00f908 626d
00f909 7265          .db "number"
00f90a f8fd          .dw VE_HEAD
                     .set VE_HEAD = VE_NUMBER
                 XT_NUMBER:
00f90b f001          .dw DO_COLON
                 PFA_NUMBER:
                 .endif
00f90c f56c          .dw XT_BASE
00f90d f086          .dw XT_FETCH
00f90e f10c          .dw XT_TO_R
00f90f f952          .dw XT_QSIGN
00f910 f10c          .dw XT_TO_R
00f911 f966          .dw XT_SET_BASE
00f912 f952          .dw XT_QSIGN
00f913 f103          .dw XT_R_FROM
00f914 f229          .dw XT_OR
00f915 f10c          .dw XT_TO_R
                     ; check whether something is left
00f916 f0be          .dw XT_DUP
00f917 f127          .dw XT_ZEROEQUAL
00f918 f03a          .dw XT_DOCONDBRANCH
00f919 f922          DEST(PFA_NUMBER0)
                       ; nothing is left. It cannot be a number at all
00f91a f589            .dw XT_2DROP
00f91b f103            .dw XT_R_FROM
00f91c f0e6            .dw XT_DROP
00f91d f103            .dw XT_R_FROM
00f91e f56c            .dw XT_BASE
00f91f f08e            .dw XT_STORE
00f920 f161            .dw XT_ZERO
00f921 f021            .dw XT_EXIT
                 PFA_NUMBER0:
00f922 f31f          .dw XT_2TO_R
00f923 f161          .dw XT_ZERO       ; starting value
00f924 f161          .dw XT_ZERO
00f925 f32e          .dw XT_2R_FROM
00f926 f985          .dw XT_TO_NUMBER ; ( 0. addr len -- d addr' len'
                     ; check length of the remaining string.
                     ; if zero: a single cell number is entered
00f927 f0c6          .dw XT_QDUP
00f928 f03a          .dw XT_DOCONDBRANCH
00f929 f946          DEST(PFA_NUMBER1)
                     ; if equal 1: mayba a trailing dot? --> double cell number
00f92a f041          .dw XT_DOLITERAL
00f92b 0001          .dw 1
00f92c fd8d          .dw XT_EQUAL
00f92d f03a          .dw XT_DOCONDBRANCH
00f92e f93d          DEST(PFA_NUMBER2)
                 	; excatly one character is left
00f92f f0a5      	.dw XT_CFETCH
00f930 f041      	.dw XT_DOLITERAL
00f931 002e      	.dw 46 ; .
00f932 fd8d      	.dw XT_EQUAL
00f933 f03a      	.dw XT_DOCONDBRANCH
00f934 f93e      	DEST(PFA_NUMBER6)
                 	; its a double cell number
                         ; incorporate sign into number
00f935 f103      	.dw XT_R_FROM
00f936 f03a              .dw XT_DOCONDBRANCH
00f937 f939      	DEST(PFA_NUMBER3)
00f938 fcef              .dw XT_DNEGATE
                 PFA_NUMBER3:
00f939 f041      	.dw XT_DOLITERAL
00f93a 0002      	.dw 2
00f93b f030      	.dw XT_DOBRANCH
00f93c f94d      	DEST(PFA_NUMBER5)
                 PFA_NUMBER2:
00f93d f0e6      	.dw XT_DROP
                 PFA_NUMBER6:
00f93e f589      	.dw XT_2DROP
00f93f f103      	.dw XT_R_FROM
00f940 f0e6      	.dw XT_DROP
00f941 f103              .dw XT_R_FROM
00f942 f56c              .dw XT_BASE
00f943 f08e              .dw XT_STORE
00f944 f161      	.dw XT_ZERO
00f945 f021      	.dw XT_EXIT
                 PFA_NUMBER1:
00f946 f589          .dw XT_2DROP ; remove the address
                     ; incorporate sign into number
00f947 f103          .dw XT_R_FROM
00f948 f03a          .dw XT_DOCONDBRANCH
00f949 f94b          DEST(PFA_NUMBER4)
00f94a f661          .dw XT_NEGATE
                 PFA_NUMBER4:
00f94b f041          .dw XT_DOLITERAL
00f94c 0001          .dw 1
                 PFA_NUMBER5:
00f94d f103          .dw XT_R_FROM
00f94e f56c          .dw XT_BASE
00f94f f08e          .dw XT_STORE
00f950 f158          .dw XT_TRUE
00f951 f021          .dw XT_EXIT
                 .include "words/q-sign.asm"
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 XT_QSIGN:
00f952 f001          .dw DO_COLON 
                 PFA_QSIGN:        ; ( c -- ) 
                 .endif
00f953 f0dc          .dw XT_OVER    ; ( -- addr len addr )
00f954 f0a5          .dw XT_CFETCH
00f955 f041          .dw XT_DOLITERAL
00f956 002d          .dw '-'
00f957 fd8d          .dw XT_EQUAL  ; ( -- addr len flag )
00f958 f0be          .dw XT_DUP
00f959 f10c          .dw XT_TO_R
00f95a f03a          .dw XT_DOCONDBRANCH
00f95b f95f          DEST(PFA_NUMBERSIGN_DONE)
00f95c f041          .dw XT_DOLITERAL      ; skip sign character
00f95d 0001          .dw 1
00f95e f9c3          .dw XT_SLASHSTRING
                 PFA_NUMBERSIGN_DONE:
00f95f f103          .dw XT_R_FROM
00f960 f021          .dw XT_EXIT
                 .include "words/set-base.asm"
                 
                 ; Numeric IO
                 ; skip a numeric prefix character
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 XT_BASES:
00f961 f05c          .dw PFA_DOCONSTANT
                 .endif
00f962 000a
00f963 0010
00f964 0002
00f965 000a          .dw 10,16,2,10 ; last one could a 8 instead.
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 XT_SET_BASE:
00f966 f001          .dw DO_COLON 
                 PFA_SET_BASE:        ; ( adr1 len1 -- adr2 len2 ) 
                 .endif
00f967 f0dc          .dw XT_OVER
00f968 f0a5          .dw XT_CFETCH
00f969 f041          .dw XT_DOLITERAL
00f96a 0023          .dw 35
00f96b f1a0          .dw XT_MINUS
00f96c f0be          .dw XT_DUP
00f96d f161          .dw XT_ZERO
00f96e f041          .dw XT_DOLITERAL
00f96f 0004          .dw 4
00f970 f69c          .dw XT_WITHIN
00f971 f03a          .dw XT_DOCONDBRANCH
00f972 f97d          DEST(SET_BASE1)
                 	.if cpu_msp430==1
                 	.endif
00f973 f961      	.dw XT_BASES
00f974 f1aa      	.dw XT_PLUS
00f975 f3d3      	.dw XT_FETCHI
00f976 f56c      	.dw XT_BASE
00f977 f08e      	.dw XT_STORE
00f978 f041      	.dw XT_DOLITERAL
00f979 0001      	.dw 1
00f97a f9c3      	.dw XT_SLASHSTRING
00f97b f030      	.dw XT_DOBRANCH
00f97c f97e      	DEST(SET_BASE2)
                 SET_BASE1:
00f97d f0e6      	.dw XT_DROP
                 SET_BASE2:
00f97e f021          .dw XT_EXIT 
                 
                 ; create bases 10 , 16 , 2 , 8 ,
                 ; : set-base 35 - dup 0 4 within if 
                 ;    bases + @i base ! 1 /string 
                 ;   else 
                 ;    drop
                 ;   then ;
                 .include "words/to-number.asm"
                 
                 ; Numeric IO
                 ; convert a string to a number  c-addr2/u2 is the unconverted string
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_TO_NUMBER:
00f97f ff07          .dw $ff07
00f980 6e3e
00f981 6d75
00f982 6562
00f983 0072          .db ">number",0
00f984 f906          .dw VE_HEAD
                     .set VE_HEAD = VE_TO_NUMBER
                 XT_TO_NUMBER:
00f985 f001          .dw DO_COLON
                 
                 .endif
                 
00f986 f0be
00f987 f03a      TONUM1: .DW XT_DUP,XT_DOCONDBRANCH
00f988 f99e              DEST(TONUM3)
00f989 f0dc
00f98a f0a5
00f98b f778              .DW XT_OVER,XT_CFETCH,XT_DIGITQ
00f98c f127
00f98d f03a              .DW XT_ZEROEQUAL,XT_DOCONDBRANCH
00f98e f991              DEST(TONUM2)
00f98f f0e6
00f990 f021              .DW XT_DROP,XT_EXIT
00f991 f10c
00f992 fd14
00f993 f56c
00f994 f086
00f995 0142      TONUM2: .DW XT_TO_R,XT_2SWAP,XT_BASE,XT_FETCH,XT_UDSTAR
00f996 f103
00f997 013a
00f998 fd14              .DW XT_R_FROM,XT_MPLUS,XT_2SWAP
00f999 f041
00f99a 0001
00f99b f9c3
00f99c f030              .DW XT_DOLITERAL,1,XT_SLASHSTRING,XT_DOBRANCH
00f99d f986              DEST(TONUM1)
00f99e f021      TONUM3: .DW XT_EXIT
                 
                 ;C >NUMBER  ud adr u -- ud' adr' u'
                 ;C                      convert string to number
                 ;   BEGIN
                 ;   DUP WHILE
                 ;       OVER C@ DIGIT?
                 ;       0= IF DROP EXIT THEN
                 ;       >R 2SWAP BASE @ UD*
                 ;       R> M+ 2SWAP
                 ;       1 /STRING
                 ;   REPEAT ;
                 .include "words/parse.asm"
                 
                 ; String
                 ; in input buffer parse ccc delimited string by the delimiter char.
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_PARSE:
00f99f ff05          .dw $ff05
00f9a0 6170
00f9a1 7372
00f9a2 0065          .db "parse",0
00f9a3 f97f          .dw VE_HEAD
                     .set VE_HEAD = VE_PARSE
                 XT_PARSE:
00f9a4 f001          .dw DO_COLON
                 PFA_PARSE:
                 .endif
00f9a5 f10c          .dw XT_TO_R     ; ( -- )
00f9a6 f9b9          .dw XT_SOURCE   ; ( -- addr len)
00f9a7 f599          .dw XT_TO_IN     ; ( -- addr len >in)
00f9a8 f086          .dw XT_FETCH
00f9a9 f9c3          .dw XT_SLASHSTRING ; ( -- addr' len' )
                 
00f9aa f103          .dw XT_R_FROM      ; ( -- addr' len' c)
00f9ab f88f          .dw XT_CSCAN       ; ( -- addr' len'')
00f9ac f0be          .dw XT_DUP         ; ( -- addr' len'' len'')
00f9ad f23c          .dw XT_1PLUS
00f9ae f599          .dw XT_TO_IN        ; ( -- addr' len'' len'' >in)
00f9af f266          .dw XT_PLUSSTORE   ; ( -- addr' len')
00f9b0 f041          .dw XT_DOLITERAL
00f9b1 0001          .dw 1
00f9b2 f9c3          .dw XT_SLASHSTRING
00f9b3 f021          .dw XT_EXIT
                 .include "words/source.asm"
                 
                 ; System
                 ; address and current length of the input buffer
                 VE_SOURCE:
00f9b4 ff06          .dw $FF06
00f9b5 6f73
00f9b6 7275
00f9b7 6563          .db "source"
00f9b8 f99f          .dw VE_HEAD
                     .set VE_HEAD = VE_SOURCE
                 XT_SOURCE:
00f9b9 fc21          .dw PFA_DODEFER1
                 PFA_SOURCE:
00f9ba 0016          .dw USER_SOURCE
00f9bb fbea          .dw XT_UDEFERFETCH
00f9bc fbf6          .dw XT_UDEFERSTORE
                 
                 
                 .include "words/slash-string.asm"
                 
                 ; String
                 ; adjust string from addr1 to addr1+n, reduce length from u1 to u2 by n
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SLASHSTRING:
00f9bd ff07          .dw $ff07
00f9be 732f
00f9bf 7274
00f9c0 6e69
00f9c1 0067          .db "/string",0
00f9c2 f9b4          .dw VE_HEAD
                     .set VE_HEAD = VE_SLASHSTRING
                 XT_SLASHSTRING:
00f9c3 f001          .dw DO_COLON
                 PFA_SLASHSTRING:
                 .endif
00f9c4 f0ee          .dw XT_ROT
00f9c5 f0dc          .dw XT_OVER
00f9c6 f1aa          .dw XT_PLUS
00f9c7 f0ee          .dw XT_ROT
00f9c8 f0ee          .dw XT_ROT
00f9c9 f1a0          .dw XT_MINUS
00f9ca f021          .dw XT_EXIT
                 
                 .include "words/parse-name.asm"
                 
                 ; String
                 ; In the SOURCE buffer parse whitespace delimited string. Returns string address within SOURCE.
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 VE_PARSENAME:
00f9cb ff0a          .dw $FF0A 
00f9cc 6170
00f9cd 7372
00f9ce 2d65
00f9cf 616e
00f9d0 656d          .db "parse-name"
00f9d1 f9bd          .dw VE_HEAD
                     .set VE_HEAD = VE_PARSENAME
                 XT_PARSENAME:
00f9d2 f001          .dw DO_COLON 
                 PFA_PARSENAME:
                 .endif
00f9d3 f612          .dw XT_BL
00f9d4 f9d6          .dw XT_SKIPSCANCHAR
00f9d5 f021          .dw XT_EXIT 
                 
                 ; ( c -- addr2 len2 ) 
                 ; String
                 ; skips char and scan what's left in source for char
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 ;VE_SKIPSCANCHAR:
                 ;    .dw $FF0A 
                 ;    .db "skipscanchar"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_SKIPSCANCHAR
                 XT_SKIPSCANCHAR:
00f9d6 f001          .dw DO_COLON
                 PFA_SKIPSCANCHAR:
                 .endif
00f9d7 f10c          .dw XT_TO_R
00f9d8 f9b9          .dw XT_SOURCE 
00f9d9 f599          .dw XT_TO_IN 
00f9da f086          .dw XT_FETCH 
00f9db f9c3          .dw XT_SLASHSTRING 
                 
00f9dc f115          .dw XT_R_FETCH
00f9dd f877          .dw XT_CSKIP
00f9de f103          .dw XT_R_FROM
00f9df f88f          .dw XT_CSCAN
                 
                     ; adjust >IN
00f9e0 f580          .dw XT_2DUP
00f9e1 f1aa          .dw XT_PLUS
00f9e2 f9b9          .dw XT_SOURCE 
00f9e3 f0e6          .dw XT_DROP
00f9e4 f1a0          .dw XT_MINUS
00f9e5 f599          .dw XT_TO_IN
00f9e6 f08e          .dw XT_STORE
00f9e7 f021          .dw XT_EXIT
                 .include "words/find-name.asm"
                 
                 ; Tools
                 ; search wordlists for an entry with the name from c-addr/len
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_FINDNAME:
00f9e8 ff09          .dw $ff09
00f9e9 6966
00f9ea 646e
00f9eb 6e2d
00f9ec 6d61
00f9ed 0065          .db "find-name",0
00f9ee f9cb          .dw VE_HEAD
                     .set VE_HEAD = VE_FINDNAME
                 XT_FINDNAME:
00f9ef f001          .dw DO_COLON
                 PFA_FINDNAME:
                 .endif
00f9f0 f041          .dw XT_DOLITERAL
00f9f1 f9fb          .dw XT_FINDNAMEA
00f9f2 f041          .dw XT_DOLITERAL
00f9f3 005a          .dw CFG_ORDERLISTLEN
00f9f4 0420          .dw XT_MAPSTACK
00f9f5 f127          .dw XT_ZEROEQUAL
00f9f6 f03a          .dw XT_DOCONDBRANCH
00f9f7 f9fa          DEST(PFA_FINDNAME1)
00f9f8 f589            .dw XT_2DROP
00f9f9 f161            .dw XT_ZERO
                 PFA_FINDNAME1:
00f9fa f021          .dw XT_EXIT
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 XT_FINDNAMEA:
00f9fb f001          .dw DO_COLON
                 PFA_FINDNAMEA:
                 .endif
00f9fc f10c          .dw XT_TO_R
00f9fd f580          .dw XT_2DUP
00f9fe f103          .dw XT_R_FROM
00f9ff fc33          .dw XT_SEARCH_WORDLIST
00fa00 f0be          .dw XT_DUP
00fa01 f03a          .dw XT_DOCONDBRANCH
00fa02 fa08          DEST(PFA_FINDNAMEA1)
00fa03 f10c            .dw XT_TO_R
00fa04 f0fd            .dw XT_NIP
00fa05 f0fd            .dw XT_NIP
00fa06 f103            .dw XT_R_FROM
00fa07 f158            .dw XT_TRUE
                 PFA_FINDNAMEA1:
00fa08 f021          .dw XT_EXIT
                 
                 .include "words/prompt-ok.asm"
                 
                 ; System
                 ; send the READY prompt to the command line
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 ;VE_PROMPTOK:
                 ;    .dw $ff02
                 ;    .db "ok"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_PROMPTOK
                 XT_PROMPTOK:
00fa09 f001          .dw DO_COLON
                 PFA_PROMPTOK:
00fa0a f792          .dw XT_DOSLITERAL
00fa0b 0003          .dw 3
00fa0c 6f20
00fa0d 006b          .db " ok",0
                 .endif
00fa0e f7c5          .dw XT_ITYPE
00fa0f f021          .dw XT_EXIT
                 .include "words/prompt-ready.asm"
                 
                 ; System
                 ; process the error prompt
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 ;VE_PROMPTRDY:
                 ;    .dw $ff04
                 ;    .db "p_er"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_PROMPTRDY
                 XT_PROMPTREADY:
00fa10 f001          .dw DO_COLON
                 PFA_PROMPTREADY:
00fa11 f792          .dw XT_DOSLITERAL
00fa12 0002          .dw 2
00fa13 203e          .db "> "
                 .endif
00fa14 f7fa          .dw XT_CR
00fa15 f7c5          .dw XT_ITYPE
00fa16 f021          .dw XT_EXIT
                 .include "words/prompt-error.asm"
                 
                 ; System
                 ; process the error prompt
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 ;VE_PROMPTERROR:
                 ;    .dw $ff04
                 ;    .db "p_er"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_PROMPTERROR
                 XT_PROMPTERROR:
00fa17 f001          .dw DO_COLON
                 PFA_PROMPTERROR:
00fa18 f792      	.dw XT_DOSLITERAL
00fa19 0004          .dw 4
00fa1a 3f20
00fa1b 203f          .db " ?? "
                 .endif
00fa1c f7c5          .dw XT_ITYPE
00fa1d f56c          .dw XT_BASE
00fa1e f086          .dw XT_FETCH
00fa1f f10c          .dw XT_TO_R
00fa20 f5ff          .dw XT_DECIMAL
00fa21 f747          .dw XT_DOT
00fa22 f599          .dw XT_TO_IN
00fa23 f086          .dw XT_FETCH
00fa24 f747          .dw XT_DOT
00fa25 f103          .dw XT_R_FROM
00fa26 f56c          .dw XT_BASE
00fa27 f08e          .dw XT_STORE
00fa28 f021          .dw XT_EXIT
                 
                 .include "words/quit.asm"
                 
                 ; System
                 ; main loop of amforth. accept - interpret in an endless loop
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_QUIT:
00fa29 ff04          .dw $ff04
00fa2a 7571
00fa2b 7469          .db "quit"
00fa2c f9e8          .dw VE_HEAD
                     .set VE_HEAD = VE_QUIT
                 XT_QUIT:
00fa2d f001          .dw DO_COLON
                 PFA_QUIT:
                 .endif
                 PFA_QUIT1:
00fa2e 02cd
00fa2f 02d4
00fa30 f08e          .dw XT_LP0,XT_LP,XT_STORE
00fa31 fa8f          .dw XT_SP0
00fa32 f297          .dw XT_SP_STORE
00fa33 fa9c          .dw XT_RP0
00fa34 f281          .dw XT_RP_STORE
00fa35 036f          .dw XT_LBRACKET
                 
                 PFA_QUIT2:
00fa36 f566          .dw XT_STATE
00fa37 f086          .dw XT_FETCH
00fa38 f127          .dw XT_ZEROEQUAL
00fa39 f03a          .dw XT_DOCONDBRANCH
00fa3a fa3c          DEST(PFA_QUIT4)
00fa3b fa10          .dw XT_PROMPTREADY
                 PFA_QUIT4:
00fa3c f8f9          .dw XT_REFILL
00fa3d f03a          .dw XT_DOCONDBRANCH
00fa3e fa36          DEST(PFA_QUIT2)
00fa3f f041          .dw XT_DOLITERAL
00fa40 fab5          .dw XT_INTERPRET
00fa41 f848          .dw XT_CATCH
00fa42 f0c6          .dw XT_QDUP
00fa43 f03a          .dw XT_DOCONDBRANCH
00fa44 fa4e          DEST(PFA_QUIT3)
00fa45 f0be      	.dw XT_DUP
00fa46 f041      	.dw XT_DOLITERAL
00fa47 fffe      	.dw -2
00fa48 f17b      	.dw XT_LESS
00fa49 f03a      	.dw XT_DOCONDBRANCH
00fa4a fa4c      	DEST(PFA_QUIT5)
00fa4b fa17      	.dw XT_PROMPTERROR
                 PFA_QUIT5:
00fa4c f030      	.dw XT_DOBRANCH
00fa4d fa2e      	DEST(PFA_QUIT1)
                 PFA_QUIT3:
00fa4e fa09          .dw XT_PROMPTOK
00fa4f f030          .dw XT_DOBRANCH
00fa50 fa36          DEST(PFA_QUIT2)
00fa51 f021          .dw XT_EXIT ; never reached
                 
                 .include "words/pause.asm"
                 
                 ; Multitasking
                 ; Fetch pause vector and execute it. may make a context/task switch
                 VE_PAUSE:
00fa52 ff05          .dw $ff05
00fa53 6170
00fa54 7375
00fa55 0065          .db "pause",0
00fa56 fa29          .dw VE_HEAD
                     .set VE_HEAD = VE_PAUSE
                 XT_PAUSE:
00fa57 fc21          .dw PFA_DODEFER1
                 PFA_PAUSE:
00fa58 0125          .dw ram_pause
00fa59 fbd6          .dw XT_RDEFERFETCH
00fa5a fbe0          .dw XT_RDEFERSTORE
                 
                 .dseg
000125           ram_pause: .byte 2
                 .cseg
                 .include "words/cold.asm"
                 
                 ; System
                 ; start up amforth.
                 VE_COLD:
00fa5b ff04          .dw $ff04
00fa5c 6f63
00fa5d 646c          .db "cold"
00fa5e fa52          .dw VE_HEAD
                     .set VE_HEAD = VE_COLD
                 XT_COLD:
00fa5f fa60          .dw PFA_COLD
                 PFA_COLD:
00fa60 b6a4          in_ mcu_boot, MCUSR
00fa61 2422          clr zerol
00fa62 2433          clr zeroh
00fa63 be24          out_ MCUSR, zerol
                     ; clear RAM
00fa64 e0e0          ldi zl, low(ramstart)
00fa65 e0f1          ldi zh, high(ramstart)
                 clearloop:
00fa66 9221          st Z+, zerol
00fa67 30e0          cpi zl, low(sram_size+ramstart)
00fa68 f7e9          brne clearloop
00fa69 34f1          cpi zh, high(sram_size+ramstart)
00fa6a f7d9          brne clearloop
                     ; init first user data area
                     ; allocate space for User Area
                 .dseg
000127           ram_user1: .byte SYSUSERSIZE + APPUSERSIZE
                 .cseg
00fa6b e2e7          ldi zl, low(ram_user1)
00fa6c e0f1          ldi zh, high(ram_user1)
00fa6d 012f          movw upl, zl
                     ; init return stack pointer
00fa6e ef0f          ldi temp0,low(rstackstart)
00fa6f bf0d          out_ SPL,temp0
00fa70 8304          std Z+4, temp0
00fa71 e410          ldi temp1,high(rstackstart)
00fa72 bf1e          out_ SPH,temp1
00fa73 8315          std Z+5, temp1
                 
                     ; init parameter stack pointer
00fa74 eacf          ldi yl,low(stackstart)
00fa75 83c6          std Z+6, yl
00fa76 e4d0          ldi yh,high(stackstart)
00fa77 83d7          std Z+7, yh
                 
                     ; load Forth IP with starting word
00fa78 e8a1          ldi XL, low(PFA_WARM)
00fa79 efba          ldi XH, high(PFA_WARM)
                     ; its a far jump...
00fa7a 940c f005     jmp_ DO_NEXT
                 .include "words/warm.asm"
                 
                 ; System
                 ; initialize amforth further. executes turnkey operation and go to quit
                 VE_WARM:
00fa7c ff04          .dw $ff04
00fa7d 6177
00fa7e 6d72          .db "warm"
00fa7f fa5b          .dw VE_HEAD
                     .set VE_HEAD = VE_WARM
                 XT_WARM:
00fa80 f001          .dw DO_COLON
                 PFA_WARM:
00fa81 fd5a          .dw XT_INITUSER
00fa82 f041          .dw XT_DOLITERAL
00fa83 fb8c          .dw XT_NOOP
00fa84 f041          .dw XT_DOLITERAL
00fa85 fa57          .dw XT_PAUSE
00fa86 fc01          .dw XT_DEFERSTORE
00fa87 036f          .dw XT_LBRACKET
00fa88 f61a          .dw XT_TURNKEY
00fa89 fa2d          .dw XT_QUIT
00fa8a f021          .dw XT_EXIT
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/sp0.asm"
                 
                 ; Stack
                 ; start address of the data stack
                 VE_SP0:
00fa8b ff03          .dw $ff03
00fa8c 7073
00fa8d 0030          .db "sp0",0
00fa8e fa7c          .dw VE_HEAD
                     .set VE_HEAD = VE_SP0
                 XT_SP0:
00fa8f f07c          .dw PFA_DOVALUE1
                 PFA_SP0:
00fa90 0006          .dw USER_SP0
00fa91 fbea          .dw XT_UDEFERFETCH
00fa92 fbf6          .dw XT_UDEFERSTORE
                 
                 ; ( -- addr) 
                 ; Stack
                 ; address of user variable to store top-of-stack for inactive tasks
                 VE_SP:
00fa93 ff02          .dw $ff02
00fa94 7073          .db "sp"
00fa95 fa8b          .dw VE_HEAD
                     .set VE_HEAD = VE_SP
                 XT_SP:
00fa96 f062          .dw PFA_DOUSER
                 PFA_SP:
00fa97 0008          .dw USER_SP
                 .include "words/rp0.asm"
                 
                 ; Stack
                 ; start address of return stack
                 VE_RP0:
00fa98 ff03          .dw $ff03
00fa99 7072
00fa9a 0030          .db "rp0",0
00fa9b fa93          .dw VE_HEAD
                     .set VE_HEAD = VE_RP0
                 XT_RP0:
00fa9c f001          .dw DO_COLON
                 PFA_RP0:
00fa9d faa0          .dw XT_DORP0
00fa9e f086          .dw XT_FETCH
00fa9f f021          .dw XT_EXIT
                 
                 ; ( -- addr) 
                 ; Stack
                 ; user variable of the address of the initial return stack
                 ;VE_DORP0:
                 ;    .dw $ff05
                 ;    .db "(rp0)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DORP0
                 XT_DORP0:
00faa0 f062          .dw PFA_DOUSER
                 PFA_DORP0:
00faa1 0004          .dw USER_RP
                 .include "words/depth.asm"
                 
                 ; Stack
                 ; number of single-cell values contained in the data stack before n was placed on the stack.
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DEPTH:
00faa2 ff05          .dw $ff05
00faa3 6564
00faa4 7470
00faa5 0068          .db "depth",0
00faa6 fa98          .dw VE_HEAD
                     .set VE_HEAD = VE_DEPTH
                 XT_DEPTH:
00faa7 f001          .dw DO_COLON
                 PFA_DEPTH:
                 .endif
00faa8 fa8f          .dw XT_SP0
00faa9 f28e          .dw XT_SP_FETCH
00faaa f1a0          .dw XT_MINUS
00faab f211          .dw XT_2SLASH
00faac f242          .dw XT_1MINUS
00faad f021          .dw XT_EXIT
                 .include "words/interpret.asm"
                 
                 ; System
                 ; Interpret SOURCE word by word.
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_INTERPRET:
00faae ff09          .dw $ff09
00faaf 6e69
00fab0 6574
00fab1 7072
00fab2 6572
00fab3 0074          .db "interpret",0
00fab4 faa2          .dw VE_HEAD
                     .set VE_HEAD = VE_INTERPRET
                 XT_INTERPRET:
00fab5 f001          .dw DO_COLON
                 .endif
                 PFA_INTERPRET:
00fab6 f9d2          .dw XT_PARSENAME ; ( -- addr len )
00fab7 f0be          .dw XT_DUP   ; ( -- addr len flag)
00fab8 f03a          .dw XT_DOCONDBRANCH
00fab9 fac5          DEST(PFA_INTERPRET2)
00faba fad0            .dw XT_DORECOGNIZER
00fabb f566            .dw XT_STATE
00fabc f086            .dw XT_FETCH
00fabd f03a            .dw XT_DOCONDBRANCH
00fabe fac0          DEST(PFA_INTERPRET1)
00fabf fbb9            .dw XT_ICELLPLUS   ; we need the compile action
                 PFA_INTERPRET1:
00fac0 f3d3            .dw XT_FETCHI
00fac1 f02b            .dw XT_EXECUTE
00fac2 fb64            .dw XT_QSTACK
00fac3 f030          .dw XT_DOBRANCH
00fac4 fab6          DEST(PFA_INTERPRET)
                 PFA_INTERPRET2:
00fac5 f589          .dw XT_2DROP
00fac6 f021          .dw XT_EXIT
                 .include "words/do-recognizer.asm"
                 
                 ; System
                 ; walk the recognizer stack
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DORECOGNIZER:
00fac7 ff0d          .dw $ff0d
00fac8 6f64
00fac9 722d
00faca 6365
00facb 676f
00facc 696e
00facd 657a
00face 0072          .db "do-recognizer",0
00facf faae          .dw VE_HEAD
                     .set VE_HEAD = VE_DORECOGNIZER
                 XT_DORECOGNIZER:
00fad0 f001          .dw DO_COLON
                 PFA_DORECOGNIZER:
                 .endif
00fad1 f041          .dw XT_DOLITERAL
00fad2 fadc          .dw XT_DORECOGNIZER_A
00fad3 f041          .dw XT_DOLITERAL
00fad4 006c          .dw CFG_RECOGNIZERLISTLEN
00fad5 0420          .dw XT_MAPSTACK
00fad6 f127          .dw XT_ZEROEQUAL
00fad7 f03a          .dw XT_DOCONDBRANCH
00fad8 fadb          DEST(PFA_DORECOGNIZER1)
00fad9 f589            .dw XT_2DROP
00fada fb57            .dw XT_R_FAIL
                 PFA_DORECOGNIZER1:
00fadb f021          .dw XT_EXIT
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 ; ( addr len XT -- addr len [ r:table -1 | 0 ] )
                 XT_DORECOGNIZER_A:
00fadc f001         .dw DO_COLON
                 PFA_DORECOGNIZER_A:
                 .endif
00fadd f0ee         .dw XT_ROT  ; -- len xt addr
00fade f0ee         .dw XT_ROT  ; -- xt addr len
00fadf f580         .dw XT_2DUP 
00fae0 f31f         .dw XT_2TO_R
00fae1 f0ee         .dw XT_ROT  ; -- addr len xt
00fae2 f02b         .dw XT_EXECUTE ; -- i*x r:foo | r:fail
00fae3 f32e         .dw XT_2R_FROM
00fae4 f0ee         .dw XT_ROT
00fae5 f0be         .dw XT_DUP
00fae6 fb57         .dw XT_R_FAIL
00fae7 fd8d         .dw XT_EQUAL
00fae8 f03a         .dw XT_DOCONDBRANCH
00fae9 faed         DEST(PFA_DORECOGNIZER_A1)
00faea f0e6           .dw XT_DROP
00faeb f161           .dw XT_ZERO
00faec f021           .dw XT_EXIT
                 PFA_DORECOGNIZER_A1:
00faed f0fd         .dw XT_NIP 
00faee f0fd         .dw XT_NIP
00faef f158         .dw XT_TRUE
00faf0 f021         .dw XT_EXIT
                 
                 ; : do-recognizer ( addr len -- i*x r:table|r:fail )
                 ;    \ ( addr len -- addr len 0 | i*x r:table -1 )
                 ;    [: rot rot 2dup 2>r rot execute 2r> rot 
                 ;          dup r:fail = ( -- addr len r:table f )
                 ;          if drop 0 else nip nip -1 then
                 ;    ;] 
                 ;    EE_RECOGNIZERLISTLEN map-stack ( -- i*x addr len r:table f )
                 ;    0= if \ a recognizer did the job, remove addr/len
                 ;     2drop r:fail 
                 ;    then
                 ;
                 .include "words/r-intnumber.asm"
                 
                 ; Interpreter
                 ; Method table for single cell integers
                 
                 
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_R_NUM:
00faf1 ff05          .dw $ff05
00faf2 3a72
00faf3 756e
00faf4 006d          .db "r:num",0
00faf5 fac7          .dw VE_HEAD
                     .set VE_HEAD = VE_R_NUM
                 XT_R_NUM:
00faf6 f05c          .dw PFA_DOCONSTANT
                 PFA_R_NUM:
                 .endif
00faf7 fb8c          .dw XT_NOOP    ; interpret
00faf8 01ed          .dw XT_LITERAL ; compile
00faf9 fb03          .dw XT_FAILNUM ; postpone
                 
                 ; ( -- addr )
                 ; Interpreter
                 ; Method table for double cell integers
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_R_DNUM:
00fafa ff06          .dw $ff06
00fafb 3a72
00fafc 6e64
00fafd 6d75          .db "r:dnum"
00fafe faf1          .dw VE_HEAD
                     .set VE_HEAD = VE_R_DNUM
                 XT_R_DNUM:
00faff f05c          .dw PFA_DOCONSTANT
                 PFA_R_DNUM:
                 .endif
00fb00 fb8c          .dw XT_NOOP     ; interpret
00fb01 fd81          .dw XT_2LITERAL ; compile
00fb02 fb09          .dw XT_FAILDNUM ; postpone
                 
                 ; ( -- addr )
                 ; Interpreter
                 ; Method to print a number and throw exception "invalid postpone"
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 ;VE_FAILNUM:
                 ;    .dw $ff06
                 ;    .db "fail:i"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_FAILNUM
                 XT_FAILNUM:
00fb03 f001          .dw DO_COLON
                 PFA_FAILNUM:
                 .endif
00fb04 f747          .dw XT_DOT
00fb05 f041          .dw XT_DOLITERAL
00fb06 ffd0          .dw -48
00fb07 f85e          .dw XT_THROW
00fb08 f021          .dw XT_EXIT
                 
                 ; ( -- addr )
                 ; Interpreter
                 ; Method to print a double cell number and throw exception "invalid postpone"
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 VE_FAILDNUM:
                 ;    .dw $ff06
                 ;    .db "fail:d"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_FAILDNUM
                 XT_FAILDNUM:
00fb09 f001          .dw DO_COLON
                 PFA_FAILDNUM:
                 .endif
00fb0a f73f          .dw XT_DDOT
00fb0b f041          .dw XT_DOLITERAL
00fb0c ffd0          .dw -48
00fb0d f85e          .dw XT_THROW
00fb0e f021          .dw XT_EXIT
                 
                 ; ( addr len -- f )
                 ; Interpreter
                 ; recognizer for integer numbers
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 VE_REC_NUM:
00fb0f ff07          .dw $ff07
00fb10 6572
00fb11 3a63
00fb12 756e
00fb13 006d          .db "rec:num",0
00fb14 fafa          .dw VE_HEAD
                     .set VE_HEAD = VE_REC_NUM
                 XT_REC_NUM:
00fb15 f001          .dw DO_COLON
                 PFA_REC_NUM:
                 .endif
                     ; try converting to a number
00fb16 f90b          .dw XT_NUMBER
00fb17 f03a          .dw XT_DOCONDBRANCH
00fb18 fb22          DEST(PFA_REC_NONUMBER)
00fb19 f041          .dw XT_DOLITERAL
00fb1a 0001          .dw 1
00fb1b fd8d          .dw XT_EQUAL
00fb1c f03a          .dw XT_DOCONDBRANCH
00fb1d fb20          DEST(PFA_REC_INTNUM2)
00fb1e faf6            .dw XT_R_NUM
00fb1f f021            .dw XT_EXIT
                 PFA_REC_INTNUM2:
00fb20 faff            .dw XT_R_DNUM
00fb21 f021            .dw XT_EXIT
                 PFA_REC_NONUMBER:
00fb22 fb57          .dw XT_R_FAIL
00fb23 f021          .dw XT_EXIT
                 .include "words/r-word.asm"
                 
                 ; Interpreter
                 ; search for a word
                 .if cpu_msp430==1
                 .endif
                 .if cpu_avr8==1
                 VE_REC_WORD:
00fb24 ff08          .dw $ff08
00fb25 6572
00fb26 3a63
00fb27 6f77
00fb28 6472          .db "rec:word"
00fb29 fb0f          .dw VE_HEAD
                     .set VE_HEAD = VE_REC_WORD
                 XT_REC_WORD:
00fb2a f001          .dw DO_COLON
                 PFA_REC_WORD:
                 .endif
00fb2b f9ef          .DW XT_FINDNAME
00fb2c f0be          .dw XT_DUP
00fb2d f127          .dw XT_ZEROEQUAL
00fb2e f03a          .dw XT_DOCONDBRANCH
00fb2f fb33          DEST(PFA_REC_WORD_FOUND)
00fb30 f0e6              .dw XT_DROP
00fb31 fb57      	.dw XT_R_FAIL
00fb32 f021      	.dw XT_EXIT
                 PFA_REC_WORD_FOUND:
00fb33 fb3a          .dw XT_R_WORD
                 
00fb34 f021          .dw XT_EXIT
                 
                 ; ( -- addr )
                 ; Interpreter
                 ; actions to handle execution tokens and their flags
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_R_WORD:
00fb35 ff06          .dw $ff06
00fb36 3a72
00fb37 6f77
00fb38 6472          .db "r:word"
00fb39 fb24          .dw VE_HEAD
                     .set VE_HEAD = VE_R_WORD
                 XT_R_WORD:
00fb3a f05c          .dw PFA_DOCONSTANT
                 PFA_R_WORD:
                 .endif
00fb3b fb3e          .dw XT_R_WORD_INTERPRET
00fb3c fb42          .dw XT_R_WORD_COMPILE
00fb3d fb4a          .dw XT_R_WORD_POSTPONE
                 
                 ; ( XT flags -- )
                 ; Interpreter
                 ; interpret method for WORD recognizer
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 XT_R_WORD_INTERPRET:
00fb3e f001          .dw DO_COLON
                 PFA_R_WORD_INTERPRET:
                 .endif
00fb3f f0e6          .dw XT_DROP ; the flags are in the way
00fb40 f02b          .dw XT_EXECUTE
00fb41 f021          .dw XT_EXIT
                 
                 ; ( XT flags -- )
                 ; Interpreter
                 ; Compile method for WORD recognizer
                 .if cpu_msp430==1
                 .endif
                 .if cpu_avr8==1
                 XT_R_WORD_COMPILE:
00fb42 f001          .dw DO_COLON
                 PFA_R_WORD_COMPILE:
                 .endif
00fb43 f12e          .dw XT_ZEROLESS
00fb44 f03a          .dw XT_DOCONDBRANCH
00fb45 fb48          DEST(PFA_R_WORD_COMPILE1)
00fb46 01d7      	.dw XT_COMMA
00fb47 f021              .dw XT_EXIT
                 PFA_R_WORD_COMPILE1:
00fb48 f02b              .dw XT_EXECUTE
00fb49 f021          .dw XT_EXIT
                 
                 ; ( XT flags -- )
                 ; Interpreter
                 ; Postpone method for WORD recognizer
                 .if cpu_msp430==1
                 .endif
                 .if cpu_avr8==1
                 XT_R_WORD_POSTPONE:
00fb4a f001          .dw DO_COLON
                 PFA_R_WORD_POSTPONE:
                 .endif
00fb4b f12e          .dw XT_ZEROLESS
00fb4c f03a          .dw XT_DOCONDBRANCH
00fb4d fb50          DEST(PFA_R_WORD_POSTPONE1)
00fb4e 01cc            .dw XT_COMPILE
00fb4f 01cc            .dw XT_COMPILE
                 PFA_R_WORD_POSTPONE1:
00fb50 01d7          .dw XT_COMMA
00fb51 f021          .dw XT_EXIT
                 .include "words/r-fail.asm"
                 
                 ; Interpreter
                 ; there is no parser for this recognizer, this is the default and failsafe part
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_R_FAIL:
00fb52 ff06          .dw $ff06
00fb53 3a72
00fb54 6166
00fb55 6c69          .db "r:fail"
00fb56 fb35          .dw VE_HEAD
                     .set VE_HEAD = VE_R_FAIL
                 XT_R_FAIL:
00fb57 f05c          .dw PFA_DOCONSTANT
                 PFA_R_FAIL:
                 .endif
00fb58 fb5b          .dw XT_FAIL  ; interpret
00fb59 fb5b          .dw XT_FAIL  ; compile
00fb5a fb5b          .dw XT_FAIL  ; postpone
                 
                 ; ( addr len -- )
                 ; Interpreter
                 ; default failure action: throw exception -13.
                 .if cpu_msp430==1
                 .endif
                 .if cpu_avr8==1
                 ;VE_FAIL:
                 ;    .dw $ff04
                 ;    .db "fail"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_FAIL
                 XT_FAIL:
00fb5b f001          .dw DO_COLON
                 PFA_FAIL:
                 .endif
00fb5c f041          .dw XT_DOLITERAL
00fb5d fff3          .dw -13
00fb5e f85e          .dw XT_THROW
                 
                 .include "words/q-stack.asm"
                 
                 ; Tools
                 ; check data stack depth and exit to quit if underrun
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_QSTACK:
00fb5f ff06          .dw $ff06
00fb60 733f
00fb61 6174
00fb62 6b63          .db "?stack"
00fb63 fb52          .dw VE_HEAD
                     .set VE_HEAD = VE_QSTACK
                 XT_QSTACK:
00fb64 f001          .dw DO_COLON
                 PFA_QSTACK:
                 .endif
00fb65 faa7          .dw XT_DEPTH
00fb66 f12e          .dw XT_ZEROLESS
00fb67 f03a          .dw XT_DOCONDBRANCH
00fb68 fb6c          DEST(PFA_QSTACK1)
00fb69 f041            .dw XT_DOLITERAL
00fb6a fffc            .dw -4
00fb6b f85e            .dw XT_THROW
                 PFA_QSTACK1:
00fb6c f021          .dw XT_EXIT
                 .include "words/ver.asm"
                 
                 ; Tools
                 ; print the version string
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DOT_VER:
00fb6d ff03          .dw $ff03
00fb6e 6576
../../common\words/ver.asm(12): warning: .cseg .db misalignment - padding zero byte
00fb6f 0072          .db "ver"
00fb70 fb5f          .dw VE_HEAD
                     .set VE_HEAD = VE_DOT_VER
                 XT_DOT_VER:
00fb71 f001          .dw DO_COLON
                 PFA_DOT_VER:
                 .endif
00fb72 f528          .dw XT_ENV_FORTHNAME
00fb73 f7c5          .dw XT_ITYPE
00fb74 f807          .dw XT_SPACE
00fb75 f56c          .dw XT_BASE
00fb76 f086          .dw XT_FETCH
                 
00fb77 f536          .dw XT_ENV_FORTHVERSION
00fb78 f5ff          .dw XT_DECIMAL
00fb79 fd71          .dw XT_S2D
00fb7a f6e3          .dw XT_L_SHARP
00fb7b f6eb          .dw XT_SHARP
00fb7c f041          .dw XT_DOLITERAL
00fb7d 002e          .dw '.'
00fb7e f6d4          .dw XT_HOLD
00fb7f f701          .dw XT_SHARP_S
00fb80 f70c          .dw XT_SHARP_G
00fb81 f820          .dw XT_TYPE
00fb82 f56c          .dw XT_BASE
00fb83 f08e          .dw XT_STORE
00fb84 f807          .dw XT_SPACE
00fb85 f53e          .dw XT_ENV_CPU
00fb86 f7c5          .dw XT_ITYPE
                 
00fb87 f021          .dw XT_EXIT
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/noop.asm"
                 
                 ; Tools
                 ; do nothing
                 VE_NOOP:
00fb88 ff04          .dw $ff04
00fb89 6f6e
00fb8a 706f          .db "noop"
00fb8b fb6d          .dw VE_HEAD
                     .set VE_HEAD = VE_NOOP
                 XT_NOOP:
00fb8c fb8d          .dw PFA_NOOP
                 PFA_NOOP:
00fb8d 940c f005     jmp_ DO_NEXT
                 .include "words/unused.asm"
                 
                 ; Tools
                 ; Amount of available RAM (incl. PAD)
                 VE_UNUSED:
00fb8f ff06          .dw $ff06
00fb90 6e75
00fb91 7375
00fb92 6465          .db "unused"
00fb93 fb88          .dw VE_HEAD
                     .set VE_HEAD = VE_UNUSED
                 XT_UNUSED:
00fb94 f001          .dw DO_COLON
                 PFA_UNUSED:
00fb95 f28e          .dw XT_SP_FETCH
00fb96 f5e0          .dw XT_HERE
00fb97 f1a0          .dw XT_MINUS
00fb98 f021          .dw XT_EXIT
                 
                 .include "words/to.asm"
                 
                 ; Tools
                 ; store the TOS to the named value (eeprom cell)
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_TO:
00fb99 0002          .dw $0002
00fb9a 6f74          .db "to"
00fb9b fb8f          .dw VE_HEAD
                     .set VE_HEAD = VE_TO
                 XT_TO:
00fb9c f001          .dw DO_COLON
                 PFA_TO:
                 .endif
00fb9d f82f          .dw XT_TICK
00fb9e fd7a          .dw XT_TO_BODY
00fb9f f566          .dw XT_STATE
00fba0 f086          .dw XT_FETCH
00fba1 f03a          .dw XT_DOCONDBRANCH
00fba2 fbad          DEST(PFA_TO1)
00fba3 01cc          .dw XT_COMPILE
00fba4 fba7          .dw XT_DOTO
00fba5 01d7          .dw XT_COMMA
00fba6 f021          .dw XT_EXIT
                 
                 ; ( n -- ) (R: IP -- IP+1)
                 ; Tools
                 ; runtime portion of to
                 ;VE_DOTO:
                 ;    .dw $ff04
                 ;    .db "(to)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOTO
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 XT_DOTO:
00fba7 f001          .dw DO_COLON
                 PFA_DOTO:
                 .endif
00fba8 f103          .dw XT_R_FROM
00fba9 f0be          .dw XT_DUP
00fbaa fbb9          .dw XT_ICELLPLUS
00fbab f10c          .dw XT_TO_R
00fbac f3d3          .dw XT_FETCHI
                 PFA_TO1:
00fbad f0be          .dw XT_DUP
00fbae fbb9          .dw XT_ICELLPLUS
00fbaf fbb9          .dw XT_ICELLPLUS
00fbb0 f3d3          .dw XT_FETCHI
00fbb1 f02b          .dw XT_EXECUTE
00fbb2 f021          .dw XT_EXIT
                 .include "words/i-cellplus.asm"
                 
                 ; Compiler
                 ; skip to the next cell in flash
                 VE_ICELLPLUS:
00fbb3 ff07          .dw $FF07
00fbb4 2d69
00fbb5 6563
00fbb6 6c6c
00fbb7 002b          .db "i-cell+",0
00fbb8 fb99          .dw VE_HEAD
                     .set VE_HEAD = VE_ICELLPLUS
                 XT_ICELLPLUS:
00fbb9 f001          .dw DO_COLON
                 PFA_ICELLPLUS:
00fbba f23c          .dw XT_1PLUS
00fbbb f021          .dw XT_EXIT
                 
                 .include "words/edefer-fetch.asm"
                 
                 ; System
                 ; does the real defer@ for eeprom defers
                 VE_EDEFERFETCH:
00fbbc ff07          .dw $ff07
00fbbd 6445
00fbbe 6665
00fbbf 7265
00fbc0 0040          .db "Edefer@",0
00fbc1 fbb3          .dw VE_HEAD
                     .set VE_HEAD = VE_EDEFERFETCH
                 XT_EDEFERFETCH:
00fbc2 f001          .dw DO_COLON
                 PFA_EDEFERFETCH:
00fbc3 f3d3          .dw XT_FETCHI
00fbc4 f360          .dw XT_FETCHE
00fbc5 f021          .dw XT_EXIT
                 .include "words/edefer-store.asm"
                 
                 ; System
                 ; does the real defer! for eeprom defers
                 VE_EDEFERSTORE:
00fbc6 ff07          .dw $ff07
00fbc7 6445
00fbc8 6665
00fbc9 7265
00fbca 0021          .db "Edefer!",0
00fbcb fbbc          .dw VE_HEAD
                     .set VE_HEAD = VE_EDEFERSTORE
                 XT_EDEFERSTORE:
00fbcc f001          .dw DO_COLON
                 PFA_EDEFERSTORE:
00fbcd f3d3          .dw XT_FETCHI
00fbce f33c          .dw XT_STOREE
00fbcf f021          .dw XT_EXIT
                 .include "words/rdefer-fetch.asm"
                 
                 ; System
                 ; The defer@ for ram defers
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_RDEFERFETCH:
00fbd0 ff07          .dw $ff07
00fbd1 6452
00fbd2 6665
00fbd3 7265
00fbd4 0040          .db "Rdefer@",0
00fbd5 fbc6          .dw VE_HEAD
                     .set VE_HEAD = VE_RDEFERFETCH
                 XT_RDEFERFETCH:
00fbd6 f001          .dw DO_COLON
                 PFA_RDEFERFETCH:
                 .endif
00fbd7 f3d3          .dw XT_FETCHI
00fbd8 f086          .dw XT_FETCH
00fbd9 f021          .dw XT_EXIT
                 .include "words/rdefer-store.asm"
                 
                 ; System
                 ; The defer! for ram defers
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_RDEFERSTORE:
00fbda ff07          .dw $ff07
00fbdb 6452
00fbdc 6665
00fbdd 7265
00fbde 0021          .db "Rdefer!",0
00fbdf fbd0          .dw VE_HEAD
                     .set VE_HEAD = VE_RDEFERSTORE
                 XT_RDEFERSTORE:
00fbe0 f001          .dw DO_COLON
                 PFA_RDEFERSTORE:
                 .endif
00fbe1 f3d3          .dw XT_FETCHI
00fbe2 f08e          .dw XT_STORE
00fbe3 f021          .dw XT_EXIT
                 
                 .include "words/udefer-fetch.asm"
                 
                 ; System
                 ; does the real defer@ for user based defers
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_UDEFERFETCH:
00fbe4 ff07          .dw $ff07
00fbe5 6455
00fbe6 6665
00fbe7 7265
00fbe8 0040          .db "Udefer@",0
00fbe9 fbda          .dw VE_HEAD
                     .set VE_HEAD = VE_UDEFERFETCH
                 XT_UDEFERFETCH:
00fbea f001          .dw DO_COLON
                 PFA_UDEFERFETCH:
                 .endif
00fbeb f3d3          .dw XT_FETCHI
00fbec f303          .dw XT_UP_FETCH
00fbed f1aa          .dw XT_PLUS
00fbee f086          .dw XT_FETCH
00fbef f021          .dw XT_EXIT
                 .include "words/udefer-store.asm"
                 
                 ; System
                 ; does the real defer! for user based defers
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_UDEFERSTORE:
00fbf0 ff07          .dw $ff07
00fbf1 6455
00fbf2 6665
00fbf3 7265
00fbf4 0021          .db "Udefer!",0
00fbf5 fbe4          .dw VE_HEAD
                     .set VE_HEAD = VE_UDEFERSTORE
                 XT_UDEFERSTORE:
00fbf6 f001          .dw DO_COLON
                 PFA_UDEFERSTORE:
                 .endif
                 
00fbf7 f3d3          .dw XT_FETCHI
00fbf8 f303          .dw XT_UP_FETCH
00fbf9 f1aa          .dw XT_PLUS
00fbfa f08e          .dw XT_STORE
00fbfb f021          .dw XT_EXIT
                 
                 .include "words/defer-store.asm"
                 
                 ; System
                 ; stores xt1 as the xt to be executed when xt2 is called
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DEFERSTORE:
00fbfc ff06          .dw $ff06
00fbfd 6564
00fbfe 6566
00fbff 2172          .db "defer!"
00fc00 fbf0          .dw VE_HEAD
                     .set VE_HEAD = VE_DEFERSTORE
                 XT_DEFERSTORE:
00fc01 f001          .dw DO_COLON
                 PFA_DEFERSTORE:
                 .endif
00fc02 fd7a          .dw XT_TO_BODY
00fc03 f0be          .dw XT_DUP
00fc04 fbb9          .dw XT_ICELLPLUS
00fc05 fbb9          .dw XT_ICELLPLUS
00fc06 f3d3          .dw XT_FETCHI
00fc07 f02b          .dw XT_EXECUTE
00fc08 f021          .dw XT_EXIT
                 
                 .include "words/defer-fetch.asm"
                 
                 ; System
                 ; returns the XT associated with the given XT
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DEFERFETCH:
00fc09 ff06          .dw $ff06
00fc0a 6564
00fc0b 6566
00fc0c 4072          .db "defer@"
00fc0d fbfc          .dw VE_HEAD
                     .set VE_HEAD = VE_DEFERFETCH
                 XT_DEFERFETCH:
00fc0e f001          .dw DO_COLON
                 PFA_DEFERFETCH:
                 .endif
00fc0f fd7a          .dw XT_TO_BODY 
00fc10 f0be          .dw XT_DUP
00fc11 fbb9          .dw XT_ICELLPLUS
00fc12 f3d3          .dw XT_FETCHI
00fc13 f02b          .dw XT_EXECUTE
00fc14 f021          .dw XT_EXIT
                 .include "words/do-defer.asm"
                 
                 ; System
                 ; runtime of defer
                 VE_DODEFER:
00fc15 ff07          .dw $ff07
00fc16 6428
00fc17 6665
00fc18 7265
00fc19 0029          .db "(defer)", 0
00fc1a fc09          .dw VE_HEAD
                     .set VE_HEAD = VE_DODEFER
                 XT_DODEFER:
00fc1b f001          .dw DO_COLON
                 PFA_DODEFER:
00fc1c 01a6          .dw XT_DOCREATE
00fc1d 030a          .dw XT_REVEAL
00fc1e 01cc          .dw XT_COMPILE
00fc1f fc21          .dw PFA_DODEFER1
00fc20 f021          .dw XT_EXIT
                 PFA_DODEFER1:
00fc21 940e 032e     call_ DO_DODOES
00fc23 f0be          .dw XT_DUP
00fc24 fbb9          .dw XT_ICELLPLUS
00fc25 f3d3          .dw XT_FETCHI
00fc26 f02b          .dw XT_EXECUTE 
00fc27 f02b          .dw XT_EXECUTE
00fc28 f021          .dw XT_EXIT
                 
                 ; : (defer) <builds does> dup i-cell+ @i execute execute ;
                 
                 
                 .include "words/search-wordlist.asm"
                 
                 ; Search Order
                 ; searches the word list wid for the word at c-addr/len
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SEARCH_WORDLIST:
00fc29 ff0f          .dw $ff0f
00fc2a 6573
00fc2b 7261
00fc2c 6863
00fc2d 772d
00fc2e 726f
00fc2f 6c64
00fc30 7369
00fc31 0074          .db "search-wordlist",0
00fc32 fc15          .dw VE_HEAD
                     .set VE_HEAD = VE_SEARCH_WORDLIST
                 XT_SEARCH_WORDLIST:
00fc33 f001          .dw DO_COLON
                 PFA_SEARCH_WORDLIST:
                 .endif
00fc34 f10c          .dw XT_TO_R
00fc35 f161          .dw XT_ZERO
00fc36 f041          .dw XT_DOLITERAL
00fc37 fc48          .dw XT_ISWORD
00fc38 f103          .dw XT_R_FROM
00fc39 fc65          .dw XT_TRAVERSEWORDLIST
00fc3a f0be          .dw XT_DUP
00fc3b f127          .dw XT_ZEROEQUAL
00fc3c f03a          .dw XT_DOCONDBRANCH
00fc3d fc42          DEST(PFA_SEARCH_WORDLIST1)
00fc3e f589             .dw XT_2DROP
00fc3f f0e6             .dw XT_DROP
00fc40 f161             .dw XT_ZERO
00fc41 f021             .dw XT_EXIT
                 PFA_SEARCH_WORDLIST1:
                       ; ... get the XT ...
00fc42 f0be            .dw XT_DUP
00fc43 fc8c            .dw XT_NFA2CFA
                       ; .. and get the header flag
00fc44 f0d1            .dw XT_SWAP
00fc45 0178            .dw XT_NAME2FLAGS
00fc46 0165            .dw XT_IMMEDIATEQ
00fc47 f021          .dw XT_EXIT
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 XT_ISWORD:
00fc48 f001          .dw DO_COLON
                 PFA_ISWORD:
                 .endif
                     ; ( c-addr len 0 nt -- c-addr len 0 true| nt false )
00fc49 f10c          .dw XT_TO_R
00fc4a f0e6          .dw XT_DROP
00fc4b f580          .dw XT_2DUP
00fc4c f115          .dw XT_R_FETCH  ; -- addr len addr len nt
00fc4d fc80          .dw XT_NAME2STRING
00fc4e fc96          .dw XT_ICOMPARE      ; (-- addr len f )
00fc4f f03a          .dw XT_DOCONDBRANCH
00fc50 fc56          DEST(PFA_ISWORD3)
                       ; not now
00fc51 f103            .dw XT_R_FROM
00fc52 f0e6            .dw XT_DROP
00fc53 f161            .dw XT_ZERO
00fc54 f158            .dw XT_TRUE         ; maybe next word
00fc55 f021            .dw XT_EXIT
                 PFA_ISWORD3:
                       ; we found the word, now clean up iteration data ...
00fc56 f589            .dw XT_2DROP
00fc57 f103            .dw XT_R_FROM
00fc58 f161            .dw XT_ZERO       ; finish traverse-wordlist
00fc59 f021            .dw XT_EXIT
                 .include "words/traverse-wordlist.asm"
                 
                 ; Tools Ext (2012)
                 ; call the xt for every member of the wordlist wid until xt returns false
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_TRAVERSEWORDLIST:
00fc5a ff11          .dw $ff11
00fc5b 7274
00fc5c 7661
00fc5d 7265
00fc5e 6573
00fc5f 772d
00fc60 726f
00fc61 6c64
00fc62 7369
00fc63 0074          .db "traverse-wordlist",0
00fc64 fc29          .dw VE_HEAD
                     .set VE_HEAD = VE_TRAVERSEWORDLIST
                 XT_TRAVERSEWORDLIST:
00fc65 f001          .dw DO_COLON
                 PFA_TRAVERSEWORDLIST:
                 
                 .endif
00fc66 f360          .dw XT_FETCHE
                 PFA_TRAVERSEWORDLIST1:
00fc67 f0be          .dw XT_DUP           ; ( -- xt nt nt )
00fc68 f03a          .dw XT_DOCONDBRANCH  ; ( -- nt ) is nfa = counted string
00fc69 fc76          DEST(PFA_TRAVERSEWORDLIST2)
00fc6a f580          .dw XT_2DUP
00fc6b f31f          .dw XT_2TO_R
00fc6c f0d1          .dw XT_SWAP
00fc6d f02b          .dw XT_EXECUTE
00fc6e f32e          .dw XT_2R_FROM
00fc6f f0ee          .dw XT_ROT
00fc70 f03a          .dw XT_DOCONDBRANCH
00fc71 fc76          DEST(PFA_TRAVERSEWORDLIST2)
00fc72 0487          .dw XT_NFA2LFA
00fc73 f3d3          .dw XT_FETCHI
00fc74 f030          .dw XT_DOBRANCH      ; ( -- addr )
00fc75 fc67          DEST(PFA_TRAVERSEWORDLIST1)       ; ( -- addr )
                 PFA_TRAVERSEWORDLIST2:
00fc76 f589          .dw XT_2DROP
00fc77 f021          .dw XT_EXIT
                 
                 ; : traverse-wordlist ( i*x xt wid -- i*x' ) 
                 ;        begin @ dup 
                 ;        while 
                 ;          2dup 2>r 
                 ;          cell + swap execute ( i*x nt -- i*x' f ) 
                 ;          2r> rot 
                 ;        while repeat then 2drop ; 
                 .include "words/name2string.asm"
                 
                 ; Tools Ext (2012)
                 ; get a (flash) string from a name token nt
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_NAME2STRING:
00fc78 ff0b          .dw $ff0b
00fc79 616e
00fc7a 656d
00fc7b 733e
00fc7c 7274
00fc7d 6e69
00fc7e 0067          .db "name>string",0
00fc7f fc5a          .dw VE_HEAD
                     .set VE_HEAD = VE_NAME2STRING
                 XT_NAME2STRING:
00fc80 f001          .dw DO_COLON
                 PFA_NAME2STRING:
                 
                 .endif
00fc81 f7f1          .dw XT_ICOUNT   ; ( -- addr n )
00fc82 f041          .dw XT_DOLITERAL
00fc83 00ff          .dw 255
00fc84 f220          .dw XT_AND      ; mask immediate bit
00fc85 f021          .dw XT_EXIT
                 .include "words/nfa2cfa.asm"
                 
                 ; Tools
                 ; get the XT from a name token
                 VE_NFA2CFA:
00fc86 ff07          .dw $ff07
00fc87 666e
00fc88 3e61
00fc89 6663
../../avr8\words/nfa2cfa.asm(6): warning: .cseg .db misalignment - padding zero byte
00fc8a 0061          .db "nfa>cfa"
00fc8b fc78          .dw VE_HEAD
                     .set VE_HEAD = VE_NFA2CFA
                 XT_NFA2CFA:
00fc8c f001          .dw DO_COLON
                 PFA_NFA2CFA:
00fc8d 0487          .dw XT_NFA2LFA ; skip to link field
00fc8e f23c          .dw XT_1PLUS   ; next is the execution token
00fc8f f021          .dw XT_EXIT
                 .include "words/icompare.asm"
                 
                 ; Tools
                 ; compares string in RAM with string in flash. f is zero if equal like COMPARE
                 VE_ICOMPARE:
00fc90 ff08          .dw $ff08
00fc91 6369
00fc92 6d6f
00fc93 6170
00fc94 6572          .db "icompare"
00fc95 fc86          .dw VE_HEAD
                     .set VE_HEAD = VE_ICOMPARE
                 XT_ICOMPARE:
00fc96 f001          .dw DO_COLON
                 PFA_ICOMPARE:
00fc97 f10c          .dw XT_TO_R    ; ( -- r-addr r-len f-addr)
00fc98 f0dc          .dw XT_OVER    ; ( -- r-addr r-len f-addr r-len)
00fc99 f103          .dw XT_R_FROM  ; ( -- r-addr r-len f-addr r-len f-len )
00fc9a f120          .dw XT_NOTEQUAL ; ( -- r-addr r-len f-addr flag )
00fc9b f03a          .dw XT_DOCONDBRANCH
00fc9c fca1          .dw PFA_ICOMPARE_SAMELEN
00fc9d f589            .dw XT_2DROP
00fc9e f0e6            .dw XT_DROP
00fc9f f158            .dw XT_TRUE
00fca0 f021            .dw XT_EXIT
                 PFA_ICOMPARE_SAMELEN:
00fca1 f0d1          .dw XT_SWAP ; ( -- r-addr f-addr len )
00fca2 f161          .dw XT_ZERO
00fca3 0296          .dw XT_QDOCHECK
00fca4 f03a          .dw XT_DOCONDBRANCH
00fca5 fcc4          .dw PFA_ICOMPARE_DONE
00fca6 f29c          .dw XT_DODO
                 PFA_ICOMPARE_LOOP:
                     ; ( r-addr f-addr --)
00fca7 f0dc          .dw XT_OVER
00fca8 f086          .dw XT_FETCH
                 .if WANT_IGNORECASE == 1
                 .endif
00fca9 f0dc          .dw XT_OVER
00fcaa f3d3          .dw XT_FETCHI ; ( -- r-addr f-addr r-cc f- cc)
                 .if WANT_IGNORECASE == 1
                 .endif
                     ; flash strings are zero-padded at the last cell
                     ; that means: if the flash cell is less $0100, than mask the
                     ; high byte in the ram cell
00fcab f0be          .dw XT_DUP
                     ;.dw XT_BYTESWAP
00fcac f041          .dw XT_DOLITERAL
00fcad 0100          .dw $100
00fcae f169          .dw XT_ULESS
00fcaf f03a          .dw XT_DOCONDBRANCH
00fcb0 fcb5          .dw PFA_ICOMPARE_LASTCELL
00fcb1 f0d1          .dw XT_SWAP
00fcb2 f041          .dw XT_DOLITERAL
00fcb3 00ff          .dw $00FF
00fcb4 f220          .dw XT_AND  ; the final swap can be omitted
                 PFA_ICOMPARE_LASTCELL:
00fcb5 f120          .dw XT_NOTEQUAL
00fcb6 f03a          .dw XT_DOCONDBRANCH
00fcb7 fcbc          .dw PFA_ICOMPARE_NEXTLOOP
00fcb8 f589          .dw XT_2DROP
00fcb9 f158          .dw XT_TRUE
00fcba f2d5          .dw XT_UNLOOP
00fcbb f021          .dw XT_EXIT
                 PFA_ICOMPARE_NEXTLOOP:
00fcbc f23c          .dw XT_1PLUS
00fcbd f0d1          .dw XT_SWAP
00fcbe f579          .dw XT_CELLPLUS
00fcbf f0d1          .dw XT_SWAP
00fcc0 f041          .dw XT_DOLITERAL
00fcc1 0002          .dw 2
00fcc2 f2bb          .dw XT_DOPLUSLOOP
00fcc3 fca7          .dw PFA_ICOMPARE_LOOP
                 PFA_ICOMPARE_DONE:
00fcc4 f589          .dw XT_2DROP
00fcc5 f161          .dw XT_ZERO
00fcc6 f021          .dw XT_EXIT
                 
                 .if WANT_IGNORECASE == 1
                 .endif
                 
                 .include "words/star.asm"
                 
                 ; Arithmetics
                 ; multiply routine
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_STAR:
00fcc7 ff01          .dw $ff01
00fcc8 002a          .db "*",0
00fcc9 fc90          .dw VE_HEAD
                     .set VE_HEAD = VE_STAR
                 XT_STAR:
00fcca f001          .dw DO_COLON
                 PFA_STAR:
                 .endif
                 
00fccb f1b3          .dw XT_MSTAR
00fccc f0e6          .dw XT_DROP
00fccd f021          .dw XT_EXIT
                 .include "words/j.asm"
                 
                 ; Compiler
                 ; loop counter of outer loop
                 VE_J:
00fcce ff01          .dw $FF01
00fccf 006a          .db "j",0
00fcd0 fcc7          .dw VE_HEAD
                     .set VE_HEAD = VE_J
                 XT_J:
00fcd1 f001          .dw DO_COLON
                 PFA_J:
00fcd2 f277          .dw XT_RP_FETCH
00fcd3 f041          .dw XT_DOLITERAL
00fcd4 0007          .dw 7
00fcd5 f1aa          .dw XT_PLUS
00fcd6 f086          .dw XT_FETCH
00fcd7 f277          .dw XT_RP_FETCH
00fcd8 f041          .dw XT_DOLITERAL
00fcd9 0009          .dw 9
00fcda f1aa          .dw XT_PLUS
00fcdb f086          .dw XT_FETCH
00fcdc f1aa          .dw XT_PLUS
00fcdd f021          .dw XT_EXIT
                 
                 .include "words/dabs.asm"
                 
                 ; Arithmetics
                 ; double cell absolute value
                 VE_DABS:
00fcde ff04          .dw $ff04
00fcdf 6164
00fce0 7362          .db "dabs"
00fce1 fcce          .dw VE_HEAD
                     .set VE_HEAD = VE_DABS
                 XT_DABS:
00fce2 f001          .dw DO_COLON
                 PFA_DABS:
00fce3 f0be          .dw XT_DUP
00fce4 f12e          .dw XT_ZEROLESS
00fce5 f03a          .dw XT_DOCONDBRANCH
00fce6 fce8          .dw PFA_DABS1
00fce7 fcef          .dw XT_DNEGATE
                 PFA_DABS1:
00fce8 f021          .dw XT_EXIT
                 ; : dabs      ( ud1 -- +d2 ) dup 0< if dnegate then ;
                 .include "words/dnegate.asm"
                 
                 ; Arithmetics
                 ; double cell negation
                 VE_DNEGATE:
00fce9 ff07          .dw $ff07
00fcea 6e64
00fceb 6765
00fcec 7461
00fced 0065          .db "dnegate",0
00fcee fcde          .dw VE_HEAD
                     .set VE_HEAD = VE_DNEGATE
                 XT_DNEGATE:
00fcef f001          .dw DO_COLON
                 PFA_DNEGATE:
00fcf0 f446          .dw XT_DINVERT
00fcf1 f041          .dw XT_DOLITERAL
00fcf2 0001          .dw 1
00fcf3 f161          .dw XT_ZERO
00fcf4 f420          .dw XT_DPLUS
00fcf5 f021          .dw XT_EXIT
                 ; : dnegate   ( ud1 -- ud2 ) dinvert 1. d+ ;
                 .include "words/cmove.asm"
                 
                 ; Memory
                 ; copy data in RAM, from lower to higher addresses
                 VE_CMOVE:
00fcf6 ff05          .dw $ff05
00fcf7 6d63
00fcf8 766f
00fcf9 0065          .db "cmove",0
00fcfa fce9          .dw VE_HEAD
                     .set VE_HEAD  = VE_CMOVE
                 XT_CMOVE:
00fcfb fcfc          .dw PFA_CMOVE
                 PFA_CMOVE:
00fcfc 93bf          push xh
00fcfd 93af          push xl
00fcfe 91e9          ld zl, Y+
00fcff 91f9          ld zh, Y+ ; addr-to
00fd00 91a9          ld xl, Y+
00fd01 91b9          ld xh, Y+ ; addr-from
00fd02 2f09          mov temp0, tosh
00fd03 2b08          or temp0, tosl
00fd04 f021          brbs 1, PFA_CMOVE1
                 PFA_CMOVE2:
00fd05 911d          ld temp1, X+
00fd06 9311          st Z+, temp1
00fd07 9701          sbiw tosl, 1
00fd08 f7e1          brbc 1, PFA_CMOVE2
                 PFA_CMOVE1:
00fd09 91af          pop xl
00fd0a 91bf          pop xh
00fd0b 9189
00fd0c 9199          loadtos
00fd0d 940c f005     jmp_ DO_NEXT
                 .include "words/2swap.asm"
                 
                 ; Stack
                 ; Exchange the two top cell pairs
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_2SWAP:
00fd0f ff05          .dw $ff05
00fd10 7332
00fd11 6177
00fd12 0070          .db "2swap",0
00fd13 fcf6          .dw VE_HEAD
                     .set VE_HEAD = VE_2SWAP
                 XT_2SWAP:
00fd14 f001          .dw DO_COLON
                 PFA_2SWAP:
                 
                 .endif
00fd15 f0ee          .dw XT_ROT
00fd16 f10c          .dw XT_TO_R
00fd17 f0ee          .dw XT_ROT
00fd18 f103          .dw XT_R_FROM
00fd19 f021          .dw XT_EXIT
                 
                 .include "words/tib.asm"
                 
                 ; System Variable
                 ; terminal input buffer address
                 VE_TIB:
00fd1a ff03          .dw $ff03
00fd1b 6974
00fd1c 0062          .db "tib",0
00fd1d fd0f          .dw VE_HEAD
                     .set VE_HEAD = VE_TIB
                 XT_TIB:
00fd1e f04f          .dw PFA_DOVARIABLE
                 PFA_TIB:
00fd1f 014d          .dw ram_tib
                     
                 .dseg
00014d           ram_tib: .byte TIBSIZE
                 .cseg
                 ; ( -- f ) 
                 ; System
                 ; refills the input buffer
                 VE_REFILLTIB:
00fd20 ff0a          .dw $ff0a
00fd21 6572
00fd22 6966
00fd23 6c6c
00fd24 742d
00fd25 6269          .db "refill-tib"
00fd26 fd1a          .dw VE_HEAD
                     .set VE_HEAD = VE_REFILLTIB
                 XT_REFILLTIB:
00fd27 f001          .dw DO_COLON
                 PFA_REFILLTIB:
00fd28 fd1e          .dw XT_TIB
00fd29 f041          .dw XT_DOLITERAL
00fd2a 005a          .dw TIBSIZE
00fd2b f8af          .dw XT_ACCEPT
00fd2c f59f          .dw XT_NUMBERTIB
00fd2d f08e          .dw XT_STORE
00fd2e f161          .dw XT_ZERO
00fd2f f599          .dw XT_TO_IN
00fd30 f08e          .dw XT_STORE
00fd31 f158          .dw XT_TRUE ; -1
00fd32 f021          .dw XT_EXIT
                 
                 ; ( -- addr n ) 
                 ; System
                 ; address and current length of the input buffer
                 VE_SOURCETIB:
00fd33 ff0a          .dw $FF0A
00fd34 6f73
00fd35 7275
00fd36 6563
00fd37 742d
00fd38 6269          .db "source-tib"
00fd39 fd20          .dw VE_HEAD
                     .set VE_HEAD = VE_SOURCETIB
                 XT_SOURCETIB:
00fd3a f001          .dw DO_COLON
                 PFA_SOURCETIB:
00fd3b fd1e          .dw XT_TIB
00fd3c f59f          .dw XT_NUMBERTIB
00fd3d f086          .dw XT_FETCH
00fd3e f021          .dw XT_EXIT
                 
                 .include "words/init-user.asm"
                 
                 ; Tools
                 ; copy len cells from eeprom to ram
                 VE_EE2RAM:
00fd3f ff06        .dw $ff06
00fd40 6565
00fd41 723e
00fd42 6d61        .db "ee>ram"
00fd43 fd33        .dw VE_HEAD
                   .set VE_HEAD = VE_EE2RAM
                 XT_EE2RAM:
00fd44 f001        .dw DO_COLON
                 PFA_EE2RAM:          ; ( -- )
00fd45 f161          .dw XT_ZERO
00fd46 f29c          .dw XT_DODO
                 PFA_EE2RAM_1:
                     ; ( -- e-addr r-addr )
00fd47 f0dc          .dw XT_OVER
00fd48 f360          .dw XT_FETCHE
00fd49 f0dc          .dw XT_OVER
00fd4a f08e          .dw XT_STORE
00fd4b f579          .dw XT_CELLPLUS
00fd4c f0d1          .dw XT_SWAP
00fd4d f579          .dw XT_CELLPLUS
00fd4e f0d1          .dw XT_SWAP
00fd4f f2ca          .dw XT_DOLOOP
00fd50 fd47          .dw PFA_EE2RAM_1
                 PFA_EE2RAM_2:
00fd51 f589          .dw XT_2DROP
00fd52 f021          .dw XT_EXIT
                 
                 ; ( -- )
                 ; Tools
                 ; setup the default user area from eeprom
                 VE_INITUSER:
00fd53 ff09        .dw $ff09
00fd54 6e69
00fd55 7469
00fd56 752d
00fd57 6573
00fd58 0072        .db "init-user",0
00fd59 fd3f        .dw VE_HEAD
                   .set VE_HEAD = VE_INITUSER
                 XT_INITUSER:
00fd5a f001        .dw DO_COLON
                 PFA_INITUSER:          ; ( -- )
00fd5b f041          .dw XT_DOLITERAL
00fd5c 007c          .dw EE_INITUSER
00fd5d f303          .dw XT_UP_FETCH
00fd5e f041          .dw XT_DOLITERAL
00fd5f 001c          .dw SYSUSERSIZE
00fd60 f211          .dw XT_2SLASH
00fd61 fd44          .dw XT_EE2RAM
00fd62 f021          .dw XT_EXIT
                 .include "dict/compiler2.inc"
                 
                 ; included almost independently from each other
                 ; on a include-per-use basis
                 ;
                 .if DICT_COMPILER2 == 0
                 .endif
                 .include "words/bounds.asm"
                 
                 ; Tools
                 ; convert a string to an address range
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_BOUNDS:
00fd63 ff06          .dw $ff06
00fd64 6f62
00fd65 6e75
00fd66 7364          .db "bounds"
00fd67 fd53          .dw VE_HEAD
                     .set VE_HEAD = VE_BOUNDS
                 XT_BOUNDS:
00fd68 f001          .dw DO_COLON
                 PFA_BOUNDS:
                 .endif
00fd69 f0dc          .dw XT_OVER
00fd6a f1aa          .dw XT_PLUS
00fd6b f0d1          .dw XT_SWAP
00fd6c f021          .dw XT_EXIT
                 .include "words/s-to-d.asm"
                 
                 ; Conversion
                 ; extend (signed) single cell value to double cell
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_S2D:
00fd6d ff03          .dw $ff03
00fd6e 3e73
00fd6f 0064          .db "s>d",0
00fd70 fd63          .dw VE_HEAD
                     .set VE_HEAD = VE_S2D
                 XT_S2D:
00fd71 f001          .dw DO_COLON
                 PFA_S2D:
                 .endif
00fd72 f0be          .dw XT_DUP
00fd73 f12e          .dw XT_ZEROLESS
00fd74 f021          .dw XT_EXIT
                 .include "words/to-body.asm"
                 
                 ; Core
                 ; get body from XT
                 VE_TO_BODY:
00fd75 ff05          .dw $ff05
00fd76 623e
00fd77 646f
00fd78 0079          .db ">body",0
00fd79 fd6d          .dw VE_HEAD
                     .set VE_HEAD = VE_TO_BODY
                 XT_TO_BODY:
00fd7a f23d          .dw PFA_1PLUS
                 .elif AMFORTH_NRWW_SIZE>4000
                 .elif AMFORTH_NRWW_SIZE>2000
                 .else
                 .endif
                 ; now colon words
                 ;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/2literal.asm"
                 
                 ; Compiler
                 ; compile a cell pair literal in colon definitions
                 VE_2LITERAL:
00fd7b 0008          .dw $0008
00fd7c 6c32
00fd7d 7469
00fd7e 7265
00fd7f 6c61          .db "2literal"
00fd80 fd75          .dw VE_HEAD
                     .set VE_HEAD = VE_2LITERAL
                 XT_2LITERAL:
00fd81 f001          .dw DO_COLON
                 PFA_2LITERAL:
00fd82 f0d1          .dw XT_SWAP
00fd83 01cc          .dw XT_COMPILE
00fd84 f041          .dw XT_DOLITERAL
00fd85 01d7          .dw XT_COMMA
00fd86 01cc          .dw XT_COMPILE
00fd87 f041          .dw XT_DOLITERAL
00fd88 01d7          .dw XT_COMMA
                     
00fd89 f021          .dw XT_EXIT
                 .include "words/equal.asm"
                 
                 ; Compare
                 ; compares two values for equality
                 VE_EQUAL:
00fd8a ff01          .dw $ff01
00fd8b 003d          .db "=",0
00fd8c fd7b          .dw VE_HEAD
                     .set VE_HEAD = VE_EQUAL
                 XT_EQUAL:
00fd8d f001          .dw DO_COLON
                 PFA_EQUAL:
00fd8e f1a0          .dw XT_MINUS
00fd8f f127          .dw XT_ZEROEQUAL
00fd90 f021          .dw XT_EXIT
                 .include "words/num-constants.asm"
                 
                 .endif
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_ONE:
00fd91 ff01          .dw $ff01
00fd92 0031          .db "1",0
00fd93 fd8a          .dw VE_HEAD
                     .set VE_HEAD = VE_ONE
                 XT_ONE:
00fd94 f04f          .dw PFA_DOVARIABLE
                 PFA_ONE:
                 .endif
00fd95 0001              .DW 1
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_TWO:
00fd96 ff01          .dw $ff01
00fd97 0032          .db "2",0
00fd98 fd91          .dw VE_HEAD
                     .set VE_HEAD = VE_TWO
                 XT_TWO:
00fd99 f04f          .dw PFA_DOVARIABLE
                 PFA_TWO:
                 .endif
00fd9a 0002              .DW 2
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_MINUSONE:
00fd9b ff02          .dw $ff02
00fd9c 312d          .db "-1"
00fd9d fd96          .dw VE_HEAD
                     .set VE_HEAD = VE_MINUSONE
                 XT_MINUSONE:
00fd9e f04f          .dw PFA_DOVARIABLE
                 PFA_MINUSONE:
                 .endif
00fd9f ffff              .DW -1
                 .include "dict_appl_core.inc"
                 
                 ; do not delete it!
                 
                 .set flashlast = pc
                 .if (pc>FLASHEND)
                 .endif
                 
                 .dseg
                 ; define a label for the 1st free ram address
                 HERESTART:
                 .eseg
                 .include "amforth-eeprom.inc"
000046 ff ff     
                 EE_DP:
000048 9e 05         .dw DPSTART      ; Dictionary Pointer
                 EE_HERE:
00004a a7 01         .dw HERESTART    ; Memory Allocation
                 EE_EHERE:
00004c 9a 00         .dw EHERESTART     ; EEProm Memory Allocation
                 EE_TURNKEY:
00004e e9 04         .dw XT_APPLTURNKEY  ; TURNKEY
                 EE_STOREI:
000050 7f f3         .dw XT_DO_STOREI  ; Store a cell into flash
                 
                 EE_ENVIRONMENT:
000052 4d f5         .dw VE_ENVHEAD   ; environmental queries
                 EE_WL_FORTH:
000054 58 00         .dw EE_FORTHWORDLIST; forth-wordlist
                 EE_CURRENT:
000056 58 00         .dw EE_FORTHWORDLIST
                 EE_FORTHWORDLIST:
000058 9b fd         .dw VE_HEAD      ; pre-defined (compiled in) wordlist
                 CFG_ORDERLISTLEN:
00005a 01 00         .dw 1
                 CFG_ORDERLIST: ; list of wordlist id, exactly numwordlist entries
00005c 58 00         .dw EE_FORTHWORDLIST      ; get/set-order
00005e               .byte  (NUMWORDLISTS-1)*CELLSIZE ; one slot is already used
                 CFG_RECOGNIZERLISTLEN:
00006c 02 00         .dw 2
                 CFG_RECOGNIZERLIST:
00006e 2a fb         .dw XT_REC_WORD
000070 15 fb         .dw XT_REC_NUM
000072               .byte  (NUMRECOGNIZERS-2)*CELLSIZE ; two slots are already used
                 
                 EE_WLSCOPE:
000076 48 04         .dw XT_GET_CURRENT  ; default wordlist scope
                 
                 ; LEAVE stack is between data stack and return stack.
                 EE_LP0:
000078 b0 40         .dw stackstart+1
                 
                 ; MARKER saves everything up to here. Nothing beyond gets saved
                 EE_MARKER:
00007a 7a 00         .dw EE_MARKER
                 
                 ; default user area
                 EE_INITUSER:
00007c 00 00         .dw 0  ; USER_STATE
00007e 00 00         .dw 0  ; USER_FOLLOWER
000080 ff 40         .dw rstackstart  ; USER_RP
000082 af 40         .dw stackstart   ; USER_SP0
000084 af 40         .dw stackstart   ; USER_SP
                     
000086 00 00         .dw 0  ; USER_HANDLER
000088 0a 00         .dw 10 ; USER_BASE
                     
00008a a3 00         .dw XT_TX  ; USER_EMIT
00008c b1 00         .dw XT_TXQ ; USER_EMITQ
00008e 79 00         .dw XT_RX  ; USER_KEY
000090 93 00         .dw XT_RXQ ; USER_KEYQ
000092 3a fd         .dw XT_SOURCETIB ; USER_SKEY
000094 00 00         .dw 0            ; USER_G_IN
000096 27 fd         .dw XT_REFILLTIB ; USER_REFILL  
                 
                 ; calculate baud rate error
                 .equ UBRR_VAL   = ((F_CPU+BAUD*8)/(BAUD*16)-1)  ; smart round
                 .equ BAUD_REAL  = (F_CPU/(16*(UBRR_VAL+1)))     ; effective baud rate
                 .equ BAUD_ERROR = ((BAUD_REAL*1000)/BAUD-1000)  ; error in pro mille
                 
                 .if ((BAUD_ERROR>BAUD_MAXERROR) || (BAUD_ERROR<-BAUD_MAXERROR))       
                 .endif
                 EE_UBRRVAL:
000098 19 00         .dw UBRR_VAL     ; BAUDRATE
                 ; 1st free address in EEPROM.
                 EHERESTART:
                 .cseg


RESOURCE USE INFORMATION
------------------------

Notice:
The register and instruction counts are symbol table hit counts,
and hence implicitly used resources are not counted, eg, the
'lpm' instruction without operands implicitly uses r0 and z,
none of which are counted.

x,y,z are separate entities in the symbol table and are
counted separately from r26..r31 here.

.dseg memory usage only counts static data declared with .byte

"ATmega1284P" register use summary:
r0 :  20 r1 :   5 r2 :   9 r3 :  11 r4 :   4 r5 :   1 r6 :   0 r7 :   0 
r8 :   0 r9 :   0 r10:   1 r11:   1 r12:   0 r13:   0 r14:  22 r15:  20 
r16:  87 r17:  56 r18:  61 r19:  37 r20:  13 r21:  38 r22:  11 r23:   3 
r24: 210 r25: 145 r26:  39 r27:  21 r28:   7 r29:   4 r30:  88 r31:  47 
x  :   4 y  : 213 z  :  48 
Registers used: 29 out of 35 (82.9%)

"ATmega1284P" instruction use summary:
.lds  :   0 .sts  :   0 adc   :  21 add   :  16 adiw  :  18 and   :   4 
andi  :   3 asr   :   2 bclr  :   0 bld   :   0 brbc  :   2 brbs  :   7 
brcc  :   3 brcs  :   1 break :   0 breq  :   6 brge  :   1 brhc  :   0 
brhs  :   0 brid  :   0 brie  :   0 brlo  :   1 brlt  :   3 brmi  :   3 
brne  :  21 brpl  :   1 brsh  :   0 brtc  :   0 brts  :   1 brvc  :   0 
brvs  :   2 bset  :   0 bst   :   0 call  :   2 cbi   :   7 cbr   :   1 
clc   :   2 clh   :   0 cli   :   7 cln   :   0 clr   :  21 cls   :   0 
clt   :   1 clv   :   0 clz   :   0 com   :  16 cp    :  10 cpc   :  10 
cpi   :   2 cpse  :   0 dec   :  10 elpm  :  16 eor   :   3 fmul  :   0 
fmuls :   0 fmulsu:   0 icall :   0 ijmp  :   1 in    :  26 inc   :   3 
jmp   :  14 ld    : 142 ldd   :   4 ldi   :  39 lds   :   2 lpm   :   0 
lsl   :  14 lsr   :   1 mov   :  12 movw  :  72 mul   :   5 muls  :   1 
mulsu :   2 neg   :   0 nop   :   0 or    :   9 ori   :   2 out   :  32 
pop   :  52 push  :  46 rcall :  48 ret   :   7 reti  :   2 rjmp  : 107 
rol   :  32 ror   :   6 sbc   :   9 sbci  :   3 sbi   :   8 sbic  :   3 
sbis  :   0 sbiw  :  16 sbr   :   0 sbrc  :   5 sbrs  :   7 sec   :   1 
seh   :   0 sei   :   1 sen   :   0 ser   :   4 ses   :   0 set   :   2 
sev   :   0 sez   :   0 sleep :   0 spm   :   2 st    :  78 std   :   8 
sts   :   3 sub   :   6 subi  :   3 swap  :   0 tst   :   1 wdr   :   0 

Instructions used: 77 out of 114 (67.5%)

"ATmega1284P" memory use summary [bytes]:
Segment   Begin    End      Code   Data   Used    Size   Use%
---------------------------------------------------------------
[.cseg] 0x000000 0x01fb40   2170  14590  16760  131072  12.8%
[.dseg] 0x000100 0x0001a7      0    167    167   16384   1.0%
[.eseg] 0x000000 0x00009a      0    154    154    4096   3.8%

Assembly complete, 0 errors, 5 warnings
