
AVRASM ver. 2.1.52  p644-16.asm Fri Jul 10 18:43:17 2015

p644-16.asm(5): Including file '../../avr8\preamble.inc'
../../avr8\preamble.inc(2): Including file '../../avr8\macros.asm'
../../avr8\macros.asm(6): Including file '../../avr8\user.inc'
../../avr8\preamble.inc(6): Including file '../../avr8/devices/atmega644\device.asm'
../../avr8/devices/atmega644\device.asm(5): Including file '../../avr8/Atmel/Appnotes2\m644def.inc'
p644-16.asm(14): Including file '../../avr8\drivers/usart_0.asm'
../../avr8\drivers/usart_0.asm(32): Including file '../../avr8\drivers/usart_common.asm'
../../avr8\drivers/usart_common.asm(5): Including file '../../avr8\drivers/usart-isr-rx.asm'
../../avr8\drivers/usart_common.asm(17): Including file '../../avr8\words/usart-tx-poll.asm'
../../avr8\drivers/usart_common.asm(22): Including file '../../avr8\words/ubrr.asm'
../../avr8\drivers/usart_common.asm(23): Including file '../../avr8\words/usart.asm'
p644-16.asm(19): Including file '../../avr8\drivers/1wire.asm'
p644-16.asm(21): Including file '../../avr8\amforth.asm'
../../avr8\amforth.asm(12): Including file '../../avr8\drivers/generic-isr.asm'
../../avr8\amforth.asm(14): Including file '../../avr8\dict/rww.inc'
../../avr8\dict/rww.inc(1): Including file '../../avr8\words/mplus.asm'
../../avr8\dict/rww.inc(2): Including file '../../common\words/ud-star.asm'
../../avr8\dict/rww.inc(3): Including file '../../common\words/umax.asm'
../../avr8\dict/rww.inc(4): Including file '../../common\words/umin.asm'
../../avr8\dict/rww.inc(5): Including file '../../avr8\words/immediate-q.asm'
../../avr8\dict/rww.inc(6): Including file '../../avr8\words/name2flags.asm'
../../avr8\dict/rww.inc(7): Including file '../../common\words/name2interpret.asm'
../../avr8\dict/rww.inc(8): Including file '../../common\words/name2compile.asm'
../../avr8\dict/rww.inc(11): Including file '../../avr8\dict/appl_8k.inc'
../../avr8\dict/appl_8k.inc(1): Including file '../../avr8\dict/compiler1.inc'
../../avr8\dict/compiler1.inc(2): Including file '../../avr8\words/docreate.asm'
../../avr8\dict/compiler1.inc(3): Including file '../../common\words/backslash.asm'
../../avr8\dict/compiler1.inc(4): Including file '../../common\words/l-paren.asm'
../../avr8\dict/compiler1.inc(6): Including file '../../common\words/compile.asm'
../../avr8\dict/compiler1.inc(7): Including file '../../avr8\words/comma.asm'
../../avr8\dict/compiler1.inc(8): Including file '../../common\words/brackettick.asm'
../../avr8\dict/compiler1.inc(11): Including file '../../common\words/literal.asm'
../../avr8\dict/compiler1.inc(12): Including file '../../common\words/sliteral.asm'
../../avr8\dict/compiler1.inc(13): Including file '../../avr8\words/g-mark.asm'
../../avr8\dict/compiler1.inc(14): Including file '../../avr8\words/g-resolve.asm'
../../avr8\dict/compiler1.inc(15): Including file '../../avr8\words/l_mark.asm'
../../avr8\dict/compiler1.inc(16): Including file '../../avr8\words/l_resolve.asm'
../../avr8\dict/compiler1.inc(18): Including file '../../common\words/ahead.asm'
../../avr8\dict/compiler1.inc(19): Including file '../../common\words/if.asm'
../../avr8\dict/compiler1.inc(20): Including file '../../common\words/else.asm'
../../avr8\dict/compiler1.inc(21): Including file '../../common\words/then.asm'
../../avr8\dict/compiler1.inc(22): Including file '../../common\words/begin.asm'
../../avr8\dict/compiler1.inc(23): Including file '../../common\words/while.asm'
../../avr8\dict/compiler1.inc(24): Including file '../../common\words/repeat.asm'
../../avr8\dict/compiler1.inc(25): Including file '../../common\words/until.asm'
../../avr8\dict/compiler1.inc(26): Including file '../../common\words/again.asm'
../../avr8\dict/compiler1.inc(27): Including file '../../common\words/do.asm'
../../avr8\dict/compiler1.inc(28): Including file '../../common\words/loop.asm'
../../avr8\dict/compiler1.inc(29): Including file '../../common\words/plusloop.asm'
../../avr8\dict/compiler1.inc(30): Including file '../../common\words/leave.asm'
../../avr8\dict/compiler1.inc(31): Including file '../../common\words/qdo.asm'
../../avr8\dict/compiler1.inc(32): Including file '../../common\words/endloop.asm'
../../avr8\dict/compiler1.inc(34): Including file '../../common\words/l-from.asm'
../../avr8\dict/compiler1.inc(35): Including file '../../common\words/to-l.asm'
../../avr8\dict/compiler1.inc(36): Including file '../../avr8\words/lp0.asm'
../../avr8\dict/compiler1.inc(37): Including file '../../avr8\words/lp.asm'
../../avr8\dict/compiler1.inc(39): Including file '../../avr8\words/create.asm'
../../avr8\dict/compiler1.inc(40): Including file '../../avr8\words/header.asm'
../../avr8\dict/compiler1.inc(41): Including file '../../avr8\words/wlscope.asm'
../../avr8\dict/compiler1.inc(42): Including file '../../avr8\words/reveal.asm'
../../avr8\dict/compiler1.inc(43): Including file '../../avr8\words/latest.asm'
../../avr8\dict/compiler1.inc(44): Including file '../../avr8\words/does.asm'
../../avr8\dict/compiler1.inc(45): Including file '../../common\words/colon.asm'
../../avr8\dict/compiler1.inc(46): Including file '../../avr8\words/colon-noname.asm'
../../avr8\dict/compiler1.inc(47): Including file '../../common\words/semicolon.asm'
../../avr8\dict/compiler1.inc(48): Including file '../../common\words/right-bracket.asm'
../../avr8\dict/compiler1.inc(49): Including file '../../common\words/left-bracket.asm'
../../avr8\dict/compiler1.inc(50): Including file '../../common\words/variable.asm'
../../avr8\dict/compiler1.inc(51): Including file '../../common\words/constant.asm'
../../avr8\dict/compiler1.inc(52): Including file '../../avr8\words/user.asm'
../../avr8\dict/compiler1.inc(54): Including file '../../avr8\words/recurse.asm'
../../avr8\dict/compiler1.inc(55): Including file '../../avr8\words/immediate.asm'
../../avr8\dict/compiler1.inc(57): Including file '../../common\words/bracketchar.asm'
../../avr8\dict/compiler1.inc(58): Including file '../../common\words/abort-string.asm'
../../avr8\dict/compiler1.inc(59): Including file '../../common\words/abort.asm'
../../avr8\dict/compiler1.inc(60): Including file '../../common\words/q-abort.asm'
../../avr8\dict/compiler1.inc(62): Including file '../../common\words/get-stack.asm'
../../avr8\dict/compiler1.inc(63): Including file '../../common\words/set-stack.asm'
../../avr8\dict/compiler1.inc(64): Including file '../../common\words/map-stack.asm'
../../avr8\dict/compiler1.inc(65): Including file '../../avr8\words/get-current.asm'
../../avr8\dict/compiler1.inc(66): Including file '../../common\words/get-order.asm'
../../avr8\dict/compiler1.inc(68): Including file '../../avr8\words/compare.asm'
../../avr8\dict/compiler1.inc(69): Including file '../../avr8\words/nfa2lfa.asm'
../../avr8\amforth.asm(15): Including file 'dict_appl.inc'
dict_appl.inc(3): Including file '../../common\words/dot-s.asm'
dict_appl.inc(4): Including file '../../avr8\words/spirw.asm'
dict_appl.inc(5): Including file '../../avr8\words/n-spi.asm'
dict_appl.inc(6): Including file 'words/applturnkey.asm'
dict_appl.inc(7): Including file '../../avr8\dict/compiler2.inc'
../../avr8\dict/compiler2.inc(8): Including file '../../avr8\words/set-current.asm'
../../avr8\dict/compiler2.inc(9): Including file '../../avr8\words/wordlist.asm'
../../avr8\dict/compiler2.inc(11): Including file '../../avr8\words/only.asm'
../../avr8\dict/compiler2.inc(12): Including file '../../avr8\words/forth-wordlist.asm'
../../avr8\dict/compiler2.inc(13): Including file '../../common\words/set-order.asm'
../../avr8\dict/compiler2.inc(14): Including file '../../common\words/set-recognizer.asm'
../../avr8\dict/compiler2.inc(15): Including file '../../common\words/get-recognizer.asm'
../../avr8\dict/compiler2.inc(16): Including file '../../avr8\words/code.asm'
../../avr8\dict/compiler2.inc(17): Including file '../../avr8\words/end-code.asm'
../../avr8\dict/compiler2.inc(18): Including file '../../avr8\words/marker.asm'
../../avr8\dict/compiler2.inc(19): Including file '../../common\words/postpone.asm'
dict_appl.inc(8): Including file '../../avr8\words/2r_fetch.asm'
../../avr8\amforth.asm(23): Including file '../../avr8\amforth-interpreter.asm'
../../avr8\amforth.asm(24): Including file '../../avr8\dict/nrww.inc'
../../avr8\dict/nrww.inc(4): Including file '../../avr8\words/exit.asm'
../../avr8\dict/nrww.inc(5): Including file '../../avr8\words/execute.asm'
../../avr8\dict/nrww.inc(6): Including file '../../avr8\words/dobranch.asm'
../../avr8\dict/nrww.inc(7): Including file '../../avr8\words/docondbranch.asm'
../../avr8\dict/nrww.inc(10): Including file '../../avr8\words/doliteral.asm'
../../avr8\dict/nrww.inc(11): Including file '../../avr8\words/dovariable.asm'
../../avr8\dict/nrww.inc(12): Including file '../../avr8\words/doconstant.asm'
../../avr8\dict/nrww.inc(13): Including file '../../avr8\words/douser.asm'
../../avr8\dict/nrww.inc(14): Including file '../../avr8\words/do-value.asm'
../../avr8\dict/nrww.inc(15): Including file '../../avr8\words/fetch.asm'
../../avr8\dict/nrww.inc(16): Including file '../../avr8\words/store.asm'
../../avr8\dict/nrww.inc(17): Including file '../../avr8\words/cstore.asm'
../../avr8\dict/nrww.inc(18): Including file '../../avr8\words/cfetch.asm'
../../avr8\dict/nrww.inc(19): Including file '../../avr8\words/fetch-u.asm'
../../avr8\dict/nrww.inc(20): Including file '../../avr8\words/store-u.asm'
../../avr8\dict/nrww.inc(23): Including file '../../avr8\words/dup.asm'
../../avr8\dict/nrww.inc(24): Including file '../../avr8\words/qdup.asm'
../../avr8\dict/nrww.inc(25): Including file '../../avr8\words/swap.asm'
../../avr8\dict/nrww.inc(26): Including file '../../avr8\words/over.asm'
../../avr8\dict/nrww.inc(27): Including file '../../avr8\words/drop.asm'
../../avr8\dict/nrww.inc(28): Including file '../../avr8\words/rot.asm'
../../avr8\dict/nrww.inc(29): Including file '../../avr8\words/nip.asm'
../../avr8\dict/nrww.inc(31): Including file '../../avr8\words/r_from.asm'
../../avr8\dict/nrww.inc(32): Including file '../../avr8\words/to_r.asm'
../../avr8\dict/nrww.inc(33): Including file '../../avr8\words/r_fetch.asm'
../../avr8\dict/nrww.inc(36): Including file '../../common\words/not-equal.asm'
../../avr8\dict/nrww.inc(37): Including file '../../avr8\words/equalzero.asm'
../../avr8\dict/nrww.inc(38): Including file '../../avr8\words/lesszero.asm'
../../avr8\dict/nrww.inc(39): Including file '../../avr8\words/greaterzero.asm'
../../avr8\dict/nrww.inc(40): Including file '../../avr8\words/d-greaterzero.asm'
../../avr8\dict/nrww.inc(41): Including file '../../avr8\words/d-lesszero.asm'
../../avr8\dict/nrww.inc(43): Including file '../../avr8\words/true.asm'
../../avr8\dict/nrww.inc(44): Including file '../../avr8\words/zero.asm'
../../avr8\dict/nrww.inc(45): Including file '../../avr8\words/uless.asm'
../../avr8\dict/nrww.inc(46): Including file '../../common\words/u-greater.asm'
../../avr8\dict/nrww.inc(47): Including file '../../avr8\words/less.asm'
../../avr8\dict/nrww.inc(48): Including file '../../avr8\words/greater.asm'
../../avr8\dict/nrww.inc(50): Including file '../../avr8\words/log2.asm'
../../avr8\dict/nrww.inc(51): Including file '../../avr8\words/minus.asm'
../../avr8\dict/nrww.inc(52): Including file '../../avr8\words/plus.asm'
../../avr8\dict/nrww.inc(53): Including file '../../avr8\words/mstar.asm'
../../avr8\dict/nrww.inc(54): Including file '../../avr8\words/umslashmod.asm'
../../avr8\dict/nrww.inc(55): Including file '../../avr8\words/umstar.asm'
../../avr8\dict/nrww.inc(57): Including file '../../avr8\words/invert.asm'
../../avr8\dict/nrww.inc(58): Including file '../../avr8\words/2slash.asm'
../../avr8\dict/nrww.inc(59): Including file '../../avr8\words/2star.asm'
../../avr8\dict/nrww.inc(60): Including file '../../avr8\words/and.asm'
../../avr8\dict/nrww.inc(61): Including file '../../avr8\words/or.asm'
../../avr8\dict/nrww.inc(62): Including file '../../avr8\words/xor.asm'
../../avr8\dict/nrww.inc(64): Including file '../../avr8\words/1plus.asm'
../../avr8\dict/nrww.inc(65): Including file '../../avr8\words/1minus.asm'
../../avr8\dict/nrww.inc(66): Including file '../../avr8\words/lshift.asm'
../../avr8\dict/nrww.inc(67): Including file '../../avr8\words/rshift.asm'
../../avr8\dict/nrww.inc(68): Including file '../../avr8\words/plusstore.asm'
../../avr8\dict/nrww.inc(70): Including file '../../avr8\words/rpfetch.asm'
../../avr8\dict/nrww.inc(71): Including file '../../avr8\words/rpstore.asm'
../../avr8\dict/nrww.inc(72): Including file '../../avr8\words/spfetch.asm'
../../avr8\dict/nrww.inc(73): Including file '../../avr8\words/spstore.asm'
../../avr8\dict/nrww.inc(75): Including file '../../avr8\words/dodo.asm'
../../avr8\dict/nrww.inc(76): Including file '../../avr8\words/i.asm'
../../avr8\dict/nrww.inc(77): Including file '../../avr8\words/doplusloop.asm'
../../avr8\dict/nrww.inc(78): Including file '../../avr8\words/doloop.asm'
../../avr8\dict/nrww.inc(79): Including file '../../avr8\words/unloop.asm'
../../avr8\dict/nrww.inc(83): Including file '../../avr8\words/cmove_g.asm'
../../avr8\dict/nrww.inc(84): Including file '../../avr8\words/byteswap.asm'
../../avr8\dict/nrww.inc(85): Including file '../../avr8\words/up.asm'
../../avr8\dict/nrww.inc(86): Including file '../../avr8\words/1ms.asm'
../../avr8\dict/nrww.inc(87): Including file '../../avr8\words/2to_r.asm'
../../avr8\dict/nrww.inc(88): Including file '../../avr8\words/2r_from.asm'
../../avr8\dict/nrww.inc(90): Including file '../../avr8\words/store-e.asm'
../../avr8\dict/nrww.inc(91): Including file '../../avr8\words/fetch-e.asm'
../../avr8\dict/nrww.inc(92): Including file '../../avr8\words/store-i.asm'
../../avr8\dict/nrww.inc(96): Including file '../../avr8\words/store-i_nrww.asm'
../../avr8\dict/nrww.inc(98): Including file '../../avr8\words/fetch-i.asm'
../../avr8\dict/nrww.inc(101): Including file '../../avr8\dict/core_8k.inc'
../../avr8\dict/core_8k.inc(2): Including file '../../avr8\words/n_to_r.asm'
../../avr8\dict/core_8k.inc(3): Including file '../../avr8\words/n_r_from.asm'
../../avr8\dict/core_8k.inc(5): Including file '../../avr8\words/d-2star.asm'
../../avr8\dict/core_8k.inc(6): Including file '../../avr8\words/d-2slash.asm'
../../avr8\dict/core_8k.inc(7): Including file '../../avr8\words/d-plus.asm'
../../avr8\dict/core_8k.inc(8): Including file '../../avr8\words/d-minus.asm'
../../avr8\dict/core_8k.inc(9): Including file '../../avr8\words/d-invert.asm'
../../avr8\dict/core_8k.inc(10): Including file '../../avr8\words/d-equal.asm'
../../avr8\dict/core_8k.inc(11): Including file '../../common\words/u-dot.asm'
../../avr8\dict/core_8k.inc(12): Including file '../../common\words/u-dot-r.asm'
../../avr8\dict/core_8k.inc(14): Including file '../../common\words/show-wordlist.asm'
../../avr8\dict/core_8k.inc(15): Including file '../../avr8\words/words.asm'
../../avr8\dict/core_8k.inc(16): Including file '../../avr8\dict/interrupt.inc'
../../avr8\dict/interrupt.inc(2): Including file '../../avr8\words/int-on.asm'
../../avr8\dict/interrupt.inc(3): Including file '../../avr8\words/int-off.asm'
../../avr8\dict/interrupt.inc(4): Including file '../../avr8\words/int-store.asm'
../../avr8\dict/interrupt.inc(5): Including file '../../avr8\words/int-fetch.asm'
../../avr8\dict/interrupt.inc(6): Including file '../../avr8\words/int-trap.asm'
../../avr8\dict/interrupt.inc(8): Including file '../../avr8\words/isr-exec.asm'
../../avr8\dict/interrupt.inc(9): Including file '../../avr8\words/isr-end.asm'
../../avr8\dict/core_8k.inc(18): Including file '../../common\words/pick.asm'
../../avr8\dict/core_8k.inc(19): Including file '../../common\words/dot-quote.asm'
../../avr8\dict/core_8k.inc(20): Including file '../../common\words/squote.asm'
../../avr8\dict/core_8k.inc(22): Including file '../../avr8\words/fill.asm'
../../avr8\dict/core_8k.inc(24): Including file '../../avr8\words/environment.asm'
../../avr8\dict/core_8k.inc(25): Including file '../../avr8\words/env-wordlists.asm'
../../avr8\dict/core_8k.inc(26): Including file '../../avr8\words/env-slashpad.asm'
../../avr8\dict/core_8k.inc(27): Including file '../../avr8\words/env-slashhold.asm'
../../avr8\dict/core_8k.inc(28): Including file '../../common\words/env-forthname.asm'
../../avr8\dict/core_8k.inc(29): Including file '../../common\words/env-forthversion.asm'
../../avr8\dict/core_8k.inc(30): Including file '../../common\words/env-cpu.asm'
../../avr8\dict/core_8k.inc(31): Including file '../../avr8\words/env-mcuinfo.asm'
../../avr8\dict/core_8k.inc(32): Including file '../../avr8\words/env-usersize.asm'
../../avr8\dict/core_8k.inc(34): Including file '../../common\words/f_cpu.asm'
../../avr8\dict/core_8k.inc(35): Including file '../../avr8\words/state.asm'
../../avr8\dict/core_8k.inc(36): Including file '../../common\words/base.asm'
../../avr8\dict/core_8k.inc(38): Including file '../../avr8\words/cells.asm'
../../avr8\dict/core_8k.inc(39): Including file '../../avr8\words/cellplus.asm'
../../avr8\dict/core_8k.inc(41): Including file '../../common\words/2dup.asm'
../../avr8\dict/core_8k.inc(42): Including file '../../common\words/2drop.asm'
../../avr8\dict/core_8k.inc(44): Including file '../../common\words/tuck.asm'
../../avr8\dict/core_8k.inc(46): Including file '../../common\words/to-in.asm'
../../avr8\dict/core_8k.inc(47): Including file '../../avr8\words/sharptib.asm'
../../avr8\dict/core_8k.inc(48): Including file '../../avr8\words/pad.asm'
../../avr8\dict/core_8k.inc(49): Including file '../../avr8\words/emit.asm'
../../avr8\dict/core_8k.inc(50): Including file '../../avr8\words/emitq.asm'
../../avr8\dict/core_8k.inc(51): Including file '../../avr8\words/key.asm'
../../avr8\dict/core_8k.inc(52): Including file '../../avr8\words/keyq.asm'
../../avr8\dict/core_8k.inc(54): Including file '../../avr8\words/dp.asm'
../../avr8\dict/core_8k.inc(55): Including file '../../avr8\words/ehere.asm'
../../avr8\dict/core_8k.inc(56): Including file '../../avr8\words/here.asm'
../../avr8\dict/core_8k.inc(57): Including file '../../avr8\words/allot.asm'
../../avr8\dict/core_8k.inc(59): Including file '../../common\words/bin.asm'
../../avr8\dict/core_8k.inc(60): Including file '../../common\words/decimal.asm'
../../avr8\dict/core_8k.inc(61): Including file '../../common\words/hex.asm'
../../avr8\dict/core_8k.inc(62): Including file '../../common\words/bl.asm'
../../avr8\dict/core_8k.inc(64): Including file '../../avr8\words/turnkey.asm'
../../avr8\dict/core_8k.inc(66): Including file '../../avr8\words/slashmod.asm'
../../avr8\dict/core_8k.inc(67): Including file '../../avr8\words/uslashmod.asm'
../../avr8\dict/core_8k.inc(68): Including file '../../avr8\words/negate.asm'
../../avr8\dict/core_8k.inc(69): Including file '../../common\words/slash.asm'
../../avr8\dict/core_8k.inc(70): Including file '../../common\words/mod.asm'
../../avr8\dict/core_8k.inc(71): Including file '../../avr8\words/abs.asm'
../../avr8\dict/core_8k.inc(72): Including file '../../common\words/min.asm'
../../avr8\dict/core_8k.inc(73): Including file '../../common\words/max.asm'
../../avr8\dict/core_8k.inc(74): Including file '../../common\words/within.asm'
../../avr8\dict/core_8k.inc(76): Including file '../../common\words/to-upper.asm'
../../avr8\dict/core_8k.inc(77): Including file '../../common\words/to-lower.asm'
../../avr8\dict/core_8k.inc(79): Including file '../../avr8\words/hld.asm'
../../avr8\dict/core_8k.inc(80): Including file '../../common\words/hold.asm'
../../avr8\dict/core_8k.inc(81): Including file '../../common\words/less-sharp.asm'
../../avr8\dict/core_8k.inc(82): Including file '../../common\words/sharp.asm'
../../avr8\dict/core_8k.inc(83): Including file '../../common\words/sharp-s.asm'
../../avr8\dict/core_8k.inc(84): Including file '../../common\words/sharp-greater.asm'
../../avr8\dict/core_8k.inc(85): Including file '../../common\words/sign.asm'
../../avr8\dict/core_8k.inc(86): Including file '../../common\words/d-dot-r.asm'
../../avr8\dict/core_8k.inc(87): Including file '../../common\words/dot-r.asm'
../../avr8\dict/core_8k.inc(88): Including file '../../common\words/d-dot.asm'
../../avr8\dict/core_8k.inc(89): Including file '../../common\words/dot.asm'
../../avr8\dict/core_8k.inc(90): Including file '../../common\words/ud-dot.asm'
../../avr8\dict/core_8k.inc(91): Including file '../../common\words/ud-dot-r.asm'
../../avr8\dict/core_8k.inc(92): Including file '../../common\words/ud-slash-mod.asm'
../../avr8\dict/core_8k.inc(93): Including file '../../common\words/digit-q.asm'
../../avr8\dict/core_8k.inc(95): Including file '../../avr8\words/do-sliteral.asm'
../../avr8\dict/core_8k.inc(96): Including file '../../avr8\words/scomma.asm'
../../avr8\dict/core_8k.inc(97): Including file '../../avr8\words/itype.asm'
../../avr8\dict/core_8k.inc(98): Including file '../../avr8\words/icount.asm'
../../avr8\dict/core_8k.inc(99): Including file '../../common\words/cr.asm'
../../avr8\dict/core_8k.inc(100): Including file '../../common\words/space.asm'
../../avr8\dict/core_8k.inc(101): Including file '../../common\words/spaces.asm'
../../avr8\dict/core_8k.inc(102): Including file '../../common\words/type.asm'
../../avr8\dict/core_8k.inc(103): Including file '../../common\words/tick.asm'
../../avr8\dict/core_8k.inc(105): Including file '../../common\words/handler.asm'
../../avr8\dict/core_8k.inc(106): Including file '../../common\words/catch.asm'
../../avr8\dict/core_8k.inc(107): Including file '../../common\words/throw.asm'
../../avr8\dict/core_8k.inc(109): Including file '../../common\words/cskip.asm'
../../avr8\dict/core_8k.inc(110): Including file '../../common\words/cscan.asm'
../../avr8\dict/core_8k.inc(111): Including file '../../common\words/accept.asm'
../../avr8\dict/core_8k.inc(112): Including file '../../avr8\words/refill.asm'
../../avr8\dict/core_8k.inc(113): Including file '../../common\words/char.asm'
../../avr8\dict/core_8k.inc(114): Including file '../../common\words/number.asm'
../../avr8\dict/core_8k.inc(115): Including file '../../common\words/q-sign.asm'
../../avr8\dict/core_8k.inc(116): Including file '../../common\words/set-base.asm'
../../avr8\dict/core_8k.inc(117): Including file '../../common\words/to-number.asm'
../../avr8\dict/core_8k.inc(118): Including file '../../common\words/parse.asm'
../../avr8\dict/core_8k.inc(119): Including file '../../avr8\words/source.asm'
../../avr8\dict/core_8k.inc(120): Including file '../../common\words/slash-string.asm'
../../avr8\dict/core_8k.inc(121): Including file '../../common\words/parse-name.asm'
../../avr8\dict/core_8k.inc(122): Including file '../../common\words/find-name.asm'
../../avr8\dict/core_8k.inc(124): Including file '../../common\words/prompt-ok.asm'
../../avr8\dict/core_8k.inc(125): Including file '../../common\words/prompt-ready.asm'
../../avr8\dict/core_8k.inc(126): Including file '../../common\words/prompt-error.asm'
../../avr8\dict/core_8k.inc(128): Including file '../../common\words/quit.asm'
../../avr8\dict/core_8k.inc(129): Including file '../../avr8\words/pause.asm'
../../avr8\dict/core_8k.inc(130): Including file '../../avr8\words/cold.asm'
../../avr8\dict/core_8k.inc(131): Including file '../../avr8\words/warm.asm'
../../avr8\dict/core_8k.inc(133): Including file '../../avr8\words/sp0.asm'
../../avr8\dict/core_8k.inc(134): Including file '../../avr8\words/rp0.asm'
../../avr8\dict/core_8k.inc(135): Including file '../../common\words/depth.asm'
../../avr8\dict/core_8k.inc(136): Including file '../../common\words/interpret.asm'
../../avr8\dict/core_8k.inc(137): Including file '../../common\words/do-recognizer.asm'
../../avr8\dict/core_8k.inc(138): Including file '../../common\words/r-intnumber.asm'
../../avr8\dict/core_8k.inc(139): Including file '../../common\words/r-word.asm'
../../avr8\dict/core_8k.inc(140): Including file '../../common\words/r-fail.asm'
../../avr8\dict/core_8k.inc(142): Including file '../../common\words/q-stack.asm'
../../avr8\dict/core_8k.inc(143): Including file '../../common\words/ver.asm'
../../avr8\dict/core_8k.inc(145): Including file '../../avr8\words/noop.asm'
../../avr8\dict/core_8k.inc(146): Including file '../../avr8\words/unused.asm'
../../avr8\dict/core_8k.inc(148): Including file '../../common\words/to.asm'
../../avr8\dict/core_8k.inc(149): Including file '../../avr8\words/i-cellplus.asm'
../../avr8\dict/core_8k.inc(151): Including file '../../avr8\words/edefer-fetch.asm'
../../avr8\dict/core_8k.inc(152): Including file '../../avr8\words/edefer-store.asm'
../../avr8\dict/core_8k.inc(153): Including file '../../common\words/rdefer-fetch.asm'
../../avr8\dict/core_8k.inc(154): Including file '../../common\words/rdefer-store.asm'
../../avr8\dict/core_8k.inc(155): Including file '../../common\words/udefer-fetch.asm'
../../avr8\dict/core_8k.inc(156): Including file '../../common\words/udefer-store.asm'
../../avr8\dict/core_8k.inc(157): Including file '../../common\words/defer-store.asm'
../../avr8\dict/core_8k.inc(158): Including file '../../common\words/defer-fetch.asm'
../../avr8\dict/core_8k.inc(159): Including file '../../avr8\words/do-defer.asm'
../../avr8\dict/core_8k.inc(161): Including file '../../common\words/search-wordlist.asm'
../../avr8\dict/core_8k.inc(162): Including file '../../common\words/traverse-wordlist.asm'
../../avr8\dict/core_8k.inc(163): Including file '../../common\words/name2string.asm'
../../avr8\dict/core_8k.inc(164): Including file '../../avr8\words/nfa2cfa.asm'
../../avr8\dict/core_8k.inc(165): Including file '../../avr8\words/icompare.asm'
../../avr8\dict/core_8k.inc(167): Including file '../../common\words/star.asm'
../../avr8\dict/core_8k.inc(168): Including file '../../avr8\words/j.asm'
../../avr8\dict/core_8k.inc(170): Including file '../../avr8\words/dabs.asm'
../../avr8\dict/core_8k.inc(171): Including file '../../avr8\words/dnegate.asm'
../../avr8\dict/core_8k.inc(172): Including file '../../avr8\words/cmove.asm'
../../avr8\dict/core_8k.inc(173): Including file '../../common\words/2swap.asm'
../../avr8\dict/core_8k.inc(175): Including file '../../avr8\words/tib.asm'
../../avr8\dict/core_8k.inc(177): Including file '../../avr8\words/init-user.asm'
../../avr8\dict/core_8k.inc(178): Including file '../../avr8\dict/compiler2.inc'
../../avr8\dict/core_8k.inc(179): Including file '../../common\words/bounds.asm'
../../avr8\dict/core_8k.inc(180): Including file '../../common\words/s-to-d.asm'
../../avr8\dict/core_8k.inc(181): Including file '../../avr8\words/to-body.asm'
../../avr8\dict/nrww.inc(111): Including file '../../avr8\words/2literal.asm'
../../avr8\dict/nrww.inc(112): Including file '../../avr8\words/equal.asm'
../../avr8\dict/nrww.inc(113): Including file '../../common\words/num-constants.asm'
../../avr8\amforth.asm(25): Including file 'dict_appl_core.inc'
../../avr8\amforth.asm(36): Including file '../../avr8\amforth-eeprom.inc'
                 
                 
                 ; file see ../template/template.asm. You may want to
                 ; copy that file to this one and edit it afterwards.
                 
                 .include "preamble.inc"
                 
                 .include "macros.asm"
                 
                 .set DICT_COMPILER2 = 0 ;
                 .set cpu_msp430 = 0
                 .set cpu_avr8   = 1
                 
                 .include "user.inc"
                 
                 ; 
                 
                 ; used by the multitasker
                 .set USER_STATE    = 0
                 .set USER_FOLLOWER = 2
                 
                 ; stackpointer, used by mulitasker
                 .set USER_RP      = 4
                 .set USER_SP0     = 6
                 .set USER_SP      = 8
                 
                 ; excpection handling
                 .set USER_HANDLER = 10
                 
                 ; numeric IO
                 .set USER_BASE  = 12
                 
                 ; character IO 
                 .set USER_EMIT  = 14
                 .set USER_EMITQ = 16
                 .set USER_KEY   = 18
                 .set USER_KEYQ  = 20
                 
                 .set USER_SOURCE  = 22
                 .set USER_TO_IN   = 24
                 .set USER_REFILL  = 26
                 
                 .set SYSUSERSIZE = 28
                 ; 
                 
                   .def zerol = r2
                   .def zeroh = r3
                   .def upl = r4
                   .def uph = r5
                 
                   .def al  = r6
                   .def ah  = r7
                   .def bl  = r8
                   .def bh  = r9
                 
                 ; internal
                   .def mcu_boot      = r10
                   .def erase_counter = r11
                 
                   .def temp4 = r14
                   .def temp5 = r15
                 
                   .def temp0 = r16
                   .def temp1 = r17
                   .def temp2 = r18
                   .def temp3 = r19
                 
                   .def temp6 = r20
                   .def temp7 = r21
                 
                   .def tosl = r24
                   .def tosh = r25
                 
                   .def wl = r22
                   .def wh = r23
                 
                 .macro loadtos
                     ld tosl, Y+
                     ld tosh, Y+
                 .endmacro
                 
                 .macro savetos
                     st -Y, tosh
                     st -Y, tosl
                 .endmacro
                 
                 .macro in_
                 .if (@1 < $40)
                   in @0,@1
                 .else
                   lds @0,@1
                 .endif
                 .endmacro
                 
                 .macro out_
                 .if (@0 < $40)
                   out @0,@1
                 .else
                   sts @0,@1
                 .endif
                 .endmacro
                 
                 .macro sbi_
                 .if (@0 < $40)
                   sbi @0,@1
                 .else
                   in_ @2,@0
                   ori @2,exp2(@1)
                   out_ @0,@2
                 .endif
                 .endmacro
                 
                 .macro cbi_
                 .if (@0 < $40)
                   cbi @0,@1
                 .else
                   in_ @2,@0
                   andi @2,~(exp2(@1))
                   out_ @0,@2
                 .endif
                 .endmacro
                 
                 .macro jmp_
                 	; a more flexible macro
                     .ifdef @0
                     .if (@0-pc > 2040) || (pc-@0>2040)
                 	jmp @0
                 	.else
                 	rjmp @0
                 	.endif
                 	.else
                 	jmp @0
                 	.endif
                 .endmacro
                 .macro call_
                 	; a more flexible macro
                     .ifdef @0
                     .if (@0-pc > 2040) || (pc-@0>2040)
                 	call @0
                 	.else
                 	rcall @0
                 	.endif
                 	.else
                 	call @0
                 	.endif
                 .endmacro
                 
                 ;               F_CPU
                 ;    µsec   16000000   14745600    8000000  1000000
                 ;    1            16      14,74          8        1
                 ;    10          160     147,45         80       10
                 ;    100        1600    1474,56        800      100
                 ;    1000      16000   14745,6        8000     1000
                 ;
                 ; cycles = µsec * f_cpu / 1e6
                 ; n_loops=cycles/5
                 ;
                 ;     cycles already used will be subtracted from the delay
                 ;     the waittime resolution is 1 cycle (delay from exact to +1 cycle)
                 ;     the maximum delay at 20MHz (50ns/clock) is 38350ns
                 ;     waitcount register must specify an immediate register
                 ;
                 ; busy waits a specfied amount of microseconds
                 .macro   delay
                       .set cycles = ( ( @0 * F_CPU ) / 1000000 )
                       .if (cycles > ( 256 * 255 * 4 + 2))
                         .error "MACRO delay - too many cycles to burn"
                       .else
                         .if (cycles > 6)
                           .set  loop_cycles = (cycles / 4)      
                           ldi   zl,low(loop_cycles)
                           ldi   zh,high(loop_cycles)
                           sbiw  Z, 1
                           brne  pc-1
                           .set  cycles = (cycles - (loop_cycles * 4))
                         .endif
                         .if (cycles > 0)
                           .if   (cycles & 4)
                             rjmp  pc+1
                             rjmp  pc+1
                           .endif
                           .if   (cycles & 2)
                             rjmp  pc+1
                           .endif
                           .if   (cycles & 1)
                             nop
                           .endif
                         .endif
                       .endif
                 .endmacro
                 
                 ; portability macros, they come from the msp430 branches
                 
                 .macro DEST
                     .dw @0
                 .endm
                 
                 ; controller specific file selected via include
                 ; directory definition when calling the assembler (-I)
                 .include "device.asm"
                 
                 ; generated automatically, do not edit
                 
                 .list
                 
                 .equ ramstart =  256
                 .equ CELLSIZE = 2
                 .macro readflashcell
                 	lsl zl
                 	rol zh
                 	lpm @0, Z+
                 	lpm @1, Z+
                 .endmacro
                 .macro writeflashcell
                 	lsl zl
                 	rol zh
                 .endmacro
                 .set WANT_ANALOG_COMPARATOR = 0
                 .set WANT_USART0 = 0
                 .set WANT_PORTA = 0
                 .set WANT_PORTB = 0
                 .set WANT_PORTC = 0
                 .set WANT_PORTD = 0
                 .set WANT_TIMER_COUNTER_0 = 0
                 .set WANT_TIMER_COUNTER_2 = 0
                 .set WANT_WATCHDOG = 0
                 .set WANT_JTAG = 0
                 .set WANT_BOOT_LOAD = 0
                 .set WANT_EXTERNAL_INTERRUPT = 0
                 .set WANT_AD_CONVERTER = 0
                 .set WANT_TIMER_COUNTER_1 = 0
                 .set WANT_EEPROM = 0
                 .set WANT_TWI = 0
                 .set WANT_SPI = 0
                 .set WANT_CPU = 0
                 .equ intvecsize = 2 ; please verify; flash size: 65536 bytes
                 .equ pclen = 2 ; please verify
                 .overlap
                 .org 2
000002 d118      	 rcall isr ; External Interrupt Request 0
                 .org 4
000004 d116      	 rcall isr ; External Interrupt Request 1
                 .org 6
000006 d114      	 rcall isr ; External Interrupt Request 2
                 .org 8
000008 d112      	 rcall isr ; Pin Change Interrupt Request 0
                 .org 10
00000a d110      	 rcall isr ; Pin Change Interrupt Request 1
                 .org 12
00000c d10e      	 rcall isr ; Pin Change Interrupt Request 2
                 .org 14
00000e d10c      	 rcall isr ; Pin Change Interrupt Request 3
                 .org 16
000010 d10a      	 rcall isr ; Watchdog Time-out Interrupt
                 .org 18
000012 d108      	 rcall isr ; Timer/Counter2 Compare Match A
                 .org 20
000014 d106      	 rcall isr ; Timer/Counter2 Compare Match B
                 .org 22
000016 d104      	 rcall isr ; Timer/Counter2 Overflow
                 .org 24
000018 d102      	 rcall isr ; Timer/Counter1 Capture Event
                 .org 26
00001a d100      	 rcall isr ; Timer/Counter1 Compare Match A
                 .org 28
00001c d0fe      	 rcall isr ; Timer/Counter1 Compare Match B
                 .org 30
00001e d0fc      	 rcall isr ; Timer/Counter1 Overflow
                 .org 32
000020 d0fa      	 rcall isr ; Timer/Counter0 Compare Match A
                 .org 34
000022 d0f8      	 rcall isr ; Timer/Counter0 Compare Match B
                 .org 36
000024 d0f6      	 rcall isr ; Timer/Counter0 Overflow
                 .org 38
000026 d0f4      	 rcall isr ; SPI Serial Transfer Complete
                 .org 40
000028 d0f2      	 rcall isr ; USART0, Rx Complete
                 .org 42
00002a d0f0      	 rcall isr ; USART0 Data register Empty
                 .org 44
00002c d0ee      	 rcall isr ; USART0, Tx Complete
                 .org 46
00002e d0ec      	 rcall isr ; Analog Comparator
                 .org 48
000030 d0ea      	 rcall isr ; ADC Conversion Complete
                 .org 50
000032 d0e8      	 rcall isr ; EEPROM Ready
                 .org 52
000034 d0e6      	 rcall isr ; 2-wire Serial Interface
                 .org 54
000036 d0e4      	 rcall isr ; Store Program Memory Read
                 .equ INTVECTORS = 28
                 .nooverlap
                 
                 ; compatability layer (maybe empty)
                 
                 ; controller data area, environment query mcu-info
                 mcu_info:
                 mcu_ramsize:
000037 1000      	.dw 4096
                 mcu_eepromsize:
000038 0800      	.dw 2048
                 mcu_maxdp:
000039 e000      	.dw 57344 
                 mcu_numints:
00003a 001c      	.dw 28
                 mcu_name:
00003b 0009      	.dw  9
00003c 5441
00003d 656d
00003e 6167
00003f 3436
000040 0034      	.db "ATmega644",0
                 .set codestart=pc
                 
                 ; some defaults, change them in your application master file
                 ; see template.asm for an example
                 
                 .set AMFORTH_RO_SEG = NRWW_START_ADDR
                 
                 ; receiving is asynchron, so an interrupt queue is useful.
                 .set WANT_ISR_RX = 1
                 
                 ; case insensitve dictionary lookup.
                 .set WANT_IGNORECASE = 0
                 
                 ; map all memories to one address space. Details in the
                 ; technical guide
                 .set WANT_UNIFIED = 0
                 
                 ; terminal input buffer
                 .set TIBSIZE  = 90    ; ANS94 needs at least 80 characters per line
                 
                 ; USER variables *in addition* to system ones
                 .set APPUSERSIZE = 10  ; size of application specific user area in bytes
                 
                 ; addresses of various data segments
                 .set rstackstart = RAMEND      ; start address of return stack, grows downward
                 .set stackstart  = RAMEND - 80 ; start address of data stack, grows downward
                 ; change only if you know what to you do
                 .set NUMWORDLISTS = 8 ; number of word lists in the searh order, at least 8
                 .set NUMRECOGNIZERS = 4 ; total number of recognizers, two are always used.
                 
                 ; 10 per mille (1 per cent) is ok.
                 .set BAUD = 38400
                 .set BAUD_MAXERROR = 10
                 
                 ; Dictionary setup
                 .set VE_HEAD = $0000
                 .set VE_ENVHEAD = $0000
                 
                 
                 .set AMFORTH_RO_SEG = NRWW_START_ADDR+1
                 
                 ; cpu clock in hertz
                 .equ F_CPU = 16000000
                 .set BAUD_MAXERROR = 30
                 .equ TIMER_INT = OVF2addr
                 
                 .include "drivers/usart_0.asm"
                 
                   .equ BAUDRATE_HIGH = UBRR0H
                   .equ USART_C = UCSR0C
                   .equ USART_B = UCSR0B
                   .equ USART_A = UCSR0A
                   .equ USART_DATA = UDR0
                   .ifndef URXCaddr
                   .equ URXCaddr = URXC0addr
                   .equ UDREaddr = UDRE0addr
                   .endif
                 
                 .equ bm_USART_RXRD = 1 << RXC0
                 .equ bm_USART_TXRD = 1 << UDRE0
                 .equ bm_ENABLE_TX  = 1 << TXEN0
                 .equ bm_ENABLE_RX  = 1 << RXEN0
                 .equ bm_ENABLE_INT_RX = 1<<RXCIE0
                 .equ bm_ENABLE_INT_TX = 1<<UDRIE0
                 
                 .equ bm_USARTC_en   = 0
                 .equ bm_ASYNC       = 0 << 6
                 .equ bm_SYNC        = 1 << 6
                 .equ bm_NO_PARITY   = 0 << 4
                 .equ bm_EVEN_PARITY = 2 << 4
                 .equ bm_ODD_PARITY  = 3 << 4
                 .equ bm_1STOPBIT    = 0 << 3
                 .equ bm_2STOPBIT    = 1 << 3
                 .equ bm_5BIT        = 0 << 1
                 .equ bm_6BIT        = 1 << 1
                 .equ bm_7BIT        = 2 << 1
                 .equ bm_8BIT        = 3 << 1
                 
                 .include "drivers/usart_common.asm"
                 
                 .set USART_C_VALUE = bm_ASYNC | bm_NO_PARITY | bm_1STOPBIT | bm_8BIT
                 .if WANT_ISR_RX == 1
                   .set USART_B_VALUE = bm_ENABLE_TX | bm_ENABLE_RX | bm_ENABLE_INT_RX
                   .include "drivers/usart-isr-rx.asm"
                 
                 
                 ; sizes have to be powers of 2!
                 .equ usart_rx_size = $10
                 .equ usart_rx_mask = usart_rx_size - 1
                 .dseg
000100           usart_rx_data: .byte usart_rx_size+2
000112           usart_rx_in: .byte 2
000114           usart_rx_out: .byte 2
                 
                 .cseg
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 ; forth code:
                 ; : rx-isr USART_DATA c@
                 ;    usart_rx_data usart_rx_in c@ dup >r
                 ;    + !
                 ;    r> 1+ usart_rx_mask and usart_rx_in c!
                 ; ;
                 ; setup with
                 ; ' rx-isr URXCaddr int!
                 usart_rx_isr:
000041 93af        push xl
000042 b7af        in xl, SREG
000043 93af        push xl
000044 93bf        push xh
000045 93ef        push zl
000046 93ff        push zh
                 
000047 91b0 00c6   lds xh, USART_DATA
                 usart_rx_store:
000049 91a0 0112   lds xl, usart_rx_in
00004b e0e0        ldi zl, low(usart_rx_data)
00004c e0f1        ldi zh, high(usart_rx_data)
00004d 0fea        add zl, xl
00004e 1df3        adc zh, zeroh
00004f 83b0        st Z, xh
                 
000050 95a3        inc xl
000051 70af        andi xl,usart_rx_mask
                 
000052 93a0 0112   sts usart_rx_in, xl
                 
                 usart_rx_isr_finish:
000054 91ff        pop zh
000055 91ef        pop zl
000056 91bf        pop xh
000057 91af        pop xl
000058 bfaf        out SREG, xl
000059 91af        pop xl
00005a 9518        reti
                 
                 .set usartpc = pc
                 .org URXCaddr
000028 c018        jmp_ usart_rx_isr
                 .org usartpc
                 
                 
                 ; ( -- ) Hardware Access
                 ; R( --)
                 ; initialize usart
                 ;VE_USART_INIT_RX:
                 ;  .dw $ff06
                 ;  .db "+usart"
                 ;  .dw VE_HEAD
                 ;  .set VE_HEAD = VE_USART_INIT_RX
                 XT_USART_INIT_RX_ISR:
00005b 7001        .dw DO_COLON
                 PFA_USART_INIT_RX_ISR:          ; ( -- )
00005c 714f        .dw XT_ZERO
00005d 7038        .dw XT_DOLITERAL
00005e 0112        .dw usart_rx_in
00005f 7088        .dw XT_CSTORE
000060 714f        .dw XT_ZERO
000061 7038        .dw XT_DOLITERAL
000062 0114        .dw usart_rx_out
000063 7088        .dw XT_CSTORE
                 
000064 701b        .dw XT_EXIT
                 
                 ; ( -- c)
                 ; MCU
                 ; get 1 character from input queue, wait if needed using interrupt driver
                 VE_RX_ISR:
000065 ff06          .dw $ff06
000066 7872
000067 692d
000068 7273          .db "rx-isr"
000069 0000          .dw VE_HEAD
                     .set VE_HEAD = VE_RX_ISR
                 XT_RX_ISR:
00006a 7001          .dw DO_COLON
                 PFA_RX_ISR:
00006b 0084        .dw XT_RXQ_ISR
00006c 7031        .dw XT_DOCONDBRANCH
00006d 006b        .dw PFA_RX_ISR
00006e 7038        .dw XT_DOLITERAL
00006f 0114        .dw usart_rx_out
000070 7093        .dw XT_CFETCH
000071 70ac        .dw XT_DUP
000072 722a        .dw XT_1PLUS
000073 7038        .dw XT_DOLITERAL
000074 000f        .dw usart_rx_mask
000075 720e        .dw XT_AND
000076 7038        .dw XT_DOLITERAL
000077 0114        .dw usart_rx_out
000078 7088        .dw XT_CSTORE
000079 7038        .dw XT_DOLITERAL
00007a 0100        .dw usart_rx_data
00007b 7198        .dw XT_PLUS
00007c 7093        .dw XT_CFETCH
00007d 701b        .dw XT_EXIT
                 
                 ; ( -- f)  
                 ; MCU
                 ; check if unread characters are in the input queue using interrupt driver
                 VE_RXQ_ISR:
00007e ff07          .dw $ff07
00007f 7872
000080 2d3f
000081 7369
000082 0072          .db "rx?-isr",0
000083 0065          .dw VE_HEAD
                     .set VE_HEAD = VE_RXQ_ISR
                 XT_RXQ_ISR:
000084 7001          .dw DO_COLON
                 PFA_RXQ_ISR:
000085 7a3c        .dw XT_PAUSE
000086 7038        .dw XT_DOLITERAL
000087 0114        .dw usart_rx_out
000088 7093        .dw XT_CFETCH
000089 7038        .dw XT_DOLITERAL
00008a 0112        .dw usart_rx_in
00008b 7093        .dw XT_CFETCH
00008c 710e        .dw XT_NOTEQUAL
00008d 701b        .dw XT_EXIT
                   .set XT_RX  = XT_RX_ISR
                   .set XT_RXQ = XT_RXQ_ISR
                   .set XT_USART_INIT_RX = XT_USART_INIT_RX_ISR
                 .else
                 .endif
                 
                 .include "words/usart-tx-poll.asm"
                 
                 ; MCU
                 ; check availability and send one character to the terminal using register poll
                 VE_TX_POLL:
00008e ff07          .dw $ff07
00008f 7874
000090 702d
000091 6c6f
000092 006c          .db "tx-poll",0
000093 007e          .dw VE_HEAD
                     .set VE_HEAD = VE_TX_POLL
                 XT_TX_POLL:
000094 7001          .dw DO_COLON
                 PFA_TX_POLL:
                   ; wait for data ready
000095 00a2        .dw XT_TXQ_POLL
000096 7031        .dw XT_DOCONDBRANCH
000097 0095        .dw PFA_TX_POLL
                   ; send to usart
000098 7038        .dw XT_DOLITERAL
000099 00c6        .dw USART_DATA
00009a 7088        .dw XT_CSTORE
00009b 701b        .dw XT_EXIT
                 
                 ; ( -- f) MCU
                 ; MCU
                 ; check if a character can be send using register poll
                 VE_TXQ_POLL:
00009c ff08          .dw $ff08
00009d 7874
00009e 2d3f
00009f 6f70
0000a0 6c6c          .db "tx?-poll"
0000a1 008e          .dw VE_HEAD
                     .set VE_HEAD = VE_TXQ_POLL
                 XT_TXQ_POLL:
0000a2 7001          .dw DO_COLON
                 PFA_TXQ_POLL:
0000a3 7a3c        .dw XT_PAUSE
0000a4 7038        .dw XT_DOLITERAL
0000a5 00c0        .dw USART_A
0000a6 7093        .dw XT_CFETCH
0000a7 7038        .dw XT_DOLITERAL
0000a8 0020        .dw bm_USART_TXRD
0000a9 720e        .dw XT_AND
0000aa 701b        .dw XT_EXIT
                 .set XT_TX  = XT_TX_POLL
                 .set XT_TXQ = XT_TXQ_POLL
                 .set XT_USART_INIT_TX = 0
                 
                 .include "words/ubrr.asm"
                 
                 ; MCU
                 ; returns usart UBRR settings
                 VE_UBRR:
0000ab ff04        .dw $ff04
0000ac 6275
0000ad 7272        .db "ubrr"
0000ae 009c        .dw VE_HEAD
                   .set VE_HEAD = VE_UBRR
                 XT_UBRR:
0000af 706a        .dw PFA_DOVALUE1
                 PFA_UBRR:          ; ( -- )
0000b0 008a        .dw EE_UBRRVAL
0000b1 7ba7        .dw XT_EDEFERFETCH
0000b2 7bb1        .dw XT_EDEFERSTORE
                 .include "words/usart.asm"
                 
                 ; MCU
                 ; initialize usart
                 VE_USART:
0000b3 ff06        .dw $ff06
0000b4 752b
0000b5 6173
0000b6 7472        .db "+usart"
0000b7 00ab        .dw VE_HEAD
                   .set VE_HEAD = VE_USART
                 XT_USART:
0000b8 7001        .dw DO_COLON
                 PFA_USART:          ; ( -- )
                 
0000b9 7038        .dw XT_DOLITERAL
0000ba 0098        .dw USART_B_VALUE
0000bb 7038        .dw XT_DOLITERAL
0000bc 00c1        .dw USART_B
0000bd 7088        .dw XT_CSTORE
                 
0000be 7038        .dw XT_DOLITERAL
0000bf 0006        .dw USART_C_VALUE
0000c0 7038        .dw XT_DOLITERAL
0000c1 00c2        .dw USART_C | bm_USARTC_en
0000c2 7088        .dw XT_CSTORE
                 
0000c3 00af        .dw XT_UBRR
0000c4 70ac        .dw XT_DUP
0000c5 72e8        .dw XT_BYTESWAP
0000c6 7038        .dw XT_DOLITERAL
0000c7 00c5        .dw BAUDRATE_HIGH
0000c8 7088        .dw XT_CSTORE
0000c9 7038        .dw XT_DOLITERAL
0000ca 00c4        .dw BAUDRATE_LOW
0000cb 7088        .dw XT_CSTORE
                 .if XT_USART_INIT_RX!=0
0000cc 005b        .dw XT_USART_INIT_RX
                 .endif
                 .if XT_USART_INIT_TX!=0
                 .endif
                 
0000cd 701b        .dw XT_EXIT
                 
                 ; settings for 1wire interface
                 .equ OW_PORT=PORTB
                 .EQU OW_BIT=4
                 .include "drivers/1wire.asm"
                 
                 ;   B. J. Rodriguez (MSP 430)
                 ;   Matthias Trute (AVR Atmega)
                 ; COPYRIGHT
                 ;   (c) 2012 Bradford J. Rodriguez for the 430 code and API
                 
                 ;  adapted 430 assembly code to AVR
                 ;  wishlist: 
                 ;     use a configurable pin at runtime, compatible with bitnames.frt
                 ;     no external pull up, no external power supply for devices
                 ;     ???
                 ;
                 ;.EQU OW_BIT=4
                 ;.equ OW_PORT=PORTE
                 .set OW_DDR=(OW_PORT-1)
                 .set OW_PIN=(OW_DDR-1)
                 
                 ;****f* 1W.RESET
                 ; NAME
                 ;   1W.RESET
                 ; SYNOPSIS
                 ;   1W.RESET ( -- f )  Initialize 1-wire devices; return true if present
                 ; DESCRIPTION
                 ;   This configures the port pin used by the 1-wire interface, and then
                 ;   sends an "initialize" sequence to the 1-wire devices.  If any device
                 ;   is present, it will be detected.
                 ;
                 ;   Timing, per DS18B20 data sheet:
                 ;   a) Output "0" (drive output low) for >480 usec.
                 ;   b) Output "1" (let output float).
                 ;   c) After 15 to 60 usec, device will drive pin low for 60 to 240 usec.
                 ;      So, wait 75 usec and sample input.
                 ;   d) Leave output high (floating) for at least 480 usec.
                 ;******
                 ; ( -- f )
                 ; Hardware
                 ; Initialize 1-wire devices; return true if present
                 VE_OW_RESET:
0000ce ff08          .dw $ff08
0000cf 7731
0000d0 722e
0000d1 7365
0000d2 7465          .db "1w.reset"
0000d3 00b3          .dw VE_HEAD
                     .set VE_HEAD = VE_OW_RESET
                 XT_OW_RESET:
0000d4 00d5          .dw PFA_OW_RESET
                 PFA_OW_RESET:
0000d5 939a
0000d6 938a          savetos
0000d7 2799          clr tosh
                     ; setup to output
0000d8 9a24          sbi OW_DDR, OW_BIT
                     ; Pull output low
0000d9 982c          cbi OW_PORT, OW_BIT
                     ; Delay >480 usec        
0000da e8e0
0000db e0f7
0000dc 9731
0000dd f7f1          DELAY   480
                     ; Critical timing period, disable interrupts.
0000de b71f          in temp1, SREG
0000df 94f8          cli
                     ; Pull output high
0000e0 9a2c          sbi OW_PORT, OW_BIT
                     ; make pin input, sends "1"
0000e1 9824          cbi OW_DDR, OW_BIT 
0000e2 e0e0
0000e3 e0f1
0000e4 9731
0000e5 f7f1          DELAY   64 ; delayB
                     ; Sample input pin, set TOS if input is zero
0000e6 b183          in tosl, OW_PIN
0000e7 ff84          sbrs tosl, OW_BIT
0000e8 ef9f          ser  tosh
                     ; End critical timing period, enable interrupts
0000e9 bf1f          out SREG, temp1
                     ; release bus
0000ea 9824          cbi OW_DDR, OW_BIT
0000eb 982c          cbi OW_PORT, OW_BIT
                 
                     ; Delay rest of 480 usec 
0000ec e8e0
0000ed e0f6
0000ee 9731
0000ef f7f1          DELAY   416
                     ; we now have the result flag in TOS        
0000f0 2f89          mov tosl, tosh
0000f1 940c 7005     jmp_ DO_NEXT
                     
                 ;****f* 1W.SLOT
                 ; NAME
                 ;   1W.SLOT
                 ; SYNOPSIS
                 ;   1W.SLOT ( c -- c' ) Write and read one bit to/from 1-wire.
                 ; DESCRIPTION
                 ;   The "touch byte" function is described in Dallas App Note 74.
                 ;   It outputs a byte to the 1-wire pin, LSB first, and reads back
                 ;   the state of the 1-wire pin after a suitable delay.
                 ;   To read a byte, output $FF and read the reply data.
                 ;   To write a byte, output that byte and discard the reply.
                 ;
                 ;   This function performs one bit of the "touch" operation --
                 ;   one read/write "slot" in Dallas jargon.  Perform this eight
                 ;   times in a row to get the "touch byte" function.
                 ;
                 ; PARAMETERS
                 ;   The input parameter is xxxxxxxxbbbbbbbo where
                 ;   'xxxxxxxx' are don't cares,
                 ;   'bbbbbbb' are bits to be shifted down, and
                 ;   'o' is the bit to be output in the slot.  This must be 1
                 ;   to create a read slot.
                 ;
                 ;   The returned value is xxxxxxxxibbbbbbb where
                 ;   'xxxxxxxx' are not known (the input shifted down 1 position),
                 ;   'i' is the bit read during the slot.  This has no meaning
                 ;   if it was a write slot.
                 ;   'bbbbbbb' are the 7 input bits, shifted down one position.
                 ;
                 ;   This peculiar parameter usage allows OWTOUCH to be written as
                 ;     OWSLOT OWSLOT OWSLOT OWSLOT OWSLOT OWSLOT OWSLOT OWSLOT 
                 ;
                 ; NOTES 
                 ;   Interrupts are disabled during each bit.
                 
                 ;   Timing, per DS18B20 data sheet:
                 ;   a) Output "0" for start period.  (> 1 us, < 15 us, typ. 6 us*)
                 ;   b) Output data bit (0 or 1), open drain 
                 ;   c) After MS from start of cycle, sample input (15 to 60 us, typ. 25 us*)
                 ;   d) After write-0 period from start of cycle, output "1" (>60 us)
                 ;   e) After recovery period, loop or return. (> 1 us)
                 ;   For writes, DS18B20 samples input 15 to 60 usec from start of cycle.
                 ;   * "Typical" values are per App Note 132 for a 300m cable length.
                 
                 ;   ---------        -------------------------------
                 ;            \      /                        /
                 ;             ------------------------------- 
                 ;            a      b          c             d     e
                 ;            |  6us |   19us   |    35us     | 2us |
                 ;******
                 ; ( c -- c' )
                 ; Hardware
                 ; Write and read one bit to/from 1-wire.
                 VE_OW_SLOT:
0000f3 ff07          .dw $ff07
0000f4 7731
0000f5 732e
0000f6 6f6c
0000f7 0074          .db "1w.slot",0
0000f8 00ce          .dw VE_HEAD
                     .set VE_HEAD = VE_OW_SLOT
                 XT_OW_SLOT:
0000f9 00fa          .dw PFA_OW_SLOT
                 PFA_OW_SLOT:
                     ; pull low
0000fa 9a24          sbi OW_DDR, OW_BIT
0000fb 982c          cbi OW_PORT, OW_BIT
                     ; disable interrupts
0000fc b71f          in temp1, SREG
0000fd 94f8          cli
0000fe e1e8
0000ff e0f0
000100 9731
000101 f7f1          DELAY   6 ; DELAY A
                     ; check bit
000102 9488          clc
000103 9587          ror tosl
000104 f410          brcc PFA_OW_SLOT0 ; a 0 keeps the bus low
                       ; release bus, a 1 is written
000105 9824            cbi OW_DDR, OW_BIT
000106 9a2c            sbi OW_PORT, OW_BIT
                 PFA_OW_SLOT0:
                     ; sample the input (no action required if zero)
000107 e2e4
000108 e0f0
000109 9731
00010a f7f1          DELAY 9   ; wait DELAY E to sample
00010b b103          in temp0, OW_PIN
00010c fd04          sbrc temp0, OW_BIT
00010d 6880          ori tosl, $80
                 
00010e ecec
00010f e0f0
000110 9731
000111 f7f1          DELAY   51 ; DELAY B
000112 9824          cbi OW_DDR, OW_BIT
000113 9a2c          sbi OW_PORT, OW_BIT ; release bus
000114 e0e8
000115 e0f0
000116 9731
000117 f7f1          delay 2
                     ; re-enable interrupts
000118 bf1f          out SREG, temp1
000119 940c 7005     jmp_ DO_NEXT
                 
                 .include "amforth.asm"
                 
                 ;;;;
                 ;;;; GPL V2 (only)
                 
                 .set AMFORTH_NRWW_SIZE=(FLASHEND-AMFORTH_RO_SEG)*2
                 
                 .set corepc = pc
                 .org $0000
000000 940c 7a45   jmp_ PFA_COLD
                 
                 .org corepc
                 .include "drivers/generic-isr.asm"
                 
                 .dseg
000116           intcur: .byte 1
                 .eseg
000000           intvec: .byte INTVECTORS * CELLSIZE
                 .cseg
                 
                 ; interrupt routine gets called (again) by rcall! This gives the
                 ; address of the int-vector on the stack.
                 isr:
00011b 920a          st -Y, r0
00011c b60f          in r0, SREG
00011d 920a          st -Y, r0
                 .if (pclen==3)
                 .endif
00011e 900f          pop r0
00011f 900f          pop r0          ; = intnum * intvectorsize + 1 (address following the rcall)
000120 940a          dec r0
                 .if intvecsize == 1 ;
                 .endif
000121 9200 0116     sts intcur, r0
000123 9009          ld r0, Y+
000124 be0f          out SREG, r0
000125 9009          ld r0, Y+
000126 9468          set ; set the interrupt flag for the inner interpreter
000127 9508          ret ; returns the interrupt, the rcall stack frame is removed!
                 
                 ; lower part of the dictionary
                 .include "dict/rww.inc"
                 
                 
                 ; Arithmetics
                 ; add a number to a double cell
                 VE_MPLUS:
000128 ff02          .dw $ff02
000129 2b6d          .db "m+"
00012a 00f3          .dw VE_HEAD
                     .set VE_HEAD = VE_MPLUS
                 XT_MPLUS:
00012b 7001          .dw DO_COLON
                 PFA_MPLUS:
00012c 7d56          .dw XT_S2D
00012d 7405          .dw XT_DPLUS
00012e 701b          .dw XT_EXIT
                 .include "words/ud-star.asm"
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_UDSTAR:
00012f ff03          .dw $ff03
000130 6475
../../common\words/ud-star.asm(9): warning: .cseg .db misalignment - padding zero byte
000131 002a          .db "ud*"
000132 0128          .dw VE_HEAD
                     .set VE_HEAD = VE_UDSTAR
                 XT_UDSTAR:
000133 7001          .dw DO_COLON
                 PFA_UDSTAR:
                 
                 .endif
                 ;Z UD*      ud1 d2 -- ud3      32*16->32 multiply
                 ;   XT_DUP >R UM* DROP  XT_SWAP R> UM* ROT + ;
                 
000134 70ac
000135 70fa
000136 71db
000137 70d4              .DW XT_DUP,XT_TO_R,XT_UMSTAR,XT_DROP
000138 70bf
000139 70f1
00013a 71db
00013b 70dc
00013c 7198
00013d 701b              .DW XT_SWAP,XT_R_FROM,XT_UMSTAR,XT_ROT,XT_PLUS,XT_EXIT
                 .include "words/umax.asm"
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_UMAX:
00013e ff04          .dw $ff04
00013f 6d75
000140 7861          .db "umax"
000141 012f          .dw VE_HEAD
                     .set VE_HEAD = VE_UMAX
                 XT_UMAX:
000142 7001          .dw DO_COLON
                 PFA_UMAX:
                 .endif
                 
000143 7565
000144 7157              .DW XT_2DUP,XT_ULESS
000145 7031      	.dw XT_DOCONDBRANCH
000146 0148      	 DEST(UMAX1)
000147 70bf              .DW XT_SWAP
000148 70d4      UMAX1:  .DW XT_DROP
000149 701b      	.dw XT_EXIT
                 .include "words/umin.asm"
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_UMIN:
00014a ff04          .dw $ff04
00014b 6d75
00014c 6e69          .db "umin"
00014d 013e          .dw VE_HEAD
                     .set VE_HEAD = VE_UMIN
                 XT_UMIN:
00014e 7001          .dw DO_COLON
                 PFA_UMIN:
                 .endif
00014f 7565
000150 7162              .DW XT_2DUP,XT_UGREATER
000151 7031      	.dw XT_DOCONDBRANCH
000152 0154      	DEST(UMIN1)
000153 70bf              .DW XT_SWAP
000154 70d4      UMIN1:  .DW XT_DROP
000155 701b      	.dw XT_EXIT
                 .include "words/immediate-q.asm"
                 
                 ; Tools
                 ; get count information out of a counted string in flash
                 ;VE_IMMEDIATEQ:
                 ;    .dw $ff06
                 ;    .db "immediate?"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_IMMEDIATEQ
                 XT_IMMEDIATEQ:
000156 7001          .dw DO_COLON
                 PFA_IMMEDIATEQ:
000157 7038          .dw XT_DOLITERAL
000158 8000          .dw $8000
000159 720e          .dw XT_AND
00015a 7115          .dw XT_ZEROEQUAL
00015b 7031          .dw XT_DOCONDBRANCH
00015c 0160          DEST(IMMEDIATEQ1)
00015d 7038           .dw XT_DOLITERAL
00015e 0001           .dw 1
00015f 701b           .dw XT_EXIT
                 IMMEDIATEQ1:
                     ; not immediate
000160 7146          .dw XT_TRUE
000161 701b          .dw XT_EXIT
                 .include "words/name2flags.asm"
                 
                 ; Tools
                 ; get the flags from a name token
                 VE_NAME2FLAGS:
000162 ff0a          .dw $ff0a
000163 616e
000164 656d
000165 663e
000166 616c
000167 7367          .db "name>flags"
000168 014a          .dw VE_HEAD
                     .set VE_HEAD = VE_NAME2FLAGS
                 XT_NAME2FLAGS:
000169 7001          .dw DO_COLON
                 PFA_NAME2FLAGS:
00016a 73bb          .dw XT_FETCHI ; skip to link field
00016b 7038          .dw XT_DOLITERAL
00016c ff00          .dw $ff00
00016d 720e          .dw XT_AND
00016e 701b          .dw XT_EXIT
                 .include "words/name2interpret.asm"
                 
                 ; Tools (ext)
                 ; get the execution token from the name token
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_NAME2INTERPRET:
00016f ff0e          .dw $ff0e
000170 616e
000171 656d
000172 693e
000173 746e
000174 7265
000175 7270
000176 7465          .db "name>interpret"
000177 0162          .dw VE_HEAD
                     .set VE_HEAD = VE_NAME2INTERPRET
                 XT_NAME2INTERPRET:
000178 7001          .dw DO_COLON
                 PFA_NAME2INTERPRET:
                 .endif
000179 7c71          .dw XT_NFA2CFA
00017a 701b          .dw XT_EXIT
                 .include "words/name2compile.asm"
                 
                 ; Tools (ext)
                 ; get the execution token from the name token in compile state
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_NAME2COMPILE:
00017b ff0c          .dw $ff0c
00017c 616e
00017d 656d
00017e 633e
00017f 6d6f
000180 6970
000181 656c          .db "name>compile"
000182 016f          .dw VE_HEAD
                     .set VE_HEAD = VE_NAME2COMPILE
                 XT_NAME2COMPILE:
000183 7001          .dw DO_COLON
                 PFA_NAME2COMPILE:
                 .endif
000184 70ac          .dw XT_DUP
000185 7c71          .dw XT_NFA2CFA
000186 70bf          .dw XT_SWAP
000187 0169          .dw XT_NAME2FLAGS
000188 0156          .dw XT_IMMEDIATEQ
000189 7031          .dw XT_DOCONDBRANCH
00018a 018e          DEST(NAME2COMPILE1)
00018b 7038      	.dw XT_DOLITERAL
00018c 01c8      	.dw XT_COMMA
00018d 701b      	.dw XT_EXIT
                 NAME2COMPILE1:
00018e 7038      	.dw XT_DOLITERAL
00018f 7025      	.dw XT_EXECUTE
000190 701b          .dw XT_EXIT
                 
                 .if AMFORTH_NRWW_SIZE > 8000
                 .include "dict/appl_8k.inc"
                 
                 
                 .include "words/docreate.asm"
                 
                 ; Compiler
                 ; parse the input and create an empty vocabulary entry without XT and data field (PF)
                 VE_DOCREATE:
000191 ff08          .dw $ff08
000192 6328
000193 6572
000194 7461
000195 2965          .db "(create)"
000196 017b          .dw VE_HEAD
                     .set VE_HEAD = VE_DOCREATE
                 XT_DOCREATE:
000197 7001          .dw DO_COLON
                 PFA_DOCREATE:
000198 79b7          .dw XT_PARSENAME
000199 02f2          .dw XT_WLSCOPE
00019a 70ac          .dw XT_DUP
00019b 70fa          .dw XT_TO_R
00019c 02d7          .dw XT_HEADER
00019d 70f1          .dw XT_R_FROM
                 .dseg
000117           COLON_SMUDGE: .byte 4
                 .cseg
00019e 7038          .dw XT_DOLITERAL
00019f 0119          .dw COLON_SMUDGE+2
0001a0 707c          .dw XT_STORE		; save wid
0001a1 7038          .dw XT_DOLITERAL
0001a2 0117          .dw COLON_SMUDGE+0
0001a3 707c          .dw XT_STORE		; save NFA
                 
0001a4 701b          .dw XT_EXIT
                 .include "words/backslash.asm"
                 
                 ; Compiler
                 ; everything up to the end of the current line is a comment
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_BACKSLASH:
0001a5 0001          .dw $0001
0001a6 005c          .db $5c,0
0001a7 0191          .dw VE_HEAD
                     .set VE_HEAD = VE_BACKSLASH
                 XT_BACKSLASH:
0001a8 7001          .dw DO_COLON
                 PFA_BACKSLASH:
                 .endif
0001a9 799e          .dw XT_SOURCE
0001aa 70eb          .dw XT_NIP
0001ab 757e          .dw XT_TO_IN
0001ac 707c          .dw XT_STORE
0001ad 701b          .dw XT_EXIT
                 .include "words/l-paren.asm"
                 
                 ; Compiler
                 ; skip everything up to the closing bracket on the same line
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_LPAREN:
0001ae 0001          .dw $0001
0001af 0028          .db "(" ,0
0001b0 01a5          .dw VE_HEAD
                     .set VE_HEAD = VE_LPAREN
                 XT_LPAREN:
0001b1 7001          .dw DO_COLON
                 PFA_LPAREN:
                 .endif
0001b2 7038          .dw XT_DOLITERAL
0001b3 0029          .dw ')'
0001b4 7989          .dw XT_PARSE
0001b5 756e          .dw XT_2DROP
0001b6 701b          .dw XT_EXIT
                 
                 .include "words/compile.asm"
                 
                 ; Dictionary
                 ; read the following cell from the dictionary and append it to the current dictionary position.
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_COMPILE:
0001b7 ff07          .dw $ff07
0001b8 6f63
0001b9 706d
0001ba 6c69
0001bb 0065          .db "compile",0
0001bc 01ae          .dw  VE_HEAD
                     .set VE_HEAD = VE_COMPILE
                 XT_COMPILE:
0001bd 7001          .dw DO_COLON
                 PFA_COMPILE:
                 .endif
0001be 70f1          .dw XT_R_FROM
0001bf 70ac          .dw XT_DUP
0001c0 7b9e          .dw XT_ICELLPLUS
0001c1 70fa          .dw XT_TO_R
0001c2 73bb          .dw XT_FETCHI
0001c3 01c8          .dw XT_COMMA
0001c4 701b          .dw XT_EXIT
                 .include "words/comma.asm"
                 
                 ; Dictionary
                 ; compile 16 bit into flash at DP
                 VE_COMMA:
0001c5 ff01          .dw $ff01
0001c6 002c          .db ',',0 ; ,
0001c7 01b7          .dw VE_HEAD
                     .set VE_HEAD = VE_COMMA
                 XT_COMMA:
0001c8 7001          .dw DO_COLON
                 PFA_COMMA:
0001c9 75b4          .dw XT_DP
0001ca 7362          .dw XT_STOREI
0001cb 75b4          .dw XT_DP
0001cc 722a          .dw XT_1PLUS
0001cd 7b8c          .dw XT_DOTO
0001ce 75b5          .dw PFA_DP
0001cf 701b          .dw XT_EXIT
                 .include "words/brackettick.asm"
                 
                 ; Compiler
                 ; what ' does in the interpreter mode, do in colon definitions
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_BRACKETTICK:
0001d0 0003          .dw $0003
0001d1 275b
0001d2 005d          .db "[']",0
0001d3 01c5          .dw VE_HEAD
                     .set VE_HEAD = VE_BRACKETTICK
                 XT_BRACKETTICK:
0001d4 7001          .dw DO_COLON
                 PFA_BRACKETTICK:
                 .endif
0001d5 7814          .dw XT_TICK
0001d6 01de          .dw XT_LITERAL
0001d7 701b          .dw XT_EXIT
                 
                 
                 .include "words/literal.asm"
                 
                 ; Compiler
                 ; compile a literal in colon defintions
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_LITERAL:
0001d8 0007          .dw $0007
0001d9 696c
0001da 6574
0001db 6172
0001dc 006c          .db "literal",0
0001dd 01d0          .dw VE_HEAD
                     .set VE_HEAD = VE_LITERAL
                 XT_LITERAL:
0001de 7001          .dw DO_COLON
                 PFA_LITERAL:
                 .endif
0001df 01bd              .DW XT_COMPILE
0001e0 7038              .DW XT_DOLITERAL
0001e1 01c8              .DW XT_COMMA
0001e2 701b              .DW XT_EXIT
                 .include "words/sliteral.asm"
                 
                 ; String
                 ; compiles a string to flash, at runtime leaves ( -- flash-addr count) on stack
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SLITERAL:
0001e3 0008        .dw $0008
0001e4 6c73
0001e5 7469
0001e6 7265
0001e7 6c61        .db "sliteral"
0001e8 01d8        .dw VE_HEAD
                   .set VE_HEAD = VE_SLITERAL
                 XT_SLITERAL:
0001e9 7001          .dw DO_COLON
                 PFA_SLITERAL:
                 .endif
0001ea 01bd          .dw XT_COMPILE
0001eb 7777          .dw XT_DOSLITERAL    ; ( -- addr n)
0001ec 7785          .dw XT_SCOMMA
0001ed 701b          .dw XT_EXIT
                 .include "words/g-mark.asm"
                 
                 ; Compiler
                 ; places current dictionary position for backward resolves
                 ;VE_GMARK:
                 ;    .dw $ff05
                 ;    .db ">mark"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_GMARK
                 XT_GMARK:
0001ee 7001          .dw DO_COLON
                 PFA_GMARK:
0001ef 75b4          .dw XT_DP
0001f0 01bd          .dw XT_COMPILE
0001f1 ffff          .dw -1           ; ffff does not erase flash
0001f2 701b          .dw XT_EXIT
                 .include "words/g-resolve.asm"
                 
                 ; Compiler
                 ; resolve backward jumps
                 ;VE_GRESOLVE:
                 ;    .dw $ff08
                 ;    .db ">resolve"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_GRESOLVE
                 XT_GRESOLVE:
0001f3 7001          .dw DO_COLON
                 PFA_GRESOLVE:
0001f4 7b49          .dw XT_QSTACK
0001f5 75b4          .dw XT_DP
0001f6 70bf          .dw XT_SWAP
0001f7 7362          .dw XT_STOREI
0001f8 701b          .dw XT_EXIT
                 .include "words/l_mark.asm"
                 
                 ; Compiler
                 ; place destination for backward branch
                 ;VE_LMARK:
                 ;    .dw $ff05
                 ;    .db "<mark"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_LMARK
                 XT_LMARK:
0001f9 7001          .dw DO_COLON
                 PFA_LMARK:
0001fa 75b4          .dw XT_DP
0001fb 701b          .dw XT_EXIT
                 .include "words/l_resolve.asm"
                 
                 ; Compiler
                 ; resolve backward branch
                 ;VE_LRESOLVE:
                 ;    .dw $ff08
                 ;    .db "<resolve"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_LRESOLVE
                 XT_LRESOLVE:
0001fc 7001          .dw DO_COLON
                 PFA_LRESOLVE:
0001fd 7b49          .dw XT_QSTACK
0001fe 01c8          .dw XT_COMMA
0001ff 701b          .dw XT_EXIT
                 
                 .include "words/ahead.asm"
                 
                 ; Compiler
                 ; do a unconditional branch
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_AHEAD:
000200 0005          .dw $0005
000201 6861
000202 6165
000203 0064          .db "ahead",0
000204 01e3          .dw VE_HEAD
                     .set VE_HEAD = VE_AHEAD
                 XT_AHEAD:
000205 7001          .dw DO_COLON
                 PFA_AHEAD:
                 .endif
000206 01bd          .dw XT_COMPILE
000207 702a          .dw XT_DOBRANCH
000208 01ee          .dw XT_GMARK
000209 701b          .dw XT_EXIT
                 .include "words/if.asm"
                 
                 ; Compiler
                 ; start conditional branch
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_IF:
00020a 0002          .dw $0002
00020b 6669          .db "if"
00020c 0200          .dw VE_HEAD
                     .set VE_HEAD = VE_IF
                 XT_IF:
00020d 7001          .dw DO_COLON
                 PFA_IF:
                 .endif
00020e 01bd          .dw XT_COMPILE
00020f 7031          .dw XT_DOCONDBRANCH
000210 01ee          .dw XT_GMARK
000211 701b          .dw XT_EXIT
                 .include "words/else.asm"
                 
                 ; Compiler
                 ; resolve the forward reference and place a new unresolved forward reference
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_ELSE:
000212 0004          .dw $0004
000213 6c65
000214 6573          .db "else"
000215 020a          .dw VE_HEAD
                     .set VE_HEAD = VE_ELSE
                 XT_ELSE:
000216 7001          .dw DO_COLON
                 PFA_ELSE:
                 .endif
000217 01bd          .dw XT_COMPILE
000218 702a          .dw XT_DOBRANCH
000219 01ee          .dw XT_GMARK
00021a 70bf          .dw XT_SWAP
00021b 01f3          .dw XT_GRESOLVE
00021c 701b          .dw XT_EXIT
                 .include "words/then.asm"
                 
                 ; Compiler
                 ; finish if
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_THEN:
00021d 0004          .dw $0004
00021e 6874
00021f 6e65          .db "then"
000220 0212          .dw VE_HEAD
                     .set VE_HEAD = VE_THEN
                 XT_THEN:
000221 7001          .dw DO_COLON
                 PFA_THEN:
                 .endif
000222 01f3          .dw XT_GRESOLVE
000223 701b          .dw XT_EXIT
                 .include "words/begin.asm"
                 
                 ; Compiler
                 ; put the next location for a transfer of control onto the control flow stack
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_BEGIN:
000224 0005          .dw $0005
000225 6562
000226 6967
000227 006e          .db "begin",0
000228 021d          .dw VE_HEAD
                     .set VE_HEAD = VE_BEGIN
                 XT_BEGIN:
000229 7001          .dw DO_COLON
                 PFA_BEGIN:
                 .endif
00022a 01f9          .dw XT_LMARK
00022b 701b          .dw XT_EXIT
                 .include "words/while.asm"
                 
                 ; Compiler
                 ; at runtime skip until repeat if non-true
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_WHILE:
00022c 0005          .dw $0005
00022d 6877
00022e 6c69
00022f 0065          .db "while",0
000230 0224          .dw VE_HEAD
                     .set VE_HEAD = VE_WHILE
                 XT_WHILE:
000231 7001          .dw DO_COLON
                 PFA_WHILE:
                 .endif
000232 020d          .dw XT_IF
000233 70bf          .dw XT_SWAP
000234 701b          .dw XT_EXIT
                 .include "words/repeat.asm"
                 
                 ; Compiler
                 ; continue execution at dest, resolve orig
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_REPEAT:
000235 0006          .dw $0006
000236 6572
000237 6570
000238 7461          .db "repeat"
000239 022c          .dw VE_HEAD
                     .set VE_HEAD = VE_REPEAT
                 XT_REPEAT:
00023a 7001          .dw DO_COLON
                 PFA_REPEAT:
                 .endif
00023b 024e          .dw XT_AGAIN
00023c 0221          .dw XT_THEN
00023d 701b          .dw XT_EXIT
                 .include "words/until.asm"
                 
                 ; Compiler
                 ; finish begin with conditional branch, leaves the loop if true flag at runtime
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_UNTIL:
00023e 0005          .dw $0005
00023f 6e75
000240 6974
000241 006c          .db "until",0
000242 0235          .dw VE_HEAD
                     .set VE_HEAD = VE_UNTIL
                 XT_UNTIL:
000243 7001          .dw DO_COLON
                 PFA_UNTIL:
                 .endif
000244 7038          .dw XT_DOLITERAL
000245 7031          .dw XT_DOCONDBRANCH
000246 01c8          .dw XT_COMMA
                 
000247 01fc          .dw XT_LRESOLVE
000248 701b          .dw XT_EXIT
                 .include "words/again.asm"
                 
                 ; Compiler
                 ; compile a jump back to dest
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_AGAIN:
000249 0005          .dw $0005
00024a 6761
00024b 6961
00024c 006e          .db "again",0
00024d 023e          .dw VE_HEAD
                     .set VE_HEAD = VE_AGAIN
                 XT_AGAIN:
00024e 7001          .dw DO_COLON
                 PFA_AGAIN:
                 .endif
00024f 01bd          .dw XT_COMPILE
000250 702a          .dw XT_DOBRANCH
000251 01fc          .dw XT_LRESOLVE
000252 701b          .dw XT_EXIT
                 .include "words/do.asm"
                 
                 ; Compiler
                 ; start do .. [+]loop
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DO:
000253 0002          .dw $0002
000254 6f64          .db "do"
000255 0249          .dw VE_HEAD
                     .set VE_HEAD = VE_DO
                 XT_DO:
000256 7001          .dw DO_COLON
                 PFA_DO:
                 
                 .endif
000257 01bd          .dw XT_COMPILE
000258 728a          .dw XT_DODO
000259 01f9          .dw XT_LMARK
00025a 714f          .dw XT_ZERO
00025b 02b1          .dw XT_TO_L
00025c 701b          .dw XT_EXIT
                 .include "words/loop.asm"
                 
                 ; Compiler
                 ; compile (loop) and resolve the backward branch
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_LOOP:
00025d 0004          .dw $0004
00025e 6f6c
00025f 706f          .db "loop"
000260 0253          .dw VE_HEAD
                     .set VE_HEAD = VE_LOOP
                 XT_LOOP:
000261 7001          .dw DO_COLON
                 PFA_LOOP:
                 .endif
000262 01bd          .dw XT_COMPILE
000263 72b8          .dw XT_DOLOOP
000264 0298          .dw XT_ENDLOOP
000265 701b          .dw XT_EXIT
                 .include "words/plusloop.asm"
                 
                 ; Compiler
                 ; compile (+loop) and resolve branches
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_PLUSLOOP:
000266 0005          .dw $0005
000267 6c2b
000268 6f6f
000269 0070          .db "+loop",0
00026a 025d          .dw VE_HEAD
                     .set VE_HEAD = VE_PLUSLOOP
                 XT_PLUSLOOP:
00026b 7001          .dw DO_COLON
                 PFA_PLUSLOOP:
                 .endif
00026c 01bd          .dw XT_COMPILE
00026d 72a9          .dw XT_DOPLUSLOOP
00026e 0298          .dw XT_ENDLOOP
00026f 701b          .dw XT_EXIT
                 .include "words/leave.asm"
                 
                 ; Compiler
                 ; immediatly leave the current DO..LOOP
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_LEAVE:
000270 0005         .dw $0005
000271 656c
000272 7661
000273 0065         .db "leave",0
000274 0266         .dw VE_HEAD
                    .set VE_HEAD = VE_LEAVE
                 XT_LEAVE:
000275 7001          .dw DO_COLON
                 PFA_LEAVE:
                 .endif
000276 01bd
000277 72c3          .DW XT_COMPILE,XT_UNLOOP
000278 0205
000279 02b1
00027a 701b          .DW XT_AHEAD,XT_TO_L,XT_EXIT
                 .include "words/qdo.asm"
                 
                 ; Compiler
                 ; start a ?do .. [+]loop control structure
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 VE_QDO:
00027b 0003          .dw $0003
00027c 643f
00027d 006f          .db "?do",0
00027e 0270          .dw VE_HEAD
                     .set VE_HEAD = VE_QDO
                 XT_QDO:
00027f 7001          .dw DO_COLON
                 PFA_QDO:
                 .endif
000280 01bd          .dw XT_COMPILE
000281 0287          .dw XT_QDOCHECK
000282 020d          .dw XT_IF
000283 0256          .dw XT_DO
000284 70bf          .dw XT_SWAP    ; DO sets a 0 marker on the leave stack
000285 02b1          .dw XT_TO_L    ; then follows at the end.
000286 701b          .dw XT_EXIT
                 
                 ; there is no special runtime for ?do, the do runtime
                 ; gets wrapped with the sequence
                 ; ... ?do-check if do ..... loop then
                 ; with
                 ; : ?do-check ( n1 n2 -- n1 n2 true | false )
                 ;   2dup = dup >r if 2drop then r> invert ;
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 XT_QDOCHECK:
000287 7001          .dw DO_COLON
                 PFA_QDOCHECK:
                 .endif
000288 7565          .dw XT_2DUP
000289 7d72          .dw XT_EQUAL
00028a 70ac          .dw XT_DUP
00028b 70fa          .dw XT_TO_R
00028c 7031          .dw XT_DOCONDBRANCH
00028d 028f          DEST(PFA_QDOCHECK1)
00028e 756e          .dw XT_2DROP
                 PFA_QDOCHECK1:
00028f 70f1          .dw XT_R_FROM
000290 71f8          .dw XT_INVERT
000291 701b          .dw XT_EXIT
                 .include "words/endloop.asm"
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_ENDLOOP:
000292 ff07          .dw $ff07
000293 6e65
000294 6c64
000295 6f6f
000296 0070          .db "endloop",0
000297 027b          .dw VE_HEAD
                     .set VE_HEAD = VE_ENDLOOP
                 XT_ENDLOOP:
000298 7001          .dw DO_COLON
                 PFA_ENDLOOP:
                 .endif
                 ;Z ENDLOOP   adrs xt --   L: 0 a1 a2 .. aN --
                 ;   <resolve                backward loop
                 ;   BEGIN L> ?DUP WHILE POSTPONE THEN REPEAT ;
                 ;                                 resolve LEAVEs
                 ; This is a common factor of LOOP and +LOOP.
                 
000299 01fc              .DW XT_LRESOLVE
00029a 02a5
00029b 70b4
00029c 7031      LOOP1:  .DW XT_L_FROM,XT_QDUP,XT_DOCONDBRANCH
00029d 02a1               DEST(LOOP2)
00029e 0221              .DW XT_THEN
00029f 702a      	.dw XT_DOBRANCH
0002a0 029a               DEST(LOOP1)
0002a1 701b      LOOP2:  .DW XT_EXIT
                 ; leave address stack
                 .include "words/l-from.asm"
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_L_FROM:
0002a2 ff02          .dw $ff02
0002a3 3e6c          .db "l>"
0002a4 0292          .dw VE_HEAD
                     .set VE_HEAD = VE_L_FROM
                 XT_L_FROM:
0002a5 7001          .dw DO_COLON
                 PFA_L_FROM:
                 
                 .endif
                 ;Z L>   -- x   L: x --      move from leave stack
                 ;   LP @ @  -2 LP +! ;
                 
0002a6 02c5          .dw XT_LP
0002a7 7074          .dw XT_FETCH
0002a8 7074          .dw XT_FETCH
0002a9 7038          .dw XT_DOLITERAL
0002aa fffe          .dw -2
0002ab 02c5          .dw XT_LP
0002ac 7254          .dw XT_PLUSSTORE
0002ad 701b          .dw XT_EXIT
                 .include "words/to-l.asm"
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_TO_L:
0002ae ff02          .dw $ff02
0002af 6c3e          .db ">l"
0002b0 02a2          .dw VE_HEAD
                     .set VE_HEAD = VE_TO_L
                 XT_TO_L:
0002b1 7001          .dw DO_COLON
                 PFA_TO_L:
                 .endif
                 ;Z >L   x --   L: -- x        move to leave stack
                 ;   CELL LP +!  LP @ ! ;      (L stack grows up)
                 
0002b2 7038              .dw XT_DOLITERAL
0002b3 0002      	.dw 2
0002b4 02c5      	.dw XT_LP
0002b5 7254      	.dw XT_PLUSSTORE
0002b6 02c5      	.dw XT_LP
0002b7 7074      	.dw XT_FETCH
0002b8 707c      	.dw XT_STORE
0002b9 701b      	.dw XT_EXIT
                 .include "words/lp0.asm"
                 
                 ; Stack
                 ; start address of leave stack
                 VE_LP0:
0002ba ff03          .dw $ff03
0002bb 706c
0002bc 0030          .db "lp0",0
0002bd 02ae          .dw VE_HEAD
                     .set VE_HEAD = VE_LP0
                 XT_LP0:
0002be 706a          .dw PFA_DOVALUE1
                 PFA_LP0:
0002bf 006a          .dw EE_LP0
0002c0 7ba7          .dw XT_EDEFERFETCH
0002c1 7bb1          .dw XT_EDEFERSTORE
                 .include "words/lp.asm"
                 
                 ; System Variable
                 ; leave stack pointer
                 VE_LP:
0002c2 ff02          .dw $ff02
0002c3 706c          .db "lp"
0002c4 02ba          .dw VE_HEAD
                     .set VE_HEAD = VE_LP
                 XT_LP:
0002c5 7043          .dw PFA_DOVARIABLE
                 PFA_LP:
0002c6 011b          .dw ram_lp
                 
                 .dseg
00011b           ram_lp: .byte 2
                 .cseg
                 
                 
                 .include "words/create.asm"
                 
                 ; Dictionary
                 ; create a dictionary header. XT is (constant), with the address of the data field of name
                 VE_CREATE:
0002c7 ff06          .dw $ff06
0002c8 7263
0002c9 6165
0002ca 6574          .db "create"
0002cb 02c2          .dw VE_HEAD
                     .set VE_HEAD = VE_CREATE
                 XT_CREATE:
0002cc 7001          .dw DO_COLON
                 PFA_CREATE:
0002cd 0197          .dw XT_DOCREATE
0002ce 02fb          .dw XT_REVEAL
0002cf 01bd          .dw XT_COMPILE
0002d0 704d          .dw PFA_DOCONSTANT
0002d1 701b          .dw XT_EXIT
                 .include "words/header.asm"
                 
                 ; Compiler
                 ; creates the vocabulary header without XT and data field (PF) in the wordlist wid
                 VE_HEADER:
0002d2 ff06          .dw $ff06
0002d3 6568
0002d4 6461
0002d5 7265          .db "header"
0002d6 02c7          .dw VE_HEAD
                     .set VE_HEAD = VE_HEADER
                 XT_HEADER:
0002d7 7001          .dw DO_COLON
                 PFA_HEADER:
0002d8 75b4          .dw XT_DP           ; the new Name Field
0002d9 70fa          .dw XT_TO_R
0002da 70fa          .dw XT_TO_R		; ( R: NFA WID )
0002db 70ac          .dw XT_DUP    
0002dc 7123          .dw XT_GREATERZERO 
0002dd 7031          .dw XT_DOCONDBRANCH
0002de 02e9          .dw PFA_HEADER1
0002df 70ac          .dw XT_DUP
0002e0 7038          .dw XT_DOLITERAL
0002e1 ff00          .dw $ff00           ; all flags are off (e.g. immediate)
0002e2 7217          .dw XT_OR
0002e3 7789          .dw XT_DOSCOMMA
                     ; make the link to the previous entry in this wordlist
0002e4 70f1          .dw XT_R_FROM
0002e5 734e          .dw XT_FETCHE
0002e6 01c8          .dw XT_COMMA
0002e7 70f1          .dw XT_R_FROM
0002e8 701b          .dw XT_EXIT
                 
                 PFA_HEADER1:
                     ; -16: attempt to use zero length string as a name
0002e9 7038          .dw XT_DOLITERAL
0002ea fff0          .dw -16
0002eb 7843          .dw XT_THROW
                 
                 .include "words/wlscope.asm"
                 
                 ; Compiler
                 ; dynamically place a word in a wordlist. The word name may be changed.
                 VE_WLSCOPE:
0002ec ff07          .dw $ff07
0002ed 6c77
0002ee 6373
0002ef 706f
0002f0 0065          .db "wlscope",0
0002f1 02d2          .dw VE_HEAD
                     .set VE_HEAD = VE_WLSCOPE
                 XT_WLSCOPE:
0002f2 7c06          .dw PFA_DODEFER1
                 PFA_WLSCOPE:
0002f3 0068          .dw EE_WLSCOPE
0002f4 7ba7          .dw XT_EDEFERFETCH
0002f5 7bb1          .dw XT_EDEFERSTORE
                 
                 ; wlscope, "wordlist scope" ( addr len -- addr' len' wid ), is a deferred word
                 ; which enables the AmForth application to choose the wordlist ( wid ) for the
                 ; new voc entry based on the input ( addr len ) string. The name of the new voc
                 ; entry ( addr' len' ) may be different from the input string. Note that all
                 ; created voc entry types pass through the wlscope mechanism. The default
                 ; wlscope action passes the input string to the output without modification and
                 ; uses get-current to select the wid.
                 .include "words/reveal.asm"
                 
                 ; Dictionary
                 ; makes an entry in a wordlist visible, if not already done.
                 VE_REVEAL:
0002f6 ff06          .dw $ff06
0002f7 6572
0002f8 6576
0002f9 6c61          .db "reveal"
0002fa 02ec          .dw VE_HEAD
                     .set VE_HEAD = VE_REVEAL
                 XT_REVEAL:
0002fb 7001          .dw DO_COLON
                 PFA_REVEAL:
0002fc 7038          .dw XT_DOLITERAL
0002fd 0117          .dw COLON_SMUDGE+0
0002fe 7074          .dw XT_FETCH
0002ff 70b4          .dw XT_QDUP
000300 7031          .dw XT_DOCONDBRANCH
000301 030a          .dw PFA_REVEAL1
                 ;
000302 7038          .dw XT_DOLITERAL
000303 0119          .dw COLON_SMUDGE+2
000304 7074          .dw XT_FETCH		; ( NFA WID )
000305 732a          .dw XT_STOREE
                     ; prevent duplicate actions and cooperate with :noname
000306 714f          .dw XT_ZERO
000307 7038          .dw XT_DOLITERAL
000308 0117          .dw COLON_SMUDGE+0
000309 707c          .dw XT_STORE
                 PFA_REVEAL1:
00030a 701b          .dw XT_EXIT
                 .include "words/latest.asm"
                 
                 ; System Variable
                 ; system LATEST
                 VE_LATEST:
00030b ff06          .dw $ff06
00030c 616c
00030d 6574
00030e 7473          .db "latest"
00030f 02f6          .dw VE_HEAD
                     .set VE_HEAD = VE_LATEST
                 XT_LATEST:
000310 7043          .dw PFA_DOVARIABLE
                 PFA_LATEST:
000311 011d          .dw ram_LATEST
                 
                 .dseg
00011d           ram_LATEST: .byte 2
                 .cseg
                 .include "words/does.asm"
                 
                 ; Compiler
                 ; organize the XT replacement to call other colon code
                 VE_DOES:
000312 0005          .dw $0005
000313 6f64
000314 7365
000315 003e          .db "does>",0
000316 030b          .dw VE_HEAD
                     .set VE_HEAD = VE_DOES
                 XT_DOES:
000317 7001          .dw DO_COLON
                 PFA_DOES:
000318 01bd          .dw XT_COMPILE
000319 032a          .dw XT_DODOES
00031a 01bd          .dw XT_COMPILE  ; create a code snippet to be used in an embedded XT
00031b 940e          .dw $940e       ; the address of this compiled
00031c 01bd          .dw XT_COMPILE  ; code will replace the XT of the 
00031d 031f          .dw DO_DODOES   ; word that CREATE created
00031e 701b          .dw XT_EXIT     ; 
                 
                 DO_DODOES: ; ( -- PFA )
00031f 939a
000320 938a          savetos
000321 01cb          movw tosl, wl
000322 9601          adiw tosl, 1
                     ; the following takes the address from a real uC-call
                 .if (pclen==3)
                 .endif
000323 917f          pop wh
000324 916f          pop wl
                 
000325 93bf          push XH
000326 93af          push XL
000327 01db          movw XL, wl
000328 940c 7005     jmp_ DO_NEXT
                 
                 ; ( -- )
                 ; System
                 ; replace the XT written by CREATE to call the code that follows does>
                 ;VE_DODOES:
                 ;   .dw $ff07
                 ;   .db "(does>)"
                 ;   .set VE_HEAD = VE_DODOES
                 XT_DODOES:
00032a 7001          .dw DO_COLON
                 PFA_DODOES:
00032b 70f1          .dw XT_R_FROM
00032c 7038          .dw XT_DOLITERAL
00032d 0119          .dw COLON_SMUDGE+2
00032e 7074          .dw XT_FETCH
00032f 734e          .dw XT_FETCHE
000330 0478          .dw XT_NFA2LFA
000331 722a          .dw XT_1PLUS   ; lfa>xt
                 
000332 7362          .dw XT_STOREI
000333 701b          .dw XT_EXIT
                 .include "words/colon.asm"
                 
                 ; Compiler
                 ; create a named entry in the dictionary, XT is DO_COLON
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_COLON:
000334 ff01          .dw $ff01
000335 003a          .db ":",0
000336 0312          .dw VE_HEAD
                     .set VE_HEAD = VE_COLON
                 XT_COLON:
000337 7001          .dw DO_COLON
                 PFA_COLON:
                 .endif
000338 0197          .dw XT_DOCREATE
000339 0342          .dw XT_COLONNONAME
00033a 70d4          .dw XT_DROP
00033b 701b          .dw XT_EXIT
                 .include "words/colon-noname.asm"
                 
                 ; Compiler
                 ; create an unnamed entry in the dictionary, XT is DO_COLON
                 VE_COLONNONAME:
00033c ff07          .dw $ff07
00033d 6e3a
00033e 6e6f
00033f 6d61
000340 0065          .db ":noname",0
000341 0334          .dw VE_HEAD
                     .set VE_HEAD = VE_COLONNONAME
                 XT_COLONNONAME:
000342 7001          .dw DO_COLON
                 PFA_COLONNONAME:
000343 75b4          .dw XT_DP
000344 70ac          .dw XT_DUP
000345 0310          .dw XT_LATEST
000346 707c          .dw XT_STORE
                 
000347 01bd          .dw XT_COMPILE
000348 7001          .dw DO_COLON
                 
000349 0357          .dw XT_RBRACKET
00034a 701b          .dw XT_EXIT
                 .include "words/semicolon.asm"
                 
                 ; Compiler
                 ; finish colon defintion, compiles (exit) and returns to interpret state 
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 
                 VE_SEMICOLON:
00034b 0001          .dw $0001
00034c 003b          .db $3b,0
00034d 033c          .dw VE_HEAD
                     .set VE_HEAD = VE_SEMICOLON
                 XT_SEMICOLON:
00034e 7001          .dw DO_COLON
                 PFA_SEMICOLON:
                 .endif
00034f 01bd          .dw XT_COMPILE
000350 701b          .dw XT_EXIT
000351 0360          .dw XT_LBRACKET
000352 02fb          .dw XT_REVEAL
000353 701b          .dw XT_EXIT
                 .include "words/right-bracket.asm"
                 
                 ; Compiler
                 ; enter compiler mode
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_RBRACKET:
000354 ff01          .dw $ff01
000355 005d          .db "]",0
000356 034b          .dw VE_HEAD
                     .set VE_HEAD = VE_RBRACKET
                 XT_RBRACKET:
000357 7001          .dw DO_COLON
                 PFA_RBRACKET:
                 .endif
000358 7038          .dw XT_DOLITERAL
000359 0001          .dw 1
00035a 754b          .dw XT_STATE
00035b 707c          .dw XT_STORE
00035c 701b          .dw XT_EXIT
                 .include "words/left-bracket.asm"
                 
                 ; Compiler
                 ; enter interpreter mode
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_LBRACKET:
00035d 0001          .dw $0001
00035e 005b          .db "[",0
00035f 0354          .dw VE_HEAD
                     .set VE_HEAD = VE_LBRACKET
                 XT_LBRACKET:
000360 7001          .dw DO_COLON
                 PFA_LBRACKET:
                 .endif
000361 714f          .dw XT_ZERO
000362 754b          .dw XT_STATE
000363 707c          .dw XT_STORE
000364 701b          .dw XT_EXIT
                 .include "words/variable.asm"
                 
                 ; Compiler
                 ; create a dictionary entry for a variable and allocate 1 cell RAM
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 VE_VARIABLE:
000365 ff08          .dw $ff08
000366 6176
000367 6972
000368 6261
000369 656c          .db "variable"
00036a 035d          .dw VE_HEAD
                     .set VE_HEAD = VE_VARIABLE
                 XT_VARIABLE:
00036b 7001          .dw DO_COLON
                 PFA_VARIABLE:
                 .endif
00036c 75c5          .dw XT_HERE
00036d 0378          .dw XT_CONSTANT
00036e 7038          .dw XT_DOLITERAL
00036f 0002          .dw 2
000370 75ce          .dw XT_ALLOT
000371 701b          .dw XT_EXIT
                 .include "words/constant.asm"
                 
                 ; Compiler
                 ; create a constant in the dictionary
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 VE_CONSTANT:
000372 ff08          .dw $ff08
000373 6f63
000374 736e
000375 6174
000376 746e          .db "constant"
000377 0365          .dw VE_HEAD
                     .set VE_HEAD = VE_CONSTANT
                 XT_CONSTANT:
000378 7001          .dw DO_COLON
                 PFA_CONSTANT:
                 .endif
000379 0197          .dw XT_DOCREATE
00037a 02fb          .dw XT_REVEAL
00037b 01bd          .dw XT_COMPILE
00037c 7043          .dw PFA_DOVARIABLE
00037d 01c8          .dw XT_COMMA
00037e 701b          .dw XT_EXIT
                 .include "words/user.asm"
                 
                 ; Compiler
                 ; create a dictionary entry for a user variable at offset n
                 VE_USER:
00037f ff04          .dw $ff04
000380 7375
000381 7265          .db "user"
000382 0372          .dw VE_HEAD
                     .set VE_HEAD = VE_USER
                 XT_USER:
000383 7001          .dw DO_COLON
                 PFA_USER:
000384 0197          .dw XT_DOCREATE
000385 02fb          .dw XT_REVEAL
                 
000386 01bd          .dw XT_COMPILE
000387 7053          .dw PFA_DOUSER
000388 01c8          .dw XT_COMMA
000389 701b          .dw XT_EXIT
                 
                 .include "words/recurse.asm"
                 
                 ; Compiler
                 ; compile the XT of the word currently being defined into the dictionary
                 VE_RECURSE:
00038a 0007          .dw $0007
00038b 6572
00038c 7563
00038d 7372
00038e 0065          .db "recurse",0
00038f 037f          .dw VE_HEAD
                     .set VE_HEAD = VE_RECURSE
                 XT_RECURSE:
000390 7001          .dw DO_COLON
                 PFA_RECURSE:
000391 0310          .dw XT_LATEST
000392 7074          .dw XT_FETCH
000393 01c8          .dw XT_COMMA
000394 701b          .dw XT_EXIT
                 .include "words/immediate.asm"
                 
                 ; Compiler
                 ; set immediate flag for the most recent word definition
                 VE_IMMEDIATE:
000395 ff09          .dw $ff09
000396 6d69
000397 656d
000398 6964
000399 7461
00039a 0065          .db "immediate",0
00039b 038a          .dw VE_HEAD
                     .set VE_HEAD = VE_IMMEDIATE
                 XT_IMMEDIATE:
00039c 7001          .dw DO_COLON
                 PFA_IMMEDIATE:
00039d 0439          .dw XT_GET_CURRENT
00039e 734e          .dw XT_FETCHE
00039f 70ac          .dw XT_DUP
0003a0 73bb          .dw XT_FETCHI
0003a1 7038          .dw XT_DOLITERAL
0003a2 7fff          .dw $7fff
0003a3 720e          .dw XT_AND
0003a4 70bf          .dw XT_SWAP
0003a5 7362          .dw XT_STOREI
0003a6 701b          .dw XT_EXIT
                 
                 .include "words/bracketchar.asm"
                 
                 ; Tools
                 ; skip leading space delimites, place the first character of the word on the stack
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_BRACKETCHAR:
0003a7 0006          .dw $0006
0003a8 635b
0003a9 6168
0003aa 5d72          .db "[char]"
0003ab 0395          .dw VE_HEAD
                     .set VE_HEAD = VE_BRACKETCHAR
                 XT_BRACKETCHAR:
0003ac 7001          .dw DO_COLON
                 PFA_BRACKETCHAR:
                 .endif
0003ad 01bd          .dw XT_COMPILE
0003ae 7038          .dw XT_DOLITERAL
0003af 78e6          .dw XT_CHAR
0003b0 01c8          .dw XT_COMMA
0003b1 701b          .dw XT_EXIT
                 .include "words/abort-string.asm"
                 
                 ;C         i*x x1 --       R: j*x --      x1<>0
                 ;   POSTPONE IS" POSTPONE ?ABORT ; IMMEDIATE
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_ABORTQUOTE:
0003b2 0006          .dw $0006
0003b3 6261
0003b4 726f
0003b5 2274          .db "abort",'"'
0003b6 03a7          .dw VE_HEAD
                     .set VE_HEAD = VE_ABORTQUOTE
                 XT_ABORTQUOTE:
0003b7 7001          .dw DO_COLON
                 PFA_ABORTQUOTE:
                 .endif
0003b8 74c1          .dw XT_SQUOTE
0003b9 01bd          .dw XT_COMPILE
0003ba 03ca          .dw XT_QABORT
0003bb 701b          .DW XT_EXIT
                 .include "words/abort.asm"
                 
                 ; Exceptions
                 ; send an exception -1
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_ABORT:
0003bc ff05          .dw $ff05
0003bd 6261
0003be 726f
0003bf 0074          .db "abort",0
0003c0 03b2          .dw VE_HEAD
                     .set VE_HEAD = VE_ABORT
                 XT_ABORT:
0003c1 7001          .dw DO_COLON
                 PFA_ABORT:
                 .endif
0003c2 7038          .dw XT_DOLITERAL
0003c3 ffff          .dw -1
0003c4 7843          .dw XT_THROW
                 .include "words/q-abort.asm"
                 
                 ;   ROT IF ITYPE ABORT THEN 2DROP ;
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_QABORT:
0003c5 ff06          .dw $ff06
0003c6 613f
0003c7 6f62
0003c8 7472          .db "?abort"
0003c9 03bc          .dw VE_HEAD
                     .set VE_HEAD = VE_QABORT
                 XT_QABORT:
0003ca 7001          .dw DO_COLON
                 PFA_QABORT:
                 
                 .endif
0003cb 70dc
0003cc 7031              .DW XT_ROT,XT_DOCONDBRANCH
0003cd 03d0              DEST(QABO1)
0003ce 77aa
0003cf 03c1              .DW XT_ITYPE,XT_ABORT
0003d0 756e
0003d1 701b      QABO1:  .DW XT_2DROP,XT_EXIT
                 
                 .include "words/get-stack.asm"
                 
                 ; Tools
                 ; Get a stack from EEPROM
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_GET_STACK:
0003d2 ff09          .dw $ff09
0003d3 6567
0003d4 2d74
0003d5 7473
0003d6 6361
0003d7 006b          .db "get-stack",0
0003d8 03c5          .dw VE_HEAD
                     .set VE_HEAD = VE_GET_STACK
                 XT_GET_STACK:
0003d9 7001          .dw DO_COLON
                 PFA_N_FETCH_E:
                 .endif
0003da 70ac          .dw XT_DUP
0003db 755e          .dw XT_CELLPLUS
0003dc 70bf          .dw XT_SWAP
0003dd 734e          .dw XT_FETCHE
0003de 70ac          .dw XT_DUP
0003df 70fa          .dw XT_TO_R
0003e0 714f          .dw XT_ZERO
0003e1 70bf          .dw XT_SWAP    ; go from bigger to smaller addresses
0003e2 0287          .dw XT_QDOCHECK
0003e3 7031          .dw XT_DOCONDBRANCH
0003e4 03f0          DEST(PFA_N_FETCH_E2)
0003e5 728a          .dw XT_DODO
                 PFA_N_FETCH_E1:
                     ; ( ee-addr )
0003e6 729b          .dw XT_I
0003e7 7230          .dw XT_1MINUS
0003e8 7558          .dw XT_CELLS ; ( -- ee-addr i*2 )
0003e9 70ca          .dw XT_OVER  ; ( -- ee-addr i*2 ee-addr )
0003ea 7198          .dw XT_PLUS  ; ( -- ee-addr ee-addr+i
0003eb 734e          .dw XT_FETCHE ;( -- ee-addr item_i )
0003ec 70bf          .dw XT_SWAP   ;( -- item_i ee-addr )
0003ed 7146          .dw XT_TRUE  ; shortcut for -1
0003ee 72a9          .dw XT_DOPLUSLOOP
0003ef 03e6          DEST(PFA_N_FETCH_E1)
                 PFA_N_FETCH_E2:
0003f0 756e          .dw XT_2DROP
0003f1 70f1          .dw XT_R_FROM
0003f2 701b          .dw XT_EXIT
                 
                 .include "words/set-stack.asm"
                 
                 ; Tools
                 ; Write a stack to EEPROM
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SET_STACK:
0003f3 ff09          .dw $ff09
0003f4 6573
0003f5 2d74
0003f6 7473
0003f7 6361
0003f8 006b          .db "set-stack",0
0003f9 03d2          .dw VE_HEAD
                     .set VE_HEAD = VE_SET_STACK
                 XT_SET_STACK:
0003fa 7001          .dw DO_COLON
                 PFA_SET_STACK:
                 .endif
0003fb 7565          .dw XT_2DUP
0003fc 732a          .dw XT_STOREE ; ( -- i_n .. i_0 n e-addr )
0003fd 70bf          .dw XT_SWAP    
0003fe 714f          .dw XT_ZERO
0003ff 0287          .dw XT_QDOCHECK
000400 7031          .dw XT_DOCONDBRANCH
000401 0408          DEST(PFA_SET_STACK2)
000402 728a          .dw XT_DODO
                 PFA_SET_STACK1:
000403 755e          .dw XT_CELLPLUS ; ( -- i_x e-addr )
000404 7576          .dw XT_TUCK      ; ( -- e-addr i_x e-addr
000405 732a          .dw XT_STOREE
000406 72b8          .dw XT_DOLOOP
000407 0403          DEST(PFA_SET_STACK1)
                 PFA_SET_STACK2:
000408 70d4          .dw XT_DROP
000409 701b          .dw XT_EXIT
                 
                 .include "words/map-stack.asm"
                 
                 ; Tools
                 ; Iterate over a stack
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_MAPSTACK:
00040a ff09          .dw $ff09
00040b 616d
00040c 2d70
00040d 7473
00040e 6361
00040f 006b          .db "map-stack",0
000410 03f3          .dw VE_HEAD
                     .set VE_HEAD = VE_MAPSTACK
                 XT_MAPSTACK:
000411 7001          .dw DO_COLON
                 PFA_MAPSTACK:
                 .endif
000412 70ac          .dw XT_DUP
000413 755e          .dw XT_CELLPLUS
000414 70bf          .dw XT_SWAP
000415 734e          .dw XT_FETCHE
000416 7558          .dw XT_CELLS
000417 7d4d          .dw XT_BOUNDS
000418 0287          .dw XT_QDOCHECK
000419 7031          .dw XT_DOCONDBRANCH
00041a 042e          DEST(PFA_MAPSTACK3)
00041b 728a          .dw XT_DODO
                 PFA_MAPSTACK1:
00041c 729b            .dw XT_I
00041d 734e            .dw XT_FETCHE   ; -- i*x XT id
00041e 70bf            .dw XT_SWAP
00041f 70fa            .dw XT_TO_R
000420 7103            .dw XT_R_FETCH
000421 7025            .dw XT_EXECUTE  ; i*x id -- j*y true | i*x false
000422 70b4            .dw XT_QDUP
000423 7031            .dw XT_DOCONDBRANCH
000424 0429            DEST(PFA_MAPSTACK2)
000425 70f1               .dw XT_R_FROM
000426 70d4               .dw XT_DROP
000427 72c3               .dw XT_UNLOOP
000428 701b               .dw XT_EXIT
                 PFA_MAPSTACK2:
000429 70f1            .dw XT_R_FROM
00042a 7038            .dw XT_DOLITERAL
00042b 0002            .dw 2
00042c 72a9            .dw XT_DOPLUSLOOP
00042d 041c            DEST(PFA_MAPSTACK1)
                 PFA_MAPSTACK3:
00042e 70d4          .dw XT_DROP
00042f 714f          .dw XT_ZERO
000430 701b          .dw XT_EXIT
                 
                 ;
                 ; : map-stack ( i*x XT e-addr -- j*y )
                 ;     dup cell+ swap @e cells bounds ?do 
                 ;       ( -- i*x XT )
                 ;       i @e swap >r r@ execute
                 ;       ?dup if r> drop unloop exit then
                 ;       r>
                 ;     2 +loop drop 0
                 ;
                 .include "words/get-current.asm"
                 
                 ; Search Order
                 ; get the wid of the current compilation word list
                 VE_GET_CURRENT:
000431 ff0b          .dw $ff0b
000432 6567
000433 2d74
000434 7563
000435 7272
000436 6e65
000437 0074          .db "get-current",0
000438 040a          .dw VE_HEAD
                     .set VE_HEAD = VE_GET_CURRENT
                 XT_GET_CURRENT:
000439 7001          .dw DO_COLON
                 PFA_GET_CURRENT:
00043a 7038          .dw XT_DOLITERAL
00043b 0048          .dw EE_CURRENT
00043c 734e          .dw XT_FETCHE
00043d 701b          .dw XT_EXIT
                 .include "words/get-order.asm"
                 
                 ; Search Order
                 ; Get the current search order word list
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_GET_ORDER:
00043e ff09          .dw $ff09
00043f 6567
000440 2d74
000441 726f
000442 6564
000443 0072          .db "get-order",0
000444 0431          .dw VE_HEAD
                     .set VE_HEAD = VE_GET_ORDER
                 XT_GET_ORDER:
000445 7001          .dw DO_COLON
                 PFA_GET_ORDER:
                 .endif
000446 7038          .dw XT_DOLITERAL
000447 004c          .dw CFG_ORDERLISTLEN
000448 03d9          .dw XT_GET_STACK
000449 701b          .dw XT_EXIT
                 
                 .include "words/compare.asm"
                 
                 ; String
                 ; compares two strings in RAM
                 VE_COMPARE:
00044a ff07          .dw $ff07
00044b 6f63
00044c 706d
00044d 7261
00044e 0065          .db "compare",0
00044f 043e          .dw VE_HEAD
                     .set VE_HEAD = VE_COMPARE
                 XT_COMPARE:
000450 0451          .dw PFA_COMPARE
                 PFA_COMPARE:
000451 93bf          push xh
000452 93af          push xl
000453 018c          movw temp0, tosl
000454 9189
000455 9199          loadtos
000456 01dc          movw xl, tosl
000457 9189
000458 9199          loadtos
000459 019c          movw temp2, tosl
00045a 9189
00045b 9199          loadtos
00045c 01fc          movw zl, tosl
                 PFA_COMPARE_LOOP:
00045d 90ed          ld temp4, X+
00045e 90f1          ld temp5, Z+
00045f 14ef          cp temp4, temp5
000460 f451          brne PFA_COMPARE_NOTEQUAL
000461 950a          dec temp0
000462 f019          breq PFA_COMPARE_ENDREACHED2
000463 952a          dec temp2
000464 f7c1          brne PFA_COMPARE_LOOP
000465 c001          rjmp PFA_COMPARE_ENDREACHED
                 PFA_COMPARE_ENDREACHED2:
000466 952a          dec temp2
                 PFA_COMPARE_ENDREACHED:
000467 2b02          or temp0, temp2
000468 f411          brne PFA_COMPARE_CHECKLASTCHAR
000469 2788          clr tosl
00046a c002          rjmp PFA_COMPARE_DONE
                 PFA_COMPARE_CHECKLASTCHAR:
                 PFA_COMPARE_NOTEQUAL:
00046b ef8f          ser tosl
00046c c000          rjmp PFA_COMPARE_DONE
                 
                 PFA_COMPARE_DONE:
00046d 2f98          mov tosh, tosl
00046e 91af          pop xl
00046f 91bf          pop xh
000470 940c 7005     jmp_ DO_NEXT
                 .include "words/nfa2lfa.asm"
                 
                 ; System
                 ; get the link field address from the name field address
                 VE_NFA2LFA:
000472 ff07         .dw $ff07
000473 666e
000474 3e61
000475 666c
000476 0061         .db "nfa>lfa",0
000477 044a         .dw VE_HEAD
                    .set VE_HEAD = VE_NFA2LFA
                 XT_NFA2LFA:
000478 7001          .dw DO_COLON
                 PFA_NFA2LFA:
000479 7c65          .dw XT_NAME2STRING
00047a 722a          .dw XT_1PLUS
00047b 71ff          .dw XT_2SLASH
00047c 7198          .dw XT_PLUS
00047d 701b          .dw XT_EXIT
                 .elif AMFORTH_NRWW_SIZE > 4000
                 .elif AMFORTH_NRWW_SIZE > 2000
                 .else
                 .endif
                 .include "dict_appl.inc"
                 
                 ; they may be moved to the core dictionary if needed
                 .include "words/dot-s.asm"
                 
                 ; Tools
                 ; stack dump
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DOTS:
00047e ff02          .dw $ff02
00047f 732e          .db ".s"
000480 0472          .dw VE_HEAD
                     .set VE_HEAD = VE_DOTS
                 XT_DOTS:
000481 7001          .dw DO_COLON
                 PFA_DOTS:
                 .endif
000482 7a8c          .dw XT_DEPTH
000483 7440          .dw XT_UDOT
000484 77ec          .dw XT_SPACE
000485 7a8c          .dw XT_DEPTH
000486 714f          .dw XT_ZERO
000487 0287          .dw XT_QDOCHECK
000488 7031          .dw XT_DOCONDBRANCH
000489 0490          DEST(PFA_DOTS2)
00048a 728a          .dw XT_DODO
                 PFA_DOTS1:
00048b 729b          .dw XT_I
00048c 74af          .dw XT_PICK
00048d 7440          .dw XT_UDOT
00048e 72b8          .dw XT_DOLOOP
00048f 048b          DEST(PFA_DOTS1)
                 PFA_DOTS2:
000490 701b          .dw XT_EXIT
                 .include "words/spirw.asm"
                 
                 ; MCU
                 ; SPI exchange of 1 byte
                 VE_SPIRW:
000491 ff06          .dw $ff06
000492 2163
000493 7340
000494 6970          .db "c!@spi"
000495 047e          .dw VE_HEAD
                     .set VE_HEAD  = VE_SPIRW
                 XT_SPIRW:
000496 0497          .dw PFA_SPIRW
                 PFA_SPIRW:
000497 d003          rcall do_spirw
000498 2799          clr tosh
000499 940c 7005     jmp_ DO_NEXT
                 
                 do_spirw:
00049b bd8e          out_ SPDR, tosl
                 do_spirw1:
00049c b50d          in_ temp0, SPSR
00049d 7f08          cbr temp0,7
00049e bd0d          out_ SPSR, temp0
00049f b50d          in_ temp0, SPSR
0004a0 ff07          sbrs temp0, 7
0004a1 cffa          rjmp do_spirw1   ; wait until complete
0004a2 b58e          in_ tosl, SPDR
0004a3 9508          ret
                 .include "words/n-spi.asm"
                 
                 ; MCU
                 ; read len bytes from SPI to addr
                 VE_N_SPIR:
0004a4 ff05          .dw $ff05
0004a5 406e
0004a6 7073
0004a7 0069          .db "n@spi",0
0004a8 0491          .dw VE_HEAD
                     .set VE_HEAD  = VE_N_SPIR
                 XT_N_SPIR:
0004a9 04aa          .dw PFA_N_SPIR
                 PFA_N_SPIR:
0004aa 018c          movw temp0, tosl
0004ab 9189
0004ac 9199          loadtos
0004ad 01fc          movw zl, tosl
0004ae 01c8          movw tosl, temp0
                 PFA_N_SPIR_LOOP:
0004af bc2e          out_ SPDR, zerol
                 PFA_N_SPIR_LOOP1:
0004b0 b52d          in_ temp2, SPSR
0004b1 ff27          sbrs temp2, SPIF
0004b2 cffd          rjmp PFA_N_SPIR_LOOP1
0004b3 b52e          in_ temp2, SPDR
0004b4 9321          st Z+, temp2
0004b5 9701          sbiw tosl, 1
0004b6 f7c1          brne PFA_N_SPIR_LOOP
0004b7 9189
0004b8 9199          loadtos
0004b9 940c 7005     jmp_ DO_NEXT
                 
                 ; ( addr len -- ) 
                 ; MCU
                 ; write len bytes to SPI from addr
                 VE_N_SPIW:
0004bb ff05          .dw $ff05
0004bc 216e
0004bd 7073
0004be 0069          .db "n!spi",0
0004bf 04a4          .dw VE_HEAD
                     .set VE_HEAD  = VE_N_SPIW
                 XT_N_SPIW:
0004c0 04c1          .dw PFA_N_SPIW
                 PFA_N_SPIW:
0004c1 018c          movw temp0, tosl
0004c2 9189
0004c3 9199          loadtos
0004c4 01fc          movw zl, tosl
0004c5 01c8          movw tosl, temp0
                 PFA_N_SPIW_LOOP:
0004c6 9121          ld temp2, Z+
0004c7 bd2e          out_ SPDR, temp2
                 PFA_N_SPIW_LOOP1:
0004c8 b52d          in_ temp2, SPSR
0004c9 ff27          sbrs temp2, SPIF
0004ca cffd          rjmp PFA_N_SPIW_LOOP1
0004cb b52e          in_ temp2, SPDR ; ignore the data
0004cc 9701          sbiw tosl, 1
0004cd f7c1          brne PFA_N_SPIW_LOOP
0004ce 9189
0004cf 9199          loadtos
0004d0 940c 7005     jmp_ DO_NEXT
                 .include "words/applturnkey.asm"
                 
                 ; R( -- )
                 ; application specific turnkey action
                 VE_APPLTURNKEY:
0004d2 ff0b          .dw $ff0b
0004d3 7061
0004d4 6c70
0004d5 7574
0004d6 6e72
0004d7 656b
0004d8 0079          .db "applturnkey",0
0004d9 04bb          .dw VE_HEAD
                     .set VE_HEAD = VE_APPLTURNKEY
                 XT_APPLTURNKEY:
0004da 7001          .dw DO_COLON
                 PFA_APPLTURNKEY:
0004db 00b8          .dw XT_USART
0004dc 7471          .dw XT_INTON
0004dd 7b56          .dw XT_DOT_VER
0004de 77ec          .dw XT_SPACE
0004df 7540          .dw XT_F_CPU
0004e0 7038          .dw XT_DOLITERAL
0004e1 03e8          .dw 1000
0004e2 71bd          .dw XT_UMSLASHMOD
0004e3 70bf          .dw XT_SWAP
0004e4 70d4          .dw XT_DROP
0004e5 75e4          .dw XT_DECIMAL
0004e6 772c          .dw XT_DOT
0004e7 7777          .dw XT_DOSLITERAL
0004e8 0004          .dw 4
0004e9 486b
0004ea 207a          .db "kHz "
0004eb 77aa          .dw XT_ITYPE
0004ec 701b          .dw XT_EXIT
                 .include "dict/compiler2.inc"
                 
                 ; included almost independently from each other
                 ; on a include-per-use basis
                 ;
                 .if DICT_COMPILER2 == 0
                 .set DICT_COMPILER2 = 1
                 
                 .include "words/set-current.asm"
                 
                 ; Search Order
                 ; set current word list to the given word list wid
                 VE_SET_CURRENT:
0004ed ff0b          .dw $ff0b
0004ee 6573
0004ef 2d74
0004f0 7563
0004f1 7272
0004f2 6e65
0004f3 0074          .db "set-current",0
0004f4 04d2          .dw VE_HEAD
                     .set VE_HEAD = VE_SET_CURRENT
                 XT_SET_CURRENT:
0004f5 7001          .dw DO_COLON
                 PFA_SET_CURRENT:
0004f6 7038          .dw XT_DOLITERAL
0004f7 0048          .dw EE_CURRENT
0004f8 732a          .dw XT_STOREE
0004f9 701b          .dw XT_EXIT
                 .include "words/wordlist.asm"
                 
                 ; Search Order
                 ; create a new, empty wordlist
                 VE_WORDLIST:
0004fa ff08          .dw $ff08
0004fb 6f77
0004fc 6472
0004fd 696c
0004fe 7473          .db "wordlist"
0004ff 04ed          .dw VE_HEAD
                     .set VE_HEAD = VE_WORDLIST
                 XT_WORDLIST:
000500 7001          .dw DO_COLON
                 PFA_WORDLIST:
000501 75bd          .dw XT_EHERE
000502 714f          .dw XT_ZERO
000503 70ca          .dw XT_OVER
000504 732a          .dw XT_STOREE
000505 70ac          .dw XT_DUP
000506 755e          .dw XT_CELLPLUS
000507 7b8c          .dw XT_DOTO
000508 75be          .dw PFA_EHERE
000509 701b          .dw XT_EXIT
                 
                 .include "words/only.asm"
                 
                 ; Search Order
                 ; replace the order list with the system default list
                 VE_ONLY:
00050a ff04          .dw $ff04
00050b 6e6f
00050c 796c          .db "only"
00050d 04fa          .dw VE_HEAD
                     .set VE_HEAD = VE_ONLY
                 XT_ONLY:
00050e 7001          .dw DO_COLON
                 PFA_ONLY:
00050f 7038          .dw XT_DOLITERAL
000510 004a          .dw EE_FORTHWORDLIST
000511 7038          .dw XT_DOLITERAL
000512 0001          .dw 1
000513 0529          .dw XT_SET_ORDER
000514 701b          .dw XT_EXIT
                 .include "words/forth-wordlist.asm"
                 
                 ; Search Order
                 ; get the system default word list
                 VE_FORTH_WORDLIST:
000515 ff0e          .dw $ff0e
000516 6f66
000517 7472
000518 2d68
000519 6f77
00051a 6472
00051b 696c
00051c 7473          .db "forth-wordlist"
00051d 050a          .dw VE_HEAD
                     .set VE_HEAD = VE_FORTH_WORDLIST
                 XT_FORTH_WORDLIST:
00051e 706a          .dw PFA_DOVALUE1
                 PFA_FORTH_WORDLIST:
00051f 0046          .dw EE_WL_FORTH
000520 7ba7          .dw XT_EDEFERFETCH
000521 7bb1          .dw XT_EDEFERSTORE
                 .include "words/set-order.asm"
                 
                 ; Search Order
                 ; replace the search order list
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SET_ORDER:
000522 ff09          .dw $ff09
000523 6573
000524 2d74
000525 726f
000526 6564
000527 0072          .db "set-order",0
000528 0515          .dw VE_HEAD
                     .set VE_HEAD = VE_SET_ORDER
                 XT_SET_ORDER:
000529 7001          .dw DO_COLON
                 PFA_SET_ORDER:
                 .endif
00052a 7038          .dw XT_DOLITERAL
00052b 004c          .dw CFG_ORDERLISTLEN
00052c 03fa          .dw XT_SET_STACK
00052d 701b          .dw XT_EXIT
                 
                 .include "words/set-recognizer.asm"
                 
                 ; Interpreter
                 ; replace the recognizer list
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SET_RECOGNIZERS:
00052e ff0f          .dw $ff0f
00052f 6573
000530 2d74
000531 6572
000532 6f63
000533 6e67
000534 7a69
000535 7265
000536 0073          .db "set-recognizers",0
000537 0522          .dw VE_HEAD
                     .set VE_HEAD = VE_SET_RECOGNIZERS
                 XT_SET_RECOGNIZERS:
000538 7001          .dw DO_COLON
                 PFA_SET_RECOGNIZERS:
                 .endif
000539 7038          .dw XT_DOLITERAL
00053a 005e          .dw CFG_RECOGNIZERLISTLEN
00053b 03fa          .dw XT_SET_STACK
00053c 701b          .dw XT_EXIT
                 
                 .include "words/get-recognizer.asm"
                 
                 ; Interpreter
                 ; Get the current recognizer list
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_GET_RECOGNIZERS:
00053d ff0f          .dw $ff0f
00053e 6567
00053f 2d74
000540 6572
000541 6f63
000542 6e67
000543 7a69
000544 7265
000545 0073          .db "get-recognizers",0
000546 052e          .dw VE_HEAD
                     .set VE_HEAD = VE_GET_RECOGNIZERS
                 XT_GET_RECOGNIZERS:
000547 7001          .dw DO_COLON
                 PFA_GET_RECOGNIZERS:
                 .endif
000548 7038          .dw XT_DOLITERAL
000549 005e          .dw CFG_RECOGNIZERLISTLEN
00054a 03d9          .dw XT_GET_STACK
00054b 701b          .dw XT_EXIT
                 .include "words/code.asm"
                 
                 ; Compiler
                 ; create named entry in the dictionary, XT is the data field
                 VE_CODE:
00054c ff04          .dw $ff04
00054d 6f63
00054e 6564          .db "code"
00054f 053d          .dw VE_HEAD
                     .set VE_HEAD = VE_CODE
                 XT_CODE:
000550 7001          .dw DO_COLON
                 PFA_CODE:
000551 0197          .dw XT_DOCREATE
000552 02fb          .dw XT_REVEAL
000553 75b4          .dw XT_DP
000554 7b9e          .dw XT_ICELLPLUS
000555 01c8          .dw XT_COMMA
000556 701b          .dw XT_EXIT
                 .include "words/end-code.asm"
                 
                 ; Compiler
                 ; finish a code definition
                 VE_ENDCODE:
000557 ff08          .dw $ff08
000558 6e65
000559 2d64
00055a 6f63
00055b 6564          .db "end-code"
00055c 054c          .dw VE_HEAD
                     .set VE_HEAD = VE_ENDCODE
                 XT_ENDCODE:
00055d 7001          .dw DO_COLON
                 PFA_ENDCODE:
00055e 01bd          .dw XT_COMPILE
00055f 940c          .dw $940c
000560 01bd          .dw XT_COMPILE
000561 7005          .dw DO_NEXT
000562 701b          .dw XT_EXIT
                 .include "words/marker.asm"
                 
                 ; System Value
                 ; The eeprom address until which MARKER saves and restores the eeprom data.
                 VE_MARKER:
000563 ff08          .dw $ff08
000564 6d28
000565 7261
000566 656b
000567 2972          .db "(marker)"
000568 0557          .dw VE_HEAD
                     .set VE_HEAD = VE_MARKER
                 XT_MARKER:
000569 706a          .dw PFA_DOVALUE1
                 PFA_MARKER:
00056a 006c          .dw EE_MARKER
00056b 7ba7          .dw XT_EDEFERFETCH
00056c 7bb1          .dw XT_EDEFERSTORE
                 .include "words/postpone.asm"
                 
                 ; Compiler
                 ; Append the compilation semantics of "name" to the dictionary
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_POSTPONE:
00056d 0008          .dw $0008
00056e 6f70
00056f 7473
000570 6f70
000571 656e          .db "postpone"
000572 0563          .dw VE_HEAD
                     .set VE_HEAD = VE_POSTPONE
                 XT_POSTPONE:
000573 7001          .dw DO_COLON
                 PFA_POSTPONE:
                 .endif
000574 79b7          .dw XT_PARSENAME
000575 7ab5          .dw XT_DORECOGNIZER
000576 7b9e          .dw XT_ICELLPLUS 
000577 7b9e          .dw XT_ICELLPLUS
000578 73bb          .dw XT_FETCHI
000579 7025          .dw XT_EXECUTE
00057a 701b          .dw XT_EXIT
                 .endif
                 .include "words/2r_fetch.asm"
                 
                 ; Stack
                 ; fetch content of TOR
                 VE_2R_FETCH:
00057b ff03          .dw $ff03
00057c 7232
00057d 0040          .db "2r@",0
00057e 056d          .dw VE_HEAD
                     .set VE_HEAD = VE_2R_FETCH
                 XT_2R_FETCH:
00057f 0580          .dw PFA_2R_FETCH
                 PFA_2R_FETCH:
000580 939a
000581 938a          savetos
000582 91ef          pop zl
000583 91ff          pop zh
000584 918f          pop tosl
000585 919f          pop tosh
000586 939f          push tosh
000587 938f          push tosl
000588 93ff          push zh
000589 93ef          push zl
00058a 939a
00058b 938a          savetos
00058c 01cf          movw tosl, zl
00058d 940c 7005     jmp_ DO_NEXT
                 
                 .set DPSTART = pc
                 .if(pc>AMFORTH_RO_SEG)
                 .endif
                 
                 .org AMFORTH_RO_SEG
                 .include "amforth-interpreter.asm"
                 
                 
                 DO_COLON:
007001 93bf          push XH
007002 93af          push XL          ; PUSH IP
007003 01db          movw XL, wl
007004 9611          adiw xl, 1
                 DO_NEXT:
007005 f06e          brts DO_INTERRUPT
007006 01fd          movw zl, XL        ; READ IP
007007 0fee
007008 1fff
007009 9165
00700a 9175          readflashcell wl, wh
00700b 9611          adiw XL, 1        ; INC IP
                 
                 DO_EXECUTE:
00700c 01fb          movw zl, wl
00700d 0fee
00700e 1fff
00700f 9105
007010 9115          readflashcell temp0,temp1
007011 01f8          movw zl, temp0
007012 9409          ijmp
                 
                 DO_INTERRUPT:
                     ; here we deal with interrupts the forth way
007013 94e8          clt
007014 e96c          ldi wl, LOW(XT_ISREXEC)
007015 e774          ldi wh, HIGH(XT_ISREXEC)
007016 cff5          rjmp DO_EXECUTE
                 .include "dict/nrww.inc"
                 
                 ; section together with the forth inner interpreter
                 
                 .include "words/exit.asm"
                 
                 ; Compiler
                 ; end of current colon word
                 VE_EXIT:
007017 ff04          .dw $ff04
007018 7865
007019 7469          .db "exit"
00701a 057b          .dw VE_HEAD
                     .set VE_HEAD = VE_EXIT
                 XT_EXIT:
00701b 701c          .dw PFA_EXIT
                 PFA_EXIT:
00701c 91af          pop XL
00701d 91bf          pop XH
00701e cfe6          jmp_ DO_NEXT
                 .include "words/execute.asm"
                 
                 ; System
                 ; execute XT
                 VE_EXECUTE:
00701f ff07          .dw $ff07
007020 7865
007021 6365
007022 7475
007023 0065          .db "execute",0
007024 7017          .dw VE_HEAD
                     .set VE_HEAD = VE_EXECUTE
                 XT_EXECUTE:
007025 7026          .dw PFA_EXECUTE
                 PFA_EXECUTE:
007026 01bc          movw wl, tosl
007027 9189
007028 9199          loadtos
007029 cfe2          jmp_ DO_EXECUTE
                 .include "words/dobranch.asm"
                 
                 ; System
                 ; runtime of branch
                 ;VE_DOBRANCH:
                 ;    .dw $ff08
                 ;    .db "(branch)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOBRANCH
                 XT_DOBRANCH:
00702a 702b          .dw PFA_DOBRANCH
                 PFA_DOBRANCH:
00702b 01fd          movw zl, XL
00702c 0fee
00702d 1fff
00702e 91a5
00702f 91b5          readflashcell XL,XH
007030 cfd4          jmp_ DO_NEXT
                 .include "words/docondbranch.asm"
                 
                 ; System
                 ; runtime of ?branch
                 ;VE_DOCONDBRANCH:
                 ;    .dw $ff09
                 ;    .db "(?branch)"
                 ;    .dw  VE_HEAD
                 ;    .set VE_HEAD = VE_DOCONDBRANCH
                 XT_DOCONDBRANCH:
007031 7032          .dw PFA_DOCONDBRANCH
                 PFA_DOCONDBRANCH:
007032 2b98          or tosh, tosl
007033 9189
007034 9199          loadtos
007035 f3a9          brbs 1, PFA_DOBRANCH ; 1 is z flag; if tos is zero (false), do the branch
007036 9611          adiw XL, 1
007037 cfcd          jmp_ DO_NEXT
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/doliteral.asm"
                 
                 ; System
                 ; runtime of literal
                 ;VE_DOLITERAL:
                 ;    .dw $ff09
                 ;    .db "(literal)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOLITERAL
                 XT_DOLITERAL:
007038 7039          .dw PFA_DOLITERAL
                 PFA_DOLITERAL:
007039 939a
00703a 938a          savetos
00703b 01fd          movw zl, xl
00703c 0fee
00703d 1fff
00703e 9185
00703f 9195          readflashcell tosl,tosh
007040 9611          adiw xl, 1
007041 cfc3          jmp_ DO_NEXT
                 
                 .include "words/dovariable.asm"
                 
                 ; System
                 ; puts content of parameter field (1 cell) to TOS
                 ;VE_DOVARIABLE:
                 ;    .dw $ff0a
                 ;    .db "(variable)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOVARIABLE
                 XT_DOVARIABLE:
007042 7043          .dw PFA_DOVARIABLE
                 PFA_DOVARIABLE:
007043 939a
007044 938a          savetos
007045 01fb          movw zl, wl
007046 9631          adiw zl,1
007047 0fee
007048 1fff
007049 9185
00704a 9195          readflashcell tosl,tosh
00704b cfb9          jmp_ DO_NEXT
                 .include "words/doconstant.asm"
                 
                 ; System
                 ; place data field address on TOS
                 ;VE_DOCONSTANT:
                 ;    .dw $ff0a
                 ;    .db "(constant)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOCONSTANT
                 XT_DOCONSTANT:
00704c 704d          .dw PFA_DOCONSTANT
                 PFA_DOCONSTANT:
00704d 939a
00704e 938a          savetos
00704f 01cb          movw tosl, wl
007050 9601          adiw tosl, 1
007051 cfb3          jmp_ DO_NEXT
                 .include "words/douser.asm"
                 
                 ; System
                 ; runtime part of user
                 ;VE_DOUSER:
                 ;    .dw $ff06
                 ;    .db "(user)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOUSER
                 XT_DOUSER:
007052 7053          .dw PFA_DOUSER
                 PFA_DOUSER:
007053 939a
007054 938a          savetos
007055 01fb          movw zl, wl
007056 9631          adiw zl, 1
007057 0fee
007058 1fff
007059 9185
00705a 9195          readflashcell tosl,tosh
00705b 0d84          add tosl, upl
00705c 1d95          adc tosh, uph
00705d cfa7          jmp_ DO_NEXT
                 .include "words/do-value.asm"
                 
                 ; System
                 ; runtime of value
                 VE_DOVALUE:
00705e ff07          .dw $ff07
00705f 7628
007060 6c61
007061 6575
007062 0029          .db "(value)", 0
007063 701f          .dw VE_HEAD
                     .set VE_HEAD = VE_DOVALUE
                 XT_DOVALUE:
007064 7001          .dw DO_COLON
                 PFA_DOVALUE:
007065 0197          .dw XT_DOCREATE
007066 02fb          .dw XT_REVEAL
007067 01bd          .dw XT_COMPILE
007068 706a          .dw PFA_DOVALUE1
007069 701b          .dw XT_EXIT
                 PFA_DOVALUE1:
00706a 940e 031f     call_ DO_DODOES
00706c 70ac          .dw XT_DUP
00706d 7b9e          .dw XT_ICELLPLUS
00706e 73bb          .dw XT_FETCHI
00706f 7025          .dw XT_EXECUTE
007070 701b          .dw XT_EXIT
                 
                 ; : (value) <builds does> dup icell+ @i execute ;
                 .include "words/fetch.asm"
                 
                 ; Memory
                 ; read 1 cell from RAM address
                 VE_FETCH:
007071 ff01          .dw $ff01
007072 0040          .db "@",0
007073 705e          .dw VE_HEAD
                     .set VE_HEAD = VE_FETCH
                 XT_FETCH:
007074 7075          .dw PFA_FETCH
                 PFA_FETCH:
                 .if WANT_UNIFIED == 1
                 .endif
                 PFA_FETCHRAM:
007075 01fc          movw zl, tosl
                     ; low byte is read before the high byte
007076 9181          ld tosl, z+
007077 9191          ld tosh, z+
007078 cf8c          jmp_ DO_NEXT
                 .if WANT_UNIFIED == 1
                 .endif
                 .include "words/store.asm"
                 
                 ; Memory
                 ; write n to RAM memory at addr, low byte first
                 VE_STORE:
007079 ff01          .dw $ff01
00707a 0021          .db "!",0
00707b 7071          .dw VE_HEAD
                     .set VE_HEAD = VE_STORE
                 XT_STORE:
00707c 707d          .dw PFA_STORE
                 PFA_STORE:
                 .if WANT_UNIFIED == 1
                 .endif
                 PFA_STORERAM:
00707d 01fc          movw zl, tosl
00707e 9189
00707f 9199          loadtos
                     ; the high byte is written before the low byte
007080 8391          std Z+1, tosh
007081 8380          std Z+0, tosl
007082 9189
007083 9199          loadtos
007084 cf80          jmp_ DO_NEXT
                 .if WANT_UNIFIED == 1
                 .endif
                 .include "words/cstore.asm"
                 
                 ; Memory
                 ; store a single byte to RAM address
                 VE_CSTORE:
007085 ff02          .dw $ff02
007086 2163          .db "c!"
007087 7079          .dw VE_HEAD
                     .set VE_HEAD = VE_CSTORE
                 XT_CSTORE:
007088 7089          .dw PFA_CSTORE
                 PFA_CSTORE:
007089 01fc          movw zl, tosl
00708a 9189
00708b 9199          loadtos
00708c 8380          st Z, tosl
00708d 9189
00708e 9199          loadtos
00708f cf75          jmp_ DO_NEXT
                 .include "words/cfetch.asm"
                 
                 ; Memory
                 ; fetch a single byte from memory mapped locations
                 VE_CFETCH:
007090 ff02          .dw $ff02
007091 4063          .db "c@"
007092 7085          .dw VE_HEAD
                     .set VE_HEAD  = VE_CFETCH
                 XT_CFETCH:
007093 7094          .dw PFA_CFETCH
                 PFA_CFETCH:
007094 01fc          movw zl, tosl
007095 2799          clr tosh
007096 8180          ld tosl, Z
007097 cf6d          jmp_ DO_NEXT
                 .include "words/fetch-u.asm"
                 
                 ; Memory
                 ; read 1 cell from USER area
                 VE_FETCHU:
007098 ff02          .dw $ff02
007099 7540          .db "@u"
00709a 7090          .dw VE_HEAD
                     .set VE_HEAD = VE_FETCHU
                 XT_FETCHU:
00709b 7001          .dw DO_COLON
                 PFA_FETCHU:
00709c 72f1          .dw XT_UP_FETCH
00709d 7198          .dw XT_PLUS
00709e 7074          .dw XT_FETCH
00709f 701b          .dw XT_EXIT
                 .include "words/store-u.asm"
                 
                 ; Memory
                 ; write n to USER area at offset
                 VE_STOREU:
0070a0 ff02          .dw $ff02
0070a1 7521          .db "!u"
0070a2 7098          .dw VE_HEAD
                     .set VE_HEAD = VE_STOREU
                 XT_STOREU:
0070a3 7001          .dw DO_COLON
                 PFA_STOREU:
0070a4 72f1          .dw XT_UP_FETCH
0070a5 7198          .dw XT_PLUS
0070a6 707c          .dw XT_STORE
0070a7 701b          .dw XT_EXIT
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/dup.asm"
                 
                 ; Stack
                 ; duplicate TOS
                 VE_DUP:
0070a8 ff03          .dw $ff03
0070a9 7564
0070aa 0070          .db "dup",0
0070ab 70a0          .dw VE_HEAD
                     .set VE_HEAD = VE_DUP
                 XT_DUP:
0070ac 70ad          .dw PFA_DUP
                 PFA_DUP:
0070ad 939a
0070ae 938a          savetos
0070af cf55          jmp_ DO_NEXT
                 .include "words/qdup.asm"
                 
                 ; Stack
                 ; duplicate TOS if non-zero
                 VE_QDUP:
0070b0 ff04          .dw $ff04
0070b1 643f
0070b2 7075          .db "?dup"
0070b3 70a8          .dw VE_HEAD
                     .set VE_HEAD = VE_QDUP
                 XT_QDUP:
0070b4 70b5          .dw PFA_QDUP
                 PFA_QDUP:
0070b5 2f08          mov temp0, tosl
0070b6 2b09          or temp0, tosh
0070b7 f011          breq PFA_QDUP1
0070b8 939a
0070b9 938a          savetos
                 PFA_QDUP1:
0070ba cf4a          jmp_ DO_NEXT
                 .include "words/swap.asm"
                 
                 ; Stack
                 ; swaps the two top level stack cells
                 VE_SWAP:
0070bb ff04          .dw $ff04
0070bc 7773
0070bd 7061          .db "swap"
0070be 70b0          .dw VE_HEAD
                     .set VE_HEAD = VE_SWAP
                 XT_SWAP:
0070bf 70c0          .dw PFA_SWAP
                 PFA_SWAP:
0070c0 018c          movw temp0, tosl
0070c1 9189
0070c2 9199          loadtos
0070c3 931a          st -Y, temp1
0070c4 930a          st -Y, temp0
0070c5 cf3f          jmp_ DO_NEXT
                 .include "words/over.asm"
                 
                 ; Stack
                 ; Place a copy of x1 on top of the stack
                 VE_OVER:
0070c6 ff04          .dw $ff04
0070c7 766f
0070c8 7265          .db "over"
0070c9 70bb          .dw VE_HEAD
                     .set VE_HEAD = VE_OVER
                 XT_OVER:
0070ca 70cb          .dw PFA_OVER
                 PFA_OVER:
0070cb 939a
0070cc 938a          savetos
0070cd 818a          ldd tosl, Y+2
0070ce 819b          ldd tosh, Y+3
                 
0070cf cf35          jmp_ DO_NEXT
                 .include "words/drop.asm"
                 
                 ; Stack
                 ; drop TOS
                 VE_DROP:
0070d0 ff04          .dw $ff04
0070d1 7264
0070d2 706f          .db "drop"
0070d3 70c6          .dw VE_HEAD
                     .set VE_HEAD = VE_DROP
                 XT_DROP:
0070d4 70d5          .dw PFA_DROP
                 PFA_DROP:
0070d5 9189
0070d6 9199          loadtos
0070d7 cf2d          jmp_ DO_NEXT
                 .include "words/rot.asm"
                 
                 ; Stack
                 ; rotate the three top level cells
                 VE_ROT:
0070d8 ff03          .dw $ff03
0070d9 6f72
0070da 0074          .db "rot",0
0070db 70d0          .dw VE_HEAD
                     .set VE_HEAD = VE_ROT
                 XT_ROT:
0070dc 70dd          .dw PFA_ROT
                 PFA_ROT:
0070dd 018c          movw temp0, tosl
0070de 9129          ld temp2, Y+
0070df 9139          ld temp3, Y+ 
0070e0 9189
0070e1 9199          loadtos
                         
0070e2 933a          st -Y, temp3
0070e3 932a          st -Y, temp2
0070e4 931a          st -Y, temp1
0070e5 930a          st -Y, temp0
                 
0070e6 cf1e          jmp_ DO_NEXT
                 .include "words/nip.asm"
                 
                 ; Stack
                 ; Remove Second of Stack
                 VE_NIP:
0070e7 ff03          .dw $ff03
0070e8 696e
0070e9 0070          .db "nip",0
0070ea 70d8          .dw VE_HEAD
                     .set VE_HEAD = VE_NIP
                 XT_NIP:
0070eb 70ec          .dw PFA_NIP
                 PFA_NIP:
0070ec 9622          adiw yl, 2
0070ed cf17          jmp_ DO_NEXT
                 ;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/r_from.asm"
                 
                 ; Stack
                 ; move TOR to TOS
                 VE_R_FROM:
0070ee ff02          .dw $ff02
0070ef 3e72          .db "r>"
0070f0 70e7          .dw VE_HEAD
                     .set VE_HEAD = VE_R_FROM
                 XT_R_FROM:
0070f1 70f2          .dw PFA_R_FROM
                 PFA_R_FROM:
0070f2 939a
0070f3 938a          savetos
0070f4 918f          pop tosl
0070f5 919f          pop tosh
0070f6 cf0e          jmp_ DO_NEXT
                 .include "words/to_r.asm"
                 
                 ; Stack
                 ; move TOS to TOR
                 VE_TO_R:
0070f7 ff02          .dw $ff02
0070f8 723e          .db ">r"
0070f9 70ee          .dw VE_HEAD
                     .set VE_HEAD = VE_TO_R
                 XT_TO_R:
0070fa 70fb          .dw PFA_TO_R
                 PFA_TO_R:
0070fb 939f          push tosh
0070fc 938f          push tosl
0070fd 9189
0070fe 9199          loadtos
0070ff cf05          jmp_ DO_NEXT
                 .include "words/r_fetch.asm"
                 
                 ; Stack
                 ; fetch content of TOR
                 VE_R_FETCH:
007100 ff02          .dw $ff02
007101 4072          .db "r@"
007102 70f7          .dw VE_HEAD
                     .set VE_HEAD = VE_R_FETCH
                 XT_R_FETCH:
007103 7104          .dw PFA_R_FETCH
                 PFA_R_FETCH:
007104 939a
007105 938a          savetos
007106 918f          pop tosl
007107 919f          pop tosh
007108 939f          push tosh
007109 938f          push tosl
00710a cefa          jmp_ DO_NEXT
                 
                 
                 .include "words/not-equal.asm"
                 
                 ; Compare
                 ; true if n1 is not equal to n2
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_NOTEQUAL:
00710b ff02          .dw $ff02
00710c 3e3c          .db "<>"
00710d 7100          .dw VE_HEAD
                     .set VE_HEAD = VE_NOTEQUAL
                 XT_NOTEQUAL:
00710e 7001          .dw DO_COLON
                 PFA_NOTEQUAL:
                 .endif
                 
00710f 7d72
007110 7115
007111 701b          .DW XT_EQUAL,XT_ZEROEQUAL,XT_EXIT
                 .include "words/equalzero.asm"
                 
                 ; Compare
                 ; compare with 0 (zero)
                 VE_ZEROEQUAL:
007112 ff02          .dw $ff02
007113 3d30          .db "0="
007114 710b          .dw VE_HEAD
                     .set VE_HEAD = VE_ZEROEQUAL
                 XT_ZEROEQUAL:
007115 7116          .dw PFA_ZEROEQUAL
                 PFA_ZEROEQUAL:
007116 2b98          or tosh, tosl
007117 f5d1          brne PFA_ZERO1
007118 c030          rjmp PFA_TRUE1
                 .include "words/lesszero.asm"
                 
                 ; Compare
                 ; compare with zero
                 VE_ZEROLESS:
007119 ff02          .dw $ff02
00711a 3c30          .db "0<"
00711b 7112          .dw VE_HEAD
                     .set VE_HEAD = VE_ZEROLESS
                 XT_ZEROLESS:
00711c 711d          .dw PFA_ZEROLESS
                 PFA_ZEROLESS:
00711d fd97          sbrc tosh,7
00711e c02a          rjmp PFA_TRUE1
00711f c032          rjmp PFA_ZERO1
                 .include "words/greaterzero.asm"
                 
                 ; Compare
                 ; true if n1 is greater than 0
                 VE_GREATERZERO:
007120 ff02          .dw $ff02
007121 3e30          .db "0>"
007122 7119          .dw VE_HEAD
                     .set VE_HEAD = VE_GREATERZERO
                 XT_GREATERZERO:
007123 7124          .dw PFA_GREATERZERO
                 PFA_GREATERZERO:
007124 1582          cp tosl, zerol
007125 0593          cpc tosh, zeroh
007126 f15c          brlt PFA_ZERO1
007127 f151          brbs 1, PFA_ZERO1
007128 c020          rjmp PFA_TRUE1
                 .include "words/d-greaterzero.asm"
                 
                 ; Compare
                 ; compares if a double double cell number is greater 0
                 VE_DGREATERZERO:
007129 ff03          .dw $ff03
00712a 3064
00712b 003e          .db "d0>",0
00712c 7120          .dw VE_HEAD
                     .set VE_HEAD = VE_DGREATERZERO
                 XT_DGREATERZERO:
00712d 712e          .dw PFA_DGREATERZERO
                 PFA_DGREATERZERO:
00712e 1582          cp tosl, zerol
00712f 0593          cpc tosh, zeroh
007130 9189
007131 9199          loadtos
007132 0582          cpc tosl, zerol
007133 0593          cpc tosh, zeroh
007134 f0ec          brlt PFA_ZERO1
007135 f0e1          brbs 1, PFA_ZERO1
007136 c012          rjmp PFA_TRUE1
                 .include "words/d-lesszero.asm"
                 
                 ; Compare
                 ; compares if a double double cell number is less than 0
                 VE_DXT_ZEROLESS:
007137 ff03          .dw $ff03
007138 3064
007139 003c          .db "d0<",0
00713a 7129          .dw VE_HEAD
                     .set VE_HEAD = VE_DXT_ZEROLESS
                 XT_DXT_ZEROLESS:
00713b 713c          .dw PFA_DXT_ZEROLESS
                 PFA_DXT_ZEROLESS:
00713c 9622          adiw Y,2
00713d fd97          sbrc tosh,7
00713e 940c 7149     jmp PFA_TRUE1
007140 940c 7152     jmp PFA_ZERO1
                 
                 .include "words/true.asm"
                 
                 ; Arithmetics
                 ; leaves the value -1 (true) on TOS
                 VE_TRUE:
007142 ff04          .dw $ff04
007143 7274
007144 6575          .db "true"
007145 7137          .dw VE_HEAD
                     .set VE_HEAD = VE_TRUE
                 XT_TRUE:
007146 7147          .dw PFA_TRUE
                 PFA_TRUE:
007147 939a
007148 938a          savetos
                 PFA_TRUE1:
007149 ef8f          ser tosl
00714a ef9f          ser tosh
00714b ceb9          jmp_ DO_NEXT
                 .include "words/zero.asm"
                 
                 ; Arithmetics
                 ; place a value 0 on TOS
                 VE_ZERO:
00714c ff01          .dw $ff01
00714d 0030          .db "0",0
00714e 7142          .dw VE_HEAD
                     .set VE_HEAD = VE_ZERO
                 XT_ZERO:
00714f 7150          .dw PFA_ZERO
                 PFA_ZERO:
007150 939a
007151 938a          savetos
                 PFA_ZERO1:
007152 01c1          movw tosl, zerol
007153 ceb1          jmp_ DO_NEXT
                 .include "words/uless.asm"
                 
                 ; Compare
                 ; true if u1 < u2 (unsigned)
                 VE_ULESS:
007154 ff02          .dw $ff02
007155 3c75          .db "u<"
007156 714c          .dw VE_HEAD
                     .set VE_HEAD = VE_ULESS
                 XT_ULESS:
007157 7158          .dw PFA_ULESS
                 PFA_ULESS:
007158 9129          ld temp2, Y+
007159 9139          ld temp3, Y+
00715a 1782          cp tosl, temp2
00715b 0793          cpc tosh, temp3
00715c f3a8          brlo PFA_ZERO1
00715d f3a1          brbs 1, PFA_ZERO1
00715e cfea          jmp_ PFA_TRUE1
                 .include "words/u-greater.asm"
                 
                 ; Compare
                 ; true if u1 > u2 (unsigned)
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_UGREATER:
00715f ff02          .dw $ff02
007160 3e75          .db "u>"
007161 7154          .dw VE_HEAD
                     .set VE_HEAD = VE_UGREATER
                 XT_UGREATER:
007162 7001          .dw DO_COLON
                 PFA_UGREATER:
                 .endif
007163 70bf          .DW XT_SWAP
007164 7157          .dw XT_ULESS
007165 701b          .dw XT_EXIT
                 .include "words/less.asm"
                 
                 ; Compare
                 ; true if n1 is less than n2
                     VE_LESS:
007166 ff01          .dw $ff01
007167 003c          .db "<",0
007168 715f          .dw VE_HEAD
                     .set VE_HEAD = VE_LESS
                 XT_LESS:
007169 716a          .dw PFA_LESS
                 PFA_LESS:
00716a 9129          ld temp2, Y+
00716b 9139          ld temp3, Y+
00716c 1728          cp temp2, tosl
00716d 0739          cpc temp3, tosh
                 PFA_LESSDONE:
00716e f71c          brge PFA_ZERO1
00716f cfd9          rjmp PFA_TRUE1
                 .include "words/greater.asm"
                 
                 ; Compare
                 ; flag is true if n1 is greater than n2
                 VE_GREATER:
007170 ff01          .dw $ff01
007171 003e          .db ">",0
007172 7166          .dw VE_HEAD
                     .set VE_HEAD = VE_GREATER
                 XT_GREATER:
007173 7174          .dw PFA_GREATER
                 PFA_GREATER:
007174 9129          ld temp2, Y+
007175 9139          ld temp3, Y+
007176 1728          cp temp2, tosl
007177 0739          cpc temp3, tosh
                 PFA_GREATERDONE:
007178 f2cc          brlt PFA_ZERO1
007179 f2c1          brbs 1, PFA_ZERO1
00717a cfce          rjmp PFA_TRUE1
                 
                 .include "words/log2.asm"
                 
                 ; Arithmetics
                 ; logarithm to base 2 or highest set bitnumber
                 VE_LOG2:
00717b ff04          .dw $ff04
00717c 6f6c
00717d 3267          .db "log2"
00717e 7170          .dw VE_HEAD
                     .set VE_HEAD = VE_LOG2
                 XT_LOG2:
00717f 7180          .dw PFA_LOG2
                 PFA_LOG2:
007180 01fc          movw zl, tosl
007181 2799          clr tosh
007182 e180          ldi tosl, 16
                 PFA_LOG2_1:
007183 958a          dec tosl
007184 f022          brmi PFA_LOG2_2 ; wrong data
007185 0fee          lsl  zl
007186 1fff          rol  zh
007187 f7d8          brcc PFA_LOG2_1
007188 ce7c          jmp_ DO_NEXT
                 
                 PFA_LOG2_2:
007189 959a          dec tosh
00718a ce7a          jmp_ DO_NEXT
                 .include "words/minus.asm"
                 
                 ; Arithmetics
                 ; subtract n2 from n1
                 VE_MINUS:
00718b ff01          .dw $ff01
00718c 002d          .db "-",0
00718d 717b          .dw VE_HEAD
                     .set VE_HEAD = VE_MINUS
                 XT_MINUS:
00718e 718f          .dw PFA_MINUS
                 PFA_MINUS:
00718f 9109          ld temp0, Y+
007190 9119          ld temp1, Y+
007191 1b08          sub temp0, tosl
007192 0b19          sbc temp1, tosh
007193 01c8          movw tosl, temp0
007194 ce70          jmp_ DO_NEXT
                 .include "words/plus.asm"
                 
                 ; Arithmetics
                 ; add n1 and n2
                 VE_PLUS:
007195 ff01          .dw $ff01
007196 002b          .db "+",0
007197 718b          .dw VE_HEAD
                     .set VE_HEAD = VE_PLUS
                 XT_PLUS:
007198 7199          .dw PFA_PLUS
                 PFA_PLUS:
007199 9109          ld temp0, Y+
00719a 9119          ld temp1, Y+
00719b 0f80          add tosl, temp0
00719c 1f91          adc tosh, temp1
00719d ce67          jmp_ DO_NEXT
                 .include "words/mstar.asm"
                 
                 ; Arithmetics
                 ; multiply 2 cells to a double cell
                 VE_MSTAR:
00719e ff02          .dw $ff02
00719f 2a6d          .db "m*"
0071a0 7195          .dw VE_HEAD
                     .set VE_HEAD = VE_MSTAR
                 XT_MSTAR:
0071a1 71a2          .dw PFA_MSTAR
                 PFA_MSTAR:
0071a2 018c          movw temp0, tosl
0071a3 9189
0071a4 9199          loadtos
0071a5 019c          movw temp2, tosl
                     ; high cell ah*bh
0071a6 0231          muls temp3, temp1
0071a7 0170          movw temp4, r0
                     ; low cell  al*bl
0071a8 9f20          mul  temp2, temp0
0071a9 01c0          movw tosl, r0
                     ; signed ah*bl
0071aa 0330          mulsu temp3, temp0
0071ab 08f3          sbc   temp5, zeroh
0071ac 0d90          add   tosh,  r0
0071ad 1ce1          adc   temp4, r1
0071ae 1cf3          adc   temp5, zeroh
                     
                     ; signed al*bh
0071af 0312          mulsu temp1, temp2
0071b0 08f3          sbc   temp5, zeroh
0071b1 0d90          add   tosh,  r0
0071b2 1ce1          adc   temp4, r1
0071b3 1cf3          adc   temp5, zeroh
                 
0071b4 939a
0071b5 938a          savetos
0071b6 01c7          movw tosl, temp4
0071b7 ce4d          jmp_ DO_NEXT
                 .include "words/umslashmod.asm"
                 
                 ; Arithmetics
                 ; unsigned division ud / u2 with remainder
                 VE_UMSLASHMOD:
0071b8 ff06          .dw $ff06
0071b9 6d75
0071ba 6d2f
0071bb 646f          .db "um/mod"
0071bc 719e          .dw VE_HEAD
                     .set VE_HEAD = VE_UMSLASHMOD
                 XT_UMSLASHMOD:
0071bd 71be          .dw PFA_UMSLASHMOD
                 PFA_UMSLASHMOD:
0071be 017c          movw temp4, tosl
                 
0071bf 9129          ld temp2, Y+
0071c0 9139          ld temp3, Y+
                   
0071c1 9109          ld temp0, Y+
0071c2 9119          ld temp1, Y+
                 
                 ;; unsigned 32/16 -> 16r16 divide
                 
                 PFA_UMSLASHMODmod:
                 
                   ; set loop counter
0071c3 e140          ldi temp6,$10
                 
                 PFA_UMSLASHMODmod_loop:
                     ; shift left, saving high bit
0071c4 2755          clr temp7
0071c5 0f00          lsl temp0
0071c6 1f11          rol temp1
0071c7 1f22          rol temp2
0071c8 1f33          rol temp3
0071c9 1f55          rol temp7
                 
                   ; try subtracting divisor
0071ca 152e          cp temp2, temp4
0071cb 053f          cpc temp3, temp5
0071cc 0552          cpc temp7,zerol
                 
0071cd f018          brcs PFA_UMSLASHMODmod_loop_control
                 
                 PFA_UMSLASHMODmod_subtract:
                     ; dividend is large enough
                     ; do the subtraction for real
                     ; and set lowest bit
0071ce 9503          inc temp0
0071cf 192e          sub temp2, temp4
0071d0 093f          sbc temp3, temp5
                 
                 PFA_UMSLASHMODmod_loop_control:
0071d1 954a          dec  temp6
0071d2 f789          brne PFA_UMSLASHMODmod_loop
                 
                 PFA_UMSLASHMODmod_done:
                     ; put remainder on stack
0071d3 933a          st -Y,temp3
0071d4 932a          st -Y,temp2
                 
                     ; put quotient on stack
0071d5 01c8          movw tosl, temp0
0071d6 ce2e          jmp_ DO_NEXT
                 .include "words/umstar.asm"
                 
                 ; Arithmetics
                 ; multiply 2 unsigned cells to a double cell
                 VE_UMSTAR:
0071d7 ff03          .dw $ff03
0071d8 6d75
0071d9 002a          .db "um*",0
0071da 71b8          .dw VE_HEAD
                     .set VE_HEAD = VE_UMSTAR
                 XT_UMSTAR:
0071db 71dc          .dw PFA_UMSTAR
                 PFA_UMSTAR:
0071dc 018c          movw temp0, tosl
0071dd 9189
0071de 9199          loadtos
                     ; result: (temp3*temp1)* 65536 + (temp3*temp0 + temp1*temp2) * 256 + (temp0 * temp2)
                     ; low bytes
0071df 9f80          mul tosl,temp0
0071e0 01f0          movw zl, r0
0071e1 2722          clr temp2
0071e2 2733          clr temp3
                     ; middle bytes
0071e3 9f90          mul tosh, temp0
0071e4 0df0          add zh, r0
0071e5 1d21          adc temp2, r1
0071e6 1d33          adc temp3, zeroh
                         
0071e7 9f81          mul tosl, temp1
0071e8 0df0          add zh, r0
0071e9 1d21          adc temp2, r1
0071ea 1d33          adc temp3, zeroh
                     
0071eb 9f91          mul tosh, temp1
0071ec 0d20          add temp2, r0
0071ed 1d31          adc temp3, r1
0071ee 01cf          movw tosl, zl
0071ef 939a
0071f0 938a          savetos
0071f1 01c9          movw tosl, temp2
0071f2 ce12          jmp_ DO_NEXT
                 
                 .include "words/invert.asm"
                 
                 ; Arithmetics
                 ; 1-complement of TOS
                 VE_INVERT:
0071f3 ff06          .dw $ff06
0071f4 6e69
0071f5 6576
0071f6 7472          .db "invert"
0071f7 71d7          .dw VE_HEAD
                     .set VE_HEAD = VE_INVERT
                 XT_INVERT:
0071f8 71f9          .dw PFA_INVERT
                 PFA_INVERT:
0071f9 9580          com tosl
0071fa 9590          com tosh
0071fb ce09          jmp_ DO_NEXT
                 .include "words/2slash.asm"
                 
                 ; Arithmetics
                 ; arithmetic shift right
                 VE_2SLASH:
0071fc ff02          .dw $ff02
0071fd 2f32          .db "2/"
0071fe 71f3          .dw VE_HEAD
                     .set VE_HEAD = VE_2SLASH
                 XT_2SLASH:
0071ff 7200          .dw PFA_2SLASH
                 PFA_2SLASH:
007200 9595          asr tosh
007201 9587          ror tosl
007202 ce02          jmp_ DO_NEXT
                 .include "words/2star.asm"
                 
                 ; Arithmetics
                 ; arithmetic shift left, filling with zero
                 VE_2STAR:
007203 ff02          .dw $ff02
007204 2a32          .db "2*"
007205 71fc          .dw VE_HEAD
                     .set VE_HEAD = VE_2STAR
                 XT_2STAR:
007206 7207          .dw PFA_2STAR
                 PFA_2STAR:
007207 0f88          lsl tosl
007208 1f99          rol tosh
007209 cdfb          jmp_ DO_NEXT
                 .include "words/and.asm"
                 
                 ; Logic
                 ; bitwise and
                 VE_AND:
00720a ff03          .dw $ff03
00720b 6e61
00720c 0064          .db "and",0
00720d 7203          .dw VE_HEAD
                     .set VE_HEAD = VE_AND
                 XT_AND:
00720e 720f          .dw PFA_AND
                 PFA_AND:
00720f 9109          ld temp0, Y+
007210 9119          ld temp1, Y+
007211 2380          and tosl, temp0
007212 2391          and tosh, temp1
007213 cdf1          jmp_ DO_NEXT
                 .include "words/or.asm"
                 
                 ; Logic
                 ; logical or
                 VE_OR:
007214 ff02          .dw $ff02
007215 726f          .db "or"
007216 720a          .dw VE_HEAD
                     .set VE_HEAD = VE_OR
                 XT_OR:
007217 7218          .dw PFA_OR
                 PFA_OR:
007218 9109          ld temp0, Y+
007219 9119          ld temp1, Y+
00721a 2b80          or tosl, temp0
00721b 2b91          or tosh, temp1
00721c cde8          jmp_ DO_NEXT
                 
                 .include "words/xor.asm"
                 
                 ; Logic
                 ; exclusive or
                 VE_XOR:
00721d ff03          .dw $ff03
00721e 6f78
00721f 0072          .db "xor",0
007220 7214          .dw VE_HEAD
                     .set VE_HEAD = VE_XOR
                 XT_XOR:
007221 7222          .dw PFA_XOR
                 PFA_XOR:
007222 9109          ld temp0, Y+
007223 9119          ld temp1, Y+
007224 2780          eor tosl, temp0
007225 2791          eor tosh, temp1
007226 cdde          jmp_ DO_NEXT
                 
                 .include "words/1plus.asm"
                 
                 ; Arithmetics
                 ; optimized increment
                 VE_1PLUS:
007227 ff02          .dw $ff02
007228 2b31          .db "1+"
007229 721d          .dw VE_HEAD
                     .set VE_HEAD = VE_1PLUS
                 XT_1PLUS:
00722a 722b          .dw PFA_1PLUS
                 PFA_1PLUS:
00722b 9601          adiw tosl,1
00722c cdd8          jmp_ DO_NEXT
                 .include "words/1minus.asm"
                 
                 ; Arithmetics
                 ; optimized decrement
                 VE_1MINUS:
00722d ff02          .dw $ff02 
00722e 2d31          .db "1-"
00722f 7227          .dw VE_HEAD
                     .set VE_HEAD = VE_1MINUS
                 XT_1MINUS:
007230 7231          .dw PFA_1MINUS
                 PFA_1MINUS:
007231 9701          sbiw tosl, 1
007232 cdd2          jmp_ DO_NEXT
                 .include "words/lshift.asm"
                 
                 ; Arithmetics
                 ; logically shift n1 left n2 times
                 VE_LSHIFT:
007233 ff06          .dw $ff06
007234 736c
007235 6968
007236 7466          .db "lshift"
007237 722d          .dw VE_HEAD
                     .set VE_HEAD = VE_LSHIFT
                 XT_LSHIFT:
007238 7239          .dw PFA_LSHIFT
                 PFA_LSHIFT:
007239 01fc          movw zl, tosl
00723a 9189
00723b 9199          loadtos
                 PFA_LSHIFT1:
00723c 9731          sbiw zl, 1
00723d f01a          brmi PFA_LSHIFT2
00723e 0f88          lsl tosl
00723f 1f99          rol tosh
007240 cffb          rjmp PFA_LSHIFT1
                 PFA_LSHIFT2:
007241 cdc3          jmp_ DO_NEXT
                 
                 .include "words/rshift.asm"
                 
                 ; Arithmetics
                 ; shift n1 n2-times logically right
                 VE_RSHIFT:
007242 ff06          .dw $ff06
007243 7372
007244 6968
007245 7466          .db "rshift"
007246 7233          .dw VE_HEAD
                     .set VE_HEAD = VE_RSHIFT
                 XT_RSHIFT:
007247 7248          .dw PFA_RSHIFT
                 PFA_RSHIFT:
007248 01fc          movw zl, tosl
007249 9189
00724a 9199          loadtos
                 PFA_RSHIFT1:
00724b 9731          sbiw zl, 1
00724c f01a          brmi PFA_RSHIFT2
00724d 9596          lsr tosh
00724e 9587          ror tosl
00724f cffb          rjmp PFA_RSHIFT1
                 PFA_RSHIFT2:
007250 cdb4          jmp_ DO_NEXT
                 
                 .include "words/plusstore.asm"
                 
                 ; Arithmetics
                 ; add n to content of RAM address a-addr
                 VE_PLUSSTORE:
007251 ff02          .dw $ff02
007252 212b          .db "+!"
007253 7242          .dw VE_HEAD
                     .set VE_HEAD = VE_PLUSSTORE
                 XT_PLUSSTORE:
007254 7255          .dw PFA_PLUSSTORE
                 PFA_PLUSSTORE:
007255 01fc          movw zl, tosl
007256 9189
007257 9199          loadtos
007258 8120          ldd temp2, Z+0
007259 8131          ldd temp3, Z+1
00725a 0f82          add tosl, temp2
00725b 1f93          adc tosh, temp3
00725c 8380          std Z+0, tosl
00725d 8391          std Z+1, tosh
00725e 9189
00725f 9199          loadtos
007260 cda4          jmp_ DO_NEXT
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/rpfetch.asm"
                 
                 ; Stack
                 ; current return stack pointer address
                 VE_RP_FETCH:
007261 ff03          .dw $ff03
007262 7072
007263 0040          .db "rp@",0
007264 7251          .dw VE_HEAD
                     .set VE_HEAD = VE_RP_FETCH
                 XT_RP_FETCH:
007265 7266          .dw PFA_RP_FETCH
                 PFA_RP_FETCH:
007266 939a
007267 938a          savetos
007268 b78d          in tosl, SPL
007269 b79e          in tosh, SPH
00726a cd9a          jmp_ DO_NEXT
                 .include "words/rpstore.asm"
                 
                 ; Stack
                 ; set return stack pointer
                 VE_RP_STORE:
00726b ff03          .dw $ff03
00726c 7072
00726d 0021          .db "rp!",0
00726e 7261          .dw VE_HEAD
                     .set VE_HEAD = VE_RP_STORE
                 XT_RP_STORE:
00726f 7270          .dw PFA_RP_STORE
                 PFA_RP_STORE:
007270 b72f          in temp2, SREG
007271 94f8          cli
007272 bf8d          out SPL, tosl
007273 bf9e          out SPH, tosh
007274 bf2f          out SREG, temp2
007275 9189
007276 9199          loadtos
007277 cd8d          jmp_ DO_NEXT
                 .include "words/spfetch.asm"
                 
                 ; Stack
                 ; current data stack pointer
                 VE_SP_FETCH:
007278 ff03          .dw $ff03
007279 7073
00727a 0040          .db "sp@",0
00727b 726b          .dw VE_HEAD
                     .set VE_HEAD = VE_SP_FETCH
                 XT_SP_FETCH:
00727c 727d          .dw PFA_SP_FETCH
                 PFA_SP_FETCH:
00727d 939a
00727e 938a          savetos
00727f 01ce          movw tosl, yl
007280 cd84          jmp_ DO_NEXT
                 .include "words/spstore.asm"
                 
                 ; Stack
                 ; set data stack pointer to addr
                 VE_SP_STORE:
007281 ff03          .dw $ff03
007282 7073
007283 0021          .db "sp!",0
007284 7278          .dw VE_HEAD
                     .set VE_HEAD = VE_SP_STORE
                 XT_SP_STORE:
007285 7286          .dw PFA_SP_STORE
                 PFA_SP_STORE:
007286 01ec          movw yl, tosl
007287 9189
007288 9199          loadtos
007289 cd7b          jmp_ DO_NEXT
                 
                 .include "words/dodo.asm"
                 
                 ; System
                 ; runtime of do
                 ;VE_DODO:
                 ;    .dw $ff04
                 ;    .db "(do)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DODO
                 XT_DODO:
00728a 728b          .dw PFA_DODO
                 PFA_DODO:
00728b 9129          ld temp2, Y+
00728c 9139          ld temp3, Y+  ; limit
                 PFA_DODO1:
00728d e8e0          ldi zl, $80
00728e 0f3e          add temp3, zl
00728f 1b82          sub  tosl, temp2
007290 0b93          sbc  tosh, temp3
                 
007291 933f          push temp3
007292 932f          push temp2    ; limit  ( --> limit + $8000)
007293 939f          push tosh
007294 938f          push tosl     ; start -> index ( --> index - (limit - $8000)
007295 9189
007296 9199          loadtos
007297 cd6d          jmp_ DO_NEXT
                 .include "words/i.asm"
                 
                 ; Compiler
                 ; current loop counter
                 VE_I:
007298 ff01          .dw $FF01
007299 0069          .db "i",0
00729a 7281          .dw VE_HEAD
                     .set VE_HEAD = VE_I
                 XT_I:
00729b 729c          .dw PFA_I
                 PFA_I:
00729c 939a
00729d 938a          savetos
00729e 918f          pop tosl
00729f 919f          pop tosh  ; index
0072a0 91ef          pop zl
0072a1 91ff          pop zh    ; limit
0072a2 93ff          push zh
0072a3 93ef          push zl
0072a4 939f          push tosh
0072a5 938f          push tosl
0072a6 0f8e          add tosl, zl
0072a7 1f9f          adc tosh, zh
0072a8 cd5c          jmp_ DO_NEXT
                 .include "words/doplusloop.asm"
                 
                 ; System
                 ; runtime of +loop
                 ;VE_DOPLUSLOOP:
                 ;    .dw $ff07
                 ;    .db "(+loop)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOPLUSLOOP
                 XT_DOPLUSLOOP:
0072a9 72aa          .dw PFA_DOPLUSLOOP
                 PFA_DOPLUSLOOP:
0072aa 91ef          pop zl
0072ab 91ff          pop zh
0072ac 0fe8          add zl, tosl
0072ad 1ff9          adc zh, tosh
0072ae 9189
0072af 9199          loadtos
0072b0 f01b          brvs PFA_DOPLUSLOOP_LEAVE
                     ; next cycle
                 PFA_DOPLUSLOOP_NEXT:
                     ; next iteration
0072b1 93ff          push zh
0072b2 93ef          push zl
0072b3 cd77          rjmp PFA_DOBRANCH ; read next cell from dictionary and jump to its destination
                 PFA_DOPLUSLOOP_LEAVE:
0072b4 910f          pop  temp0
0072b5 911f          pop  temp1  ; remove limit
0072b6 9611          adiw xl, 1  ; skip branch-back address
0072b7 cd4d          jmp_ DO_NEXT
                 .include "words/doloop.asm"
                 
                 ; System
                 ; runtime of loop
                 ;VE_DOLOOP:
                 ;    .dw $ff06
                 ;    .db "(loop)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOLOOP
                 XT_DOLOOP:
0072b8 72b9          .dw PFA_DOLOOP
                 PFA_DOLOOP:
0072b9 91ef          pop zl
0072ba 91ff          pop zh
0072bb 9631          adiw zl,1
0072bc f3bb          brvs PFA_DOPLUSLOOP_LEAVE
0072bd cff3          jmp_ PFA_DOPLUSLOOP_NEXT
                 .include "words/unloop.asm"
                 
                 ; Compiler
                 ; remove loop-sys, exit the loop and continue execution after it
                 VE_UNLOOP:
0072be ff06          .dw $ff06
0072bf 6e75
0072c0 6f6c
0072c1 706f          .db "unloop"
0072c2 7298          .dw VE_HEAD
                     .set VE_HEAD = VE_UNLOOP
                 XT_UNLOOP:
0072c3 72c4          .dw PFA_UNLOOP
                 PFA_UNLOOP:
0072c4 911f          pop temp1
0072c5 910f          pop temp0
0072c6 911f          pop temp1
0072c7 910f          pop temp0
0072c8 cd3c          jmp_ DO_NEXT
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 
                 .include "words/cmove_g.asm"
                 
                 ; Memory
                 ; copy data in RAM from higher to lower addresses.
                 VE_CMOVE_G:
0072c9 ff06          .dw $ff06
0072ca 6d63
0072cb 766f
0072cc 3e65          .db "cmove>"
0072cd 72be          .dw VE_HEAD
                     .set VE_HEAD  = VE_CMOVE_G
                 XT_CMOVE_G:
0072ce 72cf          .dw PFA_CMOVE_G
                 PFA_CMOVE_G:
0072cf 93bf          push xh
0072d0 93af          push xl
0072d1 91e9          ld zl, Y+
0072d2 91f9          ld zh, Y+ ; addr-to
0072d3 91a9          ld xl, Y+
0072d4 91b9          ld xh, Y+ ; addr-from
0072d5 2f09          mov temp0, tosh
0072d6 2b08          or temp0, tosl
0072d7 f041          brbs 1, PFA_CMOVE_G1
0072d8 0fe8          add zl, tosl
0072d9 1ff9          adc zh, tosh
0072da 0fa8          add xl, tosl
0072db 1fb9          adc xh, tosh
                 PFA_CMOVE_G2:
0072dc 911e          ld temp1, -X
0072dd 9312          st -Z, temp1
0072de 9701          sbiw tosl, 1
0072df f7e1          brbc 1, PFA_CMOVE_G2
                 PFA_CMOVE_G1:
0072e0 91af          pop xl
0072e1 91bf          pop xh
0072e2 9189
0072e3 9199          loadtos
0072e4 cd20          jmp_ DO_NEXT
                 .include "words/byteswap.asm"
                 
                 ; Arithmetics
                 ; exchange the bytes of the TOS
                 VE_BYTESWAP:
0072e5 ff02          .dw $ff02
0072e6 3c3e          .db "><"
0072e7 72c9          .dw VE_HEAD
                     .set VE_HEAD = VE_BYTESWAP
                 XT_BYTESWAP:
0072e8 72e9          .dw PFA_BYTESWAP
                 PFA_BYTESWAP:
0072e9 2f09          mov temp0, tosh
0072ea 2f98          mov tosh, tosl
0072eb 2f80          mov tosl, temp0
0072ec cd18          jmp_ DO_NEXT
                 .include "words/up.asm"
                 
                 ; System Variable
                 ; get user area pointer
                 VE_UP_FETCH:
0072ed ff03          .dw $ff03
0072ee 7075
0072ef 0040          .db "up@",0
0072f0 72e5          .dw VE_HEAD
                     .set VE_HEAD = VE_UP_FETCH
                 XT_UP_FETCH:
0072f1 72f2          .dw PFA_UP_FETCH
                 PFA_UP_FETCH:
0072f2 939a
0072f3 938a          savetos
0072f4 01c2          movw tosl, upl
0072f5 cd0f          jmp_ DO_NEXT
                 
                 ; ( addr -- ) 
                 ; System Variable
                 ; set user area pointer
                 VE_UP_STORE:
0072f6 ff03          .dw $ff03
0072f7 7075
0072f8 0021          .db "up!",0
0072f9 72ed          .dw VE_HEAD
                     .set VE_HEAD = VE_UP_STORE
                 XT_UP_STORE:
0072fa 72fb          .dw PFA_UP_STORE
                 PFA_UP_STORE:
0072fb 012c          movw upl, tosl
0072fc 9189
0072fd 9199          loadtos
0072fe cd06          jmp_ DO_NEXT
                 .include "words/1ms.asm"
                 
                 ; Time
                 ; busy waits (almost) exactly 1 millisecond
                 VE_1MS:
0072ff ff03          .dw $ff03
007300 6d31
007301 0073          .db "1ms",0
007302 72f6          .dw VE_HEAD
                     .set VE_HEAD = VE_1MS
                 XT_1MS:
007303 7304          .dw PFA_1MS
                 PFA_1MS:
007304 eae0
007305 e0ff
007306 9731
007307 f7f1          delay 1000
007308 ccfc          jmp_ DO_NEXT
                 .include "words/2to_r.asm"
                 
                 ; Stack
                 ; move DTOS to TOR
                 VE_2TO_R:
007309 ff03          .dw $ff03
00730a 3e32
00730b 0072          .db "2>r",0
00730c 72ff          .dw VE_HEAD
                     .set VE_HEAD = VE_2TO_R
                 XT_2TO_R:
00730d 730e          .dw PFA_2TO_R
                 PFA_2TO_R:
00730e 01fc          movw zl, tosl
00730f 9189
007310 9199          loadtos
007311 939f          push tosh
007312 938f          push tosl
007313 93ff          push zh
007314 93ef          push zl
007315 9189
007316 9199          loadtos
007317 cced          jmp_ DO_NEXT
                 .include "words/2r_from.asm"
                 
                 ; Stack
                 ; move DTOR to TOS
                 VE_2R_FROM:
007318 ff03          .dw $ff03
007319 7232
00731a 003e          .db "2r>",0
00731b 7309          .dw VE_HEAD
                     .set VE_HEAD = VE_2R_FROM
                 XT_2R_FROM:
00731c 731d          .dw PFA_2R_FROM
                 PFA_2R_FROM:
00731d 939a
00731e 938a          savetos
00731f 91ef          pop zl
007320 91ff          pop zh
007321 918f          pop tosl
007322 919f          pop tosh
007323 939a
007324 938a          savetos
007325 01cf          movw tosl, zl
007326 ccde          jmp_ DO_NEXT
                 
                 .include "words/store-e.asm"
                 
                 ; Memory
                 ; write n (2bytes) to eeprom address
                 VE_STOREE:
007327 ff02          .dw $ff02
007328 6521          .db "!e"
007329 7318          .dw VE_HEAD
                     .set VE_HEAD = VE_STOREE
                 XT_STOREE:
00732a 732b          .dw PFA_STOREE
                 PFA_STOREE:
                 .if WANT_UNIFIED == 1
                 .endif
                 PFA_STOREE0:
00732b 01fc          movw zl, tosl
00732c 9189
00732d 9199          loadtos
00732e b72f          in_ temp2, SREG
00732f 94f8          cli
007330 d028          rcall PFA_FETCHE2
007331 b500          in_  temp0, EEDR
007332 1708          cp temp0,tosl
007333 f009          breq PFA_STOREE3
007334 d00b          rcall PFA_STOREE1
                 PFA_STOREE3:
007335 9631          adiw zl,1
007336 d022          rcall PFA_FETCHE2
007337 b500          in_  temp0, EEDR
007338 1709          cp temp0,tosh
007339 f011          breq PFA_STOREE4
00733a 2f89          mov tosl, tosh
00733b d004          rcall PFA_STOREE1
                 PFA_STOREE4:
00733c bf2f          out_ SREG, temp2
00733d 9189
00733e 9199          loadtos
00733f ccc5          jmp_ DO_NEXT
                     
                 PFA_STOREE1:
007340 99f9          sbic EECR, EEPE
007341 cffe          rjmp PFA_STOREE1
                 
                 PFA_STOREE2: ; estore_wait_low_spm:
007342 b707          in_ temp0, SPMCSR
007343 fd00          sbrc temp0,SPMEN
007344 cffd          rjmp PFA_STOREE2
                 
007345 bdf2          out_ EEARH,zh
007346 bde1          out_ EEARL,zl
007347 bd80          out_ EEDR, tosl
007348 9afa          sbi EECR,EEMPE
007349 9af9          sbi EECR,EEPE
                 
00734a 9508          ret
                 .if WANT_UNIFIED == 1
                 .endif
                 .include "words/fetch-e.asm"
                 
                 ; Memory
                 ; read 1 cell from eeprom
                 VE_FETCHE:
00734b ff02          .dw $ff02
00734c 6540          .db "@e"
00734d 7327          .dw VE_HEAD
                     .set VE_HEAD = VE_FETCHE
                 XT_FETCHE:
00734e 734f          .dw PFA_FETCHE
                 PFA_FETCHE:
                 .if WANT_UNIFIED == 1
                 .endif
                 PFA_FETCHE1:
00734f b72f          in_ temp2, SREG
007350 94f8          cli
007351 01fc          movw zl, tosl
007352 d006          rcall PFA_FETCHE2
007353 b580          in_ tosl, EEDR
                 
007354 9631          adiw zl,1
                 
007355 d003          rcall PFA_FETCHE2
007356 b590          in_  tosh, EEDR
007357 bf2f          out_ SREG, temp2
007358 ccac          jmp_ DO_NEXT
                 
                 PFA_FETCHE2:
007359 99f9          sbic EECR, EEPE
00735a cffe          rjmp PFA_FETCHE2
                 
00735b bdf2          out_ EEARH,zh
00735c bde1          out_ EEARL,zl
                 
00735d 9af8          sbi EECR,EERE
00735e 9508          ret
                 
                 .if WANT_UNIFIED == 1
                 .endif
                 .include "words/store-i.asm"
                 
                 ; System Value
                 ; Deferred action to write a single 16bit cell to flash
                 VE_STOREI:
00735f ff02          .dw $ff02
007360 6921          .db "!i"
007361 734b          .dw VE_HEAD
                     .set VE_HEAD = VE_STOREI
                 XT_STOREI:
007362 7c06          .dw PFA_DODEFER1
                 PFA_STOREI:
007363 0042          .dw EE_STOREI
007364 7ba7          .dw XT_EDEFERFETCH
007365 7bb1          .dw XT_EDEFERSTORE
                 .if FLASHEND > $10000
                 .else
                   .include "words/store-i_nrww.asm"
                 
                 ; Memory
                 ; writes n to flash memory using assembly code (code to be placed in boot loader section)
                 VE_DO_STOREI_NRWW:
007366 ff09          .dw $ff09
007367 2128
007368 2d69
007369 726e
00736a 7777
00736b 0029          .db "(!i-nrww)",0
00736c 735f          .dw VE_HEAD
                     .set VE_HEAD = VE_DO_STOREI_NRWW
                 XT_DO_STOREI:
00736d 736e          .dw PFA_DO_STOREI_NRWW
                 PFA_DO_STOREI_NRWW:
                   ; store status register
00736e b71f        in temp1,SREG
00736f 931f        push temp1
007370 94f8        cli
                 
007371 019c        movw temp2, tosl ; save the (word) address
007372 9189
007373 9199        loadtos          ; get the new value for the flash cell
007374 93af        push xl
007375 93bf        push xh
007376 93cf        push yl
007377 93df        push yh
007378 d009        rcall DO_STOREI_atmega
007379 91df        pop yh
00737a 91cf        pop yl
00737b 91bf        pop xh
00737c 91af        pop xl
                   ; finally clear the stack
00737d 9189
00737e 9199        loadtos
00737f 911f        pop temp1
                   ; restore status register (and interrupt enable flag)
007380 bf1f        out SREG,temp1
                 
007381 cc83        jmp_ DO_NEXT
                 
                 ; 
                 DO_STOREI_atmega:
                   ; write data to temp page buffer
                   ; use the values in tosl/tosh at the
                   ; appropiate place
007382 d011        rcall pageload
                 
                   ; erase page if needed
                   ; it is needed if a bit goes from 0 to 1
007383 94e0        com temp4
007384 94f0        com temp5
007385 218e        and tosl, temp4
007386 219f        and tosh, temp5
007387 2b98        or tosh, tosl
007388 f021        breq DO_STOREI_writepage 
007389 94b3          inc erase_counter
00738a 01f9          movw zl, temp2
00738b e002          ldi temp0,(1<<PGERS)
00738c d020          rcall dospm
                 
                 DO_STOREI_writepage:
                   ; write page
00738d 01f9        movw zl, temp2
00738e e004        ldi temp0,(1<<PGWRT)
00738f d01d        rcall dospm
                 
                   ; reenable RWW section
007390 01f9        movw zl, temp2
007391 e100        ldi temp0,(1<<RWWSRE)
007392 d01a        rcall dospm
007393 9508        ret
                 
                 ; load the desired page
                 .equ pagemask = ~ ( PAGESIZE - 1 )
                 pageload:
007394 01f9        movw zl, temp2
                   ; get the beginning of page
007395 78e0        andi zl,low(pagemask)
007396 7fff        andi zh,high(pagemask)
007397 01ef        movw y, z
                   ; loop counter (in words)
007398 e8a0        ldi xl,low(pagesize)
007399 e0b0        ldi xh,high(pagesize)
                 pageload_loop:
                   ; we need the current flash value anyways
00739a 01fe        movw z, y
00739b 0fee
00739c 1fff
00739d 9145
00739e 9155        readflashcell temp6, temp7 ; destroys Z
                   ; now check: if Z points to the same cell as temp2/3, we want the new data
00739f 01fe        movw z, y
0073a0 17e2        cp zl, temp2
0073a1 07f3        cpc zh, temp3
0073a2 f011        breq pageload_newdata
0073a3 010a          movw r0, temp6
0073a4 c002          rjmp pageload_cont
                 pageload_newdata:
0073a5 017a          movw temp4, temp6
0073a6 010c          movw r0, tosl
                 pageload_cont:
0073a7 2700        clr temp0
0073a8 d004        rcall dospm
0073a9 9621        adiw y, 1
0073aa 9711        sbiw x, 1
0073ab f771        brne pageload_loop
                 
                 pageload_done:
0073ac 9508        ret
                 
                 
                 ;; dospm
                 ;;
                 ;; execute spm instruction
                 ;;   temp0 holds the value for SPMCR
                 
                 dospm:
                 dospm_wait_ee:
0073ad 99f9        sbic EECR, EEPE
0073ae cffe        rjmp dospm_wait_ee
                 dospm_wait_spm:
0073af b717        in_  temp1, SPMCSR
0073b0 fd10        sbrc temp1, SPMEN
0073b1 cffd        rjmp dospm_wait_spm
                 
                   ; turn the word addres into a byte address
0073b2 0fee
0073b3 1fff        writeflashcell
                   ; execute spm
0073b4 6001        ori temp0, (1<<SPMEN)
0073b5 bf07        out_ SPMCSR,temp0
0073b6 95e8        spm
0073b7 9508        ret
                 .endif
                 .include "words/fetch-i.asm"
                 
                 ; Memory
                 ; read 1 cell from flash
                 VE_FETCHI:
0073b8 ff02          .dw $ff02
0073b9 6940          .db "@i"
0073ba 7366          .dw VE_HEAD
                     .set VE_HEAD = VE_FETCHI
                 XT_FETCHI:
0073bb 73bc          .dw PFA_FETCHI
                 PFA_FETCHI:
0073bc 01fc          movw zl, tosl
0073bd 0fee
0073be 1fff
0073bf 9185
0073c0 9195          readflashcell tosl,tosh
0073c1 cc43          jmp_ DO_NEXT
                 
                 .if AMFORTH_NRWW_SIZE>8000
                 .include "dict/core_8k.inc"
                 
                 .include "words/n_to_r.asm"
                 
                 ; Stack
                 ; move n items from data stack to return stack
                 VE_N_TO_R:
0073c2 ff03          .dw $ff03
0073c3 3e6e
0073c4 0072          .db "n>r",0
0073c5 73b8          .dw VE_HEAD
                     .set VE_HEAD = VE_N_TO_R
                 XT_N_TO_R:
0073c6 73c7          .dw PFA_N_TO_R
                 PFA_N_TO_R:
0073c7 01fc          movw zl, tosl
0073c8 2f08          mov  temp0, tosl
                 PFA_N_TO_R1:
0073c9 9189
0073ca 9199          loadtos
0073cb 939f          push tosh
0073cc 938f          push tosl
0073cd 950a          dec temp0
0073ce f7d1          brne PFA_N_TO_R1
0073cf 93ef          push zl
0073d0 93ff          push zh
0073d1 9189
0073d2 9199          loadtos
0073d3 cc31          jmp_ DO_NEXT
                 .include "words/n_r_from.asm"
                 
                 ; Stack
                 ; move n items from return stack to data stack
                 VE_N_R_FROM:
0073d4 ff03          .dw $ff03
0073d5 726e
0073d6 003e          .db "nr>",0
0073d7 73c2          .dw VE_HEAD
                     .set VE_HEAD = VE_N_R_FROM
                 XT_N_R_FROM:
0073d8 73d9          .dw PFA_N_R_FROM
                 PFA_N_R_FROM:
0073d9 939a
0073da 938a          savetos
0073db 91ff          pop zh
0073dc 91ef          pop zl
0073dd 2f0e          mov  temp0, zl
                 PFA_N_R_FROM1:
0073de 918f          pop tosl
0073df 919f          pop tosh
0073e0 939a
0073e1 938a          savetos
0073e2 950a          dec temp0
0073e3 f7d1          brne PFA_N_R_FROM1
0073e4 01cf          movw tosl, zl
0073e5 cc1f          jmp_ DO_NEXT
                 
                 .include "words/d-2star.asm"
                 
                 ; Arithmetics
                 ; shift a double cell left
                 VE_D2STAR:
0073e6 ff03          .dw $ff03
0073e7 3264
0073e8 002a          .db "d2*",0
0073e9 73d4          .dw VE_HEAD
                     .set VE_HEAD = VE_D2STAR
                 XT_D2STAR:
0073ea 73eb          .dw PFA_D2STAR
                 PFA_D2STAR:
0073eb 9109          ld temp0, Y+
0073ec 9119          ld temp1, Y+
0073ed 0f00          lsl temp0
0073ee 1f11          rol temp1
0073ef 1f88          rol tosl
0073f0 1f99          rol tosh
0073f1 931a          st -Y, temp1
0073f2 930a          st -Y, temp0
0073f3 cc11          jmp_ DO_NEXT
                 .include "words/d-2slash.asm"
                 
                 ; Arithmetics
                 ; shift a double cell value right
                 VE_D2SLASH:
0073f4 ff03          .dw $ff03
0073f5 3264
0073f6 002f          .db "d2/",0
0073f7 73e6          .dw VE_HEAD
                     .set VE_HEAD = VE_D2SLASH
                 XT_D2SLASH:
0073f8 73f9          .dw PFA_D2SLASH
                 PFA_D2SLASH:
0073f9 9109          ld temp0, Y+
0073fa 9119          ld temp1, Y+
0073fb 9595          asr tosh
0073fc 9587          ror tosl
0073fd 9517          ror temp1
0073fe 9507          ror temp0
0073ff 931a          st -Y, temp1
007400 930a          st -Y, temp0
007401 cc03          jmp_ DO_NEXT
                 .include "words/d-plus.asm"
                 
                 ; Arithmetics
                 ; add 2 double cell values
                 VE_DPLUS:
007402 ff02          .dw $ff02
007403 2b64          .db "d+"
007404 73f4          .dw VE_HEAD
                     .set VE_HEAD = VE_DPLUS
                 XT_DPLUS:
007405 7406          .dw PFA_DPLUS
                 PFA_DPLUS:
007406 9129          ld temp2, Y+
007407 9139          ld temp3, Y+
                 
007408 90e9          ld temp4, Y+
007409 90f9          ld temp5, Y+
00740a 9149          ld temp6, Y+
00740b 9159          ld temp7, Y+
                 
00740c 0f24          add temp2, temp6
00740d 1f35          adc temp3, temp7
00740e 1d8e          adc tosl, temp4
00740f 1d9f          adc tosh, temp5
                     
007410 933a          st -Y, temp3
007411 932a          st -Y, temp2
007412 cbf2          jmp_ DO_NEXT
                 .include "words/d-minus.asm"
                 
                 ; Arithmetics
                 ; subtract d2 from d1 
                 VE_DMINUS:
007413 ff02          .dw $ff02
007414 2d64          .db "d-"
007415 7402          .dw VE_HEAD
                     .set VE_HEAD = VE_DMINUS
                 XT_DMINUS:
007416 7417          .dw PFA_DMINUS
                 PFA_DMINUS:
007417 9129          ld temp2, Y+
007418 9139          ld temp3, Y+
                 
007419 90e9          ld temp4, Y+
00741a 90f9          ld temp5, Y+
00741b 9149          ld temp6, Y+
00741c 9159          ld temp7, Y+
                 
00741d 1b42          sub temp6, temp2
00741e 0b53          sbc temp7, temp3
00741f 0ae8          sbc temp4, tosl
007420 0af9          sbc temp5, tosh
                 
007421 935a          st -Y, temp7
007422 934a          st -Y, temp6
007423 01c7          movw tosl, temp4
007424 cbe0          jmp_ DO_NEXT
                 .include "words/d-invert.asm"
                 
                 ; Arithmetics
                 ; invert all bits in the double cell value
                 VE_DINVERT:
007425 ff07          .dw $ff07
007426 6964
007427 766e
007428 7265
007429 0074          .db "dinvert",0
00742a 7413          .dw VE_HEAD
                     .set VE_HEAD = VE_DINVERT
                 XT_DINVERT:
00742b 742c          .dw PFA_DINVERT
                 PFA_DINVERT:
00742c 9109          ld temp0, Y+
00742d 9119          ld temp1, Y+
00742e 9580          com tosl
00742f 9590          com tosh
007430 9500          com temp0
007431 9510          com temp1
007432 931a          st -Y, temp1
007433 930a          st -Y, temp0
007434 cbd0          jmp_ DO_NEXT
                 .include "words/d-equal.asm"
                 
                 ; Compare
                 ; compares two double cell values
                 VE_DEQUAL:
007435 ff02          .dw $ff02
007436 3d64          .db "d="
007437 7425          .dw VE_HEAD
                     .set VE_HEAD = VE_DEQUAL
                 XT_DEQUAL:
007438 7001          .dw DO_COLON
                 PFA_DEQUAL:
007439 7416          .dw XT_DMINUS
00743a 7217          .dw XT_OR
00743b 7115          .dw XT_ZEROEQUAL
00743c 701b          .dw XT_EXIT
                 .include "words/u-dot.asm"
                 
                 ; Numeric IO
                 ; unsigned PNO with single cell numbers
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_UDOT:
00743d ff02          .dw $ff02
00743e 2e75          .db "u."
00743f 7435          .dw VE_HEAD
                     .set VE_HEAD = VE_UDOT
                 XT_UDOT:
007440 7001          .dw DO_COLON
                 PFA_UDOT:
                 .endif
007441 714f          .dw XT_ZERO
007442 7734          .dw XT_UDDOT
007443 701b          .dw XT_EXIT
                 ; : u.        ( us -- )    0 ud. ;
                 .include "words/u-dot-r.asm"
                 
                 ; Numeric IO
                 ; unsigned PNO with single cells numbers, right aligned in width w
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 
                 VE_UDOTR:
007444 ff03          .dw $ff03
007445 2e75
007446 0072          .db "u.r",0
007447 743d          .dw VE_HEAD
                     .set VE_HEAD = VE_UDOTR
                 XT_UDOTR:
007448 7001          .dw DO_COLON
                 PFA_UDOTR:
                 .endif
007449 714f          .dw XT_ZERO
00744a 70bf          .dw XT_SWAP
00744b 773d          .dw XT_UDDOTR
00744c 701b          .dw XT_EXIT
                 ; : u.r       ( s n -- )   0 swap ud.r ;
                 
                 .include "words/show-wordlist.asm"
                 
                 ; Tools
                 ; prints the name of the words in a wordlist
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SHOWWORDLIST:
00744d ff0d          .dw $ff0d
00744e 6873
00744f 776f
007450 772d
007451 726f
007452 6c64
007453 7369
007454 0074          .db "show-wordlist",0
007455 7444          .dw VE_HEAD
                     .set VE_HEAD = VE_SHOWWORDLIST
                 XT_SHOWWORDLIST:
007456 7001          .dw DO_COLON
                 PFA_SHOWWORDLIST:
                 .endif
007457 7038          .dw XT_DOLITERAL
007458 745c          .dw XT_SHOWWORD
007459 70bf          .dw XT_SWAP
00745a 7c4a          .dw XT_TRAVERSEWORDLIST
00745b 701b          .dw XT_EXIT
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 XT_SHOWWORD:
00745c 7001          .dw DO_COLON
                 PFA_SHOWWORD:
                 .endif
00745d 7c65          .dw XT_NAME2STRING
00745e 77aa          .dw XT_ITYPE
00745f 77ec          .dw XT_SPACE         ; ( -- addr n)
007460 7146          .dw XT_TRUE
007461 701b          .dw XT_EXIT
                 .include "words/words.asm"
                 
                 ; Tools
                 ; prints a list of all (visible) words in the dictionary
                 VE_WORDS:
007462 ff05          .dw $ff05
007463 6f77
007464 6472
007465 0073          .db "words",0
007466 744d          .dw VE_HEAD
                     .set VE_HEAD = VE_WORDS
                 XT_WORDS:
007467 7001          .dw DO_COLON
                 PFA_WORDS:
007468 7038          .dw XT_DOLITERAL
007469 004e          .dw CFG_ORDERLIST
00746a 734e          .dw XT_FETCHE
00746b 7456          .dw XT_SHOWWORDLIST
00746c 701b          .dw XT_EXIT
                 .include "dict/interrupt.inc"
                 
                 .include "words/int-on.asm"
                 
                 ; Interrupt
                 ; turns on all interrupts
                 VE_INTON:
00746d ff04          .dw $ff04
00746e 692b
00746f 746e          .db "+int"
007470 7462          .dw VE_HEAD
                     .set VE_HEAD = VE_INTON
                 XT_INTON:
007471 7472          .dw PFA_INTON
                 PFA_INTON:
007472 9478          sei
007473 cb91          jmp_ DO_NEXT
                 .include "words/int-off.asm"
                 
                 ; Interrupt
                 ; turns off all interrupts 
                 VE_INTOFF:
007474 ff04          .dw $ff04
007475 692d
007476 746e          .db "-int"
007477 746d          .dw VE_HEAD
                     .set VE_HEAD = VE_INTOFF
                 XT_INTOFF:
007478 7479          .dw PFA_INTOFF
                 PFA_INTOFF:
007479 94f8          cli
00747a cb8a          jmp_ DO_NEXT
                 .include "words/int-store.asm"
                 
                 ; Interrupt
                 ; stores XT as interrupt vector i
                 VE_INTSTORE:
00747b ff04          .dw $ff04
00747c 6e69
00747d 2174          .db "int!"
00747e 7474          .dw VE_HEAD
                     .set VE_HEAD = VE_INTSTORE
                 XT_INTSTORE:
00747f 7001          .dw DO_COLON
                 PFA_INTSTORE:
007480 7038          .dw XT_DOLITERAL
007481 0000          .dw intvec
007482 7198          .dw XT_PLUS
007483 732a          .dw XT_STOREE
007484 701b          .dw XT_EXIT
                 .include "words/int-fetch.asm"
                 
                 ; Interrupt
                 ; fetches XT from interrupt vector i
                 VE_INTFETCH:
007485 ff04          .dw $ff04
007486 6e69
007487 4074          .db "int@"
007488 747b          .dw VE_HEAD
                     .set VE_HEAD = VE_INTFETCH
                 XT_INTFETCH:
007489 7001          .dw DO_COLON
                 PFA_INTFETCH:
00748a 7038          .dw XT_DOLITERAL
00748b 0000          .dw intvec
00748c 7198          .dw XT_PLUS
00748d 734e          .dw XT_FETCHE
00748e 701b          .dw XT_EXIT
                 .include "words/int-trap.asm"
                 
                 ; Interrupt
                 ; trigger an interrupt
                 VE_INTTRAP:
00748f ff08          .dw $ff08
007490 6e69
007491 2d74
007492 7274
007493 7061          .db "int-trap"
007494 7485          .dw VE_HEAD
                     .set VE_HEAD = VE_INTTRAP
                 XT_INTTRAP:
007495 7496          .dw PFA_INTTRAP
                 PFA_INTTRAP:
007496 9380 0116     sts intcur, tosl
007498 9189
007499 9199          loadtos
00749a 9468          set ; set the interrupt flag for the inner interpreter
00749b cb69          jmp_ DO_NEXT
                 
                 .include "words/isr-exec.asm"
                 
                 ; Interrupt
                 ; executes an interrupt service routine
                 ;VE_ISREXEC:
                 ;    .dw $ff08
                 ;    .db "isr-exec"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_ISREXEC
                 XT_ISREXEC:
00749c 7001          .dw DO_COLON
                 PFA_ISREXEC:
00749d 7038          .dw XT_DOLITERAL
00749e 0116          .dw intcur
00749f 7093          .dw XT_CFETCH
0074a0 7038          .dw XT_DOLITERAL
0074a1 0000          .dw intvec
0074a2 7198          .dw XT_PLUS
0074a3 734e          .dw XT_FETCHE
0074a4 7025          .dw XT_EXECUTE
0074a5 74a7          .dw XT_ISREND
0074a6 701b          .dw XT_EXIT
                 .include "words/isr-end.asm"
                 
                 ; Interrupt
                 ; re-enables interrupts in an ISR
                 ;VE_ISREND:
                 ;    .dw $ff07
                 ;    .db "isr-end",0
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_ISREND
                 XT_ISREND:
0074a7 74a8          .dw PFA_ISREND
                 PFA_ISREND:
0074a8 d001          rcall PFA_ISREND1 ; clear the interrupt flag for the controller
0074a9 cb5b          jmp_ DO_NEXT
                 PFA_ISREND1:
0074aa 9518          reti
                 
                 .include "words/pick.asm"
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_PICK:
0074ab ff04          .dw $ff04
0074ac 6970
0074ad 6b63          .db "pick"
0074ae 748f          .dw VE_HEAD
                     .set VE_HEAD = VE_PICK
                 XT_PICK:
0074af 7001          .dw DO_COLON
                 PFA_PICK:
                 .endif
0074b0 722a          .dw XT_1PLUS
0074b1 7558          .dw XT_CELLS
0074b2 727c          .dw XT_SP_FETCH
0074b3 7198          .dw XT_PLUS
0074b4 7074          .dw XT_FETCH
0074b5 701b          .dw XT_EXIT
                 .include "words/dot-quote.asm"
                 
                 ; Compiler
                 ; compiles string into dictionary to be printed at runtime
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 
                 VE_DOTSTRING:
0074b6 0002          .dw $0002
0074b7 222e          .db ".",$22
0074b8 74ab          .dw VE_HEAD
                     .set VE_HEAD = VE_DOTSTRING
                 XT_DOTSTRING:
0074b9 7001          .dw DO_COLON
                 PFA_DOTSTRING:
                 .endif
0074ba 74c1          .dw XT_SQUOTE
0074bb 01bd          .dw XT_COMPILE
0074bc 77aa          .dw XT_ITYPE
0074bd 701b          .dw XT_EXIT
                 .include "words/squote.asm"
                 
                 ; Compiler
                 ; compiles a string to flash, at runtime leaves ( -- flash-addr count) on stack
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SQUOTE:
0074be 0002        .dw $0002
0074bf 2273        .db "s",$22
0074c0 74b6        .dw VE_HEAD
                   .set VE_HEAD = VE_SQUOTE
                 XT_SQUOTE:
0074c1 7001          .dw DO_COLON
                 PFA_SQUOTE:
                 .endif
0074c2 7038          .dw XT_DOLITERAL
0074c3 0022          .dw 34   ; 0x22 
0074c4 7989          .dw XT_PARSE       ; ( -- addr n)
0074c5 754b          .dw XT_STATE
0074c6 7074          .dw XT_FETCH
0074c7 7031          .dw XT_DOCONDBRANCH
0074c8 74ca          DEST(PFA_SQUOTE1)
0074c9 01e9            .dw XT_SLITERAL
                 PFA_SQUOTE1:
0074ca 701b          .dw XT_EXIT
                 
                 .include "words/fill.asm"
                 
                 ; Memory
                 ; fill u bytes memory beginning at a-addr with character c
                 VE_FILL:
0074cb ff04          .dw $ff04
0074cc 6966
0074cd 6c6c          .db "fill"
0074ce 74be          .dw VE_HEAD
                     .set VE_HEAD = VE_FILL
                 XT_FILL:
0074cf 7001          .dw DO_COLON
                 PFA_FILL:
0074d0 70dc          .dw XT_ROT
0074d1 70dc          .dw XT_ROT
0074d2 70b4
0074d3 7031          .dw XT_QDUP,XT_DOCONDBRANCH
0074d4 74dc          DEST(PFA_FILL2)
0074d5 7d4d          .dw XT_BOUNDS
0074d6 728a          .dw XT_DODO
                 PFA_FILL1:
0074d7 70ac          .dw XT_DUP
0074d8 729b          .dw XT_I
0074d9 7088          .dw XT_CSTORE  ; ( -- c c-addr)
0074da 72b8          .dw XT_DOLOOP
0074db 74d7          .dw PFA_FILL1
                 PFA_FILL2:
0074dc 70d4          .dw XT_DROP
0074dd 701b          .dw XT_EXIT
                 
                 .include "words/environment.asm"
                 
                 ; System Value
                 ; word list identifier of the environmental search list
                 VE_ENVIRONMENT:
0074de ff0b          .dw $ff0b
0074df 6e65
0074e0 6976
0074e1 6f72
0074e2 6d6e
0074e3 6e65
0074e4 0074          .db "environment",0
0074e5 74cb          .dw VE_HEAD
                     .set VE_HEAD = VE_ENVIRONMENT
                 XT_ENVIRONMENT:
0074e6 7043          .dw PFA_DOVARIABLE
                 PFA_ENVIRONMENT:
0074e7 0044          .dw EE_ENVIRONMENT
                 .include "words/env-wordlists.asm"
                 
                 ; Environment
                 ; maximum number of wordlists in the dictionary search order
                 VE_ENVWORDLISTS:
0074e8 ff09          .dw $ff09
0074e9 6f77
0074ea 6472
0074eb 696c
0074ec 7473
0074ed 0073          .db "wordlists",0
0074ee 0000          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENVWORDLISTS
                 XT_ENVWORDLISTS:
0074ef 7001          .dw DO_COLON
                 PFA_ENVWORDLISTS:
0074f0 7038          .dw XT_DOLITERAL
0074f1 0008          .dw NUMWORDLISTS
0074f2 701b          .dw XT_EXIT
                 .include "words/env-slashpad.asm"
                 
                 ; Environment
                 ; Size of the PAD buffer in bytes
                 VE_ENVSLASHPAD:
0074f3 ff04          .dw $ff04
0074f4 702f
0074f5 6461          .db "/pad"
0074f6 74e8          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENVSLASHPAD
                 XT_ENVSLASHPAD:
0074f7 7001          .dw DO_COLON
                 PFA_ENVSLASHPAD:
0074f8 727c          .dw XT_SP_FETCH
0074f9 758a          .dw XT_PAD
0074fa 718e          .dw XT_MINUS
0074fb 701b          .dw XT_EXIT
                 .include "words/env-slashhold.asm"
                 
                 ; Environment
                 ; size of the pictured numeric output buffer in bytes
                 VE_ENVSLASHHOLD:
0074fc ff05          .dw $ff05
0074fd 682f
0074fe 6c6f
0074ff 0064          .db "/hold",0
007500 74f3          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENVSLASHHOLD
                 XT_ENVSLASHHOLD:
007501 7001          .dw DO_COLON
                 PFA_ENVSLASHHOLD:
007502 758a          .dw XT_PAD
007503 75c5          .dw XT_HERE
007504 718e          .dw XT_MINUS
007505 701b          .dw XT_EXIT
                 .include "words/env-forthname.asm"
                 
                 ; Environment
                 ; flash address of the amforth name string
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_ENV_FORTHNAME:
007506 ff0a          .dw $ff0a
007507 6f66
007508 7472
007509 2d68
00750a 616e
00750b 656d          .db "forth-name"
00750c 74fc          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENV_FORTHNAME
                 XT_ENV_FORTHNAME:
00750d 7001          .dw DO_COLON
                 PFA_EN_FORTHNAME:
00750e 7777          .dw XT_DOSLITERAL
00750f 0007          .dw 7
                 .endif
007510 6d61
007511 6f66
007512 7472
../../common\words/env-forthname.asm(22): warning: .cseg .db misalignment - padding zero byte
007513 0068          .db "amforth"
                 .if cpu_msp430==1
                 .endif
007514 701b          .dw XT_EXIT
                 .include "words/env-forthversion.asm"
                 
                 ; Environment
                 ; version number of amforth
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_ENV_FORTHVERSION:
007515 ff07          .dw $ff07
007516 6576
007517 7372
007518 6f69
007519 006e          .db "version",0
00751a 7506          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENV_FORTHVERSION
                 XT_ENV_FORTHVERSION:
00751b 7001          .dw DO_COLON
                 PFA_EN_FORTHVERSION:
                 .endif
00751c 7038          .dw XT_DOLITERAL
00751d 003b          .dw 59
00751e 701b          .dw XT_EXIT
                 .include "words/env-cpu.asm"
                 
                 ; Environment
                 ; flash address of the CPU identification string
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_ENV_CPU:
00751f ff03          .dw $ff03
007520 7063
007521 0075          .db "cpu",0
007522 7515          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENV_CPU
                 XT_ENV_CPU:
007523 7001          .dw DO_COLON
                 PFA_EN_CPU:
007524 7038          .dw XT_DOLITERAL
007525 003b          .dw mcu_name
007526 77d6          .dw XT_ICOUNT
                 .endif
007527 701b          .dw XT_EXIT
                 .include "words/env-mcuinfo.asm"
                 
                 ; Environment
                 ; flash address of some CPU specific parameters
                 VE_ENV_MCUINFO:
007528 ff08          .dw $ff08
007529 636d
00752a 2d75
00752b 6e69
00752c 6f66          .db "mcu-info"
00752d 751f          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENV_MCUINFO
                 XT_ENV_MCUINFO:
00752e 7001          .dw DO_COLON
                 PFA_EN_MCUINFO:
00752f 7038          .dw XT_DOLITERAL
007530 0037          .dw mcu_info
007531 701b          .dw XT_EXIT
                 .include "words/env-usersize.asm"
                 
                 ; Environment
                 ; size of the USER area in bytes
                 VE_ENVUSERSIZE:
007532 ff05          .dw $ff05
007533 752f
007534 6573
007535 0072          .db "/user",0
007536 7528          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENVUSERSIZE
                 XT_ENVUSERSIZE:
007537 7001          .dw DO_COLON
                 PFA_ENVUSERSIZE:
007538 7038          .dw XT_DOLITERAL
007539 0026          .dw SYSUSERSIZE + APPUSERSIZE
00753a 701b          .dw XT_EXIT
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/f_cpu.asm"
                 
                 ; System
                 ; put the cpu frequency in Hz on stack
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_F_CPU:
00753b ff05          .dw $ff05
00753c 5f66
00753d 7063
00753e 0075          .db "f_cpu",0
00753f 74de          .dw VE_HEAD
                     .set VE_HEAD = VE_F_CPU
                 XT_F_CPU:
007540 7001          .dw DO_COLON
                 PFA_F_CPU:
                 .endif
007541 7038          .dw XT_DOLITERAL
007542 2400          .dw (F_CPU % 65536)
007543 7038          .dw XT_DOLITERAL
007544 00f4          .dw (F_CPU / 65536)
007545 701b          .dw XT_EXIT
                 .include "words/state.asm"
                 
                 ; System Variable
                 ; system state
                 VE_STATE:
007546 ff05          .dw $ff05
007547 7473
007548 7461
007549 0065          .db "state",0
00754a 753b          .dw VE_HEAD
                     .set VE_HEAD = VE_STATE
                 XT_STATE:
00754b 7043          .dw PFA_DOVARIABLE
                 PFA_STATE:
00754c 011f          .dw ram_state
                 
                 .dseg
00011f           ram_state: .byte 2
                 .include "words/base.asm"
                 
                 ; Numeric IO
                 ; location of the cell containing the number conversion radix
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_BASE:
00754d ff04          .dw $ff04
00754e 6162
00754f 6573          .db "base"
007550 7546          .dw VE_HEAD
                     .set VE_HEAD = VE_BASE
                 XT_BASE:
007551 7053          .dw PFA_DOUSER
                 PFA_BASE:
                 .endif
007552 000c          .dw USER_BASE
                 
                 .include "words/cells.asm"
                 
                 ; Arithmetics
                 ; n2 is the size in address units of n1 cells
                 VE_CELLS:
007553 ff05          .dw $ff05
007554 6563
007555 6c6c
007556 0073          .db "cells",0
007557 754d          .dw VE_HEAD
                     .set VE_HEAD = VE_CELLS
                 XT_CELLS:
007558 7207          .dw PFA_2STAR
                 .include "words/cellplus.asm"
                 
                 ; Arithmetics
                 ; add the size of an address-unit to a-addr1
                 VE_CELLPLUS:
007559 ff05          .dw $ff05
00755a 6563
00755b 6c6c
00755c 002b          .db "cell+",0
00755d 7553          .dw VE_HEAD
                     .set VE_HEAD = VE_CELLPLUS
                 XT_CELLPLUS:
00755e 755f          .dw PFA_CELLPLUS
                 PFA_CELLPLUS:
00755f 9602          adiw tosl, CELLSIZE
007560 caa4          jmp_ DO_NEXT
                 
                 .include "words/2dup.asm"
                 
                 ; Stack
                 ; Duplicate the 2 top elements
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_2DUP:
007561 ff04          .dw $ff04
007562 6432
007563 7075          .db "2dup"
007564 7559          .dw VE_HEAD
                     .set VE_HEAD = VE_2DUP
                 XT_2DUP:
007565 7001          .dw DO_COLON
                 PFA_2DUP:
                 .endif
                 
007566 70ca          .dw XT_OVER
007567 70ca          .dw XT_OVER
007568 701b          .dw XT_EXIT
                 .include "words/2drop.asm"
                 
                 ; Stack
                 ; Remove the 2 top elements
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_2DROP:
007569 ff05          .dw $ff05
00756a 6432
00756b 6f72
00756c 0070          .db "2drop",0
00756d 7561          .dw VE_HEAD
                     .set VE_HEAD = VE_2DROP
                 XT_2DROP:
00756e 7001          .dw DO_COLON
                 PFA_2DROP:
                 .endif
00756f 70d4          .dw XT_DROP
007570 70d4          .dw XT_DROP
007571 701b          .dw XT_EXIT
                 
                 .include "words/tuck.asm"
                 
                 ; Stack
                 ; Copy the first (top) stack item below the second stack item. 
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_TUCK:
007572 ff04          .dw $ff04
007573 7574
007574 6b63          .db "tuck"
007575 7569          .dw VE_HEAD
                     .set VE_HEAD = VE_TUCK
                 XT_TUCK:
007576 7001          .dw DO_COLON
                 PFA_TUCK:
                 .endif
007577 70bf          .dw XT_SWAP
007578 70ca          .dw XT_OVER
007579 701b          .dw XT_EXIT
                 
                 .include "words/to-in.asm"
                 
                 ; System Variable
                 ; pointer to current read position in input buffer
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_TO_IN:
00757a ff03          .dw $ff03
00757b 693e
00757c 006e          .db ">in",0
00757d 7572          .dw VE_HEAD
                     .set VE_HEAD = VE_TO_IN
                 XT_TO_IN:
00757e 7053          .dw PFA_DOUSER
                 PFA_TO_IN:
                 .endif
00757f 0018          .dw USER_TO_IN
                 .include "words/sharptib.asm"
                 
                 ; System Variable
                 ; variable holding the number of characters in TIB
                 VE_NUMBERTIB:
007580 ff04          .dw $ff04
007581 7423
007582 6269          .db "#tib"
007583 757a          .dw VE_HEAD
                     .set VE_HEAD  = VE_NUMBERTIB
                 XT_NUMBERTIB:
007584 7043          .dw PFA_DOVARIABLE
                 PFA_NUMBERTIB:
007585 0121          .dw ram_sharptib
                 
                 .dseg
000121           ram_sharptib: .byte 2
                 .cseg
                  
                 .include "words/pad.asm"
                 
                 ; System Variable
                 ; Address of the temporary scratch buffer.
                 VE_PAD:
007586 ff03          .dw $ff03
007587 6170
007588 0064          .db "pad",0
007589 7580          .dw VE_HEAD
                     .set VE_HEAD = VE_PAD
                 XT_PAD:
00758a 7001          .dw DO_COLON
                 PFA_PAD:
00758b 75c5          .dw XT_HERE
00758c 7038          .dw XT_DOLITERAL
00758d 0064          .dw 100
00758e 7198          .dw XT_PLUS
00758f 701b          .dw XT_EXIT
                 .include "words/emit.asm"
                 
                 ; Character IO
                 ; fetch the emit vector and execute it. should emit a character from TOS
                 VE_EMIT:
007590 ff04          .dw $ff04
007591 6d65
007592 7469          .db "emit"
007593 7586          .dw VE_HEAD
                     .set VE_HEAD = VE_EMIT
                 XT_EMIT:
007594 7c06          .dw PFA_DODEFER1
                 PFA_EMIT:
007595 000e          .dw USER_EMIT
007596 7bcf          .dw XT_UDEFERFETCH
007597 7bdb          .dw XT_UDEFERSTORE
                 .include "words/emitq.asm"
                 
                 ; Character IO
                 ; fetch emit? vector and execute it. should return the ready-to-send condition
                 VE_EMITQ:
007598 ff05          .dw $ff05
007599 6d65
00759a 7469
00759b 003f          .db "emit?",0
00759c 7590          .dw VE_HEAD
                     .set VE_HEAD = VE_EMITQ
                 XT_EMITQ:
00759d 7c06          .dw PFA_DODEFER1
                 PFA_EMITQ:
00759e 0010          .dw USER_EMITQ
00759f 7bcf          .dw XT_UDEFERFETCH
0075a0 7bdb          .dw XT_UDEFERSTORE
                 .include "words/key.asm"
                 
                 ; Character IO
                 ; fetch key vector and execute it, should leave a single character on TOS
                 VE_KEY:
0075a1 ff03          .dw $ff03
0075a2 656b
0075a3 0079          .db "key",0
0075a4 7598          .dw VE_HEAD
                     .set VE_HEAD = VE_KEY
                 XT_KEY:
0075a5 7c06          .dw PFA_DODEFER1
                 PFA_KEY:
0075a6 0012          .dw USER_KEY
0075a7 7bcf          .dw XT_UDEFERFETCH
0075a8 7bdb          .dw XT_UDEFERSTORE
                 .include "words/keyq.asm"
                 
                 ; Character IO
                 ; fetch key? vector and execute it. should turn on key sender, if it is disabled/stopped
                 VE_KEYQ:
0075a9 ff04          .dw $ff04
0075aa 656b
0075ab 3f79          .db "key?"
0075ac 75a1          .dw VE_HEAD
                     .set VE_HEAD = VE_KEYQ
                 XT_KEYQ:
0075ad 7c06          .dw PFA_DODEFER1
                 PFA_KEYQ:
0075ae 0014          .dw USER_KEYQ
0075af 7bcf          .dw XT_UDEFERFETCH
0075b0 7bdb          .dw XT_UDEFERSTORE
                 
                 .include "words/dp.asm"
                 
                 ; System Value
                 ; address of the next free dictionary cell
                 VE_DP:
0075b1 ff02          .dw $ff02
0075b2 7064          .db "dp"
0075b3 75a9          .dw VE_HEAD
                     .set VE_HEAD = VE_DP
                 XT_DP:
0075b4 706a          .dw PFA_DOVALUE1
                 PFA_DP:
0075b5 003a          .dw EE_DP
0075b6 7ba7          .dw XT_EDEFERFETCH
0075b7 7bb1          .dw XT_EDEFERSTORE
                 .include "words/ehere.asm"
                 
                 ; System Value
                 ; address of the next free address in eeprom
                 VE_EHERE:
0075b8 ff05          .dw $ff05
0075b9 6865
0075ba 7265
0075bb 0065          .db "ehere",0
0075bc 75b1          .dw VE_HEAD
                     .set VE_HEAD = VE_EHERE
                 XT_EHERE:
0075bd 706a          .dw PFA_DOVALUE1
                 PFA_EHERE:
0075be 003e          .dw EE_EHERE
0075bf 7ba7          .dw XT_EDEFERFETCH
0075c0 7bb1          .dw XT_EDEFERSTORE
                 .include "words/here.asm"
                 
                 ; System Value
                 ; address of the next free data space (RAM) cell
                 VE_HERE:
0075c1 ff04          .dw $ff04
0075c2 6568
0075c3 6572          .db "here"
0075c4 75b8          .dw VE_HEAD
                     .set VE_HEAD = VE_HERE
                 XT_HERE:
0075c5 706a          .dw PFA_DOVALUE1
                 PFA_HERE:
0075c6 003c          .dw EE_HERE
0075c7 7ba7          .dw XT_EDEFERFETCH
0075c8 7bb1          .dw XT_EDEFERSTORE
                 .include "words/allot.asm"
                 
                 ; System
                 ; allocate or release memory in RAM
                 VE_ALLOT:
0075c9 ff05          .dw $ff05
0075ca 6c61
0075cb 6f6c
0075cc 0074          .db "allot",0
0075cd 75c1          .dw VE_HEAD
                     .set VE_HEAD = VE_ALLOT
                 XT_ALLOT:
0075ce 7001          .dw DO_COLON
                 PFA_ALLOT:
0075cf 75c5          .dw XT_HERE
0075d0 7198          .dw XT_PLUS
0075d1 7b8c          .dw XT_DOTO
0075d2 75c6          .dw PFA_HERE
0075d3 701b          .dw XT_EXIT
                 
                 .include "words/bin.asm"
                 
                 ; Numeric IO
                 ; set base for numeric conversion to 10
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_BIN:
0075d4 ff03          .dw $ff03
0075d5 6962
0075d6 006e          .db "bin",0
0075d7 75c9          .dw VE_HEAD
                     .set VE_HEAD = VE_BIN
                 XT_BIN:
0075d8 7001          .dw DO_COLON
                 PFA_BIN:
                 .endif
0075d9 7038          .dw XT_DOLITERAL
0075da 0002          .dw 2
0075db 7551          .dw XT_BASE
0075dc 707c          .dw XT_STORE
0075dd 701b          .dw XT_EXIT
                 .include "words/decimal.asm"
                 
                 ; Numeric IO
                 ; set base for numeric conversion to 10
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DECIMAL:
0075de ff07          .dw $ff07
0075df 6564
0075e0 6963
0075e1 616d
0075e2 006c          .db "decimal",0
0075e3 75d4          .dw VE_HEAD
                     .set VE_HEAD = VE_DECIMAL
                 XT_DECIMAL:
0075e4 7001          .dw DO_COLON
                 PFA_DECIMAL:
                 .endif
0075e5 7038          .dw XT_DOLITERAL
0075e6 000a          .dw 10
0075e7 7551          .dw XT_BASE
0075e8 707c          .dw XT_STORE
0075e9 701b          .dw XT_EXIT
                 .include "words/hex.asm"
                 
                 ; Numeric IO
                 ; set base for numeric conversion to 10
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_HEX:
0075ea ff03          .dw $ff03
0075eb 6568
0075ec 0078          .db "hex",0
0075ed 75de          .dw VE_HEAD
                     .set VE_HEAD = VE_HEX
                 XT_HEX:
0075ee 7001          .dw DO_COLON
                 PFA_HEX:
                 .endif
0075ef 7038          .dw XT_DOLITERAL
0075f0 0010          .dw 16
0075f1 7551          .dw XT_BASE
0075f2 707c          .dw XT_STORE
0075f3 701b          .dw XT_EXIT
                 .include "words/bl.asm"
                 
                 ; Character IO
                 ; put ascii code of the blank to the stack
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_BL:
0075f4 ff02          .dw $ff02
0075f5 6c62          .db "bl"
0075f6 75ea          .dw VE_HEAD
                     .set VE_HEAD = VE_BL
                 XT_BL:
0075f7 7043          .dw PFA_DOVARIABLE
                 PFA_BL:
                 .endif
0075f8 0020          .dw 32
                 
                 .include "words/turnkey.asm"
                 
                 ; System Value
                 ; Deferred action during startup/reset
                 VE_TURNKEY:
0075f9 ff07          .dw $ff07
0075fa 7574
0075fb 6e72
0075fc 656b
0075fd 0079          .db "turnkey",0
0075fe 75f4          .dw VE_HEAD
                     .set VE_HEAD = VE_TURNKEY
                 XT_TURNKEY:
0075ff 7c06          .dw PFA_DODEFER1
                 PFA_TURNKEY:
007600 0040          .dw EE_TURNKEY
007601 7ba7          .dw XT_EDEFERFETCH
007602 7bb1          .dw XT_EDEFERSTORE
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/slashmod.asm"
                 
                 ; Arithmetics
                 ; signed division n1/n2 with remainder and quotient
                 VE_SLASHMOD:
007603 ff04          .dw $ff04
007604 6d2f
007605 646f          .db "/mod"
007606 75f9          .dw VE_HEAD
                     .set VE_HEAD = VE_SLASHMOD
                 XT_SLASHMOD:
007607 7608          .dw PFA_SLASHMOD
                 PFA_SLASHMOD:
007608 019c          movw temp2, tosl
                     
007609 9109          ld temp0, Y+
00760a 9119          ld temp1, Y+
                 
00760b 2f41          mov	temp6,temp1	;move dividend High to sign register
00760c 2743          eor	temp6,temp3	;xor divisor High with sign register
00760d ff17          sbrs	temp1,7	;if MSB in dividend set
00760e c004          rjmp	PFA_SLASHMOD_1
00760f 9510          com	temp1		;    change sign of dividend
007610 9500          com	temp0		
007611 5f0f          subi	temp0,low(-1)
007612 4f1f          sbci	temp1,high(-1)
                 PFA_SLASHMOD_1:	
007613 ff37          sbrs	temp3,7	;if MSB in divisor set
007614 c004          rjmp	PFA_SLASHMOD_2
007615 9530          com	temp3		;    change sign of divisor
007616 9520          com	temp2		
007617 5f2f          subi	temp2,low(-1)
007618 4f3f          sbci	temp3,high(-1)
007619 24ee      PFA_SLASHMOD_2:	clr	temp4	;clear remainder Low byte
00761a 18ff          sub	temp5,temp5;clear remainder High byte and carry
00761b e151          ldi	temp7,17	;init loop counter
                 
00761c 1f00      PFA_SLASHMOD_3:	rol	temp0		;shift left dividend
00761d 1f11          rol	temp1
00761e 955a          dec	temp7		;decrement counter
00761f f439          brne	PFA_SLASHMOD_5		;if done
007620 ff47          sbrs	temp6,7		;    if MSB in sign register set
007621 c004          rjmp	PFA_SLASHMOD_4
007622 9510          com	temp1	;        change sign of result
007623 9500          com	temp0
007624 5f0f          subi	temp0,low(-1)
007625 4f1f          sbci	temp1,high(-1)
007626 c00b      PFA_SLASHMOD_4:	rjmp PFA_SLASHMODmod_done			;    return
007627 1cee      PFA_SLASHMOD_5:	rol	temp4	;shift dividend into remainder
007628 1cff          rol	temp5
007629 1ae2          sub	temp4,temp2	;remainder = remainder - divisor
00762a 0af3          sbc	temp5,temp3	;
00762b f420          brcc	PFA_SLASHMOD_6		;if result negative
00762c 0ee2          add	temp4,temp2	;    restore remainder
00762d 1ef3          adc	temp5,temp3
00762e 9488          clc			;    clear carry to be shifted into result
00762f cfec          rjmp	PFA_SLASHMOD_3		;else
007630 9408      PFA_SLASHMOD_6:	sec			;    set carry to be shifted into result
007631 cfea          rjmp	PFA_SLASHMOD_3
                 
                 PFA_SLASHMODmod_done:
                     ; put remainder on stack
007632 92fa          st -Y,temp5
007633 92ea          st -Y,temp4
                 
                     ; put quotient on stack
007634 01c8          movw tosl, temp0
007635 c9cf          jmp_ DO_NEXT
                 .include "words/uslashmod.asm"
                 
                 ; Arithmetics
                 ; unsigned division with remainder
                 VE_USLASHMOD:
007636 ff05          .dw $ff05
007637 2f75
007638 6f6d
007639 0064          .db "u/mod",0
00763a 7603          .dw VE_HEAD
                     .set VE_HEAD = VE_USLASHMOD
                 XT_USLASHMOD:
00763b 7001          .dw DO_COLON
                 PFA_USLASHMOD:
00763c 70fa          .dw XT_TO_R
00763d 714f          .dw XT_ZERO
00763e 70f1          .dw XT_R_FROM
00763f 71bd          .dw XT_UMSLASHMOD
007640 701b          .dw XT_EXIT
                 .include "words/negate.asm"
                 
                 ; Logic
                 ; 2-complement
                 VE_NEGATE:
007641 ff06          .dw $ff06
007642 656e
007643 6167
007644 6574          .db "negate"
007645 7636          .dw VE_HEAD
                     .set VE_HEAD = VE_NEGATE
                 XT_NEGATE:
007646 7001          .dw DO_COLON
                 PFA_NEGATE:
007647 71f8          .dw XT_INVERT
007648 722a          .dw XT_1PLUS
007649 701b          .dw XT_EXIT
                 .include "words/slash.asm"
                 
                 ; Arithmetics
                 ; divide n1 by n2. giving the quotient
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 
                 VE_SLASH:
00764a ff01          .dw $ff01
00764b 002f          .db "/",0
00764c 7641          .dw VE_HEAD
                     .set VE_HEAD = VE_SLASH
                 XT_SLASH:
00764d 7001          .dw DO_COLON
                 PFA_SLASH:
                 .endif
00764e 7607          .dw XT_SLASHMOD
00764f 70eb          .dw XT_NIP
007650 701b          .dw XT_EXIT
                 
                 .include "words/mod.asm"
                 
                 ; Arithmetics
                 ; divide n1 by n2 giving the remainder n3
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 
                 VE_MOD:
007651 ff03          .dw $ff03
007652 6f6d
007653 0064          .db "mod",0
007654 764a          .dw VE_HEAD
                     .set VE_HEAD = VE_MOD
                 XT_MOD:
007655 7001          .dw DO_COLON
                 PFA_MOD:
                 .endif
007656 7607          .dw XT_SLASHMOD
007657 70d4          .dw XT_DROP
007658 701b          .dw XT_EXIT
                 .include "words/abs.asm"
                 
                 ; Arithmetics
                 ; get the absolute value
                 VE_ABS:
007659 ff03          .dw $ff03
00765a 6261
00765b 0073          .db "abs",0
00765c 7651          .dw VE_HEAD
                     .set VE_HEAD = VE_ABS
                 XT_ABS:
00765d 765e          .dw PFA_ABS
                 PFA_ABS:
00765e 2399          tst tosh
00765f f41a          brpl PFA_ABS1
007660 9580          com tosl
007661 9590          com tosh
007662 9601          adiw tosl, 1
                 PFA_ABS1:
007663 c9a1          jmp_ do_next
                 .include "words/min.asm"
                 
                 ; Compare
                 ; compare two values leave the smaller one
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 
                 VE_MIN:
007664 ff03          .dw $ff03
007665 696d
007666 006e          .db "min",0
007667 7659          .dw VE_HEAD
                     .set VE_HEAD = VE_MIN
                 XT_MIN:
007668 7001          .dw DO_COLON
                 PFA_MIN:
                 .endif
007669 7565          .dw XT_2DUP
00766a 7173          .dw XT_GREATER
00766b 7031          .dw XT_DOCONDBRANCH
00766c 766e          DEST(PFA_MIN1)
00766d 70bf          .dw XT_SWAP
                 PFA_MIN1:
00766e 70d4          .dw XT_DROP
00766f 701b          .dw XT_EXIT
                 .include "words/max.asm"
                 
                 ; Compare
                 ; compare two values, leave the bigger one
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_MAX:
007670 ff03          .dw $ff03
007671 616d
007672 0078          .db "max",0
007673 7664          .dw VE_HEAD
                     .set VE_HEAD = VE_MAX
                 XT_MAX:
007674 7001          .dw DO_COLON
                 PFA_MAX:
                 
                 .endif
007675 7565          .dw XT_2DUP
007676 7169          .dw XT_LESS
007677 7031          .dw XT_DOCONDBRANCH
007678 767a          DEST(PFA_MAX1)
007679 70bf          .dw XT_SWAP
                 PFA_MAX1:
00767a 70d4          .dw XT_DROP
00767b 701b          .dw XT_EXIT
                 .include "words/within.asm"
                 
                 ; Compare
                 ; check if n is within min..max
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_WITHIN:
00767c ff06          .dw $ff06
00767d 6977
00767e 6874
00767f 6e69          .db "within"
007680 7670          .dw VE_HEAD
                     .set VE_HEAD = VE_WITHIN
                 XT_WITHIN:
007681 7001          .dw DO_COLON
                 PFA_WITHIN:
                 .endif
007682 70ca          .dw XT_OVER
007683 718e          .dw XT_MINUS
007684 70fa          .dw XT_TO_R
007685 718e          .dw XT_MINUS
007686 70f1          .dw XT_R_FROM
007687 7157          .dw XT_ULESS
007688 701b          .dw XT_EXIT
                 
                 .include "words/to-upper.asm"
                 
                 ; String
                 ; if c is a lowercase letter convert it to uppercase
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_TOUPPER:
007689 ff07          .dw $ff07 
00768a 6f74
00768b 7075
00768c 6570
00768d 0072          .db "toupper",0
00768e 767c          .dw VE_HEAD
                     .set VE_HEAD = VE_TOUPPER
                 XT_TOUPPER:
00768f 7001          .dw DO_COLON 
                 PFA_TOUPPER:
                 .endif
007690 70ac          .dw XT_DUP 
007691 7038          .dw XT_DOLITERAL 
007692 0061          .dw 'a' 
007693 7038          .dw XT_DOLITERAL 
007694 007b          .dw 'z'+1
007695 7681          .dw XT_WITHIN 
007696 7031          .dw XT_DOCONDBRANCH
007697 769b          DEST(PFA_TOUPPER0)
007698 7038          .dw XT_DOLITERAL
007699 00df          .dw 223 ; inverse of 0x20: 0xdf
00769a 720e          .dw XT_AND 
                 PFA_TOUPPER0:
00769b 701b          .dw XT_EXIT 
                 .include "words/to-lower.asm"
                 
                 ; String
                 ; if C is an uppercase letter convert it to lowercase
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 
                 VE_TOLOWER:
00769c ff07          .dw $ff07
00769d 6f74
00769e 6f6c
00769f 6577
0076a0 0072          .db "tolower",0
0076a1 7689          .dw VE_HEAD
                     .set VE_HEAD = VE_TOLOWER
                 XT_TOLOWER:
0076a2 7001          .dw DO_COLON
                 PFA_TOLOWER:
                 .endif
0076a3 70ac          .dw XT_DUP
0076a4 7038          .dw XT_DOLITERAL
0076a5 0041          .dw 'A'
0076a6 7038          .dw XT_DOLITERAL
0076a7 005b          .dw 'Z'+1
0076a8 7681          .dw XT_WITHIN
0076a9 7031          .dw XT_DOCONDBRANCH
0076aa 76ae          DEST(PFA_TOLOWER0)
0076ab 7038          .dw XT_DOLITERAL
0076ac 0020          .dw 32
0076ad 7217          .dw XT_OR 
                 PFA_TOLOWER0:
0076ae 701b          .dw XT_EXIT 
                 ;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/hld.asm"
                 
                 ; Numeric IO
                 ; pointer to current write position in the Pictured Numeric Output buffer
                 VE_HLD:
0076af ff03          .dw $ff03
0076b0 6c68
0076b1 0064          .db "hld",0
0076b2 769c          .dw VE_HEAD
                     .set VE_HEAD = VE_HLD
                 XT_HLD:
0076b3 7043          .dw PFA_DOVARIABLE
                 PFA_HLD:
0076b4 0123          .dw ram_hld
                 
                 .dseg
000123           ram_hld: .byte 2
                 .cseg
                 .include "words/hold.asm"
                 
                 ; Numeric IO
                 ; prepend character to pictured numeric output buffer
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_HOLD:
0076b5 ff04          .dw $ff04
0076b6 6f68
0076b7 646c          .db "hold"
0076b8 76af          .dw VE_HEAD
                     .set VE_HEAD = VE_HOLD
                 XT_HOLD:
0076b9 7001          .dw DO_COLON
                 PFA_HOLD:
                 .endif
0076ba 76b3          .dw XT_HLD
0076bb 70ac          .dw XT_DUP
0076bc 7074          .dw XT_FETCH
0076bd 7230          .dw XT_1MINUS
0076be 70ac          .dw XT_DUP
0076bf 70fa          .dw XT_TO_R
0076c0 70bf          .dw XT_SWAP
0076c1 707c          .dw XT_STORE
0076c2 70f1          .dw XT_R_FROM
0076c3 7088          .dw XT_CSTORE
0076c4 701b          .dw XT_EXIT
                 .include "words/less-sharp.asm" ; <#
                 
                 ; Numeric IO
                 ; initialize the pictured numeric output conversion process
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_L_SHARP:
0076c5 ff02          .dw $ff02
0076c6 233c          .db "<#"
0076c7 76b5          .dw VE_HEAD
                     .set VE_HEAD = VE_L_SHARP
                 XT_L_SHARP:
0076c8 7001          .dw DO_COLON
                 PFA_L_SHARP:
                 .endif
0076c9 758a          .dw XT_PAD
0076ca 76b3          .dw XT_HLD
0076cb 707c          .dw XT_STORE
0076cc 701b          .dw XT_EXIT
                 .include "words/sharp.asm"
                 
                 ; Numeric IO
                 ; pictured numeric output: convert one digit
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 
                 VE_SHARP:
0076cd ff01          .dw $ff01
0076ce 0023          .db "#",0
0076cf 76c5          .dw VE_HEAD
                     .set VE_HEAD = VE_SHARP
                 XT_SHARP:
0076d0 7001          .dw DO_COLON
                 PFA_SHARP:
                 .endif
0076d1 7551          .dw XT_BASE
0076d2 7074          .dw XT_FETCH
0076d3 774d          .dw XT_UDSLASHMOD
0076d4 70dc          .dw XT_ROT
0076d5 7038          .dw XT_DOLITERAL
0076d6 0009          .dw 9
0076d7 70ca          .dw XT_OVER
0076d8 7169          .dw XT_LESS
0076d9 7031          .dw XT_DOCONDBRANCH
0076da 76de          DEST(PFA_SHARP1)
0076db 7038          .dw XT_DOLITERAL
0076dc 0007          .dw 7
0076dd 7198          .dw XT_PLUS
                 PFA_SHARP1:
0076de 7038          .dw XT_DOLITERAL
0076df 0030          .dw 48 ; ASCII 0
0076e0 7198          .dw XT_PLUS
0076e1 76b9          .dw XT_HOLD
0076e2 701b          .dw XT_EXIT
                 ; : #    ( ud1 -- ud2 ) 
                 ;        base @ ud/mod rot 9 over < if 7 + then 30 + hold ; 
                 .include "words/sharp-s.asm"
                 
                 ; Numeric IO
                 ; pictured numeric output: convert all digits until 0 (zero) is reached
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SHARP_S:
0076e3 ff02          .dw $ff02
0076e4 7323          .db "#s"
0076e5 76cd          .dw VE_HEAD
                     .set VE_HEAD = VE_SHARP_S
                 XT_SHARP_S:
0076e6 7001          .dw DO_COLON
                 PFA_SHARP_S:
                 .endif
                 NUMS1:
0076e7 76d0          .dw XT_SHARP
0076e8 7565          .dw XT_2DUP
0076e9 7217          .dw XT_OR
0076ea 7115          .dw XT_ZEROEQUAL
0076eb 7031          .dw XT_DOCONDBRANCH
0076ec 76e7          DEST(NUMS1) ; PFA_SHARP_S
0076ed 701b          .dw XT_EXIT
                 .include "words/sharp-greater.asm" ; #>
                 
                 ; Numeric IO
                 ; Pictured Numeric Output: convert PNO buffer into an string
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SHARP_G:
0076ee ff02          .dw $ff02
0076ef 3e23          .db "#>"
0076f0 76e3          .dw VE_HEAD
                     .set VE_HEAD = VE_SHARP_G
                 XT_SHARP_G:
0076f1 7001          .dw DO_COLON
                 PFA_SHARP_G:
                 .endif
0076f2 756e          .dw XT_2DROP
0076f3 76b3          .dw XT_HLD
0076f4 7074          .dw XT_FETCH
0076f5 758a          .dw XT_PAD
0076f6 70ca          .dw XT_OVER
0076f7 718e          .dw XT_MINUS
0076f8 701b          .dw XT_EXIT
                 .include "words/sign.asm"
                 
                 ; Numeric IO
                 ; place a - in HLD if n is negative
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SIGN:
0076f9 ff04          .dw $ff04
0076fa 6973
0076fb 6e67          .db "sign"
0076fc 76ee          .dw VE_HEAD
                     .set VE_HEAD = VE_SIGN
                 XT_SIGN:
0076fd 7001          .dw DO_COLON
                 PFA_SIGN:
                 .endif
0076fe 711c          .dw XT_ZEROLESS
0076ff 7031          .dw XT_DOCONDBRANCH
007700 7704          DEST(PFA_SIGN1)
007701 7038          .dw XT_DOLITERAL
007702 002d          .dw 45 ; ascii -
007703 76b9          .dw XT_HOLD
                 PFA_SIGN1:
007704 701b          .dw XT_EXIT
                 .include "words/d-dot-r.asm"
                 
                 ; Numeric IO
                 ; singed PNO with double cell numbers, right aligned in width w
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DDOTR:
007705 ff03          .dw $ff03
007706 2e64
007707 0072          .db "d.r",0
007708 76f9          .dw VE_HEAD
                     .set VE_HEAD = VE_DDOTR
                 XT_DDOTR:
007709 7001          .dw DO_COLON
                 PFA_DDOTR:
                 
                 .endif
00770a 70fa          .dw XT_TO_R
00770b 7576          .dw XT_TUCK
00770c 7cc7          .dw XT_DABS
00770d 76c8          .dw XT_L_SHARP
00770e 76e6          .dw XT_SHARP_S
00770f 70dc          .dw XT_ROT
007710 76fd          .dw XT_SIGN
007711 76f1          .dw XT_SHARP_G
007712 70f1          .dw XT_R_FROM
007713 70ca          .dw XT_OVER
007714 718e          .dw XT_MINUS
007715 77f5          .dw XT_SPACES
007716 7805          .dw XT_TYPE
007717 701b          .dw XT_EXIT
                 ; : d.r       ( d n -- )
                 ;             >r swap over dabs <# #s rot sign #> r> over - spaces type ;
                 .include "words/dot-r.asm"
                 
                 ; Numeric IO
                 ; singed PNO with single cell numbers, right aligned in width w
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DOTR:
007718 ff02          .dw $ff02
007719 722e          .db ".r"
00771a 7705          .dw VE_HEAD
                     .set VE_HEAD = VE_DOTR
                 XT_DOTR:
00771b 7001          .dw DO_COLON
                 PFA_DOTR:
                 
                 .endif
00771c 70fa          .dw XT_TO_R
00771d 7d56          .dw XT_S2D
00771e 70f1          .dw XT_R_FROM
00771f 7709          .dw XT_DDOTR
007720 701b          .dw XT_EXIT
                 ; : .r        ( s n -- )  >r s>d r> d.r ;
                 .include "words/d-dot.asm"
                 
                 ; Numeric IO
                 ; singed PNO with double cell numbers
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DDOT:
007721 ff02          .dw $ff02
007722 2e64          .db "d."
007723 7718          .dw VE_HEAD
                     .set VE_HEAD = VE_DDOT
                 XT_DDOT:
007724 7001          .dw DO_COLON
                 PFA_DDOT:
                 
                 .endif
007725 714f          .dw XT_ZERO
007726 7709          .dw XT_DDOTR
007727 77ec          .dw XT_SPACE
007728 701b          .dw XT_EXIT
                 ; : d.        ( d -- )    0 d.r space ;
                 .include "words/dot.asm"
                 
                 ; Numeric IO
                 ; singed PNO with single cell numbers
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 
                 VE_DOT:
007729 ff01          .dw $ff01
00772a 002e          .db ".",0
00772b 7721          .dw VE_HEAD
                     .set VE_HEAD = VE_DOT
                 XT_DOT:
00772c 7001          .dw DO_COLON
                 PFA_DOT:
                 .endif
00772d 7d56          .dw XT_S2D
00772e 7724          .dw XT_DDOT
00772f 701b          .dw XT_EXIT
                 ; : .         ( s -- )    s>d d. ; 
                 .include "words/ud-dot.asm"
                 
                 ; Numeric IO
                 ; unsigned PNO with double cell numbers
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_UDDOT:
007730 ff03          .dw $ff03
007731 6475
007732 002e          .db "ud.",0
007733 7729          .dw VE_HEAD
                     .set VE_HEAD = VE_UDDOT
                 XT_UDDOT:
007734 7001          .dw DO_COLON
                 PFA_UDDOT:
                 .endif
007735 714f          .dw XT_ZERO
007736 773d          .dw XT_UDDOTR
007737 77ec          .dw XT_SPACE
007738 701b          .dw XT_EXIT
                 .include "words/ud-dot-r.asm"
                 
                 ; Numeric IO
                 ; unsigned PNO with double cell numbers, right aligned in width w
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 
                 VE_UDDOTR:
007739 ff04          .dw $ff04
00773a 6475
00773b 722e          .db "ud.r"
00773c 7730          .dw VE_HEAD
                     .set VE_HEAD = VE_UDDOTR
                 XT_UDDOTR:
00773d 7001          .dw DO_COLON
                 PFA_UDDOTR:
                 .endif
00773e 70fa          .dw XT_TO_R
00773f 76c8          .dw XT_L_SHARP
007740 76e6          .dw XT_SHARP_S
007741 76f1          .dw XT_SHARP_G
007742 70f1          .dw XT_R_FROM
007743 70ca          .dw XT_OVER
007744 718e          .dw XT_MINUS
007745 77f5          .dw XT_SPACES
007746 7805          .dw XT_TYPE
007747 701b          .dw XT_EXIT
                 .include "words/ud-slash-mod.asm"
                 
                 ; Arithmetics
                 ; unsigned double cell division with remainder
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_UDSLASHMOD:
007748 ff06          .dw $ff06
007749 6475
00774a 6d2f
00774b 646f          .db "ud/mod"
00774c 7739          .dw VE_HEAD
                     .set VE_HEAD = VE_UDSLASHMOD
                 XT_UDSLASHMOD:
00774d 7001          .dw DO_COLON
                 PFA_UDSLASHMOD:
                 .endif
00774e 70fa          .dw XT_TO_R
00774f 714f          .dw XT_ZERO
007750 7103          .dw XT_R_FETCH
007751 71bd          .dw XT_UMSLASHMOD
007752 70f1          .dw XT_R_FROM
007753 70bf          .dw XT_SWAP
007754 70fa          .dw XT_TO_R
007755 71bd          .dw XT_UMSLASHMOD
007756 70f1          .dw XT_R_FROM
007757 701b          .dw XT_EXIT
                 .include "words/digit-q.asm"
                 
                 ; Numeric IO
                 ; tries to convert a character to a number, set flag accordingly
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DIGITQ:
007758 ff06          .dw $ff06 
007759 6964
00775a 6967
00775b 3f74          .db "digit?"
00775c 7748          .dw VE_HEAD
                     .set VE_HEAD = VE_DIGITQ
                 XT_DIGITQ:
00775d 7001          .dw DO_COLON 
                 PFA_DIGITQ:
                 .endif
00775e 768f          .dw XT_TOUPPER
00775f 70ac
007760 7038
007761 0039
007762 7173
007763 7038
007764 0100          .DW XT_DUP,XT_DOLITERAL,57,XT_GREATER,XT_DOLITERAL,256
007765 720e
007766 7198
007767 70ac
007768 7038
007769 0140
00776a 7173          .DW XT_AND,XT_PLUS,XT_DUP,XT_DOLITERAL,320,XT_GREATER
00776b 7038
00776c 0107
00776d 720e
00776e 718e
00776f 7038
007770 0030          .DW XT_DOLITERAL,263,XT_AND,XT_MINUS,XT_DOLITERAL,48
007771 718e
007772 70ac
007773 7551
007774 7074
007775 7157          .DW XT_MINUS,XT_DUP,XT_BASE,XT_FETCH,XT_ULESS
007776 701b          .DW XT_EXIT
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/do-sliteral.asm"
                 
                 ; String
                 ; runtime portion of sliteral
                 ;VE_DOSLITERAL:
                 ;  .dw $ff0a
                 ;  .db "(sliteral)"
                 ;  .dw VE_HEAD
                 ;  .set VE_HEAD = VE_DOSLITERAL
                 XT_DOSLITERAL:
007777 7001        .dw DO_COLON
                 PFA_DOSLITERAL:
007778 7103        .dw XT_R_FETCH   ; ( -- addr )
007779 77d6        .dw XT_ICOUNT
00777a 70f1        .dw XT_R_FROM
00777b 70ca        .dw XT_OVER     ; ( -- addr' n addr n)
00777c 722a        .dw XT_1PLUS
00777d 71ff        .dw XT_2SLASH   ; ( -- addr' n addr k )
00777e 7198        .dw XT_PLUS     ; ( -- addr' n addr'' )
00777f 722a        .dw XT_1PLUS
007780 70fa        .dw XT_TO_R     ; ( -- )
007781 701b        .dw XT_EXIT
                 .include "words/scomma.asm"
                 
                 ; Compiler
                 ; compiles a string from RAM to Flash
                 VE_SCOMMA:
007782 ff02        .dw $ff02
007783 2c73        .db "s",$2c
007784 7758        .dw VE_HEAD
                   .set VE_HEAD = VE_SCOMMA
                 XT_SCOMMA:
007785 7001          .dw DO_COLON
                 PFA_SCOMMA:
007786 70ac          .dw XT_DUP
007787 7789          .dw XT_DOSCOMMA
007788 701b          .dw XT_EXIT
                 
                 ; ( addr len len' -- ) 
                 ; Compiler
                 ; compiles a string from RAM to Flash
                 ;VE_DOSCOMMA:
                 ;  .dw $ff04
                 ;  .db "(s",$2c,")"
                 ;  .dw VE_HEAD
                 ;  .set VE_HEAD = VE_DOSCOMMA
                 XT_DOSCOMMA:
007789 7001          .dw DO_COLON
                 PFA_DOSCOMMA:
00778a 01c8          .dw XT_COMMA
00778b 70ac          .dw XT_DUP   ; ( --addr len len)
00778c 71ff          .dw XT_2SLASH ; ( -- addr len len/2
00778d 7576          .dw XT_TUCK   ; ( -- addr len/2 len len/2
00778e 7206          .dw XT_2STAR  ; ( -- addr len/2 len len'
00778f 718e          .dw XT_MINUS  ; ( -- addr len/2 rem
007790 70fa          .dw XT_TO_R
007791 714f          .dw XT_ZERO
007792 0287          .dw XT_QDOCHECK
007793 7031          .dw XT_DOCONDBRANCH
007794 779c          .dw PFA_SCOMMA2
007795 728a          .dw XT_DODO
                 PFA_SCOMMA1:
007796 70ac          .dw XT_DUP         ; ( -- addr addr )
007797 7074          .dw XT_FETCH       ; ( -- addr c1c2 )
007798 01c8          .dw XT_COMMA       ; ( -- addr )
007799 755e          .dw XT_CELLPLUS    ; ( -- addr+cell )
00779a 72b8          .dw XT_DOLOOP
00779b 7796          .dw PFA_SCOMMA1
                 PFA_SCOMMA2:
00779c 70f1          .dw XT_R_FROM
00779d 7123          .dw XT_GREATERZERO
00779e 7031          .dw XT_DOCONDBRANCH
00779f 77a3          .dw PFA_SCOMMA3
0077a0 70ac            .dw XT_DUP     ; well, tricky
0077a1 7093            .dw XT_CFETCH
0077a2 01c8            .dw XT_COMMA
                 PFA_SCOMMA3:
0077a3 70d4          .dw XT_DROP        ; ( -- )
0077a4 701b          .dw XT_EXIT
                 .include "words/itype.asm"
                 
                 ; Tools
                 ; reads string from flash and prints it
                 VE_ITYPE:
0077a5 ff05          .dw $ff05
0077a6 7469
0077a7 7079
0077a8 0065          .db "itype",0
0077a9 7782          .dw VE_HEAD
                     .set VE_HEAD = VE_ITYPE
                 XT_ITYPE:
0077aa 7001          .dw DO_COLON
                 PFA_ITYPE:
0077ab 70ac          .dw XT_DUP    ; ( --addr len len)
0077ac 71ff          .dw XT_2SLASH ; ( -- addr len len/2
0077ad 7576          .dw XT_TUCK   ; ( -- addr len/2 len len/2
0077ae 7206          .dw XT_2STAR  ; ( -- addr len/2 len len'
0077af 718e          .dw XT_MINUS  ; ( -- addr len/2 rem
0077b0 70fa          .dw XT_TO_R
0077b1 714f          .dw XT_ZERO
0077b2 0287          .dw XT_QDOCHECK
0077b3 7031          .dw XT_DOCONDBRANCH
0077b4 77be          .dw PFA_ITYPE2
0077b5 728a          .dw XT_DODO
                 PFA_ITYPE1:
0077b6 70ac          .dw XT_DUP         ; ( -- addr addr )
0077b7 73bb          .dw XT_FETCHI      ; ( -- addr c1c2 )
0077b8 70ac          .dw XT_DUP
0077b9 77cb          .dw XT_LOWEMIT
0077ba 77c7          .dw XT_HIEMIT
0077bb 722a          .dw XT_1PLUS    ; ( -- addr+cell )
0077bc 72b8          .dw XT_DOLOOP
0077bd 77b6          .dw PFA_ITYPE1
                 PFA_ITYPE2:
0077be 70f1          .dw XT_R_FROM
0077bf 7123          .dw XT_GREATERZERO
0077c0 7031          .dw XT_DOCONDBRANCH
0077c1 77c5          .dw PFA_ITYPE3
0077c2 70ac            .dw XT_DUP     ; make sure the drop below has always something to do
0077c3 73bb            .dw XT_FETCHI
0077c4 77cb            .dw XT_LOWEMIT
                 PFA_ITYPE3:
0077c5 70d4          .dw XT_DROP
0077c6 701b          .dw XT_EXIT
                 
                 ; ( w -- )
                 ; R( -- )
                 ; content of cell fetched on stack.
                 ;VE_HIEMIT:
                 ;    .dw $ff06
                 ;    .db "hiemit"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_HIEMIT
                 XT_HIEMIT:
0077c7 7001          .dw DO_COLON
                 PFA_HIEMIT:
0077c8 72e8          .dw XT_BYTESWAP
0077c9 77cb          .dw XT_LOWEMIT
0077ca 701b          .dw XT_EXIT
                 
                 ; ( w -- )
                 ; R( -- )
                 ; content of cell fetched on stack.
                 ;VE_LOWEMIT:
                 ;    .dw $ff07
                 ;    .db "lowemit"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_LOWEMIT
                 XT_LOWEMIT:
0077cb 7001          .dw DO_COLON
                 PFA_LOWEMIT:
0077cc 7038          .dw XT_DOLITERAL
0077cd 00ff          .dw $00ff
0077ce 720e          .dw XT_AND
0077cf 7594          .dw XT_EMIT
0077d0 701b          .dw XT_EXIT
                 .include "words/icount.asm"
                 
                 ; Tools
                 ; get count information out of a counted string in flash
                 VE_ICOUNT:
0077d1 ff06          .dw $ff06
0077d2 6369
0077d3 756f
0077d4 746e          .db "icount"
0077d5 77a5          .dw VE_HEAD
                     .set VE_HEAD = VE_ICOUNT
                 XT_ICOUNT:
0077d6 7001          .dw DO_COLON
                 PFA_ICOUNT:
0077d7 70ac          .dw XT_DUP
0077d8 722a          .dw XT_1PLUS
0077d9 70bf          .dw XT_SWAP
0077da 73bb          .dw XT_FETCHI
0077db 701b          .dw XT_EXIT
                 .include "words/cr.asm"
                 
                 ; Character IO
                 ; cause subsequent output appear at the beginning of the next line
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_CR:
0077dc ff02          .dw 0xff02
0077dd 7263          .db "cr"
0077de 77d1          .dw VE_HEAD
                     .set VE_HEAD = VE_CR
                 XT_CR:
0077df 7001          .dw DO_COLON
                 PFA_CR:
                 .endif
                 
0077e0 7038          .dw XT_DOLITERAL
0077e1 000d          .dw 13
0077e2 7594          .dw XT_EMIT
0077e3 7038          .dw XT_DOLITERAL
0077e4 000a          .dw 10
0077e5 7594          .dw XT_EMIT
0077e6 701b          .dw XT_EXIT
                 .include "words/space.asm"
                 
                 ; Character IO
                 ; emits a space (bl)
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SPACE:
0077e7 ff05          .dw $ff05
0077e8 7073
0077e9 6361
0077ea 0065          .db "space",0
0077eb 77dc          .dw VE_HEAD
                     .set VE_HEAD = VE_SPACE
                 XT_SPACE:
0077ec 7001          .dw DO_COLON
                 PFA_SPACE:
                 .endif
0077ed 75f7          .dw XT_BL
0077ee 7594          .dw XT_EMIT
0077ef 701b          .dw XT_EXIT
                 .include "words/spaces.asm"
                 
                 ; Character IO
                 ; emits n space(s) (bl)
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SPACES:
0077f0 ff06          .dw $ff06
0077f1 7073
0077f2 6361
0077f3 7365          .db "spaces"
0077f4 77e7          .dw VE_HEAD
                     .set VE_HEAD = VE_SPACES
                 XT_SPACES:
0077f5 7001          .dw DO_COLON
                 PFA_SPACES:
                 
                 .endif
                 ;C SPACES   n --            output n spaces
                 ;   BEGIN DUP 0> WHILE SPACE 1- REPEAT DROP ;
0077f6 714f
0077f7 7674      	.DW XT_ZERO, XT_MAX
0077f8 70ac
0077f9 7031      SPCS1:  .DW XT_DUP,XT_DOCONDBRANCH
0077fa 77ff              DEST(SPCS2)
0077fb 77ec
0077fc 7230
0077fd 702a              .DW XT_SPACE,XT_1MINUS,XT_DOBRANCH
0077fe 77f8              DEST(SPCS1)
0077ff 70d4
007800 701b      SPCS2:  .DW XT_DROP,XT_EXIT
                 .include "words/type.asm"
                 
                 ; Character IO
                 ; print a RAM based string
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_TYPE:
007801 ff04          .dw $ff04
007802 7974
007803 6570          .db "type"
007804 77f0          .dw VE_HEAD
                     .set VE_HEAD = VE_TYPE
                 XT_TYPE:
007805 7001          .dw DO_COLON
                 PFA_TYPE:
                 
                 .endif
007806 7d4d          .dw XT_BOUNDS
007807 0287          .dw XT_QDOCHECK
007808 7031          .dw XT_DOCONDBRANCH
007809 7810          DEST(PFA_TYPE2)
00780a 728a          .dw XT_DODO
                 PFA_TYPE1:
00780b 729b          .dw XT_I
00780c 7093          .dw XT_CFETCH
00780d 7594          .dw XT_EMIT
00780e 72b8          .dw XT_DOLOOP
00780f 780b          DEST(PFA_TYPE1)
                 PFA_TYPE2:
007810 701b          .dw XT_EXIT
                 .include "words/tick.asm"
                 
                 ; Dictionary
                 ; search dictionary for name, return XT or throw an exception -13
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_TICK:
007811 ff01          .dw $ff01
007812 0027          .db "'",0
007813 7801          .dw VE_HEAD
                     .set VE_HEAD = VE_TICK
                 XT_TICK:
007814 7001          .dw DO_COLON
                 PFA_TICK:
                 .endif
007815 79b7          .dw XT_PARSENAME
007816 7ab5          .dw XT_DORECOGNIZER
007817 7b1f          .dw XT_R_WORD
007818 7d72          .dw XT_EQUAL
007819 7031          .dw XT_DOCONDBRANCH
00781a 781d          DEST(PFA_TICK1)
00781b 70d4          .dw XT_DROP
00781c 701b          .dw XT_EXIT
                 PFA_TICK1:
00781d 7038          .dw XT_DOLITERAL
00781e fff3          .dw -13
00781f 7843          .dw XT_THROW
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/handler.asm"
                 
                 ; Exceptions
                 ; USER variable used by catch/throw
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_HANDLER:
007820 ff07          .dw $ff07
007821 6168
007822 646e
007823 656c
007824 0072          .db "handler",0
007825 7811          .dw VE_HEAD
                     .set VE_HEAD = VE_HANDLER
                 XT_HANDLER:
007826 7053          .dw PFA_DOUSER
                 PFA_HANDLER:
                 .endif
007827 000a          .dw USER_HANDLER
                 .include "words/catch.asm"
                 
                 ; Exceptions
                 ; execute XT and check for exceptions.
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_CATCH:
007828 ff05          .dw $ff05
007829 6163
00782a 6374
00782b 0068          .db "catch",0
00782c 7820          .dw VE_HEAD
                     .set VE_HEAD = VE_CATCH
                 XT_CATCH:
00782d 7001          .dw DO_COLON
                 PFA_CATCH:
                 .endif
                 
                     ; sp@ >r
00782e 727c          .dw XT_SP_FETCH
00782f 70fa          .dw XT_TO_R
                     ; handler @ >r
007830 7826          .dw XT_HANDLER
007831 7074          .dw XT_FETCH
007832 70fa          .dw XT_TO_R
                     ; rp@ handler !
007833 7265          .dw XT_RP_FETCH
007834 7826          .dw XT_HANDLER
007835 707c          .dw XT_STORE
007836 7025          .dw XT_EXECUTE
                     ; r> handler !
007837 70f1          .dw XT_R_FROM
007838 7826          .dw XT_HANDLER
007839 707c          .dw XT_STORE
00783a 70f1          .dw XT_R_FROM
00783b 70d4          .dw XT_DROP
00783c 714f          .dw XT_ZERO
00783d 701b          .dw XT_EXIT
                 .include "words/throw.asm"
                 
                 ; Exceptions
                 ; throw an exception
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_THROW:
00783e ff05          .dw $ff05
00783f 6874
007840 6f72
007841 0077          .db "throw",0
007842 7828          .dw VE_HEAD
                     .set VE_HEAD = VE_THROW
                 XT_THROW:
007843 7001          .dw DO_COLON
                 PFA_THROW:
                 .endif
007844 70ac          .dw XT_DUP
007845 7115          .dw XT_ZEROEQUAL
007846 7031          .dw XT_DOCONDBRANCH
007847 784a          DEST(PFA_THROW1)
007848 70d4      	.dw XT_DROP
007849 701b      	.dw XT_EXIT
                 PFA_THROW1:
00784a 7826          .dw XT_HANDLER
00784b 7074          .dw XT_FETCH
00784c 726f          .dw XT_RP_STORE
00784d 70f1          .dw XT_R_FROM
00784e 7826          .dw XT_HANDLER
00784f 707c          .dw XT_STORE
007850 70f1          .dw XT_R_FROM
007851 70bf          .dw XT_SWAP
007852 70fa          .dw XT_TO_R
007853 7285          .dw XT_SP_STORE
007854 70d4          .dw XT_DROP
007855 70f1          .dw XT_R_FROM    
007856 701b          .dw XT_EXIT
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/cskip.asm"
                 
                 ; String
                 ; skips leading occurancies in string at addr1/n1 leaving addr2/n2 pointing to the 1st non-c character
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_CSKIP:
007857 ff05          .dw $ff05
007858 7363
007859 696b
00785a 0070          .db "cskip",0
00785b 783e          .dw VE_HEAD
                     .set VE_HEAD = VE_CSKIP
                 XT_CSKIP:
00785c 7001          .dw DO_COLON
                 PFA_CSKIP:
                 .endif
00785d 70fa          .dw XT_TO_R           ; ( -- addr1 n1 )
                 PFA_CSKIP1:
00785e 70ac          .dw XT_DUP            ; ( -- addr' n' n' )
00785f 7031          .dw XT_DOCONDBRANCH   ; ( -- addr' n')
007860 786c          DEST(PFA_CSKIP2)
007861 70ca          .dw XT_OVER           ; ( -- addr' n' addr' )
007862 7093          .dw XT_CFETCH         ; ( -- addr' n' c' )
007863 7103          .dw XT_R_FETCH        ; ( -- addr' n' c' c )
007864 7d72          .dw XT_EQUAL          ; ( -- addr' n' f )
007865 7031          .dw XT_DOCONDBRANCH   ; ( -- addr' n')
007866 786c          DEST(PFA_CSKIP2)
007867 7038          .dw XT_DOLITERAL
007868 0001          .dw 1
007869 79a8          .dw XT_SLASHSTRING
00786a 702a          .dw XT_DOBRANCH
00786b 785e          DEST(PFA_CSKIP1)
                 PFA_CSKIP2:
00786c 70f1          .dw XT_R_FROM
00786d 70d4          .dw XT_DROP           ; ( -- addr2 n2)
00786e 701b          .dw XT_EXIT
                 .include "words/cscan.asm"
                 
                 ; String
                 ; Scan string at addr1/n1 for the first occurance of c, leaving addr1/n2, char at n2 is first non-c character
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_CSCAN:
00786f ff05          .dw $ff05
007870 7363
007871 6163
../../common\words/cscan.asm(12): warning: .cseg .db misalignment - padding zero byte
007872 006e          .db "cscan"
007873 7857          .dw VE_HEAD
                     .set VE_HEAD = VE_CSCAN
                 XT_CSCAN:
007874 7001          .dw DO_COLON
                 PFA_CSCAN:
                 .endif
007875 70fa          .dw XT_TO_R
007876 70ca          .dw XT_OVER
                 PFA_CSCAN1:
007877 70ac          .dw XT_DUP
007878 7093          .dw XT_CFETCH
007879 7103          .dw XT_R_FETCH
00787a 7d72          .dw XT_EQUAL
00787b 7115          .dw XT_ZEROEQUAL
00787c 7031          .dw XT_DOCONDBRANCH
00787d 7889          DEST(PFA_CSCAN2)
00787e 70bf            .dw XT_SWAP
00787f 7230            .dw XT_1MINUS
007880 70bf            .dw XT_SWAP
007881 70ca            .dw XT_OVER
007882 711c            .dw XT_ZEROLESS ; not negative
007883 7115            .dw XT_ZEROEQUAL
007884 7031            .dw XT_DOCONDBRANCH
007885 7889            DEST(PFA_CSCAN2)
007886 722a              .dw XT_1PLUS
007887 702a              .dw XT_DOBRANCH
007888 7877              DEST(PFA_CSCAN1)
                 PFA_CSCAN2:
007889 70eb          .dw XT_NIP
00788a 70ca          .dw XT_OVER
00788b 718e          .dw XT_MINUS
00788c 70f1          .dw XT_R_FROM
00788d 70d4          .dw XT_DROP
00788e 701b          .dw XT_EXIT
                 
                 ; : my-cscan ( addr len c -- addr len' )
                 ;    >r over ( -- addr len addr )
                 ;    begin
                 ;      dup c@ r@ <> while
                 ;       swap 1- swap over 0 >=  while
                 ;        1+ 
                 ;     repeat then
                 ;     nip over - r> drop 
                 ; ;
                 .include "words/accept.asm"
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_ACCEPT:
00788f ff06          .dw $ff06
007890 6361
007891 6563
007892 7470          .db "accept"
007893 786f          .dw VE_HEAD
                     .set VE_HEAD = VE_ACCEPT
                 XT_ACCEPT:
007894 7001          .dw DO_COLON
                 PFA_ACCEPT:
                 
                 .endif
007895 70ca
007896 7198
007897 7230
007898 70ca              .DW XT_OVER,XT_PLUS,XT_1MINUS,XT_OVER
007899 75a5
00789a 70ac
00789b 78ce
00789c 7115
00789d 7031      ACC1:   .DW XT_KEY,XT_DUP,XT_CRLFQ,XT_ZEROEQUAL,XT_DOCONDBRANCH
00789e 78c0              DEST(ACC5)
00789f 70ac
0078a0 7038
0078a1 0008
0078a2 7d72
0078a3 7031              .DW XT_DUP,XT_DOLITERAL,8,XT_EQUAL,XT_DOCONDBRANCH
0078a4 78b7              DEST(ACC3)
0078a5 70d4
0078a6 70dc
0078a7 7565
0078a8 7173
0078a9 70fa
0078aa 70dc
0078ab 70dc
0078ac 70f1
0078ad 7031              .DW XT_DROP,XT_ROT,XT_2DUP,XT_GREATER,XT_TO_R,XT_ROT,XT_ROT,XT_R_FROM,XT_DOCONDBRANCH
0078ae 78b5      	DEST(ACC6)
0078af 78c6
0078b0 7230
0078b1 70fa
0078b2 70ca
0078b3 70f1
0078b4 0142      	.DW XT_BS,XT_1MINUS,XT_TO_R,XT_OVER,XT_R_FROM,XT_UMAX
                 ACC6:
0078b5 702a              .DW XT_DOBRANCH
0078b6 78be              DEST(ACC4)
0078b7 70ac
0078b8 7594
0078b9 70ca
0078ba 7088
0078bb 722a
0078bc 70ca
0078bd 014e      ACC3:   .DW XT_DUP,XT_EMIT,XT_OVER,XT_CSTORE,XT_1PLUS,XT_OVER,XT_UMIN
0078be 702a      ACC4:   .DW XT_DOBRANCH
0078bf 7899              DEST(ACC1)
0078c0 70d4
0078c1 70eb
0078c2 70bf
0078c3 718e
0078c4 77df
0078c5 701b      ACC5:   .DW XT_DROP,XT_NIP,XT_SWAP,XT_MINUS,XT_CR,XT_EXIT
                 
                 
                 ; ( --  ) 
                 ; System
                 ; send a backspace character to overwrite the current char
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 ;VE_BS:
                 ;    .dw $ff02
                 ;    .db "bs"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_BS
                 XT_BS:
0078c6 7001          .dw DO_COLON
                 .endif
0078c7 7038          .dw XT_DOLITERAL
0078c8 0008          .dw 8
0078c9 70ac          .dw XT_DUP
0078ca 7594          .dw XT_EMIT
0078cb 77ec          .dw XT_SPACE
0078cc 7594          .dw XT_EMIT
0078cd 701b          .dw XT_EXIT
                 
                 
                 ; ( c -- f ) 
                 ; System
                 ; is the character a line end character?
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 ;VE_CRLFQ:
                 ;    .dw $ff02
                 ;    .db "crlf?"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_CRLFQ
                 XT_CRLFQ:
0078ce 7001          .dw DO_COLON
                 .endif
0078cf 70ac          .dw XT_DUP
0078d0 7038          .dw XT_DOLITERAL
0078d1 000d          .dw 13
0078d2 7d72          .dw XT_EQUAL
0078d3 70bf          .dw XT_SWAP
0078d4 7038          .dw XT_DOLITERAL
0078d5 000a          .dw 10
0078d6 7d72          .dw XT_EQUAL
0078d7 7217          .dw XT_OR
0078d8 701b          .dw XT_EXIT
                 .include "words/refill.asm"
                 
                 ; System
                 ; refills the input buffer
                 VE_REFILL:
0078d9 ff06          .dw $ff06
0078da 6572
0078db 6966
0078dc 6c6c          .db "refill"
0078dd 788f          .dw VE_HEAD
                     .set VE_HEAD = VE_REFILL
                 XT_REFILL:
0078de 7c06          .dw PFA_DODEFER1
                 PFA_REFILL:
0078df 001a          .dw USER_REFILL
0078e0 7bcf          .dw XT_UDEFERFETCH
0078e1 7bdb          .dw XT_UDEFERSTORE
                 
                 .include "words/char.asm"
                 
                 ; Tools
                 ; copy the first character of the next word onto the stack
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_CHAR:
0078e2 ff04          .dw $ff04
0078e3 6863
0078e4 7261          .db "char"
0078e5 78d9          .dw VE_HEAD
                     .set VE_HEAD = VE_CHAR
                 XT_CHAR:
0078e6 7001          .dw DO_COLON
                 PFA_CHAR:
                 .endif
0078e7 79b7          .dw XT_PARSENAME
0078e8 70d4          .dw XT_DROP
0078e9 7093          .dw XT_CFETCH
0078ea 701b          .dw XT_EXIT
                 .include "words/number.asm"
                 
                 ; Numeric IO
                 ; convert a string at addr to a number
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_NUMBER:
0078eb ff06          .dw $ff06
0078ec 756e
0078ed 626d
0078ee 7265          .db "number"
0078ef 78e2          .dw VE_HEAD
                     .set VE_HEAD = VE_NUMBER
                 XT_NUMBER:
0078f0 7001          .dw DO_COLON
                 PFA_NUMBER:
                 .endif
0078f1 7551          .dw XT_BASE
0078f2 7074          .dw XT_FETCH
0078f3 70fa          .dw XT_TO_R
0078f4 7937          .dw XT_QSIGN
0078f5 70fa          .dw XT_TO_R
0078f6 794b          .dw XT_SET_BASE
0078f7 7937          .dw XT_QSIGN
0078f8 70f1          .dw XT_R_FROM
0078f9 7217          .dw XT_OR
0078fa 70fa          .dw XT_TO_R
                     ; check whether something is left
0078fb 70ac          .dw XT_DUP
0078fc 7115          .dw XT_ZEROEQUAL
0078fd 7031          .dw XT_DOCONDBRANCH
0078fe 7907          DEST(PFA_NUMBER0)
                       ; nothing is left. It cannot be a number at all
0078ff 756e            .dw XT_2DROP
007900 70f1            .dw XT_R_FROM
007901 70d4            .dw XT_DROP
007902 70f1            .dw XT_R_FROM
007903 7551            .dw XT_BASE
007904 707c            .dw XT_STORE
007905 714f            .dw XT_ZERO
007906 701b            .dw XT_EXIT
                 PFA_NUMBER0:
007907 730d          .dw XT_2TO_R
007908 714f          .dw XT_ZERO       ; starting value
007909 714f          .dw XT_ZERO
00790a 731c          .dw XT_2R_FROM
00790b 796a          .dw XT_TO_NUMBER ; ( 0. addr len -- d addr' len'
                     ; check length of the remaining string.
                     ; if zero: a single cell number is entered
00790c 70b4          .dw XT_QDUP
00790d 7031          .dw XT_DOCONDBRANCH
00790e 792b          DEST(PFA_NUMBER1)
                     ; if equal 1: mayba a trailing dot? --> double cell number
00790f 7038          .dw XT_DOLITERAL
007910 0001          .dw 1
007911 7d72          .dw XT_EQUAL
007912 7031          .dw XT_DOCONDBRANCH
007913 7922          DEST(PFA_NUMBER2)
                 	; excatly one character is left
007914 7093      	.dw XT_CFETCH
007915 7038      	.dw XT_DOLITERAL
007916 002e      	.dw 46 ; .
007917 7d72      	.dw XT_EQUAL
007918 7031      	.dw XT_DOCONDBRANCH
007919 7923      	DEST(PFA_NUMBER6)
                 	; its a double cell number
                         ; incorporate sign into number
00791a 70f1      	.dw XT_R_FROM
00791b 7031              .dw XT_DOCONDBRANCH
00791c 791e      	DEST(PFA_NUMBER3)
00791d 7cd4              .dw XT_DNEGATE
                 PFA_NUMBER3:
00791e 7038      	.dw XT_DOLITERAL
00791f 0002      	.dw 2
007920 702a      	.dw XT_DOBRANCH
007921 7932      	DEST(PFA_NUMBER5)
                 PFA_NUMBER2:
007922 70d4      	.dw XT_DROP
                 PFA_NUMBER6:
007923 756e      	.dw XT_2DROP
007924 70f1      	.dw XT_R_FROM
007925 70d4      	.dw XT_DROP
007926 70f1              .dw XT_R_FROM
007927 7551              .dw XT_BASE
007928 707c              .dw XT_STORE
007929 714f      	.dw XT_ZERO
00792a 701b      	.dw XT_EXIT
                 PFA_NUMBER1:
00792b 756e          .dw XT_2DROP ; remove the address
                     ; incorporate sign into number
00792c 70f1          .dw XT_R_FROM
00792d 7031          .dw XT_DOCONDBRANCH
00792e 7930          DEST(PFA_NUMBER4)
00792f 7646          .dw XT_NEGATE
                 PFA_NUMBER4:
007930 7038          .dw XT_DOLITERAL
007931 0001          .dw 1
                 PFA_NUMBER5:
007932 70f1          .dw XT_R_FROM
007933 7551          .dw XT_BASE
007934 707c          .dw XT_STORE
007935 7146          .dw XT_TRUE
007936 701b          .dw XT_EXIT
                 .include "words/q-sign.asm"
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 XT_QSIGN:
007937 7001          .dw DO_COLON 
                 PFA_QSIGN:        ; ( c -- ) 
                 .endif
007938 70ca          .dw XT_OVER    ; ( -- addr len addr )
007939 7093          .dw XT_CFETCH
00793a 7038          .dw XT_DOLITERAL
00793b 002d          .dw '-'
00793c 7d72          .dw XT_EQUAL  ; ( -- addr len flag )
00793d 70ac          .dw XT_DUP
00793e 70fa          .dw XT_TO_R
00793f 7031          .dw XT_DOCONDBRANCH
007940 7944          DEST(PFA_NUMBERSIGN_DONE)
007941 7038          .dw XT_DOLITERAL      ; skip sign character
007942 0001          .dw 1
007943 79a8          .dw XT_SLASHSTRING
                 PFA_NUMBERSIGN_DONE:
007944 70f1          .dw XT_R_FROM
007945 701b          .dw XT_EXIT
                 .include "words/set-base.asm"
                 
                 ; Numeric IO
                 ; skip a numeric prefix character
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 XT_BASES:
007946 704d          .dw PFA_DOCONSTANT
                 .endif
007947 000a
007948 0010
007949 0002
00794a 000a          .dw 10,16,2,10 ; last one could a 8 instead.
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 XT_SET_BASE:
00794b 7001          .dw DO_COLON 
                 PFA_SET_BASE:        ; ( adr1 len1 -- adr2 len2 ) 
                 .endif
00794c 70ca          .dw XT_OVER
00794d 7093          .dw XT_CFETCH
00794e 7038          .dw XT_DOLITERAL
00794f 0023          .dw 35
007950 718e          .dw XT_MINUS
007951 70ac          .dw XT_DUP
007952 714f          .dw XT_ZERO
007953 7038          .dw XT_DOLITERAL
007954 0004          .dw 4
007955 7681          .dw XT_WITHIN
007956 7031          .dw XT_DOCONDBRANCH
007957 7962          DEST(SET_BASE1)
                 	.if cpu_msp430==1
                 	.endif
007958 7946      	.dw XT_BASES
007959 7198      	.dw XT_PLUS
00795a 73bb      	.dw XT_FETCHI
00795b 7551      	.dw XT_BASE
00795c 707c      	.dw XT_STORE
00795d 7038      	.dw XT_DOLITERAL
00795e 0001      	.dw 1
00795f 79a8      	.dw XT_SLASHSTRING
007960 702a      	.dw XT_DOBRANCH
007961 7963      	DEST(SET_BASE2)
                 SET_BASE1:
007962 70d4      	.dw XT_DROP
                 SET_BASE2:
007963 701b          .dw XT_EXIT 
                 
                 ; create bases 10 , 16 , 2 , 8 ,
                 ; : set-base 35 - dup 0 4 within if 
                 ;    bases + @i base ! 1 /string 
                 ;   else 
                 ;    drop
                 ;   then ;
                 .include "words/to-number.asm"
                 
                 ; Numeric IO
                 ; convert a string to a number  c-addr2/u2 is the unconverted string
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_TO_NUMBER:
007964 ff07          .dw $ff07
007965 6e3e
007966 6d75
007967 6562
007968 0072          .db ">number",0
007969 78eb          .dw VE_HEAD
                     .set VE_HEAD = VE_TO_NUMBER
                 XT_TO_NUMBER:
00796a 7001          .dw DO_COLON
                 
                 .endif
                 
00796b 70ac
00796c 7031      TONUM1: .DW XT_DUP,XT_DOCONDBRANCH
00796d 7983              DEST(TONUM3)
00796e 70ca
00796f 7093
007970 775d              .DW XT_OVER,XT_CFETCH,XT_DIGITQ
007971 7115
007972 7031              .DW XT_ZEROEQUAL,XT_DOCONDBRANCH
007973 7976              DEST(TONUM2)
007974 70d4
007975 701b              .DW XT_DROP,XT_EXIT
007976 70fa
007977 7cf9
007978 7551
007979 7074
00797a 0133      TONUM2: .DW XT_TO_R,XT_2SWAP,XT_BASE,XT_FETCH,XT_UDSTAR
00797b 70f1
00797c 012b
00797d 7cf9              .DW XT_R_FROM,XT_MPLUS,XT_2SWAP
00797e 7038
00797f 0001
007980 79a8
007981 702a              .DW XT_DOLITERAL,1,XT_SLASHSTRING,XT_DOBRANCH
007982 796b              DEST(TONUM1)
007983 701b      TONUM3: .DW XT_EXIT
                 
                 ;C >NUMBER  ud adr u -- ud' adr' u'
                 ;C                      convert string to number
                 ;   BEGIN
                 ;   DUP WHILE
                 ;       OVER C@ DIGIT?
                 ;       0= IF DROP EXIT THEN
                 ;       >R 2SWAP BASE @ UD*
                 ;       R> M+ 2SWAP
                 ;       1 /STRING
                 ;   REPEAT ;
                 .include "words/parse.asm"
                 
                 ; String
                 ; in input buffer parse ccc delimited string by the delimiter char.
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_PARSE:
007984 ff05          .dw $ff05
007985 6170
007986 7372
007987 0065          .db "parse",0
007988 7964          .dw VE_HEAD
                     .set VE_HEAD = VE_PARSE
                 XT_PARSE:
007989 7001          .dw DO_COLON
                 PFA_PARSE:
                 .endif
00798a 70fa          .dw XT_TO_R     ; ( -- )
00798b 799e          .dw XT_SOURCE   ; ( -- addr len)
00798c 757e          .dw XT_TO_IN     ; ( -- addr len >in)
00798d 7074          .dw XT_FETCH
00798e 79a8          .dw XT_SLASHSTRING ; ( -- addr' len' )
                 
00798f 70f1          .dw XT_R_FROM      ; ( -- addr' len' c)
007990 7874          .dw XT_CSCAN       ; ( -- addr' len'')
007991 70ac          .dw XT_DUP         ; ( -- addr' len'' len'')
007992 722a          .dw XT_1PLUS
007993 757e          .dw XT_TO_IN        ; ( -- addr' len'' len'' >in)
007994 7254          .dw XT_PLUSSTORE   ; ( -- addr' len')
007995 7038          .dw XT_DOLITERAL
007996 0001          .dw 1
007997 79a8          .dw XT_SLASHSTRING
007998 701b          .dw XT_EXIT
                 .include "words/source.asm"
                 
                 ; System
                 ; address and current length of the input buffer
                 VE_SOURCE:
007999 ff06          .dw $FF06
00799a 6f73
00799b 7275
00799c 6563          .db "source"
00799d 7984          .dw VE_HEAD
                     .set VE_HEAD = VE_SOURCE
                 XT_SOURCE:
00799e 7c06          .dw PFA_DODEFER1
                 PFA_SOURCE:
00799f 0016          .dw USER_SOURCE
0079a0 7bcf          .dw XT_UDEFERFETCH
0079a1 7bdb          .dw XT_UDEFERSTORE
                 
                 
                 .include "words/slash-string.asm"
                 
                 ; String
                 ; adjust string from addr1 to addr1+n, reduce length from u1 to u2 by n
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SLASHSTRING:
0079a2 ff07          .dw $ff07
0079a3 732f
0079a4 7274
0079a5 6e69
0079a6 0067          .db "/string",0
0079a7 7999          .dw VE_HEAD
                     .set VE_HEAD = VE_SLASHSTRING
                 XT_SLASHSTRING:
0079a8 7001          .dw DO_COLON
                 PFA_SLASHSTRING:
                 .endif
0079a9 70dc          .dw XT_ROT
0079aa 70ca          .dw XT_OVER
0079ab 7198          .dw XT_PLUS
0079ac 70dc          .dw XT_ROT
0079ad 70dc          .dw XT_ROT
0079ae 718e          .dw XT_MINUS
0079af 701b          .dw XT_EXIT
                 
                 .include "words/parse-name.asm"
                 
                 ; String
                 ; In the SOURCE buffer parse whitespace delimited string. Returns string address within SOURCE.
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 VE_PARSENAME:
0079b0 ff0a          .dw $FF0A 
0079b1 6170
0079b2 7372
0079b3 2d65
0079b4 616e
0079b5 656d          .db "parse-name"
0079b6 79a2          .dw VE_HEAD
                     .set VE_HEAD = VE_PARSENAME
                 XT_PARSENAME:
0079b7 7001          .dw DO_COLON 
                 PFA_PARSENAME:
                 .endif
0079b8 75f7          .dw XT_BL
0079b9 79bb          .dw XT_SKIPSCANCHAR
0079ba 701b          .dw XT_EXIT 
                 
                 ; ( c -- addr2 len2 ) 
                 ; String
                 ; skips char and scan what's left in source for char
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 ;VE_SKIPSCANCHAR:
                 ;    .dw $FF0A 
                 ;    .db "skipscanchar"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_SKIPSCANCHAR
                 XT_SKIPSCANCHAR:
0079bb 7001          .dw DO_COLON
                 PFA_SKIPSCANCHAR:
                 .endif
0079bc 70fa          .dw XT_TO_R
0079bd 799e          .dw XT_SOURCE 
0079be 757e          .dw XT_TO_IN 
0079bf 7074          .dw XT_FETCH 
0079c0 79a8          .dw XT_SLASHSTRING 
                 
0079c1 7103          .dw XT_R_FETCH
0079c2 785c          .dw XT_CSKIP
0079c3 70f1          .dw XT_R_FROM
0079c4 7874          .dw XT_CSCAN
                 
                     ; adjust >IN
0079c5 7565          .dw XT_2DUP
0079c6 7198          .dw XT_PLUS
0079c7 799e          .dw XT_SOURCE 
0079c8 70d4          .dw XT_DROP
0079c9 718e          .dw XT_MINUS
0079ca 757e          .dw XT_TO_IN
0079cb 707c          .dw XT_STORE
0079cc 701b          .dw XT_EXIT
                 .include "words/find-name.asm"
                 
                 ; Tools
                 ; search wordlists for an entry with the name from c-addr/len
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_FINDNAME:
0079cd ff09          .dw $ff09
0079ce 6966
0079cf 646e
0079d0 6e2d
0079d1 6d61
0079d2 0065          .db "find-name",0
0079d3 79b0          .dw VE_HEAD
                     .set VE_HEAD = VE_FINDNAME
                 XT_FINDNAME:
0079d4 7001          .dw DO_COLON
                 PFA_FINDNAME:
                 .endif
0079d5 7038          .dw XT_DOLITERAL
0079d6 79e0          .dw XT_FINDNAMEA
0079d7 7038          .dw XT_DOLITERAL
0079d8 004c          .dw CFG_ORDERLISTLEN
0079d9 0411          .dw XT_MAPSTACK
0079da 7115          .dw XT_ZEROEQUAL
0079db 7031          .dw XT_DOCONDBRANCH
0079dc 79df          DEST(PFA_FINDNAME1)
0079dd 756e            .dw XT_2DROP
0079de 714f            .dw XT_ZERO
                 PFA_FINDNAME1:
0079df 701b          .dw XT_EXIT
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 XT_FINDNAMEA:
0079e0 7001          .dw DO_COLON
                 PFA_FINDNAMEA:
                 .endif
0079e1 70fa          .dw XT_TO_R
0079e2 7565          .dw XT_2DUP
0079e3 70f1          .dw XT_R_FROM
0079e4 7c18          .dw XT_SEARCH_WORDLIST
0079e5 70ac          .dw XT_DUP
0079e6 7031          .dw XT_DOCONDBRANCH
0079e7 79ed          DEST(PFA_FINDNAMEA1)
0079e8 70fa            .dw XT_TO_R
0079e9 70eb            .dw XT_NIP
0079ea 70eb            .dw XT_NIP
0079eb 70f1            .dw XT_R_FROM
0079ec 7146            .dw XT_TRUE
                 PFA_FINDNAMEA1:
0079ed 701b          .dw XT_EXIT
                 
                 .include "words/prompt-ok.asm"
                 
                 ; System
                 ; send the READY prompt to the command line
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 ;VE_PROMPTOK:
                 ;    .dw $ff02
                 ;    .db "ok"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_PROMPTOK
                 XT_PROMPTOK:
0079ee 7001          .dw DO_COLON
                 PFA_PROMPTOK:
0079ef 7777          .dw XT_DOSLITERAL
0079f0 0003          .dw 3
0079f1 6f20
0079f2 006b          .db " ok",0
                 .endif
0079f3 77aa          .dw XT_ITYPE
0079f4 701b          .dw XT_EXIT
                 .include "words/prompt-ready.asm"
                 
                 ; System
                 ; process the error prompt
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 ;VE_PROMPTRDY:
                 ;    .dw $ff04
                 ;    .db "p_er"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_PROMPTRDY
                 XT_PROMPTREADY:
0079f5 7001          .dw DO_COLON
                 PFA_PROMPTREADY:
0079f6 7777          .dw XT_DOSLITERAL
0079f7 0002          .dw 2
0079f8 203e          .db "> "
                 .endif
0079f9 77df          .dw XT_CR
0079fa 77aa          .dw XT_ITYPE
0079fb 701b          .dw XT_EXIT
                 .include "words/prompt-error.asm"
                 
                 ; System
                 ; process the error prompt
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 ;VE_PROMPTERROR:
                 ;    .dw $ff04
                 ;    .db "p_er"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_PROMPTERROR
                 XT_PROMPTERROR:
0079fc 7001          .dw DO_COLON
                 PFA_PROMPTERROR:
0079fd 7777      	.dw XT_DOSLITERAL
0079fe 0004          .dw 4
0079ff 3f20
007a00 203f          .db " ?? "
                 .endif
007a01 77aa          .dw XT_ITYPE
007a02 7551          .dw XT_BASE
007a03 7074          .dw XT_FETCH
007a04 70fa          .dw XT_TO_R
007a05 75e4          .dw XT_DECIMAL
007a06 772c          .dw XT_DOT
007a07 757e          .dw XT_TO_IN
007a08 7074          .dw XT_FETCH
007a09 772c          .dw XT_DOT
007a0a 70f1          .dw XT_R_FROM
007a0b 7551          .dw XT_BASE
007a0c 707c          .dw XT_STORE
007a0d 701b          .dw XT_EXIT
                 
                 .include "words/quit.asm"
                 
                 ; System
                 ; main loop of amforth. accept - interpret in an endless loop
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_QUIT:
007a0e ff04          .dw $ff04
007a0f 7571
007a10 7469          .db "quit"
007a11 79cd          .dw VE_HEAD
                     .set VE_HEAD = VE_QUIT
                 XT_QUIT:
007a12 7001          .dw DO_COLON
                 PFA_QUIT:
                 .endif
                 PFA_QUIT1:
007a13 02be
007a14 02c5
007a15 707c          .dw XT_LP0,XT_LP,XT_STORE
007a16 7a74          .dw XT_SP0
007a17 7285          .dw XT_SP_STORE
007a18 7a81          .dw XT_RP0
007a19 726f          .dw XT_RP_STORE
007a1a 0360          .dw XT_LBRACKET
                 
                 PFA_QUIT2:
007a1b 754b          .dw XT_STATE
007a1c 7074          .dw XT_FETCH
007a1d 7115          .dw XT_ZEROEQUAL
007a1e 7031          .dw XT_DOCONDBRANCH
007a1f 7a21          DEST(PFA_QUIT4)
007a20 79f5          .dw XT_PROMPTREADY
                 PFA_QUIT4:
007a21 78de          .dw XT_REFILL
007a22 7031          .dw XT_DOCONDBRANCH
007a23 7a1b          DEST(PFA_QUIT2)
007a24 7038          .dw XT_DOLITERAL
007a25 7a9a          .dw XT_INTERPRET
007a26 782d          .dw XT_CATCH
007a27 70b4          .dw XT_QDUP
007a28 7031          .dw XT_DOCONDBRANCH
007a29 7a33          DEST(PFA_QUIT3)
007a2a 70ac      	.dw XT_DUP
007a2b 7038      	.dw XT_DOLITERAL
007a2c fffe      	.dw -2
007a2d 7169      	.dw XT_LESS
007a2e 7031      	.dw XT_DOCONDBRANCH
007a2f 7a31      	DEST(PFA_QUIT5)
007a30 79fc      	.dw XT_PROMPTERROR
                 PFA_QUIT5:
007a31 702a      	.dw XT_DOBRANCH
007a32 7a13      	DEST(PFA_QUIT1)
                 PFA_QUIT3:
007a33 79ee          .dw XT_PROMPTOK
007a34 702a          .dw XT_DOBRANCH
007a35 7a1b          DEST(PFA_QUIT2)
007a36 701b          .dw XT_EXIT ; never reached
                 
                 .include "words/pause.asm"
                 
                 ; Multitasking
                 ; Fetch pause vector and execute it. may make a context/task switch
                 VE_PAUSE:
007a37 ff05          .dw $ff05
007a38 6170
007a39 7375
007a3a 0065          .db "pause",0
007a3b 7a0e          .dw VE_HEAD
                     .set VE_HEAD = VE_PAUSE
                 XT_PAUSE:
007a3c 7c06          .dw PFA_DODEFER1
                 PFA_PAUSE:
007a3d 0125          .dw ram_pause
007a3e 7bbb          .dw XT_RDEFERFETCH
007a3f 7bc5          .dw XT_RDEFERSTORE
                 
                 .dseg
000125           ram_pause: .byte 2
                 .cseg
                 .include "words/cold.asm"
                 
                 ; System
                 ; start up amforth.
                 VE_COLD:
007a40 ff04          .dw $ff04
007a41 6f63
007a42 646c          .db "cold"
007a43 7a37          .dw VE_HEAD
                     .set VE_HEAD = VE_COLD
                 XT_COLD:
007a44 7a45          .dw PFA_COLD
                 PFA_COLD:
007a45 b6a4          in_ mcu_boot, MCUSR
007a46 2422          clr zerol
007a47 2433          clr zeroh
007a48 be24          out_ MCUSR, zerol
                     ; clear RAM
007a49 e0e0          ldi zl, low(ramstart)
007a4a e0f1          ldi zh, high(ramstart)
                 clearloop:
007a4b 9221          st Z+, zerol
007a4c 30e0          cpi zl, low(sram_size+ramstart)
007a4d f7e9          brne clearloop
007a4e 31f1          cpi zh, high(sram_size+ramstart)
007a4f f7d9          brne clearloop
                     ; init first user data area
                     ; allocate space for User Area
                 .dseg
000127           ram_user1: .byte SYSUSERSIZE + APPUSERSIZE
                 .cseg
007a50 e2e7          ldi zl, low(ram_user1)
007a51 e0f1          ldi zh, high(ram_user1)
007a52 012f          movw upl, zl
                     ; init return stack pointer
007a53 ef0f          ldi temp0,low(rstackstart)
007a54 bf0d          out_ SPL,temp0
007a55 8304          std Z+4, temp0
007a56 e110          ldi temp1,high(rstackstart)
007a57 bf1e          out_ SPH,temp1
007a58 8315          std Z+5, temp1
                 
                     ; init parameter stack pointer
007a59 eacf          ldi yl,low(stackstart)
007a5a 83c6          std Z+6, yl
007a5b e1d0          ldi yh,high(stackstart)
007a5c 83d7          std Z+7, yh
                 
                     ; load Forth IP with starting word
007a5d e6a6          ldi XL, low(PFA_WARM)
007a5e e7ba          ldi XH, high(PFA_WARM)
                     ; its a far jump...
007a5f 940c 7005     jmp_ DO_NEXT
                 .include "words/warm.asm"
                 
                 ; System
                 ; initialize amforth further. executes turnkey operation and go to quit
                 VE_WARM:
007a61 ff04          .dw $ff04
007a62 6177
007a63 6d72          .db "warm"
007a64 7a40          .dw VE_HEAD
                     .set VE_HEAD = VE_WARM
                 XT_WARM:
007a65 7001          .dw DO_COLON
                 PFA_WARM:
007a66 7d3f          .dw XT_INITUSER
007a67 7038          .dw XT_DOLITERAL
007a68 7b71          .dw XT_NOOP
007a69 7038          .dw XT_DOLITERAL
007a6a 7a3c          .dw XT_PAUSE
007a6b 7be6          .dw XT_DEFERSTORE
007a6c 0360          .dw XT_LBRACKET
007a6d 75ff          .dw XT_TURNKEY
007a6e 7a12          .dw XT_QUIT
007a6f 701b          .dw XT_EXIT
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/sp0.asm"
                 
                 ; Stack
                 ; start address of the data stack
                 VE_SP0:
007a70 ff03          .dw $ff03
007a71 7073
007a72 0030          .db "sp0",0
007a73 7a61          .dw VE_HEAD
                     .set VE_HEAD = VE_SP0
                 XT_SP0:
007a74 706a          .dw PFA_DOVALUE1
                 PFA_SP0:
007a75 0006          .dw USER_SP0
007a76 7bcf          .dw XT_UDEFERFETCH
007a77 7bdb          .dw XT_UDEFERSTORE
                 
                 ; ( -- addr) 
                 ; Stack
                 ; address of user variable to store top-of-stack for inactive tasks
                 VE_SP:
007a78 ff02          .dw $ff02
007a79 7073          .db "sp"
007a7a 7a70          .dw VE_HEAD
                     .set VE_HEAD = VE_SP
                 XT_SP:
007a7b 7053          .dw PFA_DOUSER
                 PFA_SP:
007a7c 0008          .dw USER_SP
                 .include "words/rp0.asm"
                 
                 ; Stack
                 ; start address of return stack
                 VE_RP0:
007a7d ff03          .dw $ff03
007a7e 7072
007a7f 0030          .db "rp0",0
007a80 7a78          .dw VE_HEAD
                     .set VE_HEAD = VE_RP0
                 XT_RP0:
007a81 7001          .dw DO_COLON
                 PFA_RP0:
007a82 7a85          .dw XT_DORP0
007a83 7074          .dw XT_FETCH
007a84 701b          .dw XT_EXIT
                 
                 ; ( -- addr) 
                 ; Stack
                 ; user variable of the address of the initial return stack
                 ;VE_DORP0:
                 ;    .dw $ff05
                 ;    .db "(rp0)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DORP0
                 XT_DORP0:
007a85 7053          .dw PFA_DOUSER
                 PFA_DORP0:
007a86 0004          .dw USER_RP
                 .include "words/depth.asm"
                 
                 ; Stack
                 ; number of single-cell values contained in the data stack before n was placed on the stack.
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DEPTH:
007a87 ff05          .dw $ff05
007a88 6564
007a89 7470
007a8a 0068          .db "depth",0
007a8b 7a7d          .dw VE_HEAD
                     .set VE_HEAD = VE_DEPTH
                 XT_DEPTH:
007a8c 7001          .dw DO_COLON
                 PFA_DEPTH:
                 .endif
007a8d 7a74          .dw XT_SP0
007a8e 727c          .dw XT_SP_FETCH
007a8f 718e          .dw XT_MINUS
007a90 71ff          .dw XT_2SLASH
007a91 7230          .dw XT_1MINUS
007a92 701b          .dw XT_EXIT
                 .include "words/interpret.asm"
                 
                 ; System
                 ; Interpret SOURCE word by word.
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_INTERPRET:
007a93 ff09          .dw $ff09
007a94 6e69
007a95 6574
007a96 7072
007a97 6572
007a98 0074          .db "interpret",0
007a99 7a87          .dw VE_HEAD
                     .set VE_HEAD = VE_INTERPRET
                 XT_INTERPRET:
007a9a 7001          .dw DO_COLON
                 .endif
                 PFA_INTERPRET:
007a9b 79b7          .dw XT_PARSENAME ; ( -- addr len )
007a9c 70ac          .dw XT_DUP   ; ( -- addr len flag)
007a9d 7031          .dw XT_DOCONDBRANCH
007a9e 7aaa          DEST(PFA_INTERPRET2)
007a9f 7ab5            .dw XT_DORECOGNIZER
007aa0 754b            .dw XT_STATE
007aa1 7074            .dw XT_FETCH
007aa2 7031            .dw XT_DOCONDBRANCH
007aa3 7aa5          DEST(PFA_INTERPRET1)
007aa4 7b9e            .dw XT_ICELLPLUS   ; we need the compile action
                 PFA_INTERPRET1:
007aa5 73bb            .dw XT_FETCHI
007aa6 7025            .dw XT_EXECUTE
007aa7 7b49            .dw XT_QSTACK
007aa8 702a          .dw XT_DOBRANCH
007aa9 7a9b          DEST(PFA_INTERPRET)
                 PFA_INTERPRET2:
007aaa 756e          .dw XT_2DROP
007aab 701b          .dw XT_EXIT
                 .include "words/do-recognizer.asm"
                 
                 ; System
                 ; walk the recognizer stack
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DORECOGNIZER:
007aac ff0d          .dw $ff0d
007aad 6f64
007aae 722d
007aaf 6365
007ab0 676f
007ab1 696e
007ab2 657a
007ab3 0072          .db "do-recognizer",0
007ab4 7a93          .dw VE_HEAD
                     .set VE_HEAD = VE_DORECOGNIZER
                 XT_DORECOGNIZER:
007ab5 7001          .dw DO_COLON
                 PFA_DORECOGNIZER:
                 .endif
007ab6 7038          .dw XT_DOLITERAL
007ab7 7ac1          .dw XT_DORECOGNIZER_A
007ab8 7038          .dw XT_DOLITERAL
007ab9 005e          .dw CFG_RECOGNIZERLISTLEN
007aba 0411          .dw XT_MAPSTACK
007abb 7115          .dw XT_ZEROEQUAL
007abc 7031          .dw XT_DOCONDBRANCH
007abd 7ac0          DEST(PFA_DORECOGNIZER1)
007abe 756e            .dw XT_2DROP
007abf 7b3c            .dw XT_R_FAIL
                 PFA_DORECOGNIZER1:
007ac0 701b          .dw XT_EXIT
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 ; ( addr len XT -- addr len [ r:table -1 | 0 ] )
                 XT_DORECOGNIZER_A:
007ac1 7001         .dw DO_COLON
                 PFA_DORECOGNIZER_A:
                 .endif
007ac2 70dc         .dw XT_ROT  ; -- len xt addr
007ac3 70dc         .dw XT_ROT  ; -- xt addr len
007ac4 7565         .dw XT_2DUP 
007ac5 730d         .dw XT_2TO_R
007ac6 70dc         .dw XT_ROT  ; -- addr len xt
007ac7 7025         .dw XT_EXECUTE ; -- i*x r:foo | r:fail
007ac8 731c         .dw XT_2R_FROM
007ac9 70dc         .dw XT_ROT
007aca 70ac         .dw XT_DUP
007acb 7b3c         .dw XT_R_FAIL
007acc 7d72         .dw XT_EQUAL
007acd 7031         .dw XT_DOCONDBRANCH
007ace 7ad2         DEST(PFA_DORECOGNIZER_A1)
007acf 70d4           .dw XT_DROP
007ad0 714f           .dw XT_ZERO
007ad1 701b           .dw XT_EXIT
                 PFA_DORECOGNIZER_A1:
007ad2 70eb         .dw XT_NIP 
007ad3 70eb         .dw XT_NIP
007ad4 7146         .dw XT_TRUE
007ad5 701b         .dw XT_EXIT
                 
                 ; : do-recognizer ( addr len -- i*x r:table|r:fail )
                 ;    \ ( addr len -- addr len 0 | i*x r:table -1 )
                 ;    [: rot rot 2dup 2>r rot execute 2r> rot 
                 ;          dup r:fail = ( -- addr len r:table f )
                 ;          if drop 0 else nip nip -1 then
                 ;    ;] 
                 ;    EE_RECOGNIZERLISTLEN map-stack ( -- i*x addr len r:table f )
                 ;    0= if \ a recognizer did the job, remove addr/len
                 ;     2drop r:fail 
                 ;    then
                 ;
                 .include "words/r-intnumber.asm"
                 
                 ; Interpreter
                 ; Method table for single cell integers
                 
                 
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_R_NUM:
007ad6 ff05          .dw $ff05
007ad7 3a72
007ad8 756e
007ad9 006d          .db "r:num",0
007ada 7aac          .dw VE_HEAD
                     .set VE_HEAD = VE_R_NUM
                 XT_R_NUM:
007adb 704d          .dw PFA_DOCONSTANT
                 PFA_R_NUM:
                 .endif
007adc 7b71          .dw XT_NOOP    ; interpret
007add 01de          .dw XT_LITERAL ; compile
007ade 7ae8          .dw XT_FAILNUM ; postpone
                 
                 ; ( -- addr )
                 ; Interpreter
                 ; Method table for double cell integers
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_R_DNUM:
007adf ff06          .dw $ff06
007ae0 3a72
007ae1 6e64
007ae2 6d75          .db "r:dnum"
007ae3 7ad6          .dw VE_HEAD
                     .set VE_HEAD = VE_R_DNUM
                 XT_R_DNUM:
007ae4 704d          .dw PFA_DOCONSTANT
                 PFA_R_DNUM:
                 .endif
007ae5 7b71          .dw XT_NOOP     ; interpret
007ae6 7d66          .dw XT_2LITERAL ; compile
007ae7 7aee          .dw XT_FAILDNUM ; postpone
                 
                 ; ( -- addr )
                 ; Interpreter
                 ; Method to print a number and throw exception "invalid postpone"
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 ;VE_FAILNUM:
                 ;    .dw $ff06
                 ;    .db "fail:i"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_FAILNUM
                 XT_FAILNUM:
007ae8 7001          .dw DO_COLON
                 PFA_FAILNUM:
                 .endif
007ae9 772c          .dw XT_DOT
007aea 7038          .dw XT_DOLITERAL
007aeb ffd0          .dw -48
007aec 7843          .dw XT_THROW
007aed 701b          .dw XT_EXIT
                 
                 ; ( -- addr )
                 ; Interpreter
                 ; Method to print a double cell number and throw exception "invalid postpone"
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 VE_FAILDNUM:
                 ;    .dw $ff06
                 ;    .db "fail:d"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_FAILDNUM
                 XT_FAILDNUM:
007aee 7001          .dw DO_COLON
                 PFA_FAILDNUM:
                 .endif
007aef 7724          .dw XT_DDOT
007af0 7038          .dw XT_DOLITERAL
007af1 ffd0          .dw -48
007af2 7843          .dw XT_THROW
007af3 701b          .dw XT_EXIT
                 
                 ; ( addr len -- f )
                 ; Interpreter
                 ; recognizer for integer numbers
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 VE_REC_NUM:
007af4 ff07          .dw $ff07
007af5 6572
007af6 3a63
007af7 756e
007af8 006d          .db "rec:num",0
007af9 7adf          .dw VE_HEAD
                     .set VE_HEAD = VE_REC_NUM
                 XT_REC_NUM:
007afa 7001          .dw DO_COLON
                 PFA_REC_NUM:
                 .endif
                     ; try converting to a number
007afb 78f0          .dw XT_NUMBER
007afc 7031          .dw XT_DOCONDBRANCH
007afd 7b07          DEST(PFA_REC_NONUMBER)
007afe 7038          .dw XT_DOLITERAL
007aff 0001          .dw 1
007b00 7d72          .dw XT_EQUAL
007b01 7031          .dw XT_DOCONDBRANCH
007b02 7b05          DEST(PFA_REC_INTNUM2)
007b03 7adb            .dw XT_R_NUM
007b04 701b            .dw XT_EXIT
                 PFA_REC_INTNUM2:
007b05 7ae4            .dw XT_R_DNUM
007b06 701b            .dw XT_EXIT
                 PFA_REC_NONUMBER:
007b07 7b3c          .dw XT_R_FAIL
007b08 701b          .dw XT_EXIT
                 .include "words/r-word.asm"
                 
                 ; Interpreter
                 ; search for a word
                 .if cpu_msp430==1
                 .endif
                 .if cpu_avr8==1
                 VE_REC_WORD:
007b09 ff08          .dw $ff08
007b0a 6572
007b0b 3a63
007b0c 6f77
007b0d 6472          .db "rec:word"
007b0e 7af4          .dw VE_HEAD
                     .set VE_HEAD = VE_REC_WORD
                 XT_REC_WORD:
007b0f 7001          .dw DO_COLON
                 PFA_REC_WORD:
                 .endif
007b10 79d4          .DW XT_FINDNAME
007b11 70ac          .dw XT_DUP
007b12 7115          .dw XT_ZEROEQUAL
007b13 7031          .dw XT_DOCONDBRANCH
007b14 7b18          DEST(PFA_REC_WORD_FOUND)
007b15 70d4              .dw XT_DROP
007b16 7b3c      	.dw XT_R_FAIL
007b17 701b      	.dw XT_EXIT
                 PFA_REC_WORD_FOUND:
007b18 7b1f          .dw XT_R_WORD
                 
007b19 701b          .dw XT_EXIT
                 
                 ; ( -- addr )
                 ; Interpreter
                 ; actions to handle execution tokens and their flags
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_R_WORD:
007b1a ff06          .dw $ff06
007b1b 3a72
007b1c 6f77
007b1d 6472          .db "r:word"
007b1e 7b09          .dw VE_HEAD
                     .set VE_HEAD = VE_R_WORD
                 XT_R_WORD:
007b1f 704d          .dw PFA_DOCONSTANT
                 PFA_R_WORD:
                 .endif
007b20 7b23          .dw XT_R_WORD_INTERPRET
007b21 7b27          .dw XT_R_WORD_COMPILE
007b22 7b2f          .dw XT_R_WORD_POSTPONE
                 
                 ; ( XT flags -- )
                 ; Interpreter
                 ; interpret method for WORD recognizer
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 XT_R_WORD_INTERPRET:
007b23 7001          .dw DO_COLON
                 PFA_R_WORD_INTERPRET:
                 .endif
007b24 70d4          .dw XT_DROP ; the flags are in the way
007b25 7025          .dw XT_EXECUTE
007b26 701b          .dw XT_EXIT
                 
                 ; ( XT flags -- )
                 ; Interpreter
                 ; Compile method for WORD recognizer
                 .if cpu_msp430==1
                 .endif
                 .if cpu_avr8==1
                 XT_R_WORD_COMPILE:
007b27 7001          .dw DO_COLON
                 PFA_R_WORD_COMPILE:
                 .endif
007b28 711c          .dw XT_ZEROLESS
007b29 7031          .dw XT_DOCONDBRANCH
007b2a 7b2d          DEST(PFA_R_WORD_COMPILE1)
007b2b 01c8      	.dw XT_COMMA
007b2c 701b              .dw XT_EXIT
                 PFA_R_WORD_COMPILE1:
007b2d 7025              .dw XT_EXECUTE
007b2e 701b          .dw XT_EXIT
                 
                 ; ( XT flags -- )
                 ; Interpreter
                 ; Postpone method for WORD recognizer
                 .if cpu_msp430==1
                 .endif
                 .if cpu_avr8==1
                 XT_R_WORD_POSTPONE:
007b2f 7001          .dw DO_COLON
                 PFA_R_WORD_POSTPONE:
                 .endif
007b30 711c          .dw XT_ZEROLESS
007b31 7031          .dw XT_DOCONDBRANCH
007b32 7b35          DEST(PFA_R_WORD_POSTPONE1)
007b33 01bd            .dw XT_COMPILE
007b34 01bd            .dw XT_COMPILE
                 PFA_R_WORD_POSTPONE1:
007b35 01c8          .dw XT_COMMA
007b36 701b          .dw XT_EXIT
                 .include "words/r-fail.asm"
                 
                 ; Interpreter
                 ; there is no parser for this recognizer, this is the default and failsafe part
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_R_FAIL:
007b37 ff06          .dw $ff06
007b38 3a72
007b39 6166
007b3a 6c69          .db "r:fail"
007b3b 7b1a          .dw VE_HEAD
                     .set VE_HEAD = VE_R_FAIL
                 XT_R_FAIL:
007b3c 704d          .dw PFA_DOCONSTANT
                 PFA_R_FAIL:
                 .endif
007b3d 7b40          .dw XT_FAIL  ; interpret
007b3e 7b40          .dw XT_FAIL  ; compile
007b3f 7b40          .dw XT_FAIL  ; postpone
                 
                 ; ( addr len -- )
                 ; Interpreter
                 ; default failure action: throw exception -13.
                 .if cpu_msp430==1
                 .endif
                 .if cpu_avr8==1
                 ;VE_FAIL:
                 ;    .dw $ff04
                 ;    .db "fail"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_FAIL
                 XT_FAIL:
007b40 7001          .dw DO_COLON
                 PFA_FAIL:
                 .endif
007b41 7038          .dw XT_DOLITERAL
007b42 fff3          .dw -13
007b43 7843          .dw XT_THROW
                 
                 .include "words/q-stack.asm"
                 
                 ; Tools
                 ; check data stack depth and exit to quit if underrun
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_QSTACK:
007b44 ff06          .dw $ff06
007b45 733f
007b46 6174
007b47 6b63          .db "?stack"
007b48 7b37          .dw VE_HEAD
                     .set VE_HEAD = VE_QSTACK
                 XT_QSTACK:
007b49 7001          .dw DO_COLON
                 PFA_QSTACK:
                 .endif
007b4a 7a8c          .dw XT_DEPTH
007b4b 711c          .dw XT_ZEROLESS
007b4c 7031          .dw XT_DOCONDBRANCH
007b4d 7b51          DEST(PFA_QSTACK1)
007b4e 7038            .dw XT_DOLITERAL
007b4f fffc            .dw -4
007b50 7843            .dw XT_THROW
                 PFA_QSTACK1:
007b51 701b          .dw XT_EXIT
                 .include "words/ver.asm"
                 
                 ; Tools
                 ; print the version string
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DOT_VER:
007b52 ff03          .dw $ff03
007b53 6576
../../common\words/ver.asm(12): warning: .cseg .db misalignment - padding zero byte
007b54 0072          .db "ver"
007b55 7b44          .dw VE_HEAD
                     .set VE_HEAD = VE_DOT_VER
                 XT_DOT_VER:
007b56 7001          .dw DO_COLON
                 PFA_DOT_VER:
                 .endif
007b57 750d          .dw XT_ENV_FORTHNAME
007b58 77aa          .dw XT_ITYPE
007b59 77ec          .dw XT_SPACE
007b5a 7551          .dw XT_BASE
007b5b 7074          .dw XT_FETCH
                 
007b5c 751b          .dw XT_ENV_FORTHVERSION
007b5d 75e4          .dw XT_DECIMAL
007b5e 7d56          .dw XT_S2D
007b5f 76c8          .dw XT_L_SHARP
007b60 76d0          .dw XT_SHARP
007b61 7038          .dw XT_DOLITERAL
007b62 002e          .dw '.'
007b63 76b9          .dw XT_HOLD
007b64 76e6          .dw XT_SHARP_S
007b65 76f1          .dw XT_SHARP_G
007b66 7805          .dw XT_TYPE
007b67 7551          .dw XT_BASE
007b68 707c          .dw XT_STORE
007b69 77ec          .dw XT_SPACE
007b6a 7523          .dw XT_ENV_CPU
007b6b 77aa          .dw XT_ITYPE
                 
007b6c 701b          .dw XT_EXIT
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/noop.asm"
                 
                 ; Tools
                 ; do nothing
                 VE_NOOP:
007b6d ff04          .dw $ff04
007b6e 6f6e
007b6f 706f          .db "noop"
007b70 7b52          .dw VE_HEAD
                     .set VE_HEAD = VE_NOOP
                 XT_NOOP:
007b71 7b72          .dw PFA_NOOP
                 PFA_NOOP:
007b72 940c 7005     jmp_ DO_NEXT
                 .include "words/unused.asm"
                 
                 ; Tools
                 ; Amount of available RAM (incl. PAD)
                 VE_UNUSED:
007b74 ff06          .dw $ff06
007b75 6e75
007b76 7375
007b77 6465          .db "unused"
007b78 7b6d          .dw VE_HEAD
                     .set VE_HEAD = VE_UNUSED
                 XT_UNUSED:
007b79 7001          .dw DO_COLON
                 PFA_UNUSED:
007b7a 727c          .dw XT_SP_FETCH
007b7b 75c5          .dw XT_HERE
007b7c 718e          .dw XT_MINUS
007b7d 701b          .dw XT_EXIT
                 
                 .include "words/to.asm"
                 
                 ; Tools
                 ; store the TOS to the named value (eeprom cell)
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_TO:
007b7e 0002          .dw $0002
007b7f 6f74          .db "to"
007b80 7b74          .dw VE_HEAD
                     .set VE_HEAD = VE_TO
                 XT_TO:
007b81 7001          .dw DO_COLON
                 PFA_TO:
                 .endif
007b82 7814          .dw XT_TICK
007b83 7d5f          .dw XT_TO_BODY
007b84 754b          .dw XT_STATE
007b85 7074          .dw XT_FETCH
007b86 7031          .dw XT_DOCONDBRANCH
007b87 7b92          DEST(PFA_TO1)
007b88 01bd          .dw XT_COMPILE
007b89 7b8c          .dw XT_DOTO
007b8a 01c8          .dw XT_COMMA
007b8b 701b          .dw XT_EXIT
                 
                 ; ( n -- ) (R: IP -- IP+1)
                 ; Tools
                 ; runtime portion of to
                 ;VE_DOTO:
                 ;    .dw $ff04
                 ;    .db "(to)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOTO
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 XT_DOTO:
007b8c 7001          .dw DO_COLON
                 PFA_DOTO:
                 .endif
007b8d 70f1          .dw XT_R_FROM
007b8e 70ac          .dw XT_DUP
007b8f 7b9e          .dw XT_ICELLPLUS
007b90 70fa          .dw XT_TO_R
007b91 73bb          .dw XT_FETCHI
                 PFA_TO1:
007b92 70ac          .dw XT_DUP
007b93 7b9e          .dw XT_ICELLPLUS
007b94 7b9e          .dw XT_ICELLPLUS
007b95 73bb          .dw XT_FETCHI
007b96 7025          .dw XT_EXECUTE
007b97 701b          .dw XT_EXIT
                 .include "words/i-cellplus.asm"
                 
                 ; Compiler
                 ; skip to the next cell in flash
                 VE_ICELLPLUS:
007b98 ff07          .dw $FF07
007b99 2d69
007b9a 6563
007b9b 6c6c
007b9c 002b          .db "i-cell+",0
007b9d 7b7e          .dw VE_HEAD
                     .set VE_HEAD = VE_ICELLPLUS
                 XT_ICELLPLUS:
007b9e 7001          .dw DO_COLON
                 PFA_ICELLPLUS:
007b9f 722a          .dw XT_1PLUS
007ba0 701b          .dw XT_EXIT
                 
                 .include "words/edefer-fetch.asm"
                 
                 ; System
                 ; does the real defer@ for eeprom defers
                 VE_EDEFERFETCH:
007ba1 ff07          .dw $ff07
007ba2 6445
007ba3 6665
007ba4 7265
007ba5 0040          .db "Edefer@",0
007ba6 7b98          .dw VE_HEAD
                     .set VE_HEAD = VE_EDEFERFETCH
                 XT_EDEFERFETCH:
007ba7 7001          .dw DO_COLON
                 PFA_EDEFERFETCH:
007ba8 73bb          .dw XT_FETCHI
007ba9 734e          .dw XT_FETCHE
007baa 701b          .dw XT_EXIT
                 .include "words/edefer-store.asm"
                 
                 ; System
                 ; does the real defer! for eeprom defers
                 VE_EDEFERSTORE:
007bab ff07          .dw $ff07
007bac 6445
007bad 6665
007bae 7265
007baf 0021          .db "Edefer!",0
007bb0 7ba1          .dw VE_HEAD
                     .set VE_HEAD = VE_EDEFERSTORE
                 XT_EDEFERSTORE:
007bb1 7001          .dw DO_COLON
                 PFA_EDEFERSTORE:
007bb2 73bb          .dw XT_FETCHI
007bb3 732a          .dw XT_STOREE
007bb4 701b          .dw XT_EXIT
                 .include "words/rdefer-fetch.asm"
                 
                 ; System
                 ; The defer@ for ram defers
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_RDEFERFETCH:
007bb5 ff07          .dw $ff07
007bb6 6452
007bb7 6665
007bb8 7265
007bb9 0040          .db "Rdefer@",0
007bba 7bab          .dw VE_HEAD
                     .set VE_HEAD = VE_RDEFERFETCH
                 XT_RDEFERFETCH:
007bbb 7001          .dw DO_COLON
                 PFA_RDEFERFETCH:
                 .endif
007bbc 73bb          .dw XT_FETCHI
007bbd 7074          .dw XT_FETCH
007bbe 701b          .dw XT_EXIT
                 .include "words/rdefer-store.asm"
                 
                 ; System
                 ; The defer! for ram defers
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_RDEFERSTORE:
007bbf ff07          .dw $ff07
007bc0 6452
007bc1 6665
007bc2 7265
007bc3 0021          .db "Rdefer!",0
007bc4 7bb5          .dw VE_HEAD
                     .set VE_HEAD = VE_RDEFERSTORE
                 XT_RDEFERSTORE:
007bc5 7001          .dw DO_COLON
                 PFA_RDEFERSTORE:
                 .endif
007bc6 73bb          .dw XT_FETCHI
007bc7 707c          .dw XT_STORE
007bc8 701b          .dw XT_EXIT
                 
                 .include "words/udefer-fetch.asm"
                 
                 ; System
                 ; does the real defer@ for user based defers
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_UDEFERFETCH:
007bc9 ff07          .dw $ff07
007bca 6455
007bcb 6665
007bcc 7265
007bcd 0040          .db "Udefer@",0
007bce 7bbf          .dw VE_HEAD
                     .set VE_HEAD = VE_UDEFERFETCH
                 XT_UDEFERFETCH:
007bcf 7001          .dw DO_COLON
                 PFA_UDEFERFETCH:
                 .endif
007bd0 73bb          .dw XT_FETCHI
007bd1 72f1          .dw XT_UP_FETCH
007bd2 7198          .dw XT_PLUS
007bd3 7074          .dw XT_FETCH
007bd4 701b          .dw XT_EXIT
                 .include "words/udefer-store.asm"
                 
                 ; System
                 ; does the real defer! for user based defers
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_UDEFERSTORE:
007bd5 ff07          .dw $ff07
007bd6 6455
007bd7 6665
007bd8 7265
007bd9 0021          .db "Udefer!",0
007bda 7bc9          .dw VE_HEAD
                     .set VE_HEAD = VE_UDEFERSTORE
                 XT_UDEFERSTORE:
007bdb 7001          .dw DO_COLON
                 PFA_UDEFERSTORE:
                 .endif
                 
007bdc 73bb          .dw XT_FETCHI
007bdd 72f1          .dw XT_UP_FETCH
007bde 7198          .dw XT_PLUS
007bdf 707c          .dw XT_STORE
007be0 701b          .dw XT_EXIT
                 
                 .include "words/defer-store.asm"
                 
                 ; System
                 ; stores xt1 as the xt to be executed when xt2 is called
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DEFERSTORE:
007be1 ff06          .dw $ff06
007be2 6564
007be3 6566
007be4 2172          .db "defer!"
007be5 7bd5          .dw VE_HEAD
                     .set VE_HEAD = VE_DEFERSTORE
                 XT_DEFERSTORE:
007be6 7001          .dw DO_COLON
                 PFA_DEFERSTORE:
                 .endif
007be7 7d5f          .dw XT_TO_BODY
007be8 70ac          .dw XT_DUP
007be9 7b9e          .dw XT_ICELLPLUS
007bea 7b9e          .dw XT_ICELLPLUS
007beb 73bb          .dw XT_FETCHI
007bec 7025          .dw XT_EXECUTE
007bed 701b          .dw XT_EXIT
                 
                 .include "words/defer-fetch.asm"
                 
                 ; System
                 ; returns the XT associated with the given XT
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DEFERFETCH:
007bee ff06          .dw $ff06
007bef 6564
007bf0 6566
007bf1 4072          .db "defer@"
007bf2 7be1          .dw VE_HEAD
                     .set VE_HEAD = VE_DEFERFETCH
                 XT_DEFERFETCH:
007bf3 7001          .dw DO_COLON
                 PFA_DEFERFETCH:
                 .endif
007bf4 7d5f          .dw XT_TO_BODY 
007bf5 70ac          .dw XT_DUP
007bf6 7b9e          .dw XT_ICELLPLUS
007bf7 73bb          .dw XT_FETCHI
007bf8 7025          .dw XT_EXECUTE
007bf9 701b          .dw XT_EXIT
                 .include "words/do-defer.asm"
                 
                 ; System
                 ; runtime of defer
                 VE_DODEFER:
007bfa ff07          .dw $ff07
007bfb 6428
007bfc 6665
007bfd 7265
007bfe 0029          .db "(defer)", 0
007bff 7bee          .dw VE_HEAD
                     .set VE_HEAD = VE_DODEFER
                 XT_DODEFER:
007c00 7001          .dw DO_COLON
                 PFA_DODEFER:
007c01 0197          .dw XT_DOCREATE
007c02 02fb          .dw XT_REVEAL
007c03 01bd          .dw XT_COMPILE
007c04 7c06          .dw PFA_DODEFER1
007c05 701b          .dw XT_EXIT
                 PFA_DODEFER1:
007c06 940e 031f     call_ DO_DODOES
007c08 70ac          .dw XT_DUP
007c09 7b9e          .dw XT_ICELLPLUS
007c0a 73bb          .dw XT_FETCHI
007c0b 7025          .dw XT_EXECUTE 
007c0c 7025          .dw XT_EXECUTE
007c0d 701b          .dw XT_EXIT
                 
                 ; : (defer) <builds does> dup i-cell+ @i execute execute ;
                 
                 
                 .include "words/search-wordlist.asm"
                 
                 ; Search Order
                 ; searches the word list wid for the word at c-addr/len
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SEARCH_WORDLIST:
007c0e ff0f          .dw $ff0f
007c0f 6573
007c10 7261
007c11 6863
007c12 772d
007c13 726f
007c14 6c64
007c15 7369
007c16 0074          .db "search-wordlist",0
007c17 7bfa          .dw VE_HEAD
                     .set VE_HEAD = VE_SEARCH_WORDLIST
                 XT_SEARCH_WORDLIST:
007c18 7001          .dw DO_COLON
                 PFA_SEARCH_WORDLIST:
                 .endif
007c19 70fa          .dw XT_TO_R
007c1a 714f          .dw XT_ZERO
007c1b 7038          .dw XT_DOLITERAL
007c1c 7c2d          .dw XT_ISWORD
007c1d 70f1          .dw XT_R_FROM
007c1e 7c4a          .dw XT_TRAVERSEWORDLIST
007c1f 70ac          .dw XT_DUP
007c20 7115          .dw XT_ZEROEQUAL
007c21 7031          .dw XT_DOCONDBRANCH
007c22 7c27          DEST(PFA_SEARCH_WORDLIST1)
007c23 756e             .dw XT_2DROP
007c24 70d4             .dw XT_DROP
007c25 714f             .dw XT_ZERO
007c26 701b             .dw XT_EXIT
                 PFA_SEARCH_WORDLIST1:
                       ; ... get the XT ...
007c27 70ac            .dw XT_DUP
007c28 7c71            .dw XT_NFA2CFA
                       ; .. and get the header flag
007c29 70bf            .dw XT_SWAP
007c2a 0169            .dw XT_NAME2FLAGS
007c2b 0156            .dw XT_IMMEDIATEQ
007c2c 701b          .dw XT_EXIT
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 XT_ISWORD:
007c2d 7001          .dw DO_COLON
                 PFA_ISWORD:
                 .endif
                     ; ( c-addr len 0 nt -- c-addr len 0 true| nt false )
007c2e 70fa          .dw XT_TO_R
007c2f 70d4          .dw XT_DROP
007c30 7565          .dw XT_2DUP
007c31 7103          .dw XT_R_FETCH  ; -- addr len addr len nt
007c32 7c65          .dw XT_NAME2STRING
007c33 7c7b          .dw XT_ICOMPARE      ; (-- addr len f )
007c34 7031          .dw XT_DOCONDBRANCH
007c35 7c3b          DEST(PFA_ISWORD3)
                       ; not now
007c36 70f1            .dw XT_R_FROM
007c37 70d4            .dw XT_DROP
007c38 714f            .dw XT_ZERO
007c39 7146            .dw XT_TRUE         ; maybe next word
007c3a 701b            .dw XT_EXIT
                 PFA_ISWORD3:
                       ; we found the word, now clean up iteration data ...
007c3b 756e            .dw XT_2DROP
007c3c 70f1            .dw XT_R_FROM
007c3d 714f            .dw XT_ZERO       ; finish traverse-wordlist
007c3e 701b            .dw XT_EXIT
                 .include "words/traverse-wordlist.asm"
                 
                 ; Tools Ext (2012)
                 ; call the xt for every member of the wordlist wid until xt returns false
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_TRAVERSEWORDLIST:
007c3f ff11          .dw $ff11
007c40 7274
007c41 7661
007c42 7265
007c43 6573
007c44 772d
007c45 726f
007c46 6c64
007c47 7369
007c48 0074          .db "traverse-wordlist",0
007c49 7c0e          .dw VE_HEAD
                     .set VE_HEAD = VE_TRAVERSEWORDLIST
                 XT_TRAVERSEWORDLIST:
007c4a 7001          .dw DO_COLON
                 PFA_TRAVERSEWORDLIST:
                 
                 .endif
007c4b 734e          .dw XT_FETCHE
                 PFA_TRAVERSEWORDLIST1:
007c4c 70ac          .dw XT_DUP           ; ( -- xt nt nt )
007c4d 7031          .dw XT_DOCONDBRANCH  ; ( -- nt ) is nfa = counted string
007c4e 7c5b          DEST(PFA_TRAVERSEWORDLIST2)
007c4f 7565          .dw XT_2DUP
007c50 730d          .dw XT_2TO_R
007c51 70bf          .dw XT_SWAP
007c52 7025          .dw XT_EXECUTE
007c53 731c          .dw XT_2R_FROM
007c54 70dc          .dw XT_ROT
007c55 7031          .dw XT_DOCONDBRANCH
007c56 7c5b          DEST(PFA_TRAVERSEWORDLIST2)
007c57 0478          .dw XT_NFA2LFA
007c58 73bb          .dw XT_FETCHI
007c59 702a          .dw XT_DOBRANCH      ; ( -- addr )
007c5a 7c4c          DEST(PFA_TRAVERSEWORDLIST1)       ; ( -- addr )
                 PFA_TRAVERSEWORDLIST2:
007c5b 756e          .dw XT_2DROP
007c5c 701b          .dw XT_EXIT
                 
                 ; : traverse-wordlist ( i*x xt wid -- i*x' ) 
                 ;        begin @ dup 
                 ;        while 
                 ;          2dup 2>r 
                 ;          cell + swap execute ( i*x nt -- i*x' f ) 
                 ;          2r> rot 
                 ;        while repeat then 2drop ; 
                 .include "words/name2string.asm"
                 
                 ; Tools Ext (2012)
                 ; get a (flash) string from a name token nt
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_NAME2STRING:
007c5d ff0b          .dw $ff0b
007c5e 616e
007c5f 656d
007c60 733e
007c61 7274
007c62 6e69
007c63 0067          .db "name>string",0
007c64 7c3f          .dw VE_HEAD
                     .set VE_HEAD = VE_NAME2STRING
                 XT_NAME2STRING:
007c65 7001          .dw DO_COLON
                 PFA_NAME2STRING:
                 
                 .endif
007c66 77d6          .dw XT_ICOUNT   ; ( -- addr n )
007c67 7038          .dw XT_DOLITERAL
007c68 00ff          .dw 255
007c69 720e          .dw XT_AND      ; mask immediate bit
007c6a 701b          .dw XT_EXIT
                 .include "words/nfa2cfa.asm"
                 
                 ; Tools
                 ; get the XT from a name token
                 VE_NFA2CFA:
007c6b ff07          .dw $ff07
007c6c 666e
007c6d 3e61
007c6e 6663
../../avr8\words/nfa2cfa.asm(6): warning: .cseg .db misalignment - padding zero byte
007c6f 0061          .db "nfa>cfa"
007c70 7c5d          .dw VE_HEAD
                     .set VE_HEAD = VE_NFA2CFA
                 XT_NFA2CFA:
007c71 7001          .dw DO_COLON
                 PFA_NFA2CFA:
007c72 0478          .dw XT_NFA2LFA ; skip to link field
007c73 722a          .dw XT_1PLUS   ; next is the execution token
007c74 701b          .dw XT_EXIT
                 .include "words/icompare.asm"
                 
                 ; Tools
                 ; compares string in RAM with string in flash. f is zero if equal like COMPARE
                 VE_ICOMPARE:
007c75 ff08          .dw $ff08
007c76 6369
007c77 6d6f
007c78 6170
007c79 6572          .db "icompare"
007c7a 7c6b          .dw VE_HEAD
                     .set VE_HEAD = VE_ICOMPARE
                 XT_ICOMPARE:
007c7b 7001          .dw DO_COLON
                 PFA_ICOMPARE:
007c7c 70fa          .dw XT_TO_R    ; ( -- r-addr r-len f-addr)
007c7d 70ca          .dw XT_OVER    ; ( -- r-addr r-len f-addr r-len)
007c7e 70f1          .dw XT_R_FROM  ; ( -- r-addr r-len f-addr r-len f-len )
007c7f 710e          .dw XT_NOTEQUAL ; ( -- r-addr r-len f-addr flag )
007c80 7031          .dw XT_DOCONDBRANCH
007c81 7c86          .dw PFA_ICOMPARE_SAMELEN
007c82 756e            .dw XT_2DROP
007c83 70d4            .dw XT_DROP
007c84 7146            .dw XT_TRUE
007c85 701b            .dw XT_EXIT
                 PFA_ICOMPARE_SAMELEN:
007c86 70bf          .dw XT_SWAP ; ( -- r-addr f-addr len )
007c87 714f          .dw XT_ZERO
007c88 0287          .dw XT_QDOCHECK
007c89 7031          .dw XT_DOCONDBRANCH
007c8a 7ca9          .dw PFA_ICOMPARE_DONE
007c8b 728a          .dw XT_DODO
                 PFA_ICOMPARE_LOOP:
                     ; ( r-addr f-addr --)
007c8c 70ca          .dw XT_OVER
007c8d 7074          .dw XT_FETCH
                 .if WANT_IGNORECASE == 1
                 .endif
007c8e 70ca          .dw XT_OVER
007c8f 73bb          .dw XT_FETCHI ; ( -- r-addr f-addr r-cc f- cc)
                 .if WANT_IGNORECASE == 1
                 .endif
                     ; flash strings are zero-padded at the last cell
                     ; that means: if the flash cell is less $0100, than mask the
                     ; high byte in the ram cell
007c90 70ac          .dw XT_DUP
                     ;.dw XT_BYTESWAP
007c91 7038          .dw XT_DOLITERAL
007c92 0100          .dw $100
007c93 7157          .dw XT_ULESS
007c94 7031          .dw XT_DOCONDBRANCH
007c95 7c9a          .dw PFA_ICOMPARE_LASTCELL
007c96 70bf          .dw XT_SWAP
007c97 7038          .dw XT_DOLITERAL
007c98 00ff          .dw $00FF
007c99 720e          .dw XT_AND  ; the final swap can be omitted
                 PFA_ICOMPARE_LASTCELL:
007c9a 710e          .dw XT_NOTEQUAL
007c9b 7031          .dw XT_DOCONDBRANCH
007c9c 7ca1          .dw PFA_ICOMPARE_NEXTLOOP
007c9d 756e          .dw XT_2DROP
007c9e 7146          .dw XT_TRUE
007c9f 72c3          .dw XT_UNLOOP
007ca0 701b          .dw XT_EXIT
                 PFA_ICOMPARE_NEXTLOOP:
007ca1 722a          .dw XT_1PLUS
007ca2 70bf          .dw XT_SWAP
007ca3 755e          .dw XT_CELLPLUS
007ca4 70bf          .dw XT_SWAP
007ca5 7038          .dw XT_DOLITERAL
007ca6 0002          .dw 2
007ca7 72a9          .dw XT_DOPLUSLOOP
007ca8 7c8c          .dw PFA_ICOMPARE_LOOP
                 PFA_ICOMPARE_DONE:
007ca9 756e          .dw XT_2DROP
007caa 714f          .dw XT_ZERO
007cab 701b          .dw XT_EXIT
                 
                 .if WANT_IGNORECASE == 1
                 .endif
                 
                 .include "words/star.asm"
                 
                 ; Arithmetics
                 ; multiply routine
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_STAR:
007cac ff01          .dw $ff01
007cad 002a          .db "*",0
007cae 7c75          .dw VE_HEAD
                     .set VE_HEAD = VE_STAR
                 XT_STAR:
007caf 7001          .dw DO_COLON
                 PFA_STAR:
                 .endif
                 
007cb0 71a1          .dw XT_MSTAR
007cb1 70d4          .dw XT_DROP
007cb2 701b          .dw XT_EXIT
                 .include "words/j.asm"
                 
                 ; Compiler
                 ; loop counter of outer loop
                 VE_J:
007cb3 ff01          .dw $FF01
007cb4 006a          .db "j",0
007cb5 7cac          .dw VE_HEAD
                     .set VE_HEAD = VE_J
                 XT_J:
007cb6 7001          .dw DO_COLON
                 PFA_J:
007cb7 7265          .dw XT_RP_FETCH
007cb8 7038          .dw XT_DOLITERAL
007cb9 0007          .dw 7
007cba 7198          .dw XT_PLUS
007cbb 7074          .dw XT_FETCH
007cbc 7265          .dw XT_RP_FETCH
007cbd 7038          .dw XT_DOLITERAL
007cbe 0009          .dw 9
007cbf 7198          .dw XT_PLUS
007cc0 7074          .dw XT_FETCH
007cc1 7198          .dw XT_PLUS
007cc2 701b          .dw XT_EXIT
                 
                 .include "words/dabs.asm"
                 
                 ; Arithmetics
                 ; double cell absolute value
                 VE_DABS:
007cc3 ff04          .dw $ff04
007cc4 6164
007cc5 7362          .db "dabs"
007cc6 7cb3          .dw VE_HEAD
                     .set VE_HEAD = VE_DABS
                 XT_DABS:
007cc7 7001          .dw DO_COLON
                 PFA_DABS:
007cc8 70ac          .dw XT_DUP
007cc9 711c          .dw XT_ZEROLESS
007cca 7031          .dw XT_DOCONDBRANCH
007ccb 7ccd          .dw PFA_DABS1
007ccc 7cd4          .dw XT_DNEGATE
                 PFA_DABS1:
007ccd 701b          .dw XT_EXIT
                 ; : dabs      ( ud1 -- +d2 ) dup 0< if dnegate then ;
                 .include "words/dnegate.asm"
                 
                 ; Arithmetics
                 ; double cell negation
                 VE_DNEGATE:
007cce ff07          .dw $ff07
007ccf 6e64
007cd0 6765
007cd1 7461
007cd2 0065          .db "dnegate",0
007cd3 7cc3          .dw VE_HEAD
                     .set VE_HEAD = VE_DNEGATE
                 XT_DNEGATE:
007cd4 7001          .dw DO_COLON
                 PFA_DNEGATE:
007cd5 742b          .dw XT_DINVERT
007cd6 7038          .dw XT_DOLITERAL
007cd7 0001          .dw 1
007cd8 714f          .dw XT_ZERO
007cd9 7405          .dw XT_DPLUS
007cda 701b          .dw XT_EXIT
                 ; : dnegate   ( ud1 -- ud2 ) dinvert 1. d+ ;
                 .include "words/cmove.asm"
                 
                 ; Memory
                 ; copy data in RAM, from lower to higher addresses
                 VE_CMOVE:
007cdb ff05          .dw $ff05
007cdc 6d63
007cdd 766f
007cde 0065          .db "cmove",0
007cdf 7cce          .dw VE_HEAD
                     .set VE_HEAD  = VE_CMOVE
                 XT_CMOVE:
007ce0 7ce1          .dw PFA_CMOVE
                 PFA_CMOVE:
007ce1 93bf          push xh
007ce2 93af          push xl
007ce3 91e9          ld zl, Y+
007ce4 91f9          ld zh, Y+ ; addr-to
007ce5 91a9          ld xl, Y+
007ce6 91b9          ld xh, Y+ ; addr-from
007ce7 2f09          mov temp0, tosh
007ce8 2b08          or temp0, tosl
007ce9 f021          brbs 1, PFA_CMOVE1
                 PFA_CMOVE2:
007cea 911d          ld temp1, X+
007ceb 9311          st Z+, temp1
007cec 9701          sbiw tosl, 1
007ced f7e1          brbc 1, PFA_CMOVE2
                 PFA_CMOVE1:
007cee 91af          pop xl
007cef 91bf          pop xh
007cf0 9189
007cf1 9199          loadtos
007cf2 940c 7005     jmp_ DO_NEXT
                 .include "words/2swap.asm"
                 
                 ; Stack
                 ; Exchange the two top cell pairs
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_2SWAP:
007cf4 ff05          .dw $ff05
007cf5 7332
007cf6 6177
007cf7 0070          .db "2swap",0
007cf8 7cdb          .dw VE_HEAD
                     .set VE_HEAD = VE_2SWAP
                 XT_2SWAP:
007cf9 7001          .dw DO_COLON
                 PFA_2SWAP:
                 
                 .endif
007cfa 70dc          .dw XT_ROT
007cfb 70fa          .dw XT_TO_R
007cfc 70dc          .dw XT_ROT
007cfd 70f1          .dw XT_R_FROM
007cfe 701b          .dw XT_EXIT
                 
                 .include "words/tib.asm"
                 
                 ; System Variable
                 ; terminal input buffer address
                 VE_TIB:
007cff ff03          .dw $ff03
007d00 6974
007d01 0062          .db "tib",0
007d02 7cf4          .dw VE_HEAD
                     .set VE_HEAD = VE_TIB
                 XT_TIB:
007d03 7043          .dw PFA_DOVARIABLE
                 PFA_TIB:
007d04 014d          .dw ram_tib
                     
                 .dseg
00014d           ram_tib: .byte TIBSIZE
                 .cseg
                 ; ( -- f ) 
                 ; System
                 ; refills the input buffer
                 VE_REFILLTIB:
007d05 ff0a          .dw $ff0a
007d06 6572
007d07 6966
007d08 6c6c
007d09 742d
007d0a 6269          .db "refill-tib"
007d0b 7cff          .dw VE_HEAD
                     .set VE_HEAD = VE_REFILLTIB
                 XT_REFILLTIB:
007d0c 7001          .dw DO_COLON
                 PFA_REFILLTIB:
007d0d 7d03          .dw XT_TIB
007d0e 7038          .dw XT_DOLITERAL
007d0f 005a          .dw TIBSIZE
007d10 7894          .dw XT_ACCEPT
007d11 7584          .dw XT_NUMBERTIB
007d12 707c          .dw XT_STORE
007d13 714f          .dw XT_ZERO
007d14 757e          .dw XT_TO_IN
007d15 707c          .dw XT_STORE
007d16 7146          .dw XT_TRUE ; -1
007d17 701b          .dw XT_EXIT
                 
                 ; ( -- addr n ) 
                 ; System
                 ; address and current length of the input buffer
                 VE_SOURCETIB:
007d18 ff0a          .dw $FF0A
007d19 6f73
007d1a 7275
007d1b 6563
007d1c 742d
007d1d 6269          .db "source-tib"
007d1e 7d05          .dw VE_HEAD
                     .set VE_HEAD = VE_SOURCETIB
                 XT_SOURCETIB:
007d1f 7001          .dw DO_COLON
                 PFA_SOURCETIB:
007d20 7d03          .dw XT_TIB
007d21 7584          .dw XT_NUMBERTIB
007d22 7074          .dw XT_FETCH
007d23 701b          .dw XT_EXIT
                 
                 .include "words/init-user.asm"
                 
                 ; Tools
                 ; copy len cells from eeprom to ram
                 VE_EE2RAM:
007d24 ff06        .dw $ff06
007d25 6565
007d26 723e
007d27 6d61        .db "ee>ram"
007d28 7d18        .dw VE_HEAD
                   .set VE_HEAD = VE_EE2RAM
                 XT_EE2RAM:
007d29 7001        .dw DO_COLON
                 PFA_EE2RAM:          ; ( -- )
007d2a 714f          .dw XT_ZERO
007d2b 728a          .dw XT_DODO
                 PFA_EE2RAM_1:
                     ; ( -- e-addr r-addr )
007d2c 70ca          .dw XT_OVER
007d2d 734e          .dw XT_FETCHE
007d2e 70ca          .dw XT_OVER
007d2f 707c          .dw XT_STORE
007d30 755e          .dw XT_CELLPLUS
007d31 70bf          .dw XT_SWAP
007d32 755e          .dw XT_CELLPLUS
007d33 70bf          .dw XT_SWAP
007d34 72b8          .dw XT_DOLOOP
007d35 7d2c          .dw PFA_EE2RAM_1
                 PFA_EE2RAM_2:
007d36 756e          .dw XT_2DROP
007d37 701b          .dw XT_EXIT
                 
                 ; ( -- )
                 ; Tools
                 ; setup the default user area from eeprom
                 VE_INITUSER:
007d38 ff09        .dw $ff09
007d39 6e69
007d3a 7469
007d3b 752d
007d3c 6573
007d3d 0072        .db "init-user",0
007d3e 7d24        .dw VE_HEAD
                   .set VE_HEAD = VE_INITUSER
                 XT_INITUSER:
007d3f 7001        .dw DO_COLON
                 PFA_INITUSER:          ; ( -- )
007d40 7038          .dw XT_DOLITERAL
007d41 006e          .dw EE_INITUSER
007d42 72f1          .dw XT_UP_FETCH
007d43 7038          .dw XT_DOLITERAL
007d44 001c          .dw SYSUSERSIZE
007d45 71ff          .dw XT_2SLASH
007d46 7d29          .dw XT_EE2RAM
007d47 701b          .dw XT_EXIT
                 .include "dict/compiler2.inc"
                 
                 ; included almost independently from each other
                 ; on a include-per-use basis
                 ;
                 .if DICT_COMPILER2 == 0
                 .endif
                 .include "words/bounds.asm"
                 
                 ; Tools
                 ; convert a string to an address range
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_BOUNDS:
007d48 ff06          .dw $ff06
007d49 6f62
007d4a 6e75
007d4b 7364          .db "bounds"
007d4c 7d38          .dw VE_HEAD
                     .set VE_HEAD = VE_BOUNDS
                 XT_BOUNDS:
007d4d 7001          .dw DO_COLON
                 PFA_BOUNDS:
                 .endif
007d4e 70ca          .dw XT_OVER
007d4f 7198          .dw XT_PLUS
007d50 70bf          .dw XT_SWAP
007d51 701b          .dw XT_EXIT
                 .include "words/s-to-d.asm"
                 
                 ; Conversion
                 ; extend (signed) single cell value to double cell
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_S2D:
007d52 ff03          .dw $ff03
007d53 3e73
007d54 0064          .db "s>d",0
007d55 7d48          .dw VE_HEAD
                     .set VE_HEAD = VE_S2D
                 XT_S2D:
007d56 7001          .dw DO_COLON
                 PFA_S2D:
                 .endif
007d57 70ac          .dw XT_DUP
007d58 711c          .dw XT_ZEROLESS
007d59 701b          .dw XT_EXIT
                 .include "words/to-body.asm"
                 
                 ; Core
                 ; get body from XT
                 VE_TO_BODY:
007d5a ff05          .dw $ff05
007d5b 623e
007d5c 646f
007d5d 0079          .db ">body",0
007d5e 7d52          .dw VE_HEAD
                     .set VE_HEAD = VE_TO_BODY
                 XT_TO_BODY:
007d5f 722b          .dw PFA_1PLUS
                 .elif AMFORTH_NRWW_SIZE>4000
                 .elif AMFORTH_NRWW_SIZE>2000
                 .else
                 .endif
                 ; now colon words
                 ;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/2literal.asm"
                 
                 ; Compiler
                 ; compile a cell pair literal in colon definitions
                 VE_2LITERAL:
007d60 0008          .dw $0008
007d61 6c32
007d62 7469
007d63 7265
007d64 6c61          .db "2literal"
007d65 7d5a          .dw VE_HEAD
                     .set VE_HEAD = VE_2LITERAL
                 XT_2LITERAL:
007d66 7001          .dw DO_COLON
                 PFA_2LITERAL:
007d67 70bf          .dw XT_SWAP
007d68 01bd          .dw XT_COMPILE
007d69 7038          .dw XT_DOLITERAL
007d6a 01c8          .dw XT_COMMA
007d6b 01bd          .dw XT_COMPILE
007d6c 7038          .dw XT_DOLITERAL
007d6d 01c8          .dw XT_COMMA
                     
007d6e 701b          .dw XT_EXIT
                 .include "words/equal.asm"
                 
                 ; Compare
                 ; compares two values for equality
                 VE_EQUAL:
007d6f ff01          .dw $ff01
007d70 003d          .db "=",0
007d71 7d60          .dw VE_HEAD
                     .set VE_HEAD = VE_EQUAL
                 XT_EQUAL:
007d72 7001          .dw DO_COLON
                 PFA_EQUAL:
007d73 718e          .dw XT_MINUS
007d74 7115          .dw XT_ZEROEQUAL
007d75 701b          .dw XT_EXIT
                 .include "words/num-constants.asm"
                 
                 .endif
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_ONE:
007d76 ff01          .dw $ff01
007d77 0031          .db "1",0
007d78 7d6f          .dw VE_HEAD
                     .set VE_HEAD = VE_ONE
                 XT_ONE:
007d79 7043          .dw PFA_DOVARIABLE
                 PFA_ONE:
                 .endif
007d7a 0001              .DW 1
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_TWO:
007d7b ff01          .dw $ff01
007d7c 0032          .db "2",0
007d7d 7d76          .dw VE_HEAD
                     .set VE_HEAD = VE_TWO
                 XT_TWO:
007d7e 7043          .dw PFA_DOVARIABLE
                 PFA_TWO:
                 .endif
007d7f 0002              .DW 2
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_MINUSONE:
007d80 ff02          .dw $ff02
007d81 312d          .db "-1"
007d82 7d7b          .dw VE_HEAD
                     .set VE_HEAD = VE_MINUSONE
                 XT_MINUSONE:
007d83 7043          .dw PFA_DOVARIABLE
                 PFA_MINUSONE:
                 .endif
007d84 ffff              .DW -1
                 .include "dict_appl_core.inc"
                 
                 ; do not delete it!
                 
                 .set flashlast = pc
                 .if (pc>FLASHEND)
                 .endif
                 
                 .dseg
                 ; define a label for the 1st free ram address
                 HERESTART:
                 .eseg
                 .include "amforth-eeprom.inc"
000038 ff ff     
                 EE_DP:
00003a 8f 05         .dw DPSTART      ; Dictionary Pointer
                 EE_HERE:
00003c a7 01         .dw HERESTART    ; Memory Allocation
                 EE_EHERE:
00003e 8c 00         .dw EHERESTART     ; EEProm Memory Allocation
                 EE_TURNKEY:
000040 da 04         .dw XT_APPLTURNKEY  ; TURNKEY
                 EE_STOREI:
000042 6d 73         .dw XT_DO_STOREI  ; Store a cell into flash
                 
                 EE_ENVIRONMENT:
000044 32 75         .dw VE_ENVHEAD   ; environmental queries
                 EE_WL_FORTH:
000046 4a 00         .dw EE_FORTHWORDLIST; forth-wordlist
                 EE_CURRENT:
000048 4a 00         .dw EE_FORTHWORDLIST
                 EE_FORTHWORDLIST:
00004a 80 7d         .dw VE_HEAD      ; pre-defined (compiled in) wordlist
                 CFG_ORDERLISTLEN:
00004c 01 00         .dw 1
                 CFG_ORDERLIST: ; list of wordlist id, exactly numwordlist entries
00004e 4a 00         .dw EE_FORTHWORDLIST      ; get/set-order
000050               .byte  (NUMWORDLISTS-1)*CELLSIZE ; one slot is already used
                 CFG_RECOGNIZERLISTLEN:
00005e 02 00         .dw 2
                 CFG_RECOGNIZERLIST:
000060 0f 7b         .dw XT_REC_WORD
000062 fa 7a         .dw XT_REC_NUM
000064               .byte  (NUMRECOGNIZERS-2)*CELLSIZE ; two slots are already used
                 
                 EE_WLSCOPE:
000068 39 04         .dw XT_GET_CURRENT  ; default wordlist scope
                 
                 ; LEAVE stack is between data stack and return stack.
                 EE_LP0:
00006a b0 10         .dw stackstart+1
                 
                 ; MARKER saves everything up to here. Nothing beyond gets saved
                 EE_MARKER:
00006c 6c 00         .dw EE_MARKER
                 
                 ; default user area
                 EE_INITUSER:
00006e 00 00         .dw 0  ; USER_STATE
000070 00 00         .dw 0  ; USER_FOLLOWER
000072 ff 10         .dw rstackstart  ; USER_RP
000074 af 10         .dw stackstart   ; USER_SP0
000076 af 10         .dw stackstart   ; USER_SP
                     
000078 00 00         .dw 0  ; USER_HANDLER
00007a 0a 00         .dw 10 ; USER_BASE
                     
00007c 94 00         .dw XT_TX  ; USER_EMIT
00007e a2 00         .dw XT_TXQ ; USER_EMITQ
000080 6a 00         .dw XT_RX  ; USER_KEY
000082 84 00         .dw XT_RXQ ; USER_KEYQ
000084 1f 7d         .dw XT_SOURCETIB ; USER_SKEY
000086 00 00         .dw 0            ; USER_G_IN
000088 0c 7d         .dw XT_REFILLTIB ; USER_REFILL  
                 
                 ; calculate baud rate error
                 .equ UBRR_VAL   = ((F_CPU+BAUD*8)/(BAUD*16)-1)  ; smart round
                 .equ BAUD_REAL  = (F_CPU/(16*(UBRR_VAL+1)))     ; effective baud rate
                 .equ BAUD_ERROR = ((BAUD_REAL*1000)/BAUD-1000)  ; error in pro mille
                 
                 .if ((BAUD_ERROR>BAUD_MAXERROR) || (BAUD_ERROR<-BAUD_MAXERROR))       
                 .endif
                 EE_UBRRVAL:
00008a 19 00         .dw UBRR_VAL     ; BAUDRATE
                 ; 1st free address in EEPROM.
                 EHERESTART:
                 .cseg


RESOURCE USE INFORMATION
------------------------

Notice:
The register and instruction counts are symbol table hit counts,
and hence implicitly used resources are not counted, eg, the
'lpm' instruction without operands implicitly uses r0 and z,
none of which are counted.

x,y,z are separate entities in the symbol table and are
counted separately from r26..r31 here.

.dseg memory usage only counts static data declared with .byte

"ATmega644" register use summary:
r0 :  20 r1 :   5 r2 :   9 r3 :  11 r4 :   4 r5 :   1 r6 :   0 r7 :   0 
r8 :   0 r9 :   0 r10:   1 r11:   1 r12:   0 r13:   0 r14:  22 r15:  20 
r16:  87 r17:  56 r18:  61 r19:  37 r20:  13 r21:  11 r22:  11 r23:   3 
r24: 210 r25: 145 r26:  39 r27:  21 r28:   7 r29:   4 r30:  88 r31:  47 
x  :   4 y  : 213 z  :  48 
Registers used: 29 out of 35 (82.9%)

"ATmega644" instruction use summary:
.lds  :   0 .sts  :   0 adc   :  21 add   :  16 adiw  :  18 and   :   4 
andi  :   3 asr   :   2 bclr  :   0 bld   :   0 brbc  :   2 brbs  :   7 
brcc  :   3 brcs  :   1 break :   0 breq  :   6 brge  :   1 brhc  :   0 
brhs  :   0 brid  :   0 brie  :   0 brlo  :   1 brlt  :   3 brmi  :   3 
brne  :  21 brpl  :   1 brsh  :   0 brtc  :   0 brts  :   1 brvc  :   0 
brvs  :   2 bset  :   0 bst   :   0 call  :   2 cbi   :   7 cbr   :   1 
clc   :   2 clh   :   0 cli   :   7 cln   :   0 clr   :  12 cls   :   0 
clt   :   1 clv   :   0 clz   :   0 com   :  16 cp    :  10 cpc   :  10 
cpi   :   2 cpse  :   0 dec   :  10 eor   :   3 fmul  :   0 fmuls :   0 
fmulsu:   0 icall :   0 ijmp  :   1 in    :  26 inc   :   3 jmp   :  14 
ld    : 142 ldd   :   4 ldi   :  39 lds   :   2 lpm   :  16 lsl   :  14 
lsr   :   1 mov   :  12 movw  :  72 mul   :   5 muls  :   1 mulsu :   2 
neg   :   0 nop   :   0 or    :   9 ori   :   2 out   :  23 pop   :  52 
push  :  46 rcall :  41 ret   :   7 reti  :   2 rjmp  : 107 rol   :  23 
ror   :   6 sbc   :   9 sbci  :   3 sbi   :   8 sbic  :   3 sbis  :   0 
sbiw  :  16 sbr   :   0 sbrc  :   5 sbrs  :   7 sec   :   1 seh   :   0 
sei   :   1 sen   :   0 ser   :   4 ses   :   0 set   :   2 sev   :   0 
sez   :   0 sleep :   0 spm   :   2 st    :  78 std   :   8 sts   :   3 
sub   :   6 subi  :   3 swap  :   0 tst   :   1 wdr   :   0 
Instructions used: 77 out of 113 (68.1%)

"ATmega644" memory use summary [bytes]:
Segment   Begin    End      Code   Data   Used    Size   Use%
---------------------------------------------------------------
[.cseg] 0x000000 0x00fb0a   2102  14534  16636   65536  25.4%
[.dseg] 0x000100 0x0001a7      0    167    167    4096   4.1%
[.eseg] 0x000000 0x00008c      0    140    140    2048   6.8%

Assembly complete, 0 errors, 5 warnings
