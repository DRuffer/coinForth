
AVRASM ver. 2.1.52  atmega256.asm Fri Jul 10 18:43:17 2015

atmega256.asm(11): Including file '../../avr8\preamble.inc'
../../avr8\preamble.inc(2): Including file '../../avr8\macros.asm'
../../avr8\macros.asm(6): Including file '../../avr8\user.inc'
../../avr8\preamble.inc(6): Including file '../../avr8/devices/atmega2561\device.asm'
../../avr8/devices/atmega2561\device.asm(5): Including file '../../avr8/Atmel/Appnotes2\m2561def.inc'
atmega256.asm(15): Including file '../../avr8\drivers/usart_1.asm'
../../avr8\drivers/usart_1.asm(31): Including file '../../avr8\drivers/usart_common.asm'
../../avr8\drivers/usart_common.asm(5): Including file '../../avr8\drivers/usart-isr-rx.asm'
../../avr8\drivers/usart_common.asm(17): Including file '../../avr8\words/usart-tx-poll.asm'
../../avr8\drivers/usart_common.asm(22): Including file '../../avr8\words/ubrr.asm'
../../avr8\drivers/usart_common.asm(23): Including file '../../avr8\words/usart.asm'
atmega256.asm(18): Including file '../../avr8\amforth-low.asm'
../../avr8\amforth-low.asm(11): Including file '../../avr8\amforth-interpreter.asm'
../../avr8\amforth-low.asm(12): Including file '../../avr8\drivers/generic-isr.asm'
../../avr8\amforth-low.asm(15): Including file '../../avr8\dict/rww.inc'
../../avr8\dict/rww.inc(1): Including file '../../avr8\words/mplus.asm'
../../avr8\dict/rww.inc(2): Including file '../../common\words/ud-star.asm'
../../avr8\dict/rww.inc(3): Including file '../../common\words/umax.asm'
../../avr8\dict/rww.inc(4): Including file '../../common\words/umin.asm'
../../avr8\dict/rww.inc(5): Including file '../../avr8\words/immediate-q.asm'
../../avr8\dict/rww.inc(6): Including file '../../avr8\words/name2flags.asm'
../../avr8\dict/rww.inc(7): Including file '../../common\words/name2interpret.asm'
../../avr8\dict/rww.inc(8): Including file '../../common\words/name2compile.asm'
../../avr8\dict/rww.inc(11): Including file '../../avr8\dict/appl_8k.inc'
../../avr8\dict/appl_8k.inc(1): Including file '../../avr8\dict/compiler1.inc'
../../avr8\dict/compiler1.inc(2): Including file '../../avr8\words/docreate.asm'
../../avr8\dict/compiler1.inc(3): Including file '../../common\words/backslash.asm'
../../avr8\dict/compiler1.inc(4): Including file '../../common\words/l-paren.asm'
../../avr8\dict/compiler1.inc(6): Including file '../../common\words/compile.asm'
../../avr8\dict/compiler1.inc(7): Including file '../../avr8\words/comma.asm'
../../avr8\dict/compiler1.inc(8): Including file '../../common\words/brackettick.asm'
../../avr8\dict/compiler1.inc(11): Including file '../../common\words/literal.asm'
../../avr8\dict/compiler1.inc(12): Including file '../../common\words/sliteral.asm'
../../avr8\dict/compiler1.inc(13): Including file '../../avr8\words/g-mark.asm'
../../avr8\dict/compiler1.inc(14): Including file '../../avr8\words/g-resolve.asm'
../../avr8\dict/compiler1.inc(15): Including file '../../avr8\words/l_mark.asm'
../../avr8\dict/compiler1.inc(16): Including file '../../avr8\words/l_resolve.asm'
../../avr8\dict/compiler1.inc(18): Including file '../../common\words/ahead.asm'
../../avr8\dict/compiler1.inc(19): Including file '../../common\words/if.asm'
../../avr8\dict/compiler1.inc(20): Including file '../../common\words/else.asm'
../../avr8\dict/compiler1.inc(21): Including file '../../common\words/then.asm'
../../avr8\dict/compiler1.inc(22): Including file '../../common\words/begin.asm'
../../avr8\dict/compiler1.inc(23): Including file '../../common\words/while.asm'
../../avr8\dict/compiler1.inc(24): Including file '../../common\words/repeat.asm'
../../avr8\dict/compiler1.inc(25): Including file '../../common\words/until.asm'
../../avr8\dict/compiler1.inc(26): Including file '../../common\words/again.asm'
../../avr8\dict/compiler1.inc(27): Including file '../../common\words/do.asm'
../../avr8\dict/compiler1.inc(28): Including file '../../common\words/loop.asm'
../../avr8\dict/compiler1.inc(29): Including file '../../common\words/plusloop.asm'
../../avr8\dict/compiler1.inc(30): Including file '../../common\words/leave.asm'
../../avr8\dict/compiler1.inc(31): Including file '../../common\words/qdo.asm'
../../avr8\dict/compiler1.inc(32): Including file '../../common\words/endloop.asm'
../../avr8\dict/compiler1.inc(34): Including file '../../common\words/l-from.asm'
../../avr8\dict/compiler1.inc(35): Including file '../../common\words/to-l.asm'
../../avr8\dict/compiler1.inc(36): Including file '../../avr8\words/lp0.asm'
../../avr8\dict/compiler1.inc(37): Including file '../../avr8\words/lp.asm'
../../avr8\dict/compiler1.inc(39): Including file '../../avr8\words/create.asm'
../../avr8\dict/compiler1.inc(40): Including file '../../avr8\words/header.asm'
../../avr8\dict/compiler1.inc(41): Including file '../../avr8\words/wlscope.asm'
../../avr8\dict/compiler1.inc(42): Including file '../../avr8\words/reveal.asm'
../../avr8\dict/compiler1.inc(43): Including file '../../avr8\words/latest.asm'
../../avr8\dict/compiler1.inc(44): Including file '../../avr8\words/does.asm'
../../avr8\dict/compiler1.inc(45): Including file '../../common\words/colon.asm'
../../avr8\dict/compiler1.inc(46): Including file '../../avr8\words/colon-noname.asm'
../../avr8\dict/compiler1.inc(47): Including file '../../common\words/semicolon.asm'
../../avr8\dict/compiler1.inc(48): Including file '../../common\words/right-bracket.asm'
../../avr8\dict/compiler1.inc(49): Including file '../../common\words/left-bracket.asm'
../../avr8\dict/compiler1.inc(50): Including file '../../common\words/variable.asm'
../../avr8\dict/compiler1.inc(51): Including file '../../common\words/constant.asm'
../../avr8\dict/compiler1.inc(52): Including file '../../avr8\words/user.asm'
../../avr8\dict/compiler1.inc(54): Including file '../../avr8\words/recurse.asm'
../../avr8\dict/compiler1.inc(55): Including file '../../avr8\words/immediate.asm'
../../avr8\dict/compiler1.inc(57): Including file '../../common\words/bracketchar.asm'
../../avr8\dict/compiler1.inc(58): Including file '../../common\words/abort-string.asm'
../../avr8\dict/compiler1.inc(59): Including file '../../common\words/abort.asm'
../../avr8\dict/compiler1.inc(60): Including file '../../common\words/q-abort.asm'
../../avr8\dict/compiler1.inc(62): Including file '../../common\words/get-stack.asm'
../../avr8\dict/compiler1.inc(63): Including file '../../common\words/set-stack.asm'
../../avr8\dict/compiler1.inc(64): Including file '../../common\words/map-stack.asm'
../../avr8\dict/compiler1.inc(65): Including file '../../avr8\words/get-current.asm'
../../avr8\dict/compiler1.inc(66): Including file '../../common\words/get-order.asm'
../../avr8\dict/compiler1.inc(68): Including file '../../avr8\words/compare.asm'
../../avr8\dict/compiler1.inc(69): Including file '../../avr8\words/nfa2lfa.asm'
../../avr8\amforth-low.asm(16): Including file 'dict_appl.inc'
dict_appl.inc(4): Including file 'words/applturnkey.asm'
../../avr8\amforth-low.asm(17): Including file '../../avr8\dict/nrww.inc'
../../avr8\dict/nrww.inc(4): Including file '../../avr8\words/exit.asm'
../../avr8\dict/nrww.inc(5): Including file '../../avr8\words/execute.asm'
../../avr8\dict/nrww.inc(6): Including file '../../avr8\words/dobranch.asm'
../../avr8\dict/nrww.inc(7): Including file '../../avr8\words/docondbranch.asm'
../../avr8\dict/nrww.inc(10): Including file '../../avr8\words/doliteral.asm'
../../avr8\dict/nrww.inc(11): Including file '../../avr8\words/dovariable.asm'
../../avr8\dict/nrww.inc(12): Including file '../../avr8\words/doconstant.asm'
../../avr8\dict/nrww.inc(13): Including file '../../avr8\words/douser.asm'
../../avr8\dict/nrww.inc(14): Including file '../../avr8\words/do-value.asm'
../../avr8\dict/nrww.inc(15): Including file '../../avr8\words/fetch.asm'
../../avr8\dict/nrww.inc(16): Including file '../../avr8\words/store.asm'
../../avr8\dict/nrww.inc(17): Including file '../../avr8\words/cstore.asm'
../../avr8\dict/nrww.inc(18): Including file '../../avr8\words/cfetch.asm'
../../avr8\dict/nrww.inc(19): Including file '../../avr8\words/fetch-u.asm'
../../avr8\dict/nrww.inc(20): Including file '../../avr8\words/store-u.asm'
../../avr8\dict/nrww.inc(23): Including file '../../avr8\words/dup.asm'
../../avr8\dict/nrww.inc(24): Including file '../../avr8\words/qdup.asm'
../../avr8\dict/nrww.inc(25): Including file '../../avr8\words/swap.asm'
../../avr8\dict/nrww.inc(26): Including file '../../avr8\words/over.asm'
../../avr8\dict/nrww.inc(27): Including file '../../avr8\words/drop.asm'
../../avr8\dict/nrww.inc(28): Including file '../../avr8\words/rot.asm'
../../avr8\dict/nrww.inc(29): Including file '../../avr8\words/nip.asm'
../../avr8\dict/nrww.inc(31): Including file '../../avr8\words/r_from.asm'
../../avr8\dict/nrww.inc(32): Including file '../../avr8\words/to_r.asm'
../../avr8\dict/nrww.inc(33): Including file '../../avr8\words/r_fetch.asm'
../../avr8\dict/nrww.inc(36): Including file '../../common\words/not-equal.asm'
../../avr8\dict/nrww.inc(37): Including file '../../avr8\words/equalzero.asm'
../../avr8\dict/nrww.inc(38): Including file '../../avr8\words/lesszero.asm'
../../avr8\dict/nrww.inc(39): Including file '../../avr8\words/greaterzero.asm'
../../avr8\dict/nrww.inc(40): Including file '../../avr8\words/d-greaterzero.asm'
../../avr8\dict/nrww.inc(41): Including file '../../avr8\words/d-lesszero.asm'
../../avr8\dict/nrww.inc(43): Including file '../../avr8\words/true.asm'
../../avr8\dict/nrww.inc(44): Including file '../../avr8\words/zero.asm'
../../avr8\dict/nrww.inc(45): Including file '../../avr8\words/uless.asm'
../../avr8\dict/nrww.inc(46): Including file '../../common\words/u-greater.asm'
../../avr8\dict/nrww.inc(47): Including file '../../avr8\words/less.asm'
../../avr8\dict/nrww.inc(48): Including file '../../avr8\words/greater.asm'
../../avr8\dict/nrww.inc(50): Including file '../../avr8\words/log2.asm'
../../avr8\dict/nrww.inc(51): Including file '../../avr8\words/minus.asm'
../../avr8\dict/nrww.inc(52): Including file '../../avr8\words/plus.asm'
../../avr8\dict/nrww.inc(53): Including file '../../avr8\words/mstar.asm'
../../avr8\dict/nrww.inc(54): Including file '../../avr8\words/umslashmod.asm'
../../avr8\dict/nrww.inc(55): Including file '../../avr8\words/umstar.asm'
../../avr8\dict/nrww.inc(57): Including file '../../avr8\words/invert.asm'
../../avr8\dict/nrww.inc(58): Including file '../../avr8\words/2slash.asm'
../../avr8\dict/nrww.inc(59): Including file '../../avr8\words/2star.asm'
../../avr8\dict/nrww.inc(60): Including file '../../avr8\words/and.asm'
../../avr8\dict/nrww.inc(61): Including file '../../avr8\words/or.asm'
../../avr8\dict/nrww.inc(62): Including file '../../avr8\words/xor.asm'
../../avr8\dict/nrww.inc(64): Including file '../../avr8\words/1plus.asm'
../../avr8\dict/nrww.inc(65): Including file '../../avr8\words/1minus.asm'
../../avr8\dict/nrww.inc(66): Including file '../../avr8\words/lshift.asm'
../../avr8\dict/nrww.inc(67): Including file '../../avr8\words/rshift.asm'
../../avr8\dict/nrww.inc(68): Including file '../../avr8\words/plusstore.asm'
../../avr8\dict/nrww.inc(70): Including file '../../avr8\words/rpfetch.asm'
../../avr8\dict/nrww.inc(71): Including file '../../avr8\words/rpstore.asm'
../../avr8\dict/nrww.inc(72): Including file '../../avr8\words/spfetch.asm'
../../avr8\dict/nrww.inc(73): Including file '../../avr8\words/spstore.asm'
../../avr8\dict/nrww.inc(75): Including file '../../avr8\words/dodo.asm'
../../avr8\dict/nrww.inc(76): Including file '../../avr8\words/i.asm'
../../avr8\dict/nrww.inc(77): Including file '../../avr8\words/doplusloop.asm'
../../avr8\dict/nrww.inc(78): Including file '../../avr8\words/doloop.asm'
../../avr8\dict/nrww.inc(79): Including file '../../avr8\words/unloop.asm'
../../avr8\dict/nrww.inc(83): Including file '../../avr8\words/cmove_g.asm'
../../avr8\dict/nrww.inc(84): Including file '../../avr8\words/byteswap.asm'
../../avr8\dict/nrww.inc(85): Including file '../../avr8\words/up.asm'
../../avr8\dict/nrww.inc(86): Including file '../../avr8\words/1ms.asm'
../../avr8\dict/nrww.inc(87): Including file '../../avr8\words/2to_r.asm'
../../avr8\dict/nrww.inc(88): Including file '../../avr8\words/2r_from.asm'
../../avr8\dict/nrww.inc(90): Including file '../../avr8\words/store-e.asm'
../../avr8\dict/nrww.inc(91): Including file '../../avr8\words/fetch-e.asm'
../../avr8\dict/nrww.inc(92): Including file '../../avr8\words/store-i.asm'
../../avr8\dict/nrww.inc(94): Including file '../../avr8\words/store-i_big.asm'
../../avr8\dict/nrww.inc(98): Including file '../../avr8\words/fetch-i.asm'
../../avr8\dict/nrww.inc(101): Including file '../../avr8\dict/core_8k.inc'
../../avr8\dict/core_8k.inc(2): Including file '../../avr8\words/n_to_r.asm'
../../avr8\dict/core_8k.inc(3): Including file '../../avr8\words/n_r_from.asm'
../../avr8\dict/core_8k.inc(5): Including file '../../avr8\words/d-2star.asm'
../../avr8\dict/core_8k.inc(6): Including file '../../avr8\words/d-2slash.asm'
../../avr8\dict/core_8k.inc(7): Including file '../../avr8\words/d-plus.asm'
../../avr8\dict/core_8k.inc(8): Including file '../../avr8\words/d-minus.asm'
../../avr8\dict/core_8k.inc(9): Including file '../../avr8\words/d-invert.asm'
../../avr8\dict/core_8k.inc(10): Including file '../../avr8\words/d-equal.asm'
../../avr8\dict/core_8k.inc(11): Including file '../../common\words/u-dot.asm'
../../avr8\dict/core_8k.inc(12): Including file '../../common\words/u-dot-r.asm'
../../avr8\dict/core_8k.inc(14): Including file '../../common\words/show-wordlist.asm'
../../avr8\dict/core_8k.inc(15): Including file '../../avr8\words/words.asm'
../../avr8\dict/core_8k.inc(16): Including file '../../avr8\dict/interrupt.inc'
../../avr8\dict/interrupt.inc(2): Including file '../../avr8\words/int-on.asm'
../../avr8\dict/interrupt.inc(3): Including file '../../avr8\words/int-off.asm'
../../avr8\dict/interrupt.inc(4): Including file '../../avr8\words/int-store.asm'
../../avr8\dict/interrupt.inc(5): Including file '../../avr8\words/int-fetch.asm'
../../avr8\dict/interrupt.inc(6): Including file '../../avr8\words/int-trap.asm'
../../avr8\dict/interrupt.inc(8): Including file '../../avr8\words/isr-exec.asm'
../../avr8\dict/interrupt.inc(9): Including file '../../avr8\words/isr-end.asm'
../../avr8\dict/core_8k.inc(18): Including file '../../common\words/pick.asm'
../../avr8\dict/core_8k.inc(19): Including file '../../common\words/dot-quote.asm'
../../avr8\dict/core_8k.inc(20): Including file '../../common\words/squote.asm'
../../avr8\dict/core_8k.inc(22): Including file '../../avr8\words/fill.asm'
../../avr8\dict/core_8k.inc(24): Including file '../../avr8\words/environment.asm'
../../avr8\dict/core_8k.inc(25): Including file '../../avr8\words/env-wordlists.asm'
../../avr8\dict/core_8k.inc(26): Including file '../../avr8\words/env-slashpad.asm'
../../avr8\dict/core_8k.inc(27): Including file '../../avr8\words/env-slashhold.asm'
../../avr8\dict/core_8k.inc(28): Including file '../../common\words/env-forthname.asm'
../../avr8\dict/core_8k.inc(29): Including file '../../common\words/env-forthversion.asm'
../../avr8\dict/core_8k.inc(30): Including file '../../common\words/env-cpu.asm'
../../avr8\dict/core_8k.inc(31): Including file '../../avr8\words/env-mcuinfo.asm'
../../avr8\dict/core_8k.inc(32): Including file '../../avr8\words/env-usersize.asm'
../../avr8\dict/core_8k.inc(34): Including file '../../common\words/f_cpu.asm'
../../avr8\dict/core_8k.inc(35): Including file '../../avr8\words/state.asm'
../../avr8\dict/core_8k.inc(36): Including file '../../common\words/base.asm'
../../avr8\dict/core_8k.inc(38): Including file '../../avr8\words/cells.asm'
../../avr8\dict/core_8k.inc(39): Including file '../../avr8\words/cellplus.asm'
../../avr8\dict/core_8k.inc(41): Including file '../../common\words/2dup.asm'
../../avr8\dict/core_8k.inc(42): Including file '../../common\words/2drop.asm'
../../avr8\dict/core_8k.inc(44): Including file '../../common\words/tuck.asm'
../../avr8\dict/core_8k.inc(46): Including file '../../common\words/to-in.asm'
../../avr8\dict/core_8k.inc(47): Including file '../../avr8\words/sharptib.asm'
../../avr8\dict/core_8k.inc(48): Including file '../../avr8\words/pad.asm'
../../avr8\dict/core_8k.inc(49): Including file '../../avr8\words/emit.asm'
../../avr8\dict/core_8k.inc(50): Including file '../../avr8\words/emitq.asm'
../../avr8\dict/core_8k.inc(51): Including file '../../avr8\words/key.asm'
../../avr8\dict/core_8k.inc(52): Including file '../../avr8\words/keyq.asm'
../../avr8\dict/core_8k.inc(54): Including file '../../avr8\words/dp.asm'
../../avr8\dict/core_8k.inc(55): Including file '../../avr8\words/ehere.asm'
../../avr8\dict/core_8k.inc(56): Including file '../../avr8\words/here.asm'
../../avr8\dict/core_8k.inc(57): Including file '../../avr8\words/allot.asm'
../../avr8\dict/core_8k.inc(59): Including file '../../common\words/bin.asm'
../../avr8\dict/core_8k.inc(60): Including file '../../common\words/decimal.asm'
../../avr8\dict/core_8k.inc(61): Including file '../../common\words/hex.asm'
../../avr8\dict/core_8k.inc(62): Including file '../../common\words/bl.asm'
../../avr8\dict/core_8k.inc(64): Including file '../../avr8\words/turnkey.asm'
../../avr8\dict/core_8k.inc(66): Including file '../../avr8\words/slashmod.asm'
../../avr8\dict/core_8k.inc(67): Including file '../../avr8\words/uslashmod.asm'
../../avr8\dict/core_8k.inc(68): Including file '../../avr8\words/negate.asm'
../../avr8\dict/core_8k.inc(69): Including file '../../common\words/slash.asm'
../../avr8\dict/core_8k.inc(70): Including file '../../common\words/mod.asm'
../../avr8\dict/core_8k.inc(71): Including file '../../avr8\words/abs.asm'
../../avr8\dict/core_8k.inc(72): Including file '../../common\words/min.asm'
../../avr8\dict/core_8k.inc(73): Including file '../../common\words/max.asm'
../../avr8\dict/core_8k.inc(74): Including file '../../common\words/within.asm'
../../avr8\dict/core_8k.inc(76): Including file '../../common\words/to-upper.asm'
../../avr8\dict/core_8k.inc(77): Including file '../../common\words/to-lower.asm'
../../avr8\dict/core_8k.inc(79): Including file '../../avr8\words/hld.asm'
../../avr8\dict/core_8k.inc(80): Including file '../../common\words/hold.asm'
../../avr8\dict/core_8k.inc(81): Including file '../../common\words/less-sharp.asm'
../../avr8\dict/core_8k.inc(82): Including file '../../common\words/sharp.asm'
../../avr8\dict/core_8k.inc(83): Including file '../../common\words/sharp-s.asm'
../../avr8\dict/core_8k.inc(84): Including file '../../common\words/sharp-greater.asm'
../../avr8\dict/core_8k.inc(85): Including file '../../common\words/sign.asm'
../../avr8\dict/core_8k.inc(86): Including file '../../common\words/d-dot-r.asm'
../../avr8\dict/core_8k.inc(87): Including file '../../common\words/dot-r.asm'
../../avr8\dict/core_8k.inc(88): Including file '../../common\words/d-dot.asm'
../../avr8\dict/core_8k.inc(89): Including file '../../common\words/dot.asm'
../../avr8\dict/core_8k.inc(90): Including file '../../common\words/ud-dot.asm'
../../avr8\dict/core_8k.inc(91): Including file '../../common\words/ud-dot-r.asm'
../../avr8\dict/core_8k.inc(92): Including file '../../common\words/ud-slash-mod.asm'
../../avr8\dict/core_8k.inc(93): Including file '../../common\words/digit-q.asm'
../../avr8\dict/core_8k.inc(95): Including file '../../avr8\words/do-sliteral.asm'
../../avr8\dict/core_8k.inc(96): Including file '../../avr8\words/scomma.asm'
../../avr8\dict/core_8k.inc(97): Including file '../../avr8\words/itype.asm'
../../avr8\dict/core_8k.inc(98): Including file '../../avr8\words/icount.asm'
../../avr8\dict/core_8k.inc(99): Including file '../../common\words/cr.asm'
../../avr8\dict/core_8k.inc(100): Including file '../../common\words/space.asm'
../../avr8\dict/core_8k.inc(101): Including file '../../common\words/spaces.asm'
../../avr8\dict/core_8k.inc(102): Including file '../../common\words/type.asm'
../../avr8\dict/core_8k.inc(103): Including file '../../common\words/tick.asm'
../../avr8\dict/core_8k.inc(105): Including file '../../common\words/handler.asm'
../../avr8\dict/core_8k.inc(106): Including file '../../common\words/catch.asm'
../../avr8\dict/core_8k.inc(107): Including file '../../common\words/throw.asm'
../../avr8\dict/core_8k.inc(109): Including file '../../common\words/cskip.asm'
../../avr8\dict/core_8k.inc(110): Including file '../../common\words/cscan.asm'
../../avr8\dict/core_8k.inc(111): Including file '../../common\words/accept.asm'
../../avr8\dict/core_8k.inc(112): Including file '../../avr8\words/refill.asm'
../../avr8\dict/core_8k.inc(113): Including file '../../common\words/char.asm'
../../avr8\dict/core_8k.inc(114): Including file '../../common\words/number.asm'
../../avr8\dict/core_8k.inc(115): Including file '../../common\words/q-sign.asm'
../../avr8\dict/core_8k.inc(116): Including file '../../common\words/set-base.asm'
../../avr8\dict/core_8k.inc(117): Including file '../../common\words/to-number.asm'
../../avr8\dict/core_8k.inc(118): Including file '../../common\words/parse.asm'
../../avr8\dict/core_8k.inc(119): Including file '../../avr8\words/source.asm'
../../avr8\dict/core_8k.inc(120): Including file '../../common\words/slash-string.asm'
../../avr8\dict/core_8k.inc(121): Including file '../../common\words/parse-name.asm'
../../avr8\dict/core_8k.inc(122): Including file '../../common\words/find-name.asm'
../../avr8\dict/core_8k.inc(124): Including file '../../common\words/prompt-ok.asm'
../../avr8\dict/core_8k.inc(125): Including file '../../common\words/prompt-ready.asm'
../../avr8\dict/core_8k.inc(126): Including file '../../common\words/prompt-error.asm'
../../avr8\dict/core_8k.inc(128): Including file '../../common\words/quit.asm'
../../avr8\dict/core_8k.inc(129): Including file '../../avr8\words/pause.asm'
../../avr8\dict/core_8k.inc(130): Including file '../../avr8\words/cold.asm'
../../avr8\dict/core_8k.inc(131): Including file '../../avr8\words/warm.asm'
../../avr8\dict/core_8k.inc(133): Including file '../../avr8\words/sp0.asm'
../../avr8\dict/core_8k.inc(134): Including file '../../avr8\words/rp0.asm'
../../avr8\dict/core_8k.inc(135): Including file '../../common\words/depth.asm'
../../avr8\dict/core_8k.inc(136): Including file '../../common\words/interpret.asm'
../../avr8\dict/core_8k.inc(137): Including file '../../common\words/do-recognizer.asm'
../../avr8\dict/core_8k.inc(138): Including file '../../common\words/r-intnumber.asm'
../../avr8\dict/core_8k.inc(139): Including file '../../common\words/r-word.asm'
../../avr8\dict/core_8k.inc(140): Including file '../../common\words/r-fail.asm'
../../avr8\dict/core_8k.inc(142): Including file '../../common\words/q-stack.asm'
../../avr8\dict/core_8k.inc(143): Including file '../../common\words/ver.asm'
../../avr8\dict/core_8k.inc(145): Including file '../../avr8\words/noop.asm'
../../avr8\dict/core_8k.inc(146): Including file '../../avr8\words/unused.asm'
../../avr8\dict/core_8k.inc(148): Including file '../../common\words/to.asm'
../../avr8\dict/core_8k.inc(149): Including file '../../avr8\words/i-cellplus.asm'
../../avr8\dict/core_8k.inc(151): Including file '../../avr8\words/edefer-fetch.asm'
../../avr8\dict/core_8k.inc(152): Including file '../../avr8\words/edefer-store.asm'
../../avr8\dict/core_8k.inc(153): Including file '../../common\words/rdefer-fetch.asm'
../../avr8\dict/core_8k.inc(154): Including file '../../common\words/rdefer-store.asm'
../../avr8\dict/core_8k.inc(155): Including file '../../common\words/udefer-fetch.asm'
../../avr8\dict/core_8k.inc(156): Including file '../../common\words/udefer-store.asm'
../../avr8\dict/core_8k.inc(157): Including file '../../common\words/defer-store.asm'
../../avr8\dict/core_8k.inc(158): Including file '../../common\words/defer-fetch.asm'
../../avr8\dict/core_8k.inc(159): Including file '../../avr8\words/do-defer.asm'
../../avr8\dict/core_8k.inc(161): Including file '../../common\words/search-wordlist.asm'
../../avr8\dict/core_8k.inc(162): Including file '../../common\words/traverse-wordlist.asm'
../../avr8\dict/core_8k.inc(163): Including file '../../common\words/name2string.asm'
../../avr8\dict/core_8k.inc(164): Including file '../../avr8\words/nfa2cfa.asm'
../../avr8\dict/core_8k.inc(165): Including file '../../avr8\words/icompare.asm'
../../avr8\dict/core_8k.inc(167): Including file '../../common\words/star.asm'
../../avr8\dict/core_8k.inc(168): Including file '../../avr8\words/j.asm'
../../avr8\dict/core_8k.inc(170): Including file '../../avr8\words/dabs.asm'
../../avr8\dict/core_8k.inc(171): Including file '../../avr8\words/dnegate.asm'
../../avr8\dict/core_8k.inc(172): Including file '../../avr8\words/cmove.asm'
../../avr8\dict/core_8k.inc(173): Including file '../../common\words/2swap.asm'
../../avr8\dict/core_8k.inc(175): Including file '../../avr8\words/tib.asm'
../../avr8\dict/core_8k.inc(177): Including file '../../avr8\words/init-user.asm'
../../avr8\dict/core_8k.inc(178): Including file '../../avr8\dict/compiler2.inc'
../../avr8\dict/compiler2.inc(8): Including file '../../avr8\words/set-current.asm'
../../avr8\dict/compiler2.inc(9): Including file '../../avr8\words/wordlist.asm'
../../avr8\dict/compiler2.inc(11): Including file '../../avr8\words/only.asm'
../../avr8\dict/compiler2.inc(12): Including file '../../avr8\words/forth-wordlist.asm'
../../avr8\dict/compiler2.inc(13): Including file '../../common\words/set-order.asm'
../../avr8\dict/compiler2.inc(14): Including file '../../common\words/set-recognizer.asm'
../../avr8\dict/compiler2.inc(15): Including file '../../common\words/get-recognizer.asm'
../../avr8\dict/compiler2.inc(16): Including file '../../avr8\words/code.asm'
../../avr8\dict/compiler2.inc(17): Including file '../../avr8\words/end-code.asm'
../../avr8\dict/compiler2.inc(18): Including file '../../avr8\words/marker.asm'
../../avr8\dict/compiler2.inc(19): Including file '../../common\words/postpone.asm'
../../avr8\dict/core_8k.inc(179): Including file '../../common\words/bounds.asm'
../../avr8\dict/core_8k.inc(180): Including file '../../common\words/s-to-d.asm'
../../avr8\dict/core_8k.inc(181): Including file '../../avr8\words/to-body.asm'
../../avr8\dict/nrww.inc(111): Including file '../../avr8\words/2literal.asm'
../../avr8\dict/nrww.inc(112): Including file '../../avr8\words/equal.asm'
../../avr8\dict/nrww.inc(113): Including file '../../common\words/num-constants.asm'
../../avr8\amforth-low.asm(18): Including file 'dict_appl_core.inc'
../../avr8\amforth-low.asm(27): Including file '../../avr8\amforth-eeprom.inc'
                 
                 
                 ; both a 24bit address space and they need a special
                 ; flash store placement in the NRWW section, way outside
                 ; of the standard 16bit jump distance.
                 
                 ; note that dict_appl_core includes a store-i_big.asm
                 ; instead if the normal store-i.asm file. This file
                 ; has all the magic needed for the large address space.
                 ; *everything else* is identical to other controllers.
                 
                 .include "preamble.inc"
                 
                 .include "macros.asm"
                 
                 .set DICT_COMPILER2 = 0 ;
                 .set cpu_msp430 = 0
                 .set cpu_avr8   = 1
                 
                 .include "user.inc"
                 
                 ; 
                 
                 ; used by the multitasker
                 .set USER_STATE    = 0
                 .set USER_FOLLOWER = 2
                 
                 ; stackpointer, used by mulitasker
                 .set USER_RP      = 4
                 .set USER_SP0     = 6
                 .set USER_SP      = 8
                 
                 ; excpection handling
                 .set USER_HANDLER = 10
                 
                 ; numeric IO
                 .set USER_BASE  = 12
                 
                 ; character IO 
                 .set USER_EMIT  = 14
                 .set USER_EMITQ = 16
                 .set USER_KEY   = 18
                 .set USER_KEYQ  = 20
                 
                 .set USER_SOURCE  = 22
                 .set USER_TO_IN   = 24
                 .set USER_REFILL  = 26
                 
                 .set SYSUSERSIZE = 28
                 ; 
                 
                   .def zerol = r2
                   .def zeroh = r3
                   .def upl = r4
                   .def uph = r5
                 
                   .def al  = r6
                   .def ah  = r7
                   .def bl  = r8
                   .def bh  = r9
                 
                 ; internal
                   .def mcu_boot      = r10
                   .def erase_counter = r11
                 
                   .def temp4 = r14
                   .def temp5 = r15
                 
                   .def temp0 = r16
                   .def temp1 = r17
                   .def temp2 = r18
                   .def temp3 = r19
                 
                   .def temp6 = r20
                   .def temp7 = r21
                 
                   .def tosl = r24
                   .def tosh = r25
                 
                   .def wl = r22
                   .def wh = r23
                 
                 .macro loadtos
                     ld tosl, Y+
                     ld tosh, Y+
                 .endmacro
                 
                 .macro savetos
                     st -Y, tosh
                     st -Y, tosl
                 .endmacro
                 
                 .macro in_
                 .if (@1 < $40)
                   in @0,@1
                 .else
                   lds @0,@1
                 .endif
                 .endmacro
                 
                 .macro out_
                 .if (@0 < $40)
                   out @0,@1
                 .else
                   sts @0,@1
                 .endif
                 .endmacro
                 
                 .macro sbi_
                 .if (@0 < $40)
                   sbi @0,@1
                 .else
                   in_ @2,@0
                   ori @2,exp2(@1)
                   out_ @0,@2
                 .endif
                 .endmacro
                 
                 .macro cbi_
                 .if (@0 < $40)
                   cbi @0,@1
                 .else
                   in_ @2,@0
                   andi @2,~(exp2(@1))
                   out_ @0,@2
                 .endif
                 .endmacro
                 
                 .macro jmp_
                 	; a more flexible macro
                     .ifdef @0
                     .if (@0-pc > 2040) || (pc-@0>2040)
                 	jmp @0
                 	.else
                 	rjmp @0
                 	.endif
                 	.else
                 	jmp @0
                 	.endif
                 .endmacro
                 .macro call_
                 	; a more flexible macro
                     .ifdef @0
                     .if (@0-pc > 2040) || (pc-@0>2040)
                 	call @0
                 	.else
                 	rcall @0
                 	.endif
                 	.else
                 	call @0
                 	.endif
                 .endmacro
                 
                 ;               F_CPU
                 ;    µsec   16000000   14745600    8000000  1000000
                 ;    1            16      14,74          8        1
                 ;    10          160     147,45         80       10
                 ;    100        1600    1474,56        800      100
                 ;    1000      16000   14745,6        8000     1000
                 ;
                 ; cycles = µsec * f_cpu / 1e6
                 ; n_loops=cycles/5
                 ;
                 ;     cycles already used will be subtracted from the delay
                 ;     the waittime resolution is 1 cycle (delay from exact to +1 cycle)
                 ;     the maximum delay at 20MHz (50ns/clock) is 38350ns
                 ;     waitcount register must specify an immediate register
                 ;
                 ; busy waits a specfied amount of microseconds
                 .macro   delay
                       .set cycles = ( ( @0 * F_CPU ) / 1000000 )
                       .if (cycles > ( 256 * 255 * 4 + 2))
                         .error "MACRO delay - too many cycles to burn"
                       .else
                         .if (cycles > 6)
                           .set  loop_cycles = (cycles / 4)      
                           ldi   zl,low(loop_cycles)
                           ldi   zh,high(loop_cycles)
                           sbiw  Z, 1
                           brne  pc-1
                           .set  cycles = (cycles - (loop_cycles * 4))
                         .endif
                         .if (cycles > 0)
                           .if   (cycles & 4)
                             rjmp  pc+1
                             rjmp  pc+1
                           .endif
                           .if   (cycles & 2)
                             rjmp  pc+1
                           .endif
                           .if   (cycles & 1)
                             nop
                           .endif
                         .endif
                       .endif
                 .endmacro
                 
                 ; portability macros, they come from the msp430 branches
                 
                 .macro DEST
                     .dw @0
                 .endm
                 
                 ; controller specific file selected via include
                 ; directory definition when calling the assembler (-I)
                 .include "device.asm"
                 
                 ; generated automatically, do not edit
                 
                 .list
                 
                 .equ ramstart =  512
                 .equ CELLSIZE = 2
                 .macro readflashcell
                 	clr temp7
                 	lsl zl
                 	rol zh
                 	rol temp7
                 	out_ RAMPZ, temp7
                 	elpm @0, Z+
                 	elpm @1, Z+
                 .endmacro
                 .macro writeflashcell
                 	clr temp7
                 	lsl zl
                 	rol zh
                 	rol temp7
                 	out_ RAMPZ, temp7
                 .endmacro
                 .set WANT_ANALOG_COMPARATOR = 0
                 .set WANT_USART0 = 0
                 .set WANT_TWI = 0
                 .set WANT_SPI = 0
                 .set WANT_PORTA = 0
                 .set WANT_PORTB = 0
                 .set WANT_PORTC = 0
                 .set WANT_PORTD = 0
                 .set WANT_PORTE = 0
                 .set WANT_PORTF = 0
                 .set WANT_PORTG = 0
                 .set WANT_TIMER_COUNTER_0 = 0
                 .set WANT_TIMER_COUNTER_2 = 0
                 .set WANT_WATCHDOG = 0
                 .set WANT_USART1 = 0
                 .set WANT_EEPROM = 0
                 .set WANT_TIMER_COUNTER_5 = 0
                 .set WANT_TIMER_COUNTER_4 = 0
                 .set WANT_TIMER_COUNTER_3 = 0
                 .set WANT_TIMER_COUNTER_1 = 0
                 .set WANT_JTAG = 0
                 .set WANT_EXTERNAL_INTERRUPT = 0
                 .set WANT_CPU = 0
                 .set WANT_AD_CONVERTER = 0
                 .set WANT_BOOT_LOAD = 0
                 .equ intvecsize = 2 ; please verify; flash size: 262144 bytes
                 .equ pclen = 3 ; please verify
                 .overlap
                 .org 2
000002 d121      	 rcall isr ; External Interrupt Request 0
                 .org 4
000004 d11f      	 rcall isr ; External Interrupt Request 1
                 .org 6
000006 d11d      	 rcall isr ; External Interrupt Request 2
                 .org 8
000008 d11b      	 rcall isr ; External Interrupt Request 3
                 .org 10
00000a d119      	 rcall isr ; External Interrupt Request 4
                 .org 12
00000c d117      	 rcall isr ; External Interrupt Request 5
                 .org 14
00000e d115      	 rcall isr ; External Interrupt Request 6
                 .org 16
000010 d113      	 rcall isr ; External Interrupt Request 7
                 .org 18
000012 d111      	 rcall isr ; Pin Change Interrupt Request 0
                 .org 20
000014 d10f      	 rcall isr ; Pin Change Interrupt Request 1
                 .org 22
000016 d10d      	 rcall isr ; Pin Change Interrupt Request 2
                 .org 24
000018 d10b      	 rcall isr ; Watchdog Time-out Interrupt
                 .org 26
00001a d109      	 rcall isr ; Timer/Counter2 Compare Match A
                 .org 28
00001c d107      	 rcall isr ; Timer/Counter2 Compare Match B
                 .org 30
00001e d105      	 rcall isr ; Timer/Counter2 Overflow
                 .org 32
000020 d103      	 rcall isr ; Timer/Counter1 Capture Event
                 .org 34
000022 d101      	 rcall isr ; Timer/Counter1 Compare Match A
                 .org 36
000024 d0ff      	 rcall isr ; Timer/Counter1 Compare Match B
                 .org 38
000026 d0fd      	 rcall isr ; Timer/Counter1 Compare Match C
                 .org 40
000028 d0fb      	 rcall isr ; Timer/Counter1 Overflow
                 .org 42
00002a d0f9      	 rcall isr ; Timer/Counter0 Compare Match A
                 .org 44
00002c d0f7      	 rcall isr ; Timer/Counter0 Compare Match B
                 .org 46
00002e d0f5      	 rcall isr ; Timer/Counter0 Overflow
                 .org 48
000030 d0f3      	 rcall isr ; SPI Serial Transfer Complete
                 .org 50
000032 d0f1      	 rcall isr ; USART0, Rx Complete
                 .org 52
000034 d0ef      	 rcall isr ; USART0 Data register Empty
                 .org 54
000036 d0ed      	 rcall isr ; USART0, Tx Complete
                 .org 56
000038 d0eb      	 rcall isr ; Analog Comparator
                 .org 58
00003a d0e9      	 rcall isr ; ADC Conversion Complete
                 .org 60
00003c d0e7      	 rcall isr ; EEPROM Ready
                 .org 62
00003e d0e5      	 rcall isr ; Timer/Counter3 Capture Event
                 .org 64
000040 d0e3      	 rcall isr ; Timer/Counter3 Compare Match A
                 .org 66
000042 d0e1      	 rcall isr ; Timer/Counter3 Compare Match B
                 .org 68
000044 d0df      	 rcall isr ; Timer/Counter3 Compare Match C
                 .org 70
000046 d0dd      	 rcall isr ; Timer/Counter3 Overflow
                 .org 72
000048 d0db      	 rcall isr ; USART1, Rx Complete
                 .org 74
00004a d0d9      	 rcall isr ; USART1 Data register Empty
                 .org 76
00004c d0d7      	 rcall isr ; USART1, Tx Complete
                 .org 78
00004e d0d5      	 rcall isr ; 2-wire Serial Interface
                 .org 80
000050 d0d3      	 rcall isr ; Store Program Memory Read
                 .org 82
000052 d0d1      	 rcall isr ; Timer/Counter4 Capture Event
                 .org 84
000054 d0cf      	 rcall isr ; Timer/Counter4 Compare Match A
                 .org 86
000056 d0cd      	 rcall isr ; Timer/Counter4 Compare Match B
                 .org 88
000058 d0cb      	 rcall isr ; Timer/Counter4 Compare Match C
                 .org 90
00005a d0c9      	 rcall isr ; Timer/Counter4 Overflow
                 .org 92
00005c d0c7      	 rcall isr ; Timer/Counter5 Capture Event
                 .org 94
00005e d0c5      	 rcall isr ; Timer/Counter5 Compare Match A
                 .org 96
000060 d0c3      	 rcall isr ; Timer/Counter5 Compare Match B
                 .org 98
000062 d0c1      	 rcall isr ; Timer/Counter5 Compare Match C
                 .org 100
000064 d0bf      	 rcall isr ; Timer/Counter5 Overflow
                 .org 102
000066 d0bd      	 rcall isr ; USART2, Rx Complete
                 .org 104
000068 d0bb      	 rcall isr ; USART2 Data register Empty
                 .org 106
00006a d0b9      	 rcall isr ; USART2, Tx Complete
                 .org 108
00006c d0b7      	 rcall isr ; USART3, Rx Complete
                 .org 110
00006e d0b5      	 rcall isr ; USART3 Data register Empty
                 .org 112
000070 d0b3      	 rcall isr ; USART3, Tx Complete
                 .equ INTVECTORS = 57
                 .nooverlap
                 
                 ; compatability layer (maybe empty)
                 
                 ; controller data area, environment query mcu-info
                 mcu_info:
                 mcu_ramsize:
000071 2000      	.dw 8192
                 mcu_eepromsize:
000072 1000      	.dw 4096
                 mcu_maxdp:
000073 ffff      	.dw 65535 
                 mcu_numints:
000074 0039      	.dw 57
                 mcu_name:
000075 000a      	.dw 10
000076 5441
000077 656d
000078 6167
000079 3532
00007a 3136      	.db "ATmega2561"
                 .set codestart=pc
                 
                 ; some defaults, change them in your application master file
                 ; see template.asm for an example
                 
                 .set AMFORTH_RO_SEG = NRWW_START_ADDR
                 
                 ; receiving is asynchron, so an interrupt queue is useful.
                 .set WANT_ISR_RX = 1
                 
                 ; case insensitve dictionary lookup.
                 .set WANT_IGNORECASE = 0
                 
                 ; map all memories to one address space. Details in the
                 ; technical guide
                 .set WANT_UNIFIED = 0
                 
                 ; terminal input buffer
                 .set TIBSIZE  = 90    ; ANS94 needs at least 80 characters per line
                 
                 ; USER variables *in addition* to system ones
                 .set APPUSERSIZE = 10  ; size of application specific user area in bytes
                 
                 ; addresses of various data segments
                 .set rstackstart = RAMEND      ; start address of return stack, grows downward
                 .set stackstart  = RAMEND - 80 ; start address of data stack, grows downward
                 ; change only if you know what to you do
                 .set NUMWORDLISTS = 8 ; number of word lists in the searh order, at least 8
                 .set NUMRECOGNIZERS = 4 ; total number of recognizers, two are always used.
                 
                 ; 10 per mille (1 per cent) is ok.
                 .set BAUD = 38400
                 .set BAUD_MAXERROR = 10
                 
                 ; Dictionary setup
                 .set VE_HEAD = $0000
                 .set VE_ENVHEAD = $0000
                 
                 
                 ; cpu clock in hertz
                 .equ F_CPU = 14745600
                 .include "drivers/usart_1.asm"
                 
                   .equ BAUDRATE_HIGH = UBRR1H
                   .equ USART_C = UCSR1C
                   .equ USART_B = UCSR1B
                   .equ USART_A = UCSR1A
                   .equ USART_DATA = UDR1
                 
                 .equ URXCaddr = URXC1addr
                 .equ UDREaddr = UDRE1addr
                 
                 .equ bm_USART_RXRD = 1 << RXC1
                 .equ bm_USART_TXRD = 1 << UDRE1
                 .equ bm_ENABLE_TX  = 1 << TXEN1
                 .equ bm_ENABLE_RX  = 1 << RXEN1
                 .equ bm_ENABLE_INT_RX = 1<<RXCIE1
                 .equ bm_ENABLE_INT_TX = 1<<UDRIE1
                 
                 .equ bm_USARTC_en   = 0
                 .equ bm_ASYNC       = 0 << 6
                 .equ bm_SYNC        = 1 << 6
                 .equ bm_NO_PARITY   = 0 << 4
                 .equ bm_EVEN_PARITY = 2 << 4
                 .equ bm_ODD_PARITY  = 3 << 4
                 .equ bm_1STOPBIT    = 0 << 3
                 .equ bm_2STOPBIT    = 1 << 3
                 .equ bm_5BIT        = 0 << 1
                 .equ bm_6BIT        = 1 << 1
                 .equ bm_7BIT        = 2 << 1
                 .equ bm_8BIT        = 3 << 1
                 
                 .include "drivers/usart_common.asm"
                 
                 .set USART_C_VALUE = bm_ASYNC | bm_NO_PARITY | bm_1STOPBIT | bm_8BIT
                 .if WANT_ISR_RX == 1
                   .set USART_B_VALUE = bm_ENABLE_TX | bm_ENABLE_RX | bm_ENABLE_INT_RX
                   .include "drivers/usart-isr-rx.asm"
                 
                 
                 ; sizes have to be powers of 2!
                 .equ usart_rx_size = $10
                 .equ usart_rx_mask = usart_rx_size - 1
                 .dseg
000200           usart_rx_data: .byte usart_rx_size+2
000212           usart_rx_in: .byte 2
000214           usart_rx_out: .byte 2
                 
                 .cseg
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 ; forth code:
                 ; : rx-isr USART_DATA c@
                 ;    usart_rx_data usart_rx_in c@ dup >r
                 ;    + !
                 ;    r> 1+ usart_rx_mask and usart_rx_in c!
                 ; ;
                 ; setup with
                 ; ' rx-isr URXCaddr int!
                 usart_rx_isr:
00007b 93af        push xl
00007c b7af        in xl, SREG
00007d 93af        push xl
00007e 93bf        push xh
00007f 93ef        push zl
000080 93ff        push zh
                 
000081 91b0 00ce   lds xh, USART_DATA
                 usart_rx_store:
000083 91a0 0212   lds xl, usart_rx_in
000085 e0e0        ldi zl, low(usart_rx_data)
000086 e0f2        ldi zh, high(usart_rx_data)
000087 0fea        add zl, xl
000088 1df3        adc zh, zeroh
000089 83b0        st Z, xh
                 
00008a 95a3        inc xl
00008b 70af        andi xl,usart_rx_mask
                 
00008c 93a0 0212   sts usart_rx_in, xl
                 
                 usart_rx_isr_finish:
00008e 91ff        pop zh
00008f 91ef        pop zl
000090 91bf        pop xh
000091 91af        pop xl
000092 bfaf        out SREG, xl
000093 91af        pop xl
000094 9518        reti
                 
                 .set usartpc = pc
                 .org URXCaddr
000048 c032        jmp_ usart_rx_isr
                 .org usartpc
                 
                 
                 ; ( -- ) Hardware Access
                 ; R( --)
                 ; initialize usart
                 ;VE_USART_INIT_RX:
                 ;  .dw $ff06
                 ;  .db "+usart"
                 ;  .dw VE_HEAD
                 ;  .set VE_HEAD = VE_USART_INIT_RX
                 XT_USART_INIT_RX_ISR:
000095 0108        .dw DO_COLON
                 PFA_USART_INIT_RX_ISR:          ; ( -- )
000096 05e5        .dw XT_ZERO
000097 04c6        .dw XT_DOLITERAL
000098 0212        .dw usart_rx_in
000099 051e        .dw XT_CSTORE
00009a 05e5        .dw XT_ZERO
00009b 04c6        .dw XT_DOLITERAL
00009c 0214        .dw usart_rx_out
00009d 051e        .dw XT_CSTORE
                 
00009e 04a6        .dw XT_EXIT
                 
                 ; ( -- c)
                 ; MCU
                 ; get 1 character from input queue, wait if needed using interrupt driver
                 VE_RX_ISR:
00009f ff06          .dw $ff06
0000a0 7872
0000a1 692d
0000a2 7273          .db "rx-isr"
0000a3 0000          .dw VE_HEAD
                     .set VE_HEAD = VE_RX_ISR
                 XT_RX_ISR:
0000a4 0108          .dw DO_COLON
                 PFA_RX_ISR:
0000a5 00be        .dw XT_RXQ_ISR
0000a6 04bf        .dw XT_DOCONDBRANCH
0000a7 00a5        .dw PFA_RX_ISR
0000a8 04c6        .dw XT_DOLITERAL
0000a9 0214        .dw usart_rx_out
0000aa 0529        .dw XT_CFETCH
0000ab 0542        .dw XT_DUP
0000ac 06c0        .dw XT_1PLUS
0000ad 04c6        .dw XT_DOLITERAL
0000ae 000f        .dw usart_rx_mask
0000af 06a4        .dw XT_AND
0000b0 04c6        .dw XT_DOLITERAL
0000b1 0214        .dw usart_rx_out
0000b2 051e        .dw XT_CSTORE
0000b3 04c6        .dw XT_DOLITERAL
0000b4 0200        .dw usart_rx_data
0000b5 062e        .dw XT_PLUS
0000b6 0529        .dw XT_CFETCH
0000b7 04a6        .dw XT_EXIT
                 
                 ; ( -- f)  
                 ; MCU
                 ; check if unread characters are in the input queue using interrupt driver
                 VE_RXQ_ISR:
0000b8 ff07          .dw $ff07
0000b9 7872
0000ba 2d3f
0000bb 7369
0000bc 0072          .db "rx?-isr",0
0000bd 009f          .dw VE_HEAD
                     .set VE_HEAD = VE_RXQ_ISR
                 XT_RXQ_ISR:
0000be 0108          .dw DO_COLON
                 PFA_RXQ_ISR:
0000bf 0ea0        .dw XT_PAUSE
0000c0 04c6        .dw XT_DOLITERAL
0000c1 0214        .dw usart_rx_out
0000c2 0529        .dw XT_CFETCH
0000c3 04c6        .dw XT_DOLITERAL
0000c4 0212        .dw usart_rx_in
0000c5 0529        .dw XT_CFETCH
0000c6 05a4        .dw XT_NOTEQUAL
0000c7 04a6        .dw XT_EXIT
                   .set XT_RX  = XT_RX_ISR
                   .set XT_RXQ = XT_RXQ_ISR
                   .set XT_USART_INIT_RX = XT_USART_INIT_RX_ISR
                 .else
                 .endif
                 
                 .include "words/usart-tx-poll.asm"
                 
                 ; MCU
                 ; check availability and send one character to the terminal using register poll
                 VE_TX_POLL:
0000c8 ff07          .dw $ff07
0000c9 7874
0000ca 702d
0000cb 6c6f
0000cc 006c          .db "tx-poll",0
0000cd 00b8          .dw VE_HEAD
                     .set VE_HEAD = VE_TX_POLL
                 XT_TX_POLL:
0000ce 0108          .dw DO_COLON
                 PFA_TX_POLL:
                   ; wait for data ready
0000cf 00dc        .dw XT_TXQ_POLL
0000d0 04bf        .dw XT_DOCONDBRANCH
0000d1 00cf        .dw PFA_TX_POLL
                   ; send to usart
0000d2 04c6        .dw XT_DOLITERAL
0000d3 00ce        .dw USART_DATA
0000d4 051e        .dw XT_CSTORE
0000d5 04a6        .dw XT_EXIT
                 
                 ; ( -- f) MCU
                 ; MCU
                 ; check if a character can be send using register poll
                 VE_TXQ_POLL:
0000d6 ff08          .dw $ff08
0000d7 7874
0000d8 2d3f
0000d9 6f70
0000da 6c6c          .db "tx?-poll"
0000db 00c8          .dw VE_HEAD
                     .set VE_HEAD = VE_TXQ_POLL
                 XT_TXQ_POLL:
0000dc 0108          .dw DO_COLON
                 PFA_TXQ_POLL:
0000dd 0ea0        .dw XT_PAUSE
0000de 04c6        .dw XT_DOLITERAL
0000df 00c8        .dw USART_A
0000e0 0529        .dw XT_CFETCH
0000e1 04c6        .dw XT_DOLITERAL
0000e2 0020        .dw bm_USART_TXRD
0000e3 06a4        .dw XT_AND
0000e4 04a6        .dw XT_EXIT
                 .set XT_TX  = XT_TX_POLL
                 .set XT_TXQ = XT_TXQ_POLL
                 .set XT_USART_INIT_TX = 0
                 
                 .include "words/ubrr.asm"
                 
                 ; MCU
                 ; returns usart UBRR settings
                 VE_UBRR:
0000e5 ff04        .dw $ff04
0000e6 6275
0000e7 7272        .db "ubrr"
0000e8 00d6        .dw VE_HEAD
                   .set VE_HEAD = VE_UBRR
                 XT_UBRR:
0000e9 0501        .dw PFA_DOVALUE1
                 PFA_UBRR:          ; ( -- )
0000ea 00c4        .dw EE_UBRRVAL
0000eb 100b        .dw XT_EDEFERFETCH
0000ec 1015        .dw XT_EDEFERSTORE
                 .include "words/usart.asm"
                 
                 ; MCU
                 ; initialize usart
                 VE_USART:
0000ed ff06        .dw $ff06
0000ee 752b
0000ef 6173
0000f0 7472        .db "+usart"
0000f1 00e5        .dw VE_HEAD
                   .set VE_HEAD = VE_USART
                 XT_USART:
0000f2 0108        .dw DO_COLON
                 PFA_USART:          ; ( -- )
                 
0000f3 04c6        .dw XT_DOLITERAL
0000f4 0098        .dw USART_B_VALUE
0000f5 04c6        .dw XT_DOLITERAL
0000f6 00c9        .dw USART_B
0000f7 051e        .dw XT_CSTORE
                 
0000f8 04c6        .dw XT_DOLITERAL
0000f9 0006        .dw USART_C_VALUE
0000fa 04c6        .dw XT_DOLITERAL
0000fb 00ca        .dw USART_C | bm_USARTC_en
0000fc 051e        .dw XT_CSTORE
                 
0000fd 00e9        .dw XT_UBRR
0000fe 0542        .dw XT_DUP
0000ff 077e        .dw XT_BYTESWAP
000100 04c6        .dw XT_DOLITERAL
000101 00cd        .dw BAUDRATE_HIGH
000102 051e        .dw XT_CSTORE
000103 04c6        .dw XT_DOLITERAL
000104 00cc        .dw BAUDRATE_LOW
000105 051e        .dw XT_CSTORE
                 .if XT_USART_INIT_RX!=0
000106 0095        .dw XT_USART_INIT_RX
                 .endif
                 .if XT_USART_INIT_TX!=0
                 .endif
                 
000107 04a6        .dw XT_EXIT
                 
                 ; all of amforth is in one segment
                 .include "amforth-low.asm"
                 
                 ;;;;
                 ;;;; GPL V2 (only)
                 
                 .set pc_ = pc
                 
                 .org $0000
000000 940c 0ea9   jmp_ PFA_COLD
                 .org pc_
                 
                 .include "amforth-interpreter.asm"
                 
                 
                 DO_COLON:
000108 93bf          push XH
000109 93af          push XL          ; PUSH IP
00010a 01db          movw XL, wl
00010b 9611          adiw xl, 1
                 DO_NEXT:
00010c f09e          brts DO_INTERRUPT
00010d 01fd          movw zl, XL        ; READ IP
00010e 2755
00010f 0fee
000110 1fff
000111 1f55
000112 bf5b
000113 9167
000114 9177          readflashcell wl, wh
000115 9611          adiw XL, 1        ; INC IP
                 
                 DO_EXECUTE:
000116 01fb          movw zl, wl
000117 2755
000118 0fee
000119 1fff
00011a 1f55
00011b bf5b
00011c 9107
00011d 9117          readflashcell temp0,temp1
00011e 01f8          movw zl, temp0
00011f 9409          ijmp
                 
                 DO_INTERRUPT:
                     ; here we deal with interrupts the forth way
000120 94e8          clt
000121 ef6c          ldi wl, LOW(XT_ISREXEC)
000122 e078          ldi wh, HIGH(XT_ISREXEC)
000123 cff2          rjmp DO_EXECUTE
                 .include "drivers/generic-isr.asm"
                 
                 .dseg
000216           intcur: .byte 1
                 .eseg
000000           intvec: .byte INTVECTORS * CELLSIZE
                 .cseg
                 
                 ; interrupt routine gets called (again) by rcall! This gives the
                 ; address of the int-vector on the stack.
                 isr:
000124 920a          st -Y, r0
000125 b60f          in r0, SREG
000126 920a          st -Y, r0
                 .if (pclen==3)
000127 900f          pop r0 ; some 128+K Flash devices use 3 cells for call/ret
                 .endif
000128 900f          pop r0
000129 900f          pop r0          ; = intnum * intvectorsize + 1 (address following the rcall)
00012a 940a          dec r0
                 .if intvecsize == 1 ;
                 .endif
00012b 9200 0216     sts intcur, r0
00012d 9009          ld r0, Y+
00012e be0f          out SREG, r0
00012f 9009          ld r0, Y+
000130 9468          set ; set the interrupt flag for the inner interpreter
000131 9508          ret ; returns the interrupt, the rcall stack frame is removed!
                 
                 .set AMFORTH_NRWW_SIZE=(FLASHEND-AMFORTH_RO_SEG)*2
                 ; lower part of the dictionary
                 .include "dict/rww.inc"
                 
                 
                 ; Arithmetics
                 ; add a number to a double cell
                 VE_MPLUS:
000132 ff02          .dw $ff02
000133 2b6d          .db "m+"
000134 00ed          .dw VE_HEAD
                     .set VE_HEAD = VE_MPLUS
                 XT_MPLUS:
000135 0108          .dw DO_COLON
                 PFA_MPLUS:
000136 1248          .dw XT_S2D
000137 0865          .dw XT_DPLUS
000138 04a6          .dw XT_EXIT
                 .include "words/ud-star.asm"
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_UDSTAR:
000139 ff03          .dw $ff03
00013a 6475
../../common\words/ud-star.asm(9): warning: .cseg .db misalignment - padding zero byte
00013b 002a          .db "ud*"
00013c 0132          .dw VE_HEAD
                     .set VE_HEAD = VE_UDSTAR
                 XT_UDSTAR:
00013d 0108          .dw DO_COLON
                 PFA_UDSTAR:
                 
                 .endif
                 ;Z UD*      ud1 d2 -- ud3      32*16->32 multiply
                 ;   XT_DUP >R UM* DROP  XT_SWAP R> UM* ROT + ;
                 
00013e 0542
00013f 0590
000140 0671
000141 056a              .DW XT_DUP,XT_TO_R,XT_UMSTAR,XT_DROP
000142 0555
000143 0587
000144 0671
000145 0572
000146 062e
000147 04a6              .DW XT_SWAP,XT_R_FROM,XT_UMSTAR,XT_ROT,XT_PLUS,XT_EXIT
                 .include "words/umax.asm"
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_UMAX:
000148 ff04          .dw $ff04
000149 6d75
00014a 7861          .db "umax"
00014b 0139          .dw VE_HEAD
                     .set VE_HEAD = VE_UMAX
                 XT_UMAX:
00014c 0108          .dw DO_COLON
                 PFA_UMAX:
                 .endif
                 
00014d 09c7
00014e 05ed              .DW XT_2DUP,XT_ULESS
00014f 04bf      	.dw XT_DOCONDBRANCH
000150 0152      	 DEST(UMAX1)
000151 0555              .DW XT_SWAP
000152 056a      UMAX1:  .DW XT_DROP
000153 04a6      	.dw XT_EXIT
                 .include "words/umin.asm"
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_UMIN:
000154 ff04          .dw $ff04
000155 6d75
000156 6e69          .db "umin"
000157 0148          .dw VE_HEAD
                     .set VE_HEAD = VE_UMIN
                 XT_UMIN:
000158 0108          .dw DO_COLON
                 PFA_UMIN:
                 .endif
000159 09c7
00015a 05f8              .DW XT_2DUP,XT_UGREATER
00015b 04bf      	.dw XT_DOCONDBRANCH
00015c 015e      	DEST(UMIN1)
00015d 0555              .DW XT_SWAP
00015e 056a      UMIN1:  .DW XT_DROP
00015f 04a6      	.dw XT_EXIT
                 .include "words/immediate-q.asm"
                 
                 ; Tools
                 ; get count information out of a counted string in flash
                 ;VE_IMMEDIATEQ:
                 ;    .dw $ff06
                 ;    .db "immediate?"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_IMMEDIATEQ
                 XT_IMMEDIATEQ:
000160 0108          .dw DO_COLON
                 PFA_IMMEDIATEQ:
000161 04c6          .dw XT_DOLITERAL
000162 8000          .dw $8000
000163 06a4          .dw XT_AND
000164 05ab          .dw XT_ZEROEQUAL
000165 04bf          .dw XT_DOCONDBRANCH
000166 016a          DEST(IMMEDIATEQ1)
000167 04c6           .dw XT_DOLITERAL
000168 0001           .dw 1
000169 04a6           .dw XT_EXIT
                 IMMEDIATEQ1:
                     ; not immediate
00016a 05dc          .dw XT_TRUE
00016b 04a6          .dw XT_EXIT
                 .include "words/name2flags.asm"
                 
                 ; Tools
                 ; get the flags from a name token
                 VE_NAME2FLAGS:
00016c ff0a          .dw $ff0a
00016d 616e
00016e 656d
00016f 663e
000170 616c
000171 7367          .db "name>flags"
000172 0154          .dw VE_HEAD
                     .set VE_HEAD = VE_NAME2FLAGS
                 XT_NAME2FLAGS:
000173 0108          .dw DO_COLON
                 PFA_NAME2FLAGS:
000174 0818          .dw XT_FETCHI ; skip to link field
000175 04c6          .dw XT_DOLITERAL
000176 ff00          .dw $ff00
000177 06a4          .dw XT_AND
000178 04a6          .dw XT_EXIT
                 .include "words/name2interpret.asm"
                 
                 ; Tools (ext)
                 ; get the execution token from the name token
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_NAME2INTERPRET:
000179 ff0e          .dw $ff0e
00017a 616e
00017b 656d
00017c 693e
00017d 746e
00017e 7265
00017f 7270
000180 7465          .db "name>interpret"
000181 016c          .dw VE_HEAD
                     .set VE_HEAD = VE_NAME2INTERPRET
                 XT_NAME2INTERPRET:
000182 0108          .dw DO_COLON
                 PFA_NAME2INTERPRET:
                 .endif
000183 10d5          .dw XT_NFA2CFA
000184 04a6          .dw XT_EXIT
                 .include "words/name2compile.asm"
                 
                 ; Tools (ext)
                 ; get the execution token from the name token in compile state
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_NAME2COMPILE:
000185 ff0c          .dw $ff0c
000186 616e
000187 656d
000188 633e
000189 6d6f
00018a 6970
00018b 656c          .db "name>compile"
00018c 0179          .dw VE_HEAD
                     .set VE_HEAD = VE_NAME2COMPILE
                 XT_NAME2COMPILE:
00018d 0108          .dw DO_COLON
                 PFA_NAME2COMPILE:
                 .endif
00018e 0542          .dw XT_DUP
00018f 10d5          .dw XT_NFA2CFA
000190 0555          .dw XT_SWAP
000191 0173          .dw XT_NAME2FLAGS
000192 0160          .dw XT_IMMEDIATEQ
000193 04bf          .dw XT_DOCONDBRANCH
000194 0198          DEST(NAME2COMPILE1)
000195 04c6      	.dw XT_DOLITERAL
000196 01d2      	.dw XT_COMMA
000197 04a6      	.dw XT_EXIT
                 NAME2COMPILE1:
000198 04c6      	.dw XT_DOLITERAL
000199 04b0      	.dw XT_EXECUTE
00019a 04a6          .dw XT_EXIT
                 
                 .if AMFORTH_NRWW_SIZE > 8000
                 .include "dict/appl_8k.inc"
                 
                 
                 .include "words/docreate.asm"
                 
                 ; Compiler
                 ; parse the input and create an empty vocabulary entry without XT and data field (PF)
                 VE_DOCREATE:
00019b ff08          .dw $ff08
00019c 6328
00019d 6572
00019e 7461
00019f 2965          .db "(create)"
0001a0 0185          .dw VE_HEAD
                     .set VE_HEAD = VE_DOCREATE
                 XT_DOCREATE:
0001a1 0108          .dw DO_COLON
                 PFA_DOCREATE:
0001a2 0e1b          .dw XT_PARSENAME
0001a3 02fc          .dw XT_WLSCOPE
0001a4 0542          .dw XT_DUP
0001a5 0590          .dw XT_TO_R
0001a6 02e1          .dw XT_HEADER
0001a7 0587          .dw XT_R_FROM
                 .dseg
000217           COLON_SMUDGE: .byte 4
                 .cseg
0001a8 04c6          .dw XT_DOLITERAL
0001a9 0219          .dw COLON_SMUDGE+2
0001aa 0512          .dw XT_STORE		; save wid
0001ab 04c6          .dw XT_DOLITERAL
0001ac 0217          .dw COLON_SMUDGE+0
0001ad 0512          .dw XT_STORE		; save NFA
                 
0001ae 04a6          .dw XT_EXIT
                 .include "words/backslash.asm"
                 
                 ; Compiler
                 ; everything up to the end of the current line is a comment
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_BACKSLASH:
0001af 0001          .dw $0001
0001b0 005c          .db $5c,0
0001b1 019b          .dw VE_HEAD
                     .set VE_HEAD = VE_BACKSLASH
                 XT_BACKSLASH:
0001b2 0108          .dw DO_COLON
                 PFA_BACKSLASH:
                 .endif
0001b3 0e02          .dw XT_SOURCE
0001b4 0581          .dw XT_NIP
0001b5 09e0          .dw XT_TO_IN
0001b6 0512          .dw XT_STORE
0001b7 04a6          .dw XT_EXIT
                 .include "words/l-paren.asm"
                 
                 ; Compiler
                 ; skip everything up to the closing bracket on the same line
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_LPAREN:
0001b8 0001          .dw $0001
0001b9 0028          .db "(" ,0
0001ba 01af          .dw VE_HEAD
                     .set VE_HEAD = VE_LPAREN
                 XT_LPAREN:
0001bb 0108          .dw DO_COLON
                 PFA_LPAREN:
                 .endif
0001bc 04c6          .dw XT_DOLITERAL
0001bd 0029          .dw ')'
0001be 0ded          .dw XT_PARSE
0001bf 09d0          .dw XT_2DROP
0001c0 04a6          .dw XT_EXIT
                 
                 .include "words/compile.asm"
                 
                 ; Dictionary
                 ; read the following cell from the dictionary and append it to the current dictionary position.
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_COMPILE:
0001c1 ff07          .dw $ff07
0001c2 6f63
0001c3 706d
0001c4 6c69
0001c5 0065          .db "compile",0
0001c6 01b8          .dw  VE_HEAD
                     .set VE_HEAD = VE_COMPILE
                 XT_COMPILE:
0001c7 0108          .dw DO_COLON
                 PFA_COMPILE:
                 .endif
0001c8 0587          .dw XT_R_FROM
0001c9 0542          .dw XT_DUP
0001ca 1002          .dw XT_ICELLPLUS
0001cb 0590          .dw XT_TO_R
0001cc 0818          .dw XT_FETCHI
0001cd 01d2          .dw XT_COMMA
0001ce 04a6          .dw XT_EXIT
                 .include "words/comma.asm"
                 
                 ; Dictionary
                 ; compile 16 bit into flash at DP
                 VE_COMMA:
0001cf ff01          .dw $ff01
0001d0 002c          .db ',',0 ; ,
0001d1 01c1          .dw VE_HEAD
                     .set VE_HEAD = VE_COMMA
                 XT_COMMA:
0001d2 0108          .dw DO_COLON
                 PFA_COMMA:
0001d3 0a16          .dw XT_DP
0001d4 07f9          .dw XT_STOREI
0001d5 0a16          .dw XT_DP
0001d6 06c0          .dw XT_1PLUS
0001d7 0ff0          .dw XT_DOTO
0001d8 0a17          .dw PFA_DP
0001d9 04a6          .dw XT_EXIT
                 .include "words/brackettick.asm"
                 
                 ; Compiler
                 ; what ' does in the interpreter mode, do in colon definitions
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_BRACKETTICK:
0001da 0003          .dw $0003
0001db 275b
0001dc 005d          .db "[']",0
0001dd 01cf          .dw VE_HEAD
                     .set VE_HEAD = VE_BRACKETTICK
                 XT_BRACKETTICK:
0001de 0108          .dw DO_COLON
                 PFA_BRACKETTICK:
                 .endif
0001df 0c78          .dw XT_TICK
0001e0 01e8          .dw XT_LITERAL
0001e1 04a6          .dw XT_EXIT
                 
                 
                 .include "words/literal.asm"
                 
                 ; Compiler
                 ; compile a literal in colon defintions
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_LITERAL:
0001e2 0007          .dw $0007
0001e3 696c
0001e4 6574
0001e5 6172
0001e6 006c          .db "literal",0
0001e7 01da          .dw VE_HEAD
                     .set VE_HEAD = VE_LITERAL
                 XT_LITERAL:
0001e8 0108          .dw DO_COLON
                 PFA_LITERAL:
                 .endif
0001e9 01c7              .DW XT_COMPILE
0001ea 04c6              .DW XT_DOLITERAL
0001eb 01d2              .DW XT_COMMA
0001ec 04a6              .DW XT_EXIT
                 .include "words/sliteral.asm"
                 
                 ; String
                 ; compiles a string to flash, at runtime leaves ( -- flash-addr count) on stack
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SLITERAL:
0001ed 0008        .dw $0008
0001ee 6c73
0001ef 7469
0001f0 7265
0001f1 6c61        .db "sliteral"
0001f2 01e2        .dw VE_HEAD
                   .set VE_HEAD = VE_SLITERAL
                 XT_SLITERAL:
0001f3 0108          .dw DO_COLON
                 PFA_SLITERAL:
                 .endif
0001f4 01c7          .dw XT_COMPILE
0001f5 0bdb          .dw XT_DOSLITERAL    ; ( -- addr n)
0001f6 0be9          .dw XT_SCOMMA
0001f7 04a6          .dw XT_EXIT
                 .include "words/g-mark.asm"
                 
                 ; Compiler
                 ; places current dictionary position for backward resolves
                 ;VE_GMARK:
                 ;    .dw $ff05
                 ;    .db ">mark"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_GMARK
                 XT_GMARK:
0001f8 0108          .dw DO_COLON
                 PFA_GMARK:
0001f9 0a16          .dw XT_DP
0001fa 01c7          .dw XT_COMPILE
0001fb ffff          .dw -1           ; ffff does not erase flash
0001fc 04a6          .dw XT_EXIT
                 .include "words/g-resolve.asm"
                 
                 ; Compiler
                 ; resolve backward jumps
                 ;VE_GRESOLVE:
                 ;    .dw $ff08
                 ;    .db ">resolve"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_GRESOLVE
                 XT_GRESOLVE:
0001fd 0108          .dw DO_COLON
                 PFA_GRESOLVE:
0001fe 0fad          .dw XT_QSTACK
0001ff 0a16          .dw XT_DP
000200 0555          .dw XT_SWAP
000201 07f9          .dw XT_STOREI
000202 04a6          .dw XT_EXIT
                 .include "words/l_mark.asm"
                 
                 ; Compiler
                 ; place destination for backward branch
                 ;VE_LMARK:
                 ;    .dw $ff05
                 ;    .db "<mark"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_LMARK
                 XT_LMARK:
000203 0108          .dw DO_COLON
                 PFA_LMARK:
000204 0a16          .dw XT_DP
000205 04a6          .dw XT_EXIT
                 .include "words/l_resolve.asm"
                 
                 ; Compiler
                 ; resolve backward branch
                 ;VE_LRESOLVE:
                 ;    .dw $ff08
                 ;    .db "<resolve"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_LRESOLVE
                 XT_LRESOLVE:
000206 0108          .dw DO_COLON
                 PFA_LRESOLVE:
000207 0fad          .dw XT_QSTACK
000208 01d2          .dw XT_COMMA
000209 04a6          .dw XT_EXIT
                 
                 .include "words/ahead.asm"
                 
                 ; Compiler
                 ; do a unconditional branch
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_AHEAD:
00020a 0005          .dw $0005
00020b 6861
00020c 6165
00020d 0064          .db "ahead",0
00020e 01ed          .dw VE_HEAD
                     .set VE_HEAD = VE_AHEAD
                 XT_AHEAD:
00020f 0108          .dw DO_COLON
                 PFA_AHEAD:
                 .endif
000210 01c7          .dw XT_COMPILE
000211 04b5          .dw XT_DOBRANCH
000212 01f8          .dw XT_GMARK
000213 04a6          .dw XT_EXIT
                 .include "words/if.asm"
                 
                 ; Compiler
                 ; start conditional branch
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_IF:
000214 0002          .dw $0002
000215 6669          .db "if"
000216 020a          .dw VE_HEAD
                     .set VE_HEAD = VE_IF
                 XT_IF:
000217 0108          .dw DO_COLON
                 PFA_IF:
                 .endif
000218 01c7          .dw XT_COMPILE
000219 04bf          .dw XT_DOCONDBRANCH
00021a 01f8          .dw XT_GMARK
00021b 04a6          .dw XT_EXIT
                 .include "words/else.asm"
                 
                 ; Compiler
                 ; resolve the forward reference and place a new unresolved forward reference
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_ELSE:
00021c 0004          .dw $0004
00021d 6c65
00021e 6573          .db "else"
00021f 0214          .dw VE_HEAD
                     .set VE_HEAD = VE_ELSE
                 XT_ELSE:
000220 0108          .dw DO_COLON
                 PFA_ELSE:
                 .endif
000221 01c7          .dw XT_COMPILE
000222 04b5          .dw XT_DOBRANCH
000223 01f8          .dw XT_GMARK
000224 0555          .dw XT_SWAP
000225 01fd          .dw XT_GRESOLVE
000226 04a6          .dw XT_EXIT
                 .include "words/then.asm"
                 
                 ; Compiler
                 ; finish if
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_THEN:
000227 0004          .dw $0004
000228 6874
000229 6e65          .db "then"
00022a 021c          .dw VE_HEAD
                     .set VE_HEAD = VE_THEN
                 XT_THEN:
00022b 0108          .dw DO_COLON
                 PFA_THEN:
                 .endif
00022c 01fd          .dw XT_GRESOLVE
00022d 04a6          .dw XT_EXIT
                 .include "words/begin.asm"
                 
                 ; Compiler
                 ; put the next location for a transfer of control onto the control flow stack
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_BEGIN:
00022e 0005          .dw $0005
00022f 6562
000230 6967
000231 006e          .db "begin",0
000232 0227          .dw VE_HEAD
                     .set VE_HEAD = VE_BEGIN
                 XT_BEGIN:
000233 0108          .dw DO_COLON
                 PFA_BEGIN:
                 .endif
000234 0203          .dw XT_LMARK
000235 04a6          .dw XT_EXIT
                 .include "words/while.asm"
                 
                 ; Compiler
                 ; at runtime skip until repeat if non-true
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_WHILE:
000236 0005          .dw $0005
000237 6877
000238 6c69
000239 0065          .db "while",0
00023a 022e          .dw VE_HEAD
                     .set VE_HEAD = VE_WHILE
                 XT_WHILE:
00023b 0108          .dw DO_COLON
                 PFA_WHILE:
                 .endif
00023c 0217          .dw XT_IF
00023d 0555          .dw XT_SWAP
00023e 04a6          .dw XT_EXIT
                 .include "words/repeat.asm"
                 
                 ; Compiler
                 ; continue execution at dest, resolve orig
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_REPEAT:
00023f 0006          .dw $0006
000240 6572
000241 6570
000242 7461          .db "repeat"
000243 0236          .dw VE_HEAD
                     .set VE_HEAD = VE_REPEAT
                 XT_REPEAT:
000244 0108          .dw DO_COLON
                 PFA_REPEAT:
                 .endif
000245 0258          .dw XT_AGAIN
000246 022b          .dw XT_THEN
000247 04a6          .dw XT_EXIT
                 .include "words/until.asm"
                 
                 ; Compiler
                 ; finish begin with conditional branch, leaves the loop if true flag at runtime
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_UNTIL:
000248 0005          .dw $0005
000249 6e75
00024a 6974
00024b 006c          .db "until",0
00024c 023f          .dw VE_HEAD
                     .set VE_HEAD = VE_UNTIL
                 XT_UNTIL:
00024d 0108          .dw DO_COLON
                 PFA_UNTIL:
                 .endif
00024e 04c6          .dw XT_DOLITERAL
00024f 04bf          .dw XT_DOCONDBRANCH
000250 01d2          .dw XT_COMMA
                 
000251 0206          .dw XT_LRESOLVE
000252 04a6          .dw XT_EXIT
                 .include "words/again.asm"
                 
                 ; Compiler
                 ; compile a jump back to dest
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_AGAIN:
000253 0005          .dw $0005
000254 6761
000255 6961
000256 006e          .db "again",0
000257 0248          .dw VE_HEAD
                     .set VE_HEAD = VE_AGAIN
                 XT_AGAIN:
000258 0108          .dw DO_COLON
                 PFA_AGAIN:
                 .endif
000259 01c7          .dw XT_COMPILE
00025a 04b5          .dw XT_DOBRANCH
00025b 0206          .dw XT_LRESOLVE
00025c 04a6          .dw XT_EXIT
                 .include "words/do.asm"
                 
                 ; Compiler
                 ; start do .. [+]loop
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DO:
00025d 0002          .dw $0002
00025e 6f64          .db "do"
00025f 0253          .dw VE_HEAD
                     .set VE_HEAD = VE_DO
                 XT_DO:
000260 0108          .dw DO_COLON
                 PFA_DO:
                 
                 .endif
000261 01c7          .dw XT_COMPILE
000262 0720          .dw XT_DODO
000263 0203          .dw XT_LMARK
000264 05e5          .dw XT_ZERO
000265 02bb          .dw XT_TO_L
000266 04a6          .dw XT_EXIT
                 .include "words/loop.asm"
                 
                 ; Compiler
                 ; compile (loop) and resolve the backward branch
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_LOOP:
000267 0004          .dw $0004
000268 6f6c
000269 706f          .db "loop"
00026a 025d          .dw VE_HEAD
                     .set VE_HEAD = VE_LOOP
                 XT_LOOP:
00026b 0108          .dw DO_COLON
                 PFA_LOOP:
                 .endif
00026c 01c7          .dw XT_COMPILE
00026d 074e          .dw XT_DOLOOP
00026e 02a2          .dw XT_ENDLOOP
00026f 04a6          .dw XT_EXIT
                 .include "words/plusloop.asm"
                 
                 ; Compiler
                 ; compile (+loop) and resolve branches
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_PLUSLOOP:
000270 0005          .dw $0005
000271 6c2b
000272 6f6f
000273 0070          .db "+loop",0
000274 0267          .dw VE_HEAD
                     .set VE_HEAD = VE_PLUSLOOP
                 XT_PLUSLOOP:
000275 0108          .dw DO_COLON
                 PFA_PLUSLOOP:
                 .endif
000276 01c7          .dw XT_COMPILE
000277 073f          .dw XT_DOPLUSLOOP
000278 02a2          .dw XT_ENDLOOP
000279 04a6          .dw XT_EXIT
                 .include "words/leave.asm"
                 
                 ; Compiler
                 ; immediatly leave the current DO..LOOP
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_LEAVE:
00027a 0005         .dw $0005
00027b 656c
00027c 7661
00027d 0065         .db "leave",0
00027e 0270         .dw VE_HEAD
                    .set VE_HEAD = VE_LEAVE
                 XT_LEAVE:
00027f 0108          .dw DO_COLON
                 PFA_LEAVE:
                 .endif
000280 01c7
000281 0759          .DW XT_COMPILE,XT_UNLOOP
000282 020f
000283 02bb
000284 04a6          .DW XT_AHEAD,XT_TO_L,XT_EXIT
                 .include "words/qdo.asm"
                 
                 ; Compiler
                 ; start a ?do .. [+]loop control structure
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 VE_QDO:
000285 0003          .dw $0003
000286 643f
000287 006f          .db "?do",0
000288 027a          .dw VE_HEAD
                     .set VE_HEAD = VE_QDO
                 XT_QDO:
000289 0108          .dw DO_COLON
                 PFA_QDO:
                 .endif
00028a 01c7          .dw XT_COMPILE
00028b 0291          .dw XT_QDOCHECK
00028c 0217          .dw XT_IF
00028d 0260          .dw XT_DO
00028e 0555          .dw XT_SWAP    ; DO sets a 0 marker on the leave stack
00028f 02bb          .dw XT_TO_L    ; then follows at the end.
000290 04a6          .dw XT_EXIT
                 
                 ; there is no special runtime for ?do, the do runtime
                 ; gets wrapped with the sequence
                 ; ... ?do-check if do ..... loop then
                 ; with
                 ; : ?do-check ( n1 n2 -- n1 n2 true | false )
                 ;   2dup = dup >r if 2drop then r> invert ;
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 XT_QDOCHECK:
000291 0108          .dw DO_COLON
                 PFA_QDOCHECK:
                 .endif
000292 09c7          .dw XT_2DUP
000293 1264          .dw XT_EQUAL
000294 0542          .dw XT_DUP
000295 0590          .dw XT_TO_R
000296 04bf          .dw XT_DOCONDBRANCH
000297 0299          DEST(PFA_QDOCHECK1)
000298 09d0          .dw XT_2DROP
                 PFA_QDOCHECK1:
000299 0587          .dw XT_R_FROM
00029a 068e          .dw XT_INVERT
00029b 04a6          .dw XT_EXIT
                 .include "words/endloop.asm"
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_ENDLOOP:
00029c ff07          .dw $ff07
00029d 6e65
00029e 6c64
00029f 6f6f
0002a0 0070          .db "endloop",0
0002a1 0285          .dw VE_HEAD
                     .set VE_HEAD = VE_ENDLOOP
                 XT_ENDLOOP:
0002a2 0108          .dw DO_COLON
                 PFA_ENDLOOP:
                 .endif
                 ;Z ENDLOOP   adrs xt --   L: 0 a1 a2 .. aN --
                 ;   <resolve                backward loop
                 ;   BEGIN L> ?DUP WHILE POSTPONE THEN REPEAT ;
                 ;                                 resolve LEAVEs
                 ; This is a common factor of LOOP and +LOOP.
                 
0002a3 0206              .DW XT_LRESOLVE
0002a4 02af
0002a5 054a
0002a6 04bf      LOOP1:  .DW XT_L_FROM,XT_QDUP,XT_DOCONDBRANCH
0002a7 02ab               DEST(LOOP2)
0002a8 022b              .DW XT_THEN
0002a9 04b5      	.dw XT_DOBRANCH
0002aa 02a4               DEST(LOOP1)
0002ab 04a6      LOOP2:  .DW XT_EXIT
                 ; leave address stack
                 .include "words/l-from.asm"
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_L_FROM:
0002ac ff02          .dw $ff02
0002ad 3e6c          .db "l>"
0002ae 029c          .dw VE_HEAD
                     .set VE_HEAD = VE_L_FROM
                 XT_L_FROM:
0002af 0108          .dw DO_COLON
                 PFA_L_FROM:
                 
                 .endif
                 ;Z L>   -- x   L: x --      move from leave stack
                 ;   LP @ @  -2 LP +! ;
                 
0002b0 02cf          .dw XT_LP
0002b1 050a          .dw XT_FETCH
0002b2 050a          .dw XT_FETCH
0002b3 04c6          .dw XT_DOLITERAL
0002b4 fffe          .dw -2
0002b5 02cf          .dw XT_LP
0002b6 06ea          .dw XT_PLUSSTORE
0002b7 04a6          .dw XT_EXIT
                 .include "words/to-l.asm"
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_TO_L:
0002b8 ff02          .dw $ff02
0002b9 6c3e          .db ">l"
0002ba 02ac          .dw VE_HEAD
                     .set VE_HEAD = VE_TO_L
                 XT_TO_L:
0002bb 0108          .dw DO_COLON
                 PFA_TO_L:
                 .endif
                 ;Z >L   x --   L: -- x        move to leave stack
                 ;   CELL LP +!  LP @ ! ;      (L stack grows up)
                 
0002bc 04c6              .dw XT_DOLITERAL
0002bd 0002      	.dw 2
0002be 02cf      	.dw XT_LP
0002bf 06ea      	.dw XT_PLUSSTORE
0002c0 02cf      	.dw XT_LP
0002c1 050a      	.dw XT_FETCH
0002c2 0512      	.dw XT_STORE
0002c3 04a6      	.dw XT_EXIT
                 .include "words/lp0.asm"
                 
                 ; Stack
                 ; start address of leave stack
                 VE_LP0:
0002c4 ff03          .dw $ff03
0002c5 706c
0002c6 0030          .db "lp0",0
0002c7 02b8          .dw VE_HEAD
                     .set VE_HEAD = VE_LP0
                 XT_LP0:
0002c8 0501          .dw PFA_DOVALUE1
                 PFA_LP0:
0002c9 00a4          .dw EE_LP0
0002ca 100b          .dw XT_EDEFERFETCH
0002cb 1015          .dw XT_EDEFERSTORE
                 .include "words/lp.asm"
                 
                 ; System Variable
                 ; leave stack pointer
                 VE_LP:
0002cc ff02          .dw $ff02
0002cd 706c          .db "lp"
0002ce 02c4          .dw VE_HEAD
                     .set VE_HEAD = VE_LP
                 XT_LP:
0002cf 04d4          .dw PFA_DOVARIABLE
                 PFA_LP:
0002d0 021b          .dw ram_lp
                 
                 .dseg
00021b           ram_lp: .byte 2
                 .cseg
                 
                 
                 .include "words/create.asm"
                 
                 ; Dictionary
                 ; create a dictionary header. XT is (constant), with the address of the data field of name
                 VE_CREATE:
0002d1 ff06          .dw $ff06
0002d2 7263
0002d3 6165
0002d4 6574          .db "create"
0002d5 02cc          .dw VE_HEAD
                     .set VE_HEAD = VE_CREATE
                 XT_CREATE:
0002d6 0108          .dw DO_COLON
                 PFA_CREATE:
0002d7 01a1          .dw XT_DOCREATE
0002d8 0305          .dw XT_REVEAL
0002d9 01c7          .dw XT_COMPILE
0002da 04e1          .dw PFA_DOCONSTANT
0002db 04a6          .dw XT_EXIT
                 .include "words/header.asm"
                 
                 ; Compiler
                 ; creates the vocabulary header without XT and data field (PF) in the wordlist wid
                 VE_HEADER:
0002dc ff06          .dw $ff06
0002dd 6568
0002de 6461
0002df 7265          .db "header"
0002e0 02d1          .dw VE_HEAD
                     .set VE_HEAD = VE_HEADER
                 XT_HEADER:
0002e1 0108          .dw DO_COLON
                 PFA_HEADER:
0002e2 0a16          .dw XT_DP           ; the new Name Field
0002e3 0590          .dw XT_TO_R
0002e4 0590          .dw XT_TO_R		; ( R: NFA WID )
0002e5 0542          .dw XT_DUP    
0002e6 05b9          .dw XT_GREATERZERO 
0002e7 04bf          .dw XT_DOCONDBRANCH
0002e8 02f3          .dw PFA_HEADER1
0002e9 0542          .dw XT_DUP
0002ea 04c6          .dw XT_DOLITERAL
0002eb ff00          .dw $ff00           ; all flags are off (e.g. immediate)
0002ec 06ad          .dw XT_OR
0002ed 0bed          .dw XT_DOSCOMMA
                     ; make the link to the previous entry in this wordlist
0002ee 0587          .dw XT_R_FROM
0002ef 07e5          .dw XT_FETCHE
0002f0 01d2          .dw XT_COMMA
0002f1 0587          .dw XT_R_FROM
0002f2 04a6          .dw XT_EXIT
                 
                 PFA_HEADER1:
                     ; -16: attempt to use zero length string as a name
0002f3 04c6          .dw XT_DOLITERAL
0002f4 fff0          .dw -16
0002f5 0ca7          .dw XT_THROW
                 
                 .include "words/wlscope.asm"
                 
                 ; Compiler
                 ; dynamically place a word in a wordlist. The word name may be changed.
                 VE_WLSCOPE:
0002f6 ff07          .dw $ff07
0002f7 6c77
0002f8 6373
0002f9 706f
0002fa 0065          .db "wlscope",0
0002fb 02dc          .dw VE_HEAD
                     .set VE_HEAD = VE_WLSCOPE
                 XT_WLSCOPE:
0002fc 106a          .dw PFA_DODEFER1
                 PFA_WLSCOPE:
0002fd 00a2          .dw EE_WLSCOPE
0002fe 100b          .dw XT_EDEFERFETCH
0002ff 1015          .dw XT_EDEFERSTORE
                 
                 ; wlscope, "wordlist scope" ( addr len -- addr' len' wid ), is a deferred word
                 ; which enables the AmForth application to choose the wordlist ( wid ) for the
                 ; new voc entry based on the input ( addr len ) string. The name of the new voc
                 ; entry ( addr' len' ) may be different from the input string. Note that all
                 ; created voc entry types pass through the wlscope mechanism. The default
                 ; wlscope action passes the input string to the output without modification and
                 ; uses get-current to select the wid.
                 .include "words/reveal.asm"
                 
                 ; Dictionary
                 ; makes an entry in a wordlist visible, if not already done.
                 VE_REVEAL:
000300 ff06          .dw $ff06
000301 6572
000302 6576
000303 6c61          .db "reveal"
000304 02f6          .dw VE_HEAD
                     .set VE_HEAD = VE_REVEAL
                 XT_REVEAL:
000305 0108          .dw DO_COLON
                 PFA_REVEAL:
000306 04c6          .dw XT_DOLITERAL
000307 0217          .dw COLON_SMUDGE+0
000308 050a          .dw XT_FETCH
000309 054a          .dw XT_QDUP
00030a 04bf          .dw XT_DOCONDBRANCH
00030b 0314          .dw PFA_REVEAL1
                 ;
00030c 04c6          .dw XT_DOLITERAL
00030d 0219          .dw COLON_SMUDGE+2
00030e 050a          .dw XT_FETCH		; ( NFA WID )
00030f 07c1          .dw XT_STOREE
                     ; prevent duplicate actions and cooperate with :noname
000310 05e5          .dw XT_ZERO
000311 04c6          .dw XT_DOLITERAL
000312 0217          .dw COLON_SMUDGE+0
000313 0512          .dw XT_STORE
                 PFA_REVEAL1:
000314 04a6          .dw XT_EXIT
                 .include "words/latest.asm"
                 
                 ; System Variable
                 ; system LATEST
                 VE_LATEST:
000315 ff06          .dw $ff06
000316 616c
000317 6574
000318 7473          .db "latest"
000319 0300          .dw VE_HEAD
                     .set VE_HEAD = VE_LATEST
                 XT_LATEST:
00031a 04d4          .dw PFA_DOVARIABLE
                 PFA_LATEST:
00031b 021d          .dw ram_LATEST
                 
                 .dseg
00021d           ram_LATEST: .byte 2
                 .cseg
                 .include "words/does.asm"
                 
                 ; Compiler
                 ; organize the XT replacement to call other colon code
                 VE_DOES:
00031c 0005          .dw $0005
00031d 6f64
00031e 7365
00031f 003e          .db "does>",0
000320 0315          .dw VE_HEAD
                     .set VE_HEAD = VE_DOES
                 XT_DOES:
000321 0108          .dw DO_COLON
                 PFA_DOES:
000322 01c7          .dw XT_COMPILE
000323 0334          .dw XT_DODOES
000324 01c7          .dw XT_COMPILE  ; create a code snippet to be used in an embedded XT
000325 940e          .dw $940e       ; the address of this compiled
000326 01c7          .dw XT_COMPILE  ; code will replace the XT of the 
000327 0329          .dw DO_DODOES   ; word that CREATE created
000328 04a6          .dw XT_EXIT     ; 
                 
                 DO_DODOES: ; ( -- PFA )
000329 939a
00032a 938a          savetos
00032b 01cb          movw tosl, wl
00032c 9601          adiw tosl, 1
                     ; the following takes the address from a real uC-call
                 .if (pclen==3)
00032d 917f          pop wh ; some 128K Flash devices use 3 cells for call/ret
                 .endif
00032e 917f          pop wh
00032f 916f          pop wl
                 
000330 93bf          push XH
000331 93af          push XL
000332 01db          movw XL, wl
000333 cdd8          jmp_ DO_NEXT
                 
                 ; ( -- )
                 ; System
                 ; replace the XT written by CREATE to call the code that follows does>
                 ;VE_DODOES:
                 ;   .dw $ff07
                 ;   .db "(does>)"
                 ;   .set VE_HEAD = VE_DODOES
                 XT_DODOES:
000334 0108          .dw DO_COLON
                 PFA_DODOES:
000335 0587          .dw XT_R_FROM
000336 04c6          .dw XT_DOLITERAL
000337 0219          .dw COLON_SMUDGE+2
000338 050a          .dw XT_FETCH
000339 07e5          .dw XT_FETCHE
00033a 0481          .dw XT_NFA2LFA
00033b 06c0          .dw XT_1PLUS   ; lfa>xt
                 
00033c 07f9          .dw XT_STOREI
00033d 04a6          .dw XT_EXIT
                 .include "words/colon.asm"
                 
                 ; Compiler
                 ; create a named entry in the dictionary, XT is DO_COLON
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_COLON:
00033e ff01          .dw $ff01
00033f 003a          .db ":",0
000340 031c          .dw VE_HEAD
                     .set VE_HEAD = VE_COLON
                 XT_COLON:
000341 0108          .dw DO_COLON
                 PFA_COLON:
                 .endif
000342 01a1          .dw XT_DOCREATE
000343 034c          .dw XT_COLONNONAME
000344 056a          .dw XT_DROP
000345 04a6          .dw XT_EXIT
                 .include "words/colon-noname.asm"
                 
                 ; Compiler
                 ; create an unnamed entry in the dictionary, XT is DO_COLON
                 VE_COLONNONAME:
000346 ff07          .dw $ff07
000347 6e3a
000348 6e6f
000349 6d61
00034a 0065          .db ":noname",0
00034b 033e          .dw VE_HEAD
                     .set VE_HEAD = VE_COLONNONAME
                 XT_COLONNONAME:
00034c 0108          .dw DO_COLON
                 PFA_COLONNONAME:
00034d 0a16          .dw XT_DP
00034e 0542          .dw XT_DUP
00034f 031a          .dw XT_LATEST
000350 0512          .dw XT_STORE
                 
000351 01c7          .dw XT_COMPILE
000352 0108          .dw DO_COLON
                 
000353 0361          .dw XT_RBRACKET
000354 04a6          .dw XT_EXIT
                 .include "words/semicolon.asm"
                 
                 ; Compiler
                 ; finish colon defintion, compiles (exit) and returns to interpret state 
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 
                 VE_SEMICOLON:
000355 0001          .dw $0001
000356 003b          .db $3b,0
000357 0346          .dw VE_HEAD
                     .set VE_HEAD = VE_SEMICOLON
                 XT_SEMICOLON:
000358 0108          .dw DO_COLON
                 PFA_SEMICOLON:
                 .endif
000359 01c7          .dw XT_COMPILE
00035a 04a6          .dw XT_EXIT
00035b 036a          .dw XT_LBRACKET
00035c 0305          .dw XT_REVEAL
00035d 04a6          .dw XT_EXIT
                 .include "words/right-bracket.asm"
                 
                 ; Compiler
                 ; enter compiler mode
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_RBRACKET:
00035e ff01          .dw $ff01
00035f 005d          .db "]",0
000360 0355          .dw VE_HEAD
                     .set VE_HEAD = VE_RBRACKET
                 XT_RBRACKET:
000361 0108          .dw DO_COLON
                 PFA_RBRACKET:
                 .endif
000362 04c6          .dw XT_DOLITERAL
000363 0001          .dw 1
000364 09ac          .dw XT_STATE
000365 0512          .dw XT_STORE
000366 04a6          .dw XT_EXIT
                 .include "words/left-bracket.asm"
                 
                 ; Compiler
                 ; enter interpreter mode
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_LBRACKET:
000367 0001          .dw $0001
000368 005b          .db "[",0
000369 035e          .dw VE_HEAD
                     .set VE_HEAD = VE_LBRACKET
                 XT_LBRACKET:
00036a 0108          .dw DO_COLON
                 PFA_LBRACKET:
                 .endif
00036b 05e5          .dw XT_ZERO
00036c 09ac          .dw XT_STATE
00036d 0512          .dw XT_STORE
00036e 04a6          .dw XT_EXIT
                 .include "words/variable.asm"
                 
                 ; Compiler
                 ; create a dictionary entry for a variable and allocate 1 cell RAM
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 VE_VARIABLE:
00036f ff08          .dw $ff08
000370 6176
000371 6972
000372 6261
000373 656c          .db "variable"
000374 0367          .dw VE_HEAD
                     .set VE_HEAD = VE_VARIABLE
                 XT_VARIABLE:
000375 0108          .dw DO_COLON
                 PFA_VARIABLE:
                 .endif
000376 0a27          .dw XT_HERE
000377 0382          .dw XT_CONSTANT
000378 04c6          .dw XT_DOLITERAL
000379 0002          .dw 2
00037a 0a30          .dw XT_ALLOT
00037b 04a6          .dw XT_EXIT
                 .include "words/constant.asm"
                 
                 ; Compiler
                 ; create a constant in the dictionary
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 VE_CONSTANT:
00037c ff08          .dw $ff08
00037d 6f63
00037e 736e
00037f 6174
000380 746e          .db "constant"
000381 036f          .dw VE_HEAD
                     .set VE_HEAD = VE_CONSTANT
                 XT_CONSTANT:
000382 0108          .dw DO_COLON
                 PFA_CONSTANT:
                 .endif
000383 01a1          .dw XT_DOCREATE
000384 0305          .dw XT_REVEAL
000385 01c7          .dw XT_COMPILE
000386 04d4          .dw PFA_DOVARIABLE
000387 01d2          .dw XT_COMMA
000388 04a6          .dw XT_EXIT
                 .include "words/user.asm"
                 
                 ; Compiler
                 ; create a dictionary entry for a user variable at offset n
                 VE_USER:
000389 ff04          .dw $ff04
00038a 7375
00038b 7265          .db "user"
00038c 037c          .dw VE_HEAD
                     .set VE_HEAD = VE_USER
                 XT_USER:
00038d 0108          .dw DO_COLON
                 PFA_USER:
00038e 01a1          .dw XT_DOCREATE
00038f 0305          .dw XT_REVEAL
                 
000390 01c7          .dw XT_COMPILE
000391 04e7          .dw PFA_DOUSER
000392 01d2          .dw XT_COMMA
000393 04a6          .dw XT_EXIT
                 
                 .include "words/recurse.asm"
                 
                 ; Compiler
                 ; compile the XT of the word currently being defined into the dictionary
                 VE_RECURSE:
000394 0007          .dw $0007
000395 6572
000396 7563
000397 7372
000398 0065          .db "recurse",0
000399 0389          .dw VE_HEAD
                     .set VE_HEAD = VE_RECURSE
                 XT_RECURSE:
00039a 0108          .dw DO_COLON
                 PFA_RECURSE:
00039b 031a          .dw XT_LATEST
00039c 050a          .dw XT_FETCH
00039d 01d2          .dw XT_COMMA
00039e 04a6          .dw XT_EXIT
                 .include "words/immediate.asm"
                 
                 ; Compiler
                 ; set immediate flag for the most recent word definition
                 VE_IMMEDIATE:
00039f ff09          .dw $ff09
0003a0 6d69
0003a1 656d
0003a2 6964
0003a3 7461
0003a4 0065          .db "immediate",0
0003a5 0394          .dw VE_HEAD
                     .set VE_HEAD = VE_IMMEDIATE
                 XT_IMMEDIATE:
0003a6 0108          .dw DO_COLON
                 PFA_IMMEDIATE:
0003a7 0443          .dw XT_GET_CURRENT
0003a8 07e5          .dw XT_FETCHE
0003a9 0542          .dw XT_DUP
0003aa 0818          .dw XT_FETCHI
0003ab 04c6          .dw XT_DOLITERAL
0003ac 7fff          .dw $7fff
0003ad 06a4          .dw XT_AND
0003ae 0555          .dw XT_SWAP
0003af 07f9          .dw XT_STOREI
0003b0 04a6          .dw XT_EXIT
                 
                 .include "words/bracketchar.asm"
                 
                 ; Tools
                 ; skip leading space delimites, place the first character of the word on the stack
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_BRACKETCHAR:
0003b1 0006          .dw $0006
0003b2 635b
0003b3 6168
0003b4 5d72          .db "[char]"
0003b5 039f          .dw VE_HEAD
                     .set VE_HEAD = VE_BRACKETCHAR
                 XT_BRACKETCHAR:
0003b6 0108          .dw DO_COLON
                 PFA_BRACKETCHAR:
                 .endif
0003b7 01c7          .dw XT_COMPILE
0003b8 04c6          .dw XT_DOLITERAL
0003b9 0d4a          .dw XT_CHAR
0003ba 01d2          .dw XT_COMMA
0003bb 04a6          .dw XT_EXIT
                 .include "words/abort-string.asm"
                 
                 ;C         i*x x1 --       R: j*x --      x1<>0
                 ;   POSTPONE IS" POSTPONE ?ABORT ; IMMEDIATE
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_ABORTQUOTE:
0003bc 0006          .dw $0006
0003bd 6261
0003be 726f
0003bf 2274          .db "abort",'"'
0003c0 03b1          .dw VE_HEAD
                     .set VE_HEAD = VE_ABORTQUOTE
                 XT_ABORTQUOTE:
0003c1 0108          .dw DO_COLON
                 PFA_ABORTQUOTE:
                 .endif
0003c2 0922          .dw XT_SQUOTE
0003c3 01c7          .dw XT_COMPILE
0003c4 03d4          .dw XT_QABORT
0003c5 04a6          .DW XT_EXIT
                 .include "words/abort.asm"
                 
                 ; Exceptions
                 ; send an exception -1
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_ABORT:
0003c6 ff05          .dw $ff05
0003c7 6261
0003c8 726f
0003c9 0074          .db "abort",0
0003ca 03bc          .dw VE_HEAD
                     .set VE_HEAD = VE_ABORT
                 XT_ABORT:
0003cb 0108          .dw DO_COLON
                 PFA_ABORT:
                 .endif
0003cc 04c6          .dw XT_DOLITERAL
0003cd ffff          .dw -1
0003ce 0ca7          .dw XT_THROW
                 .include "words/q-abort.asm"
                 
                 ;   ROT IF ITYPE ABORT THEN 2DROP ;
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_QABORT:
0003cf ff06          .dw $ff06
0003d0 613f
0003d1 6f62
0003d2 7472          .db "?abort"
0003d3 03c6          .dw VE_HEAD
                     .set VE_HEAD = VE_QABORT
                 XT_QABORT:
0003d4 0108          .dw DO_COLON
                 PFA_QABORT:
                 
                 .endif
0003d5 0572
0003d6 04bf              .DW XT_ROT,XT_DOCONDBRANCH
0003d7 03da              DEST(QABO1)
0003d8 0c0e
0003d9 03cb              .DW XT_ITYPE,XT_ABORT
0003da 09d0
0003db 04a6      QABO1:  .DW XT_2DROP,XT_EXIT
                 
                 .include "words/get-stack.asm"
                 
                 ; Tools
                 ; Get a stack from EEPROM
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_GET_STACK:
0003dc ff09          .dw $ff09
0003dd 6567
0003de 2d74
0003df 7473
0003e0 6361
0003e1 006b          .db "get-stack",0
0003e2 03cf          .dw VE_HEAD
                     .set VE_HEAD = VE_GET_STACK
                 XT_GET_STACK:
0003e3 0108          .dw DO_COLON
                 PFA_N_FETCH_E:
                 .endif
0003e4 0542          .dw XT_DUP
0003e5 09bf          .dw XT_CELLPLUS
0003e6 0555          .dw XT_SWAP
0003e7 07e5          .dw XT_FETCHE
0003e8 0542          .dw XT_DUP
0003e9 0590          .dw XT_TO_R
0003ea 05e5          .dw XT_ZERO
0003eb 0555          .dw XT_SWAP    ; go from bigger to smaller addresses
0003ec 0291          .dw XT_QDOCHECK
0003ed 04bf          .dw XT_DOCONDBRANCH
0003ee 03fa          DEST(PFA_N_FETCH_E2)
0003ef 0720          .dw XT_DODO
                 PFA_N_FETCH_E1:
                     ; ( ee-addr )
0003f0 0731          .dw XT_I
0003f1 06c6          .dw XT_1MINUS
0003f2 09b9          .dw XT_CELLS ; ( -- ee-addr i*2 )
0003f3 0560          .dw XT_OVER  ; ( -- ee-addr i*2 ee-addr )
0003f4 062e          .dw XT_PLUS  ; ( -- ee-addr ee-addr+i
0003f5 07e5          .dw XT_FETCHE ;( -- ee-addr item_i )
0003f6 0555          .dw XT_SWAP   ;( -- item_i ee-addr )
0003f7 05dc          .dw XT_TRUE  ; shortcut for -1
0003f8 073f          .dw XT_DOPLUSLOOP
0003f9 03f0          DEST(PFA_N_FETCH_E1)
                 PFA_N_FETCH_E2:
0003fa 09d0          .dw XT_2DROP
0003fb 0587          .dw XT_R_FROM
0003fc 04a6          .dw XT_EXIT
                 
                 .include "words/set-stack.asm"
                 
                 ; Tools
                 ; Write a stack to EEPROM
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SET_STACK:
0003fd ff09          .dw $ff09
0003fe 6573
0003ff 2d74
000400 7473
000401 6361
000402 006b          .db "set-stack",0
000403 03dc          .dw VE_HEAD
                     .set VE_HEAD = VE_SET_STACK
                 XT_SET_STACK:
000404 0108          .dw DO_COLON
                 PFA_SET_STACK:
                 .endif
000405 09c7          .dw XT_2DUP
000406 07c1          .dw XT_STOREE ; ( -- i_n .. i_0 n e-addr )
000407 0555          .dw XT_SWAP    
000408 05e5          .dw XT_ZERO
000409 0291          .dw XT_QDOCHECK
00040a 04bf          .dw XT_DOCONDBRANCH
00040b 0412          DEST(PFA_SET_STACK2)
00040c 0720          .dw XT_DODO
                 PFA_SET_STACK1:
00040d 09bf          .dw XT_CELLPLUS ; ( -- i_x e-addr )
00040e 09d8          .dw XT_TUCK      ; ( -- e-addr i_x e-addr
00040f 07c1          .dw XT_STOREE
000410 074e          .dw XT_DOLOOP
000411 040d          DEST(PFA_SET_STACK1)
                 PFA_SET_STACK2:
000412 056a          .dw XT_DROP
000413 04a6          .dw XT_EXIT
                 
                 .include "words/map-stack.asm"
                 
                 ; Tools
                 ; Iterate over a stack
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_MAPSTACK:
000414 ff09          .dw $ff09
000415 616d
000416 2d70
000417 7473
000418 6361
000419 006b          .db "map-stack",0
00041a 03fd          .dw VE_HEAD
                     .set VE_HEAD = VE_MAPSTACK
                 XT_MAPSTACK:
00041b 0108          .dw DO_COLON
                 PFA_MAPSTACK:
                 .endif
00041c 0542          .dw XT_DUP
00041d 09bf          .dw XT_CELLPLUS
00041e 0555          .dw XT_SWAP
00041f 07e5          .dw XT_FETCHE
000420 09b9          .dw XT_CELLS
000421 123f          .dw XT_BOUNDS
000422 0291          .dw XT_QDOCHECK
000423 04bf          .dw XT_DOCONDBRANCH
000424 0438          DEST(PFA_MAPSTACK3)
000425 0720          .dw XT_DODO
                 PFA_MAPSTACK1:
000426 0731            .dw XT_I
000427 07e5            .dw XT_FETCHE   ; -- i*x XT id
000428 0555            .dw XT_SWAP
000429 0590            .dw XT_TO_R
00042a 0599            .dw XT_R_FETCH
00042b 04b0            .dw XT_EXECUTE  ; i*x id -- j*y true | i*x false
00042c 054a            .dw XT_QDUP
00042d 04bf            .dw XT_DOCONDBRANCH
00042e 0433            DEST(PFA_MAPSTACK2)
00042f 0587               .dw XT_R_FROM
000430 056a               .dw XT_DROP
000431 0759               .dw XT_UNLOOP
000432 04a6               .dw XT_EXIT
                 PFA_MAPSTACK2:
000433 0587            .dw XT_R_FROM
000434 04c6            .dw XT_DOLITERAL
000435 0002            .dw 2
000436 073f            .dw XT_DOPLUSLOOP
000437 0426            DEST(PFA_MAPSTACK1)
                 PFA_MAPSTACK3:
000438 056a          .dw XT_DROP
000439 05e5          .dw XT_ZERO
00043a 04a6          .dw XT_EXIT
                 
                 ;
                 ; : map-stack ( i*x XT e-addr -- j*y )
                 ;     dup cell+ swap @e cells bounds ?do 
                 ;       ( -- i*x XT )
                 ;       i @e swap >r r@ execute
                 ;       ?dup if r> drop unloop exit then
                 ;       r>
                 ;     2 +loop drop 0
                 ;
                 .include "words/get-current.asm"
                 
                 ; Search Order
                 ; get the wid of the current compilation word list
                 VE_GET_CURRENT:
00043b ff0b          .dw $ff0b
00043c 6567
00043d 2d74
00043e 7563
00043f 7272
000440 6e65
000441 0074          .db "get-current",0
000442 0414          .dw VE_HEAD
                     .set VE_HEAD = VE_GET_CURRENT
                 XT_GET_CURRENT:
000443 0108          .dw DO_COLON
                 PFA_GET_CURRENT:
000444 04c6          .dw XT_DOLITERAL
000445 0082          .dw EE_CURRENT
000446 07e5          .dw XT_FETCHE
000447 04a6          .dw XT_EXIT
                 .include "words/get-order.asm"
                 
                 ; Search Order
                 ; Get the current search order word list
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_GET_ORDER:
000448 ff09          .dw $ff09
000449 6567
00044a 2d74
00044b 726f
00044c 6564
00044d 0072          .db "get-order",0
00044e 043b          .dw VE_HEAD
                     .set VE_HEAD = VE_GET_ORDER
                 XT_GET_ORDER:
00044f 0108          .dw DO_COLON
                 PFA_GET_ORDER:
                 .endif
000450 04c6          .dw XT_DOLITERAL
000451 0086          .dw CFG_ORDERLISTLEN
000452 03e3          .dw XT_GET_STACK
000453 04a6          .dw XT_EXIT
                 
                 .include "words/compare.asm"
                 
                 ; String
                 ; compares two strings in RAM
                 VE_COMPARE:
000454 ff07          .dw $ff07
000455 6f63
000456 706d
000457 7261
000458 0065          .db "compare",0
000459 0448          .dw VE_HEAD
                     .set VE_HEAD = VE_COMPARE
                 XT_COMPARE:
00045a 045b          .dw PFA_COMPARE
                 PFA_COMPARE:
00045b 93bf          push xh
00045c 93af          push xl
00045d 018c          movw temp0, tosl
00045e 9189
00045f 9199          loadtos
000460 01dc          movw xl, tosl
000461 9189
000462 9199          loadtos
000463 019c          movw temp2, tosl
000464 9189
000465 9199          loadtos
000466 01fc          movw zl, tosl
                 PFA_COMPARE_LOOP:
000467 90ed          ld temp4, X+
000468 90f1          ld temp5, Z+
000469 14ef          cp temp4, temp5
00046a f451          brne PFA_COMPARE_NOTEQUAL
00046b 950a          dec temp0
00046c f019          breq PFA_COMPARE_ENDREACHED2
00046d 952a          dec temp2
00046e f7c1          brne PFA_COMPARE_LOOP
00046f c001          rjmp PFA_COMPARE_ENDREACHED
                 PFA_COMPARE_ENDREACHED2:
000470 952a          dec temp2
                 PFA_COMPARE_ENDREACHED:
000471 2b02          or temp0, temp2
000472 f411          brne PFA_COMPARE_CHECKLASTCHAR
000473 2788          clr tosl
000474 c002          rjmp PFA_COMPARE_DONE
                 PFA_COMPARE_CHECKLASTCHAR:
                 PFA_COMPARE_NOTEQUAL:
000475 ef8f          ser tosl
000476 c000          rjmp PFA_COMPARE_DONE
                 
                 PFA_COMPARE_DONE:
000477 2f98          mov tosh, tosl
000478 91af          pop xl
000479 91bf          pop xh
00047a cc91          jmp_ DO_NEXT
                 .include "words/nfa2lfa.asm"
                 
                 ; System
                 ; get the link field address from the name field address
                 VE_NFA2LFA:
00047b ff07         .dw $ff07
00047c 666e
00047d 3e61
00047e 666c
00047f 0061         .db "nfa>lfa",0
000480 0454         .dw VE_HEAD
                    .set VE_HEAD = VE_NFA2LFA
                 XT_NFA2LFA:
000481 0108          .dw DO_COLON
                 PFA_NFA2LFA:
000482 10c9          .dw XT_NAME2STRING
000483 06c0          .dw XT_1PLUS
000484 0695          .dw XT_2SLASH
000485 062e          .dw XT_PLUS
000486 04a6          .dw XT_EXIT
                 .elif AMFORTH_NRWW_SIZE > 4000
                 .elif AMFORTH_NRWW_SIZE > 2000
                 .else
                 .endif
                 .include "dict_appl.inc"
                 
                 ; they may be moved to the core dictionary if needed
                 
                 .include "words/applturnkey.asm"
                 
                 ; R( -- )
                 ; application specific turnkey action
                 VE_APPLTURNKEY:
000487 ff0b          .dw $ff0b
000488 7061
000489 6c70
00048a 7574
00048b 6e72
00048c 656b
00048d 0079          .db "applturnkey",0
00048e 047b          .dw VE_HEAD
                     .set VE_HEAD = VE_APPLTURNKEY
                 XT_APPLTURNKEY:
00048f 0108          .dw DO_COLON
                 PFA_APPLTURNKEY:
000490 00f2          .dw XT_USART
                 
000491 08d1          .dw XT_INTON
000492 0fba          .dw XT_DOT_VER
000493 0c50          .dw XT_SPACE
000494 09a1          .dw XT_F_CPU
000495 04c6          .dw XT_DOLITERAL
000496 03e8          .dw 1000
000497 0653          .dw XT_UMSLASHMOD
000498 0555          .dw XT_SWAP
000499 056a          .dw XT_DROP
00049a 0a46          .dw XT_DECIMAL
00049b 0b90          .dw XT_DOT
00049c 0bdb          .dw XT_DOSLITERAL
00049d 0004          .dw 4
00049e 486b
00049f 207a          .db "kHz "
0004a0 0c0e          .dw XT_ITYPE
                     
0004a1 04a6          .dw XT_EXIT
                 
                 .include "dict/nrww.inc" ; well, not really nrww, but simplifies things alot
                 
                 ; section together with the forth inner interpreter
                 
                 .include "words/exit.asm"
                 
                 ; Compiler
                 ; end of current colon word
                 VE_EXIT:
0004a2 ff04          .dw $ff04
0004a3 7865
0004a4 7469          .db "exit"
0004a5 0487          .dw VE_HEAD
                     .set VE_HEAD = VE_EXIT
                 XT_EXIT:
0004a6 04a7          .dw PFA_EXIT
                 PFA_EXIT:
0004a7 91af          pop XL
0004a8 91bf          pop XH
0004a9 cc62          jmp_ DO_NEXT
                 .include "words/execute.asm"
                 
                 ; System
                 ; execute XT
                 VE_EXECUTE:
0004aa ff07          .dw $ff07
0004ab 7865
0004ac 6365
0004ad 7475
0004ae 0065          .db "execute",0
0004af 04a2          .dw VE_HEAD
                     .set VE_HEAD = VE_EXECUTE
                 XT_EXECUTE:
0004b0 04b1          .dw PFA_EXECUTE
                 PFA_EXECUTE:
0004b1 01bc          movw wl, tosl
0004b2 9189
0004b3 9199          loadtos
0004b4 cc61          jmp_ DO_EXECUTE
                 .include "words/dobranch.asm"
                 
                 ; System
                 ; runtime of branch
                 ;VE_DOBRANCH:
                 ;    .dw $ff08
                 ;    .db "(branch)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOBRANCH
                 XT_DOBRANCH:
0004b5 04b6          .dw PFA_DOBRANCH
                 PFA_DOBRANCH:
0004b6 01fd          movw zl, XL
0004b7 2755
0004b8 0fee
0004b9 1fff
0004ba 1f55
0004bb bf5b
0004bc 91a7
0004bd 91b7          readflashcell XL,XH
0004be cc4d          jmp_ DO_NEXT
                 .include "words/docondbranch.asm"
                 
                 ; System
                 ; runtime of ?branch
                 ;VE_DOCONDBRANCH:
                 ;    .dw $ff09
                 ;    .db "(?branch)"
                 ;    .dw  VE_HEAD
                 ;    .set VE_HEAD = VE_DOCONDBRANCH
                 XT_DOCONDBRANCH:
0004bf 04c0          .dw PFA_DOCONDBRANCH
                 PFA_DOCONDBRANCH:
0004c0 2b98          or tosh, tosl
0004c1 9189
0004c2 9199          loadtos
0004c3 f391          brbs 1, PFA_DOBRANCH ; 1 is z flag; if tos is zero (false), do the branch
0004c4 9611          adiw XL, 1
0004c5 cc46          jmp_ DO_NEXT
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/doliteral.asm"
                 
                 ; System
                 ; runtime of literal
                 ;VE_DOLITERAL:
                 ;    .dw $ff09
                 ;    .db "(literal)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOLITERAL
                 XT_DOLITERAL:
0004c6 04c7          .dw PFA_DOLITERAL
                 PFA_DOLITERAL:
0004c7 939a
0004c8 938a          savetos
0004c9 01fd          movw zl, xl
0004ca 2755
0004cb 0fee
0004cc 1fff
0004cd 1f55
0004ce bf5b
0004cf 9187
0004d0 9197          readflashcell tosl,tosh
0004d1 9611          adiw xl, 1
0004d2 cc39          jmp_ DO_NEXT
                 
                 .include "words/dovariable.asm"
                 
                 ; System
                 ; puts content of parameter field (1 cell) to TOS
                 ;VE_DOVARIABLE:
                 ;    .dw $ff0a
                 ;    .db "(variable)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOVARIABLE
                 XT_DOVARIABLE:
0004d3 04d4          .dw PFA_DOVARIABLE
                 PFA_DOVARIABLE:
0004d4 939a
0004d5 938a          savetos
0004d6 01fb          movw zl, wl
0004d7 9631          adiw zl,1
0004d8 2755
0004d9 0fee
0004da 1fff
0004db 1f55
0004dc bf5b
0004dd 9187
0004de 9197          readflashcell tosl,tosh
0004df cc2c          jmp_ DO_NEXT
                 .include "words/doconstant.asm"
                 
                 ; System
                 ; place data field address on TOS
                 ;VE_DOCONSTANT:
                 ;    .dw $ff0a
                 ;    .db "(constant)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOCONSTANT
                 XT_DOCONSTANT:
0004e0 04e1          .dw PFA_DOCONSTANT
                 PFA_DOCONSTANT:
0004e1 939a
0004e2 938a          savetos
0004e3 01cb          movw tosl, wl
0004e4 9601          adiw tosl, 1
0004e5 cc26          jmp_ DO_NEXT
                 .include "words/douser.asm"
                 
                 ; System
                 ; runtime part of user
                 ;VE_DOUSER:
                 ;    .dw $ff06
                 ;    .db "(user)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOUSER
                 XT_DOUSER:
0004e6 04e7          .dw PFA_DOUSER
                 PFA_DOUSER:
0004e7 939a
0004e8 938a          savetos
0004e9 01fb          movw zl, wl
0004ea 9631          adiw zl, 1
0004eb 2755
0004ec 0fee
0004ed 1fff
0004ee 1f55
0004ef bf5b
0004f0 9187
0004f1 9197          readflashcell tosl,tosh
0004f2 0d84          add tosl, upl
0004f3 1d95          adc tosh, uph
0004f4 cc17          jmp_ DO_NEXT
                 .include "words/do-value.asm"
                 
                 ; System
                 ; runtime of value
                 VE_DOVALUE:
0004f5 ff07          .dw $ff07
0004f6 7628
0004f7 6c61
0004f8 6575
0004f9 0029          .db "(value)", 0
0004fa 04aa          .dw VE_HEAD
                     .set VE_HEAD = VE_DOVALUE
                 XT_DOVALUE:
0004fb 0108          .dw DO_COLON
                 PFA_DOVALUE:
0004fc 01a1          .dw XT_DOCREATE
0004fd 0305          .dw XT_REVEAL
0004fe 01c7          .dw XT_COMPILE
0004ff 0501          .dw PFA_DOVALUE1
000500 04a6          .dw XT_EXIT
                 PFA_DOVALUE1:
000501 de27          call_ DO_DODOES
000502 0542          .dw XT_DUP
000503 1002          .dw XT_ICELLPLUS
000504 0818          .dw XT_FETCHI
000505 04b0          .dw XT_EXECUTE
000506 04a6          .dw XT_EXIT
                 
                 ; : (value) <builds does> dup icell+ @i execute ;
                 .include "words/fetch.asm"
                 
                 ; Memory
                 ; read 1 cell from RAM address
                 VE_FETCH:
000507 ff01          .dw $ff01
000508 0040          .db "@",0
000509 04f5          .dw VE_HEAD
                     .set VE_HEAD = VE_FETCH
                 XT_FETCH:
00050a 050b          .dw PFA_FETCH
                 PFA_FETCH:
                 .if WANT_UNIFIED == 1
                 .endif
                 PFA_FETCHRAM:
00050b 01fc          movw zl, tosl
                     ; low byte is read before the high byte
00050c 9181          ld tosl, z+
00050d 9191          ld tosh, z+
00050e cbfd          jmp_ DO_NEXT
                 .if WANT_UNIFIED == 1
                 .endif
                 .include "words/store.asm"
                 
                 ; Memory
                 ; write n to RAM memory at addr, low byte first
                 VE_STORE:
00050f ff01          .dw $ff01
000510 0021          .db "!",0
000511 0507          .dw VE_HEAD
                     .set VE_HEAD = VE_STORE
                 XT_STORE:
000512 0513          .dw PFA_STORE
                 PFA_STORE:
                 .if WANT_UNIFIED == 1
                 .endif
                 PFA_STORERAM:
000513 01fc          movw zl, tosl
000514 9189
000515 9199          loadtos
                     ; the high byte is written before the low byte
000516 8391          std Z+1, tosh
000517 8380          std Z+0, tosl
000518 9189
000519 9199          loadtos
00051a cbf1          jmp_ DO_NEXT
                 .if WANT_UNIFIED == 1
                 .endif
                 .include "words/cstore.asm"
                 
                 ; Memory
                 ; store a single byte to RAM address
                 VE_CSTORE:
00051b ff02          .dw $ff02
00051c 2163          .db "c!"
00051d 050f          .dw VE_HEAD
                     .set VE_HEAD = VE_CSTORE
                 XT_CSTORE:
00051e 051f          .dw PFA_CSTORE
                 PFA_CSTORE:
00051f 01fc          movw zl, tosl
000520 9189
000521 9199          loadtos
000522 8380          st Z, tosl
000523 9189
000524 9199          loadtos
000525 cbe6          jmp_ DO_NEXT
                 .include "words/cfetch.asm"
                 
                 ; Memory
                 ; fetch a single byte from memory mapped locations
                 VE_CFETCH:
000526 ff02          .dw $ff02
000527 4063          .db "c@"
000528 051b          .dw VE_HEAD
                     .set VE_HEAD  = VE_CFETCH
                 XT_CFETCH:
000529 052a          .dw PFA_CFETCH
                 PFA_CFETCH:
00052a 01fc          movw zl, tosl
00052b 2799          clr tosh
00052c 8180          ld tosl, Z
00052d cbde          jmp_ DO_NEXT
                 .include "words/fetch-u.asm"
                 
                 ; Memory
                 ; read 1 cell from USER area
                 VE_FETCHU:
00052e ff02          .dw $ff02
00052f 7540          .db "@u"
000530 0526          .dw VE_HEAD
                     .set VE_HEAD = VE_FETCHU
                 XT_FETCHU:
000531 0108          .dw DO_COLON
                 PFA_FETCHU:
000532 0787          .dw XT_UP_FETCH
000533 062e          .dw XT_PLUS
000534 050a          .dw XT_FETCH
000535 04a6          .dw XT_EXIT
                 .include "words/store-u.asm"
                 
                 ; Memory
                 ; write n to USER area at offset
                 VE_STOREU:
000536 ff02          .dw $ff02
000537 7521          .db "!u"
000538 052e          .dw VE_HEAD
                     .set VE_HEAD = VE_STOREU
                 XT_STOREU:
000539 0108          .dw DO_COLON
                 PFA_STOREU:
00053a 0787          .dw XT_UP_FETCH
00053b 062e          .dw XT_PLUS
00053c 0512          .dw XT_STORE
00053d 04a6          .dw XT_EXIT
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/dup.asm"
                 
                 ; Stack
                 ; duplicate TOS
                 VE_DUP:
00053e ff03          .dw $ff03
00053f 7564
000540 0070          .db "dup",0
000541 0536          .dw VE_HEAD
                     .set VE_HEAD = VE_DUP
                 XT_DUP:
000542 0543          .dw PFA_DUP
                 PFA_DUP:
000543 939a
000544 938a          savetos
000545 cbc6          jmp_ DO_NEXT
                 .include "words/qdup.asm"
                 
                 ; Stack
                 ; duplicate TOS if non-zero
                 VE_QDUP:
000546 ff04          .dw $ff04
000547 643f
000548 7075          .db "?dup"
000549 053e          .dw VE_HEAD
                     .set VE_HEAD = VE_QDUP
                 XT_QDUP:
00054a 054b          .dw PFA_QDUP
                 PFA_QDUP:
00054b 2f08          mov temp0, tosl
00054c 2b09          or temp0, tosh
00054d f011          breq PFA_QDUP1
00054e 939a
00054f 938a          savetos
                 PFA_QDUP1:
000550 cbbb          jmp_ DO_NEXT
                 .include "words/swap.asm"
                 
                 ; Stack
                 ; swaps the two top level stack cells
                 VE_SWAP:
000551 ff04          .dw $ff04
000552 7773
000553 7061          .db "swap"
000554 0546          .dw VE_HEAD
                     .set VE_HEAD = VE_SWAP
                 XT_SWAP:
000555 0556          .dw PFA_SWAP
                 PFA_SWAP:
000556 018c          movw temp0, tosl
000557 9189
000558 9199          loadtos
000559 931a          st -Y, temp1
00055a 930a          st -Y, temp0
00055b cbb0          jmp_ DO_NEXT
                 .include "words/over.asm"
                 
                 ; Stack
                 ; Place a copy of x1 on top of the stack
                 VE_OVER:
00055c ff04          .dw $ff04
00055d 766f
00055e 7265          .db "over"
00055f 0551          .dw VE_HEAD
                     .set VE_HEAD = VE_OVER
                 XT_OVER:
000560 0561          .dw PFA_OVER
                 PFA_OVER:
000561 939a
000562 938a          savetos
000563 818a          ldd tosl, Y+2
000564 819b          ldd tosh, Y+3
                 
000565 cba6          jmp_ DO_NEXT
                 .include "words/drop.asm"
                 
                 ; Stack
                 ; drop TOS
                 VE_DROP:
000566 ff04          .dw $ff04
000567 7264
000568 706f          .db "drop"
000569 055c          .dw VE_HEAD
                     .set VE_HEAD = VE_DROP
                 XT_DROP:
00056a 056b          .dw PFA_DROP
                 PFA_DROP:
00056b 9189
00056c 9199          loadtos
00056d cb9e          jmp_ DO_NEXT
                 .include "words/rot.asm"
                 
                 ; Stack
                 ; rotate the three top level cells
                 VE_ROT:
00056e ff03          .dw $ff03
00056f 6f72
000570 0074          .db "rot",0
000571 0566          .dw VE_HEAD
                     .set VE_HEAD = VE_ROT
                 XT_ROT:
000572 0573          .dw PFA_ROT
                 PFA_ROT:
000573 018c          movw temp0, tosl
000574 9129          ld temp2, Y+
000575 9139          ld temp3, Y+ 
000576 9189
000577 9199          loadtos
                         
000578 933a          st -Y, temp3
000579 932a          st -Y, temp2
00057a 931a          st -Y, temp1
00057b 930a          st -Y, temp0
                 
00057c cb8f          jmp_ DO_NEXT
                 .include "words/nip.asm"
                 
                 ; Stack
                 ; Remove Second of Stack
                 VE_NIP:
00057d ff03          .dw $ff03
00057e 696e
00057f 0070          .db "nip",0
000580 056e          .dw VE_HEAD
                     .set VE_HEAD = VE_NIP
                 XT_NIP:
000581 0582          .dw PFA_NIP
                 PFA_NIP:
000582 9622          adiw yl, 2
000583 cb88          jmp_ DO_NEXT
                 ;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/r_from.asm"
                 
                 ; Stack
                 ; move TOR to TOS
                 VE_R_FROM:
000584 ff02          .dw $ff02
000585 3e72          .db "r>"
000586 057d          .dw VE_HEAD
                     .set VE_HEAD = VE_R_FROM
                 XT_R_FROM:
000587 0588          .dw PFA_R_FROM
                 PFA_R_FROM:
000588 939a
000589 938a          savetos
00058a 918f          pop tosl
00058b 919f          pop tosh
00058c cb7f          jmp_ DO_NEXT
                 .include "words/to_r.asm"
                 
                 ; Stack
                 ; move TOS to TOR
                 VE_TO_R:
00058d ff02          .dw $ff02
00058e 723e          .db ">r"
00058f 0584          .dw VE_HEAD
                     .set VE_HEAD = VE_TO_R
                 XT_TO_R:
000590 0591          .dw PFA_TO_R
                 PFA_TO_R:
000591 939f          push tosh
000592 938f          push tosl
000593 9189
000594 9199          loadtos
000595 cb76          jmp_ DO_NEXT
                 .include "words/r_fetch.asm"
                 
                 ; Stack
                 ; fetch content of TOR
                 VE_R_FETCH:
000596 ff02          .dw $ff02
000597 4072          .db "r@"
000598 058d          .dw VE_HEAD
                     .set VE_HEAD = VE_R_FETCH
                 XT_R_FETCH:
000599 059a          .dw PFA_R_FETCH
                 PFA_R_FETCH:
00059a 939a
00059b 938a          savetos
00059c 918f          pop tosl
00059d 919f          pop tosh
00059e 939f          push tosh
00059f 938f          push tosl
0005a0 cb6b          jmp_ DO_NEXT
                 
                 
                 .include "words/not-equal.asm"
                 
                 ; Compare
                 ; true if n1 is not equal to n2
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_NOTEQUAL:
0005a1 ff02          .dw $ff02
0005a2 3e3c          .db "<>"
0005a3 0596          .dw VE_HEAD
                     .set VE_HEAD = VE_NOTEQUAL
                 XT_NOTEQUAL:
0005a4 0108          .dw DO_COLON
                 PFA_NOTEQUAL:
                 .endif
                 
0005a5 1264
0005a6 05ab
0005a7 04a6          .DW XT_EQUAL,XT_ZEROEQUAL,XT_EXIT
                 .include "words/equalzero.asm"
                 
                 ; Compare
                 ; compare with 0 (zero)
                 VE_ZEROEQUAL:
0005a8 ff02          .dw $ff02
0005a9 3d30          .db "0="
0005aa 05a1          .dw VE_HEAD
                     .set VE_HEAD = VE_ZEROEQUAL
                 XT_ZEROEQUAL:
0005ab 05ac          .dw PFA_ZEROEQUAL
                 PFA_ZEROEQUAL:
0005ac 2b98          or tosh, tosl
0005ad f5d1          brne PFA_ZERO1
0005ae c030          rjmp PFA_TRUE1
                 .include "words/lesszero.asm"
                 
                 ; Compare
                 ; compare with zero
                 VE_ZEROLESS:
0005af ff02          .dw $ff02
0005b0 3c30          .db "0<"
0005b1 05a8          .dw VE_HEAD
                     .set VE_HEAD = VE_ZEROLESS
                 XT_ZEROLESS:
0005b2 05b3          .dw PFA_ZEROLESS
                 PFA_ZEROLESS:
0005b3 fd97          sbrc tosh,7
0005b4 c02a          rjmp PFA_TRUE1
0005b5 c032          rjmp PFA_ZERO1
                 .include "words/greaterzero.asm"
                 
                 ; Compare
                 ; true if n1 is greater than 0
                 VE_GREATERZERO:
0005b6 ff02          .dw $ff02
0005b7 3e30          .db "0>"
0005b8 05af          .dw VE_HEAD
                     .set VE_HEAD = VE_GREATERZERO
                 XT_GREATERZERO:
0005b9 05ba          .dw PFA_GREATERZERO
                 PFA_GREATERZERO:
0005ba 1582          cp tosl, zerol
0005bb 0593          cpc tosh, zeroh
0005bc f15c          brlt PFA_ZERO1
0005bd f151          brbs 1, PFA_ZERO1
0005be c020          rjmp PFA_TRUE1
                 .include "words/d-greaterzero.asm"
                 
                 ; Compare
                 ; compares if a double double cell number is greater 0
                 VE_DGREATERZERO:
0005bf ff03          .dw $ff03
0005c0 3064
0005c1 003e          .db "d0>",0
0005c2 05b6          .dw VE_HEAD
                     .set VE_HEAD = VE_DGREATERZERO
                 XT_DGREATERZERO:
0005c3 05c4          .dw PFA_DGREATERZERO
                 PFA_DGREATERZERO:
0005c4 1582          cp tosl, zerol
0005c5 0593          cpc tosh, zeroh
0005c6 9189
0005c7 9199          loadtos
0005c8 0582          cpc tosl, zerol
0005c9 0593          cpc tosh, zeroh
0005ca f0ec          brlt PFA_ZERO1
0005cb f0e1          brbs 1, PFA_ZERO1
0005cc c012          rjmp PFA_TRUE1
                 .include "words/d-lesszero.asm"
                 
                 ; Compare
                 ; compares if a double double cell number is less than 0
                 VE_DXT_ZEROLESS:
0005cd ff03          .dw $ff03
0005ce 3064
0005cf 003c          .db "d0<",0
0005d0 05bf          .dw VE_HEAD
                     .set VE_HEAD = VE_DXT_ZEROLESS
                 XT_DXT_ZEROLESS:
0005d1 05d2          .dw PFA_DXT_ZEROLESS
                 PFA_DXT_ZEROLESS:
0005d2 9622          adiw Y,2
0005d3 fd97          sbrc tosh,7
0005d4 940c 05df     jmp PFA_TRUE1
0005d6 940c 05e8     jmp PFA_ZERO1
                 
                 .include "words/true.asm"
                 
                 ; Arithmetics
                 ; leaves the value -1 (true) on TOS
                 VE_TRUE:
0005d8 ff04          .dw $ff04
0005d9 7274
0005da 6575          .db "true"
0005db 05cd          .dw VE_HEAD
                     .set VE_HEAD = VE_TRUE
                 XT_TRUE:
0005dc 05dd          .dw PFA_TRUE
                 PFA_TRUE:
0005dd 939a
0005de 938a          savetos
                 PFA_TRUE1:
0005df ef8f          ser tosl
0005e0 ef9f          ser tosh
0005e1 cb2a          jmp_ DO_NEXT
                 .include "words/zero.asm"
                 
                 ; Arithmetics
                 ; place a value 0 on TOS
                 VE_ZERO:
0005e2 ff01          .dw $ff01
0005e3 0030          .db "0",0
0005e4 05d8          .dw VE_HEAD
                     .set VE_HEAD = VE_ZERO
                 XT_ZERO:
0005e5 05e6          .dw PFA_ZERO
                 PFA_ZERO:
0005e6 939a
0005e7 938a          savetos
                 PFA_ZERO1:
0005e8 01c1          movw tosl, zerol
0005e9 cb22          jmp_ DO_NEXT
                 .include "words/uless.asm"
                 
                 ; Compare
                 ; true if u1 < u2 (unsigned)
                 VE_ULESS:
0005ea ff02          .dw $ff02
0005eb 3c75          .db "u<"
0005ec 05e2          .dw VE_HEAD
                     .set VE_HEAD = VE_ULESS
                 XT_ULESS:
0005ed 05ee          .dw PFA_ULESS
                 PFA_ULESS:
0005ee 9129          ld temp2, Y+
0005ef 9139          ld temp3, Y+
0005f0 1782          cp tosl, temp2
0005f1 0793          cpc tosh, temp3
0005f2 f3a8          brlo PFA_ZERO1
0005f3 f3a1          brbs 1, PFA_ZERO1
0005f4 cfea          jmp_ PFA_TRUE1
                 .include "words/u-greater.asm"
                 
                 ; Compare
                 ; true if u1 > u2 (unsigned)
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_UGREATER:
0005f5 ff02          .dw $ff02
0005f6 3e75          .db "u>"
0005f7 05ea          .dw VE_HEAD
                     .set VE_HEAD = VE_UGREATER
                 XT_UGREATER:
0005f8 0108          .dw DO_COLON
                 PFA_UGREATER:
                 .endif
0005f9 0555          .DW XT_SWAP
0005fa 05ed          .dw XT_ULESS
0005fb 04a6          .dw XT_EXIT
                 .include "words/less.asm"
                 
                 ; Compare
                 ; true if n1 is less than n2
                     VE_LESS:
0005fc ff01          .dw $ff01
0005fd 003c          .db "<",0
0005fe 05f5          .dw VE_HEAD
                     .set VE_HEAD = VE_LESS
                 XT_LESS:
0005ff 0600          .dw PFA_LESS
                 PFA_LESS:
000600 9129          ld temp2, Y+
000601 9139          ld temp3, Y+
000602 1728          cp temp2, tosl
000603 0739          cpc temp3, tosh
                 PFA_LESSDONE:
000604 f71c          brge PFA_ZERO1
000605 cfd9          rjmp PFA_TRUE1
                 .include "words/greater.asm"
                 
                 ; Compare
                 ; flag is true if n1 is greater than n2
                 VE_GREATER:
000606 ff01          .dw $ff01
000607 003e          .db ">",0
000608 05fc          .dw VE_HEAD
                     .set VE_HEAD = VE_GREATER
                 XT_GREATER:
000609 060a          .dw PFA_GREATER
                 PFA_GREATER:
00060a 9129          ld temp2, Y+
00060b 9139          ld temp3, Y+
00060c 1728          cp temp2, tosl
00060d 0739          cpc temp3, tosh
                 PFA_GREATERDONE:
00060e f2cc          brlt PFA_ZERO1
00060f f2c1          brbs 1, PFA_ZERO1
000610 cfce          rjmp PFA_TRUE1
                 
                 .include "words/log2.asm"
                 
                 ; Arithmetics
                 ; logarithm to base 2 or highest set bitnumber
                 VE_LOG2:
000611 ff04          .dw $ff04
000612 6f6c
000613 3267          .db "log2"
000614 0606          .dw VE_HEAD
                     .set VE_HEAD = VE_LOG2
                 XT_LOG2:
000615 0616          .dw PFA_LOG2
                 PFA_LOG2:
000616 01fc          movw zl, tosl
000617 2799          clr tosh
000618 e180          ldi tosl, 16
                 PFA_LOG2_1:
000619 958a          dec tosl
00061a f022          brmi PFA_LOG2_2 ; wrong data
00061b 0fee          lsl  zl
00061c 1fff          rol  zh
00061d f7d8          brcc PFA_LOG2_1
00061e caed          jmp_ DO_NEXT
                 
                 PFA_LOG2_2:
00061f 959a          dec tosh
000620 caeb          jmp_ DO_NEXT
                 .include "words/minus.asm"
                 
                 ; Arithmetics
                 ; subtract n2 from n1
                 VE_MINUS:
000621 ff01          .dw $ff01
000622 002d          .db "-",0
000623 0611          .dw VE_HEAD
                     .set VE_HEAD = VE_MINUS
                 XT_MINUS:
000624 0625          .dw PFA_MINUS
                 PFA_MINUS:
000625 9109          ld temp0, Y+
000626 9119          ld temp1, Y+
000627 1b08          sub temp0, tosl
000628 0b19          sbc temp1, tosh
000629 01c8          movw tosl, temp0
00062a cae1          jmp_ DO_NEXT
                 .include "words/plus.asm"
                 
                 ; Arithmetics
                 ; add n1 and n2
                 VE_PLUS:
00062b ff01          .dw $ff01
00062c 002b          .db "+",0
00062d 0621          .dw VE_HEAD
                     .set VE_HEAD = VE_PLUS
                 XT_PLUS:
00062e 062f          .dw PFA_PLUS
                 PFA_PLUS:
00062f 9109          ld temp0, Y+
000630 9119          ld temp1, Y+
000631 0f80          add tosl, temp0
000632 1f91          adc tosh, temp1
000633 cad8          jmp_ DO_NEXT
                 .include "words/mstar.asm"
                 
                 ; Arithmetics
                 ; multiply 2 cells to a double cell
                 VE_MSTAR:
000634 ff02          .dw $ff02
000635 2a6d          .db "m*"
000636 062b          .dw VE_HEAD
                     .set VE_HEAD = VE_MSTAR
                 XT_MSTAR:
000637 0638          .dw PFA_MSTAR
                 PFA_MSTAR:
000638 018c          movw temp0, tosl
000639 9189
00063a 9199          loadtos
00063b 019c          movw temp2, tosl
                     ; high cell ah*bh
00063c 0231          muls temp3, temp1
00063d 0170          movw temp4, r0
                     ; low cell  al*bl
00063e 9f20          mul  temp2, temp0
00063f 01c0          movw tosl, r0
                     ; signed ah*bl
000640 0330          mulsu temp3, temp0
000641 08f3          sbc   temp5, zeroh
000642 0d90          add   tosh,  r0
000643 1ce1          adc   temp4, r1
000644 1cf3          adc   temp5, zeroh
                     
                     ; signed al*bh
000645 0312          mulsu temp1, temp2
000646 08f3          sbc   temp5, zeroh
000647 0d90          add   tosh,  r0
000648 1ce1          adc   temp4, r1
000649 1cf3          adc   temp5, zeroh
                 
00064a 939a
00064b 938a          savetos
00064c 01c7          movw tosl, temp4
00064d cabe          jmp_ DO_NEXT
                 .include "words/umslashmod.asm"
                 
                 ; Arithmetics
                 ; unsigned division ud / u2 with remainder
                 VE_UMSLASHMOD:
00064e ff06          .dw $ff06
00064f 6d75
000650 6d2f
000651 646f          .db "um/mod"
000652 0634          .dw VE_HEAD
                     .set VE_HEAD = VE_UMSLASHMOD
                 XT_UMSLASHMOD:
000653 0654          .dw PFA_UMSLASHMOD
                 PFA_UMSLASHMOD:
000654 017c          movw temp4, tosl
                 
000655 9129          ld temp2, Y+
000656 9139          ld temp3, Y+
                   
000657 9109          ld temp0, Y+
000658 9119          ld temp1, Y+
                 
                 ;; unsigned 32/16 -> 16r16 divide
                 
                 PFA_UMSLASHMODmod:
                 
                   ; set loop counter
000659 e140          ldi temp6,$10
                 
                 PFA_UMSLASHMODmod_loop:
                     ; shift left, saving high bit
00065a 2755          clr temp7
00065b 0f00          lsl temp0
00065c 1f11          rol temp1
00065d 1f22          rol temp2
00065e 1f33          rol temp3
00065f 1f55          rol temp7
                 
                   ; try subtracting divisor
000660 152e          cp temp2, temp4
000661 053f          cpc temp3, temp5
000662 0552          cpc temp7,zerol
                 
000663 f018          brcs PFA_UMSLASHMODmod_loop_control
                 
                 PFA_UMSLASHMODmod_subtract:
                     ; dividend is large enough
                     ; do the subtraction for real
                     ; and set lowest bit
000664 9503          inc temp0
000665 192e          sub temp2, temp4
000666 093f          sbc temp3, temp5
                 
                 PFA_UMSLASHMODmod_loop_control:
000667 954a          dec  temp6
000668 f789          brne PFA_UMSLASHMODmod_loop
                 
                 PFA_UMSLASHMODmod_done:
                     ; put remainder on stack
000669 933a          st -Y,temp3
00066a 932a          st -Y,temp2
                 
                     ; put quotient on stack
00066b 01c8          movw tosl, temp0
00066c ca9f          jmp_ DO_NEXT
                 .include "words/umstar.asm"
                 
                 ; Arithmetics
                 ; multiply 2 unsigned cells to a double cell
                 VE_UMSTAR:
00066d ff03          .dw $ff03
00066e 6d75
00066f 002a          .db "um*",0
000670 064e          .dw VE_HEAD
                     .set VE_HEAD = VE_UMSTAR
                 XT_UMSTAR:
000671 0672          .dw PFA_UMSTAR
                 PFA_UMSTAR:
000672 018c          movw temp0, tosl
000673 9189
000674 9199          loadtos
                     ; result: (temp3*temp1)* 65536 + (temp3*temp0 + temp1*temp2) * 256 + (temp0 * temp2)
                     ; low bytes
000675 9f80          mul tosl,temp0
000676 01f0          movw zl, r0
000677 2722          clr temp2
000678 2733          clr temp3
                     ; middle bytes
000679 9f90          mul tosh, temp0
00067a 0df0          add zh, r0
00067b 1d21          adc temp2, r1
00067c 1d33          adc temp3, zeroh
                         
00067d 9f81          mul tosl, temp1
00067e 0df0          add zh, r0
00067f 1d21          adc temp2, r1
000680 1d33          adc temp3, zeroh
                     
000681 9f91          mul tosh, temp1
000682 0d20          add temp2, r0
000683 1d31          adc temp3, r1
000684 01cf          movw tosl, zl
000685 939a
000686 938a          savetos
000687 01c9          movw tosl, temp2
000688 ca83          jmp_ DO_NEXT
                 
                 .include "words/invert.asm"
                 
                 ; Arithmetics
                 ; 1-complement of TOS
                 VE_INVERT:
000689 ff06          .dw $ff06
00068a 6e69
00068b 6576
00068c 7472          .db "invert"
00068d 066d          .dw VE_HEAD
                     .set VE_HEAD = VE_INVERT
                 XT_INVERT:
00068e 068f          .dw PFA_INVERT
                 PFA_INVERT:
00068f 9580          com tosl
000690 9590          com tosh
000691 ca7a          jmp_ DO_NEXT
                 .include "words/2slash.asm"
                 
                 ; Arithmetics
                 ; arithmetic shift right
                 VE_2SLASH:
000692 ff02          .dw $ff02
000693 2f32          .db "2/"
000694 0689          .dw VE_HEAD
                     .set VE_HEAD = VE_2SLASH
                 XT_2SLASH:
000695 0696          .dw PFA_2SLASH
                 PFA_2SLASH:
000696 9595          asr tosh
000697 9587          ror tosl
000698 ca73          jmp_ DO_NEXT
                 .include "words/2star.asm"
                 
                 ; Arithmetics
                 ; arithmetic shift left, filling with zero
                 VE_2STAR:
000699 ff02          .dw $ff02
00069a 2a32          .db "2*"
00069b 0692          .dw VE_HEAD
                     .set VE_HEAD = VE_2STAR
                 XT_2STAR:
00069c 069d          .dw PFA_2STAR
                 PFA_2STAR:
00069d 0f88          lsl tosl
00069e 1f99          rol tosh
00069f ca6c          jmp_ DO_NEXT
                 .include "words/and.asm"
                 
                 ; Logic
                 ; bitwise and
                 VE_AND:
0006a0 ff03          .dw $ff03
0006a1 6e61
0006a2 0064          .db "and",0
0006a3 0699          .dw VE_HEAD
                     .set VE_HEAD = VE_AND
                 XT_AND:
0006a4 06a5          .dw PFA_AND
                 PFA_AND:
0006a5 9109          ld temp0, Y+
0006a6 9119          ld temp1, Y+
0006a7 2380          and tosl, temp0
0006a8 2391          and tosh, temp1
0006a9 ca62          jmp_ DO_NEXT
                 .include "words/or.asm"
                 
                 ; Logic
                 ; logical or
                 VE_OR:
0006aa ff02          .dw $ff02
0006ab 726f          .db "or"
0006ac 06a0          .dw VE_HEAD
                     .set VE_HEAD = VE_OR
                 XT_OR:
0006ad 06ae          .dw PFA_OR
                 PFA_OR:
0006ae 9109          ld temp0, Y+
0006af 9119          ld temp1, Y+
0006b0 2b80          or tosl, temp0
0006b1 2b91          or tosh, temp1
0006b2 ca59          jmp_ DO_NEXT
                 
                 .include "words/xor.asm"
                 
                 ; Logic
                 ; exclusive or
                 VE_XOR:
0006b3 ff03          .dw $ff03
0006b4 6f78
0006b5 0072          .db "xor",0
0006b6 06aa          .dw VE_HEAD
                     .set VE_HEAD = VE_XOR
                 XT_XOR:
0006b7 06b8          .dw PFA_XOR
                 PFA_XOR:
0006b8 9109          ld temp0, Y+
0006b9 9119          ld temp1, Y+
0006ba 2780          eor tosl, temp0
0006bb 2791          eor tosh, temp1
0006bc ca4f          jmp_ DO_NEXT
                 
                 .include "words/1plus.asm"
                 
                 ; Arithmetics
                 ; optimized increment
                 VE_1PLUS:
0006bd ff02          .dw $ff02
0006be 2b31          .db "1+"
0006bf 06b3          .dw VE_HEAD
                     .set VE_HEAD = VE_1PLUS
                 XT_1PLUS:
0006c0 06c1          .dw PFA_1PLUS
                 PFA_1PLUS:
0006c1 9601          adiw tosl,1
0006c2 ca49          jmp_ DO_NEXT
                 .include "words/1minus.asm"
                 
                 ; Arithmetics
                 ; optimized decrement
                 VE_1MINUS:
0006c3 ff02          .dw $ff02 
0006c4 2d31          .db "1-"
0006c5 06bd          .dw VE_HEAD
                     .set VE_HEAD = VE_1MINUS
                 XT_1MINUS:
0006c6 06c7          .dw PFA_1MINUS
                 PFA_1MINUS:
0006c7 9701          sbiw tosl, 1
0006c8 ca43          jmp_ DO_NEXT
                 .include "words/lshift.asm"
                 
                 ; Arithmetics
                 ; logically shift n1 left n2 times
                 VE_LSHIFT:
0006c9 ff06          .dw $ff06
0006ca 736c
0006cb 6968
0006cc 7466          .db "lshift"
0006cd 06c3          .dw VE_HEAD
                     .set VE_HEAD = VE_LSHIFT
                 XT_LSHIFT:
0006ce 06cf          .dw PFA_LSHIFT
                 PFA_LSHIFT:
0006cf 01fc          movw zl, tosl
0006d0 9189
0006d1 9199          loadtos
                 PFA_LSHIFT1:
0006d2 9731          sbiw zl, 1
0006d3 f01a          brmi PFA_LSHIFT2
0006d4 0f88          lsl tosl
0006d5 1f99          rol tosh
0006d6 cffb          rjmp PFA_LSHIFT1
                 PFA_LSHIFT2:
0006d7 ca34          jmp_ DO_NEXT
                 
                 .include "words/rshift.asm"
                 
                 ; Arithmetics
                 ; shift n1 n2-times logically right
                 VE_RSHIFT:
0006d8 ff06          .dw $ff06
0006d9 7372
0006da 6968
0006db 7466          .db "rshift"
0006dc 06c9          .dw VE_HEAD
                     .set VE_HEAD = VE_RSHIFT
                 XT_RSHIFT:
0006dd 06de          .dw PFA_RSHIFT
                 PFA_RSHIFT:
0006de 01fc          movw zl, tosl
0006df 9189
0006e0 9199          loadtos
                 PFA_RSHIFT1:
0006e1 9731          sbiw zl, 1
0006e2 f01a          brmi PFA_RSHIFT2
0006e3 9596          lsr tosh
0006e4 9587          ror tosl
0006e5 cffb          rjmp PFA_RSHIFT1
                 PFA_RSHIFT2:
0006e6 ca25          jmp_ DO_NEXT
                 
                 .include "words/plusstore.asm"
                 
                 ; Arithmetics
                 ; add n to content of RAM address a-addr
                 VE_PLUSSTORE:
0006e7 ff02          .dw $ff02
0006e8 212b          .db "+!"
0006e9 06d8          .dw VE_HEAD
                     .set VE_HEAD = VE_PLUSSTORE
                 XT_PLUSSTORE:
0006ea 06eb          .dw PFA_PLUSSTORE
                 PFA_PLUSSTORE:
0006eb 01fc          movw zl, tosl
0006ec 9189
0006ed 9199          loadtos
0006ee 8120          ldd temp2, Z+0
0006ef 8131          ldd temp3, Z+1
0006f0 0f82          add tosl, temp2
0006f1 1f93          adc tosh, temp3
0006f2 8380          std Z+0, tosl
0006f3 8391          std Z+1, tosh
0006f4 9189
0006f5 9199          loadtos
0006f6 ca15          jmp_ DO_NEXT
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/rpfetch.asm"
                 
                 ; Stack
                 ; current return stack pointer address
                 VE_RP_FETCH:
0006f7 ff03          .dw $ff03
0006f8 7072
0006f9 0040          .db "rp@",0
0006fa 06e7          .dw VE_HEAD
                     .set VE_HEAD = VE_RP_FETCH
                 XT_RP_FETCH:
0006fb 06fc          .dw PFA_RP_FETCH
                 PFA_RP_FETCH:
0006fc 939a
0006fd 938a          savetos
0006fe b78d          in tosl, SPL
0006ff b79e          in tosh, SPH
000700 ca0b          jmp_ DO_NEXT
                 .include "words/rpstore.asm"
                 
                 ; Stack
                 ; set return stack pointer
                 VE_RP_STORE:
000701 ff03          .dw $ff03
000702 7072
000703 0021          .db "rp!",0
000704 06f7          .dw VE_HEAD
                     .set VE_HEAD = VE_RP_STORE
                 XT_RP_STORE:
000705 0706          .dw PFA_RP_STORE
                 PFA_RP_STORE:
000706 b72f          in temp2, SREG
000707 94f8          cli
000708 bf8d          out SPL, tosl
000709 bf9e          out SPH, tosh
00070a bf2f          out SREG, temp2
00070b 9189
00070c 9199          loadtos
00070d c9fe          jmp_ DO_NEXT
                 .include "words/spfetch.asm"
                 
                 ; Stack
                 ; current data stack pointer
                 VE_SP_FETCH:
00070e ff03          .dw $ff03
00070f 7073
000710 0040          .db "sp@",0
000711 0701          .dw VE_HEAD
                     .set VE_HEAD = VE_SP_FETCH
                 XT_SP_FETCH:
000712 0713          .dw PFA_SP_FETCH
                 PFA_SP_FETCH:
000713 939a
000714 938a          savetos
000715 01ce          movw tosl, yl
000716 c9f5          jmp_ DO_NEXT
                 .include "words/spstore.asm"
                 
                 ; Stack
                 ; set data stack pointer to addr
                 VE_SP_STORE:
000717 ff03          .dw $ff03
000718 7073
000719 0021          .db "sp!",0
00071a 070e          .dw VE_HEAD
                     .set VE_HEAD = VE_SP_STORE
                 XT_SP_STORE:
00071b 071c          .dw PFA_SP_STORE
                 PFA_SP_STORE:
00071c 01ec          movw yl, tosl
00071d 9189
00071e 9199          loadtos
00071f c9ec          jmp_ DO_NEXT
                 
                 .include "words/dodo.asm"
                 
                 ; System
                 ; runtime of do
                 ;VE_DODO:
                 ;    .dw $ff04
                 ;    .db "(do)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DODO
                 XT_DODO:
000720 0721          .dw PFA_DODO
                 PFA_DODO:
000721 9129          ld temp2, Y+
000722 9139          ld temp3, Y+  ; limit
                 PFA_DODO1:
000723 e8e0          ldi zl, $80
000724 0f3e          add temp3, zl
000725 1b82          sub  tosl, temp2
000726 0b93          sbc  tosh, temp3
                 
000727 933f          push temp3
000728 932f          push temp2    ; limit  ( --> limit + $8000)
000729 939f          push tosh
00072a 938f          push tosl     ; start -> index ( --> index - (limit - $8000)
00072b 9189
00072c 9199          loadtos
00072d c9de          jmp_ DO_NEXT
                 .include "words/i.asm"
                 
                 ; Compiler
                 ; current loop counter
                 VE_I:
00072e ff01          .dw $FF01
00072f 0069          .db "i",0
000730 0717          .dw VE_HEAD
                     .set VE_HEAD = VE_I
                 XT_I:
000731 0732          .dw PFA_I
                 PFA_I:
000732 939a
000733 938a          savetos
000734 918f          pop tosl
000735 919f          pop tosh  ; index
000736 91ef          pop zl
000737 91ff          pop zh    ; limit
000738 93ff          push zh
000739 93ef          push zl
00073a 939f          push tosh
00073b 938f          push tosl
00073c 0f8e          add tosl, zl
00073d 1f9f          adc tosh, zh
00073e c9cd          jmp_ DO_NEXT
                 .include "words/doplusloop.asm"
                 
                 ; System
                 ; runtime of +loop
                 ;VE_DOPLUSLOOP:
                 ;    .dw $ff07
                 ;    .db "(+loop)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOPLUSLOOP
                 XT_DOPLUSLOOP:
00073f 0740          .dw PFA_DOPLUSLOOP
                 PFA_DOPLUSLOOP:
000740 91ef          pop zl
000741 91ff          pop zh
000742 0fe8          add zl, tosl
000743 1ff9          adc zh, tosh
000744 9189
000745 9199          loadtos
000746 f01b          brvs PFA_DOPLUSLOOP_LEAVE
                     ; next cycle
                 PFA_DOPLUSLOOP_NEXT:
                     ; next iteration
000747 93ff          push zh
000748 93ef          push zl
000749 cd6c          rjmp PFA_DOBRANCH ; read next cell from dictionary and jump to its destination
                 PFA_DOPLUSLOOP_LEAVE:
00074a 910f          pop  temp0
00074b 911f          pop  temp1  ; remove limit
00074c 9611          adiw xl, 1  ; skip branch-back address
00074d c9be          jmp_ DO_NEXT
                 .include "words/doloop.asm"
                 
                 ; System
                 ; runtime of loop
                 ;VE_DOLOOP:
                 ;    .dw $ff06
                 ;    .db "(loop)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOLOOP
                 XT_DOLOOP:
00074e 074f          .dw PFA_DOLOOP
                 PFA_DOLOOP:
00074f 91ef          pop zl
000750 91ff          pop zh
000751 9631          adiw zl,1
000752 f3bb          brvs PFA_DOPLUSLOOP_LEAVE
000753 cff3          jmp_ PFA_DOPLUSLOOP_NEXT
                 .include "words/unloop.asm"
                 
                 ; Compiler
                 ; remove loop-sys, exit the loop and continue execution after it
                 VE_UNLOOP:
000754 ff06          .dw $ff06
000755 6e75
000756 6f6c
000757 706f          .db "unloop"
000758 072e          .dw VE_HEAD
                     .set VE_HEAD = VE_UNLOOP
                 XT_UNLOOP:
000759 075a          .dw PFA_UNLOOP
                 PFA_UNLOOP:
00075a 911f          pop temp1
00075b 910f          pop temp0
00075c 911f          pop temp1
00075d 910f          pop temp0
00075e c9ad          jmp_ DO_NEXT
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 
                 .include "words/cmove_g.asm"
                 
                 ; Memory
                 ; copy data in RAM from higher to lower addresses.
                 VE_CMOVE_G:
00075f ff06          .dw $ff06
000760 6d63
000761 766f
000762 3e65          .db "cmove>"
000763 0754          .dw VE_HEAD
                     .set VE_HEAD  = VE_CMOVE_G
                 XT_CMOVE_G:
000764 0765          .dw PFA_CMOVE_G
                 PFA_CMOVE_G:
000765 93bf          push xh
000766 93af          push xl
000767 91e9          ld zl, Y+
000768 91f9          ld zh, Y+ ; addr-to
000769 91a9          ld xl, Y+
00076a 91b9          ld xh, Y+ ; addr-from
00076b 2f09          mov temp0, tosh
00076c 2b08          or temp0, tosl
00076d f041          brbs 1, PFA_CMOVE_G1
00076e 0fe8          add zl, tosl
00076f 1ff9          adc zh, tosh
000770 0fa8          add xl, tosl
000771 1fb9          adc xh, tosh
                 PFA_CMOVE_G2:
000772 911e          ld temp1, -X
000773 9312          st -Z, temp1
000774 9701          sbiw tosl, 1
000775 f7e1          brbc 1, PFA_CMOVE_G2
                 PFA_CMOVE_G1:
000776 91af          pop xl
000777 91bf          pop xh
000778 9189
000779 9199          loadtos
00077a c991          jmp_ DO_NEXT
                 .include "words/byteswap.asm"
                 
                 ; Arithmetics
                 ; exchange the bytes of the TOS
                 VE_BYTESWAP:
00077b ff02          .dw $ff02
00077c 3c3e          .db "><"
00077d 075f          .dw VE_HEAD
                     .set VE_HEAD = VE_BYTESWAP
                 XT_BYTESWAP:
00077e 077f          .dw PFA_BYTESWAP
                 PFA_BYTESWAP:
00077f 2f09          mov temp0, tosh
000780 2f98          mov tosh, tosl
000781 2f80          mov tosl, temp0
000782 c989          jmp_ DO_NEXT
                 .include "words/up.asm"
                 
                 ; System Variable
                 ; get user area pointer
                 VE_UP_FETCH:
000783 ff03          .dw $ff03
000784 7075
000785 0040          .db "up@",0
000786 077b          .dw VE_HEAD
                     .set VE_HEAD = VE_UP_FETCH
                 XT_UP_FETCH:
000787 0788          .dw PFA_UP_FETCH
                 PFA_UP_FETCH:
000788 939a
000789 938a          savetos
00078a 01c2          movw tosl, upl
00078b c980          jmp_ DO_NEXT
                 
                 ; ( addr -- ) 
                 ; System Variable
                 ; set user area pointer
                 VE_UP_STORE:
00078c ff03          .dw $ff03
00078d 7075
00078e 0021          .db "up!",0
00078f 0783          .dw VE_HEAD
                     .set VE_HEAD = VE_UP_STORE
                 XT_UP_STORE:
000790 0791          .dw PFA_UP_STORE
                 PFA_UP_STORE:
000791 012c          movw upl, tosl
000792 9189
000793 9199          loadtos
000794 c977          jmp_ DO_NEXT
                 .include "words/1ms.asm"
                 
                 ; Time
                 ; busy waits (almost) exactly 1 millisecond
                 VE_1MS:
000795 ff03          .dw $ff03
000796 6d31
000797 0073          .db "1ms",0
000798 078c          .dw VE_HEAD
                     .set VE_HEAD = VE_1MS
                 XT_1MS:
000799 079a          .dw PFA_1MS
                 PFA_1MS:
00079a e6e6
00079b e0fe
00079c 9731
00079d f7f1
00079e 0000          delay 1000
00079f c96c          jmp_ DO_NEXT
                 .include "words/2to_r.asm"
                 
                 ; Stack
                 ; move DTOS to TOR
                 VE_2TO_R:
0007a0 ff03          .dw $ff03
0007a1 3e32
0007a2 0072          .db "2>r",0
0007a3 0795          .dw VE_HEAD
                     .set VE_HEAD = VE_2TO_R
                 XT_2TO_R:
0007a4 07a5          .dw PFA_2TO_R
                 PFA_2TO_R:
0007a5 01fc          movw zl, tosl
0007a6 9189
0007a7 9199          loadtos
0007a8 939f          push tosh
0007a9 938f          push tosl
0007aa 93ff          push zh
0007ab 93ef          push zl
0007ac 9189
0007ad 9199          loadtos
0007ae c95d          jmp_ DO_NEXT
                 .include "words/2r_from.asm"
                 
                 ; Stack
                 ; move DTOR to TOS
                 VE_2R_FROM:
0007af ff03          .dw $ff03
0007b0 7232
0007b1 003e          .db "2r>",0
0007b2 07a0          .dw VE_HEAD
                     .set VE_HEAD = VE_2R_FROM
                 XT_2R_FROM:
0007b3 07b4          .dw PFA_2R_FROM
                 PFA_2R_FROM:
0007b4 939a
0007b5 938a          savetos
0007b6 91ef          pop zl
0007b7 91ff          pop zh
0007b8 918f          pop tosl
0007b9 919f          pop tosh
0007ba 939a
0007bb 938a          savetos
0007bc 01cf          movw tosl, zl
0007bd c94e          jmp_ DO_NEXT
                 
                 .include "words/store-e.asm"
                 
                 ; Memory
                 ; write n (2bytes) to eeprom address
                 VE_STOREE:
0007be ff02          .dw $ff02
0007bf 6521          .db "!e"
0007c0 07af          .dw VE_HEAD
                     .set VE_HEAD = VE_STOREE
                 XT_STOREE:
0007c1 07c2          .dw PFA_STOREE
                 PFA_STOREE:
                 .if WANT_UNIFIED == 1
                 .endif
                 PFA_STOREE0:
0007c2 01fc          movw zl, tosl
0007c3 9189
0007c4 9199          loadtos
0007c5 b72f          in_ temp2, SREG
0007c6 94f8          cli
0007c7 d028          rcall PFA_FETCHE2
0007c8 b500          in_  temp0, EEDR
0007c9 1708          cp temp0,tosl
0007ca f009          breq PFA_STOREE3
0007cb d00b          rcall PFA_STOREE1
                 PFA_STOREE3:
0007cc 9631          adiw zl,1
0007cd d022          rcall PFA_FETCHE2
0007ce b500          in_  temp0, EEDR
0007cf 1709          cp temp0,tosh
0007d0 f011          breq PFA_STOREE4
0007d1 2f89          mov tosl, tosh
0007d2 d004          rcall PFA_STOREE1
                 PFA_STOREE4:
0007d3 bf2f          out_ SREG, temp2
0007d4 9189
0007d5 9199          loadtos
0007d6 c935          jmp_ DO_NEXT
                     
                 PFA_STOREE1:
0007d7 99f9          sbic EECR, EEPE
0007d8 cffe          rjmp PFA_STOREE1
                 
                 PFA_STOREE2: ; estore_wait_low_spm:
0007d9 b707          in_ temp0, SPMCSR
0007da fd00          sbrc temp0,SPMEN
0007db cffd          rjmp PFA_STOREE2
                 
0007dc bdf2          out_ EEARH,zh
0007dd bde1          out_ EEARL,zl
0007de bd80          out_ EEDR, tosl
0007df 9afa          sbi EECR,EEMPE
0007e0 9af9          sbi EECR,EEPE
                 
0007e1 9508          ret
                 .if WANT_UNIFIED == 1
                 .endif
                 .include "words/fetch-e.asm"
                 
                 ; Memory
                 ; read 1 cell from eeprom
                 VE_FETCHE:
0007e2 ff02          .dw $ff02
0007e3 6540          .db "@e"
0007e4 07be          .dw VE_HEAD
                     .set VE_HEAD = VE_FETCHE
                 XT_FETCHE:
0007e5 07e6          .dw PFA_FETCHE
                 PFA_FETCHE:
                 .if WANT_UNIFIED == 1
                 .endif
                 PFA_FETCHE1:
0007e6 b72f          in_ temp2, SREG
0007e7 94f8          cli
0007e8 01fc          movw zl, tosl
0007e9 d006          rcall PFA_FETCHE2
0007ea b580          in_ tosl, EEDR
                 
0007eb 9631          adiw zl,1
                 
0007ec d003          rcall PFA_FETCHE2
0007ed b590          in_  tosh, EEDR
0007ee bf2f          out_ SREG, temp2
0007ef c91c          jmp_ DO_NEXT
                 
                 PFA_FETCHE2:
0007f0 99f9          sbic EECR, EEPE
0007f1 cffe          rjmp PFA_FETCHE2
                 
0007f2 bdf2          out_ EEARH,zh
0007f3 bde1          out_ EEARL,zl
                 
0007f4 9af8          sbi EECR,EERE
0007f5 9508          ret
                 
                 .if WANT_UNIFIED == 1
                 .endif
                 .include "words/store-i.asm"
                 
                 ; System Value
                 ; Deferred action to write a single 16bit cell to flash
                 VE_STOREI:
0007f6 ff02          .dw $ff02
0007f7 6921          .db "!i"
0007f8 07e2          .dw VE_HEAD
                     .set VE_HEAD = VE_STOREI
                 XT_STOREI:
0007f9 106a          .dw PFA_DODEFER1
                 PFA_STOREI:
0007fa 007c          .dw EE_STOREI
0007fb 100b          .dw XT_EDEFERFETCH
0007fc 1015          .dw XT_EDEFERSTORE
                 .if FLASHEND > $10000
                   .include "words/store-i_big.asm"
                 
                 ; R( -- )
                 ; writes a cell in flash
                 VE_DO_STOREI:
0007fd ff04          .dw $ff04
0007fe 6928
0007ff 2921          .db "(i!)"
000800 07f6          .dw VE_HEAD
                     .set VE_HEAD = VE_DO_STOREI
                 XT_DO_STOREI:
000801 0802          .dw PFA_DO_STOREI
                 PFA_DO_STOREI:
000802 019c        movw temp2, tosl ; save the (word) address
000803 9189
000804 9199        loadtos          ; get the new value for the flash cell
000805 93af        push xl
000806 93bf        push xh
000807 93cf        push yl
000808 93df        push yh
000809 e0e1        ldi zl, byte3(DO_ISTORE_atmega)
00080a bfeb        out_ rampz, zl
00080b eff0        ldi zh, byte2(DO_ISTORE_atmega)
00080c e0e0        ldi zl, byte1(DO_ISTORE_atmega)
00080d 9519        eicall 
00080e 91df        pop yh
00080f 91cf        pop yl
000810 91bf        pop xh
000811 91af        pop xl
                   ; finally clear the stack
000812 9189
000813 9199        loadtos
000814 c8f7        jmp_ DO_NEXT
                 
                 ;
                 .set _pc = pc
                 .org NRWW_START_ADDR
                 DO_ISTORE_atmega:
                   ; write data to temp page buffer
                   ; use the values in tosl/tosh at the
                   ; appropiate place
01f000 d010        rcall pageload
                 
                   ; erase page if needed
                   ; it is needed if a bit goes from 0 to 1
01f001 94e0        com temp4
01f002 94f0        com temp5
01f003 218e        and tosl, temp4
01f004 219f        and tosh, temp5
01f005 2b98        or tosh, tosl
01f006 f019        breq DO_ISTORE_writepage 
                 
01f007 01f9          movw zl, temp2
01f008 e003          ldi temp0,(1<<PGERS|1<<SPMEN)
01f009 d023          rcall dospm
                 
                 DO_ISTORE_writepage:
                   ; write page
01f00a 01f9        movw zl, temp2
01f00b e005        ldi temp0,(1<<PGWRT|1<<SPMEN)
01f00c d020        rcall dospm
                 
                   ; reenable RWW section
01f00d 01f9        movw zl, temp2
01f00e e101        ldi temp0,(1<<RWWSRE|1<<SPMEN)
01f00f d01d        rcall dospm
01f010 9508        ret
                 
                 ; load the desired page
                 .equ pagemask = ~ ( PAGESIZE - 1 )
                 pageload:
01f011 01f9        movw zl, temp2
                   ; get the beginning of page
01f012 78e0        andi zl,low(pagemask)
01f013 7fff        andi zh,high(pagemask)
01f014 01ef        movw y, z
                   ; loop counter (in words)
01f015 e8a0        ldi xl,low(pagesize)
01f016 e0b0        ldi xh,high(pagesize)
                 pageload_loop:
                   ; we need the current flash value anyways
01f017 01fe        movw z, y
01f018 2755
01f019 0fee
01f01a 1fff
01f01b 1f55
01f01c bf5b
01f01d 9147
01f01e 9157        readflashcell temp6, temp7 ; destroys Z
                   ; now check: if Z points to the same cell as temp2/3, we want the new data
01f01f 01fe        movw z, y
01f020 17e2        cp zl, temp2
01f021 07f3        cpc zh, temp3
01f022 f011        breq pageload_newdata
01f023 010a          movw r0, temp6
01f024 c002          rjmp pageload_cont
                 pageload_newdata:
01f025 017a          movw temp4, temp6
01f026 010c          movw r0, tosl
                 pageload_cont:
01f027 e001        ldi temp0,(1<<SPMEN)
01f028 d004        rcall dospm
01f029 9621        adiw y, 1
01f02a 9711        sbiw x, 1
01f02b f759        brne pageload_loop
                 
                 pageload_done:
01f02c 9508        ret
                 
                 
                 ;; dospm
                 ;;
                 ;; execute spm instruction
                 ;;   temp0 holds the value for SPMCR
                 
                 dospm:
                   ; store status register
01f02d b71f        in temp1,SREG
01f02e 931f        push temp1
01f02f 94f8        cli
                 Wait_ee:
01f030 99f9        sbic EECR, EEPE
01f031 cffe        rjmp Wait_ee
                 wait_spm:
01f032 b717        in   temp1, SPMCSR
01f033 fd10        sbrc temp1, SPMEN
01f034 cffd        rjmp Wait_spm
                 
                   ; turn the word addres into a byte address
01f035 2755
01f036 0fee
01f037 1fff
01f038 1f55
01f039 bf5b        writeflashcell
                   ; execute spm
01f03a bf07        out SPMCSR,temp0
01f03b 95e8        spm
01f03c 911f        pop temp1
                   ; restore status register
01f03d bf1f        out SREG,temp1
01f03e 9508        ret
                 
                 .org _pc
                 .else
                 .endif
                 .include "words/fetch-i.asm"
                 
                 ; Memory
                 ; read 1 cell from flash
                 VE_FETCHI:
000815 ff02          .dw $ff02
000816 6940          .db "@i"
000817 07fd          .dw VE_HEAD
                     .set VE_HEAD = VE_FETCHI
                 XT_FETCHI:
000818 0819          .dw PFA_FETCHI
                 PFA_FETCHI:
000819 01fc          movw zl, tosl
00081a 2755
00081b 0fee
00081c 1fff
00081d 1f55
00081e bf5b
00081f 9187
000820 9197          readflashcell tosl,tosh
000821 c8ea          jmp_ DO_NEXT
                 
                 .if AMFORTH_NRWW_SIZE>8000
                 .include "dict/core_8k.inc"
                 
                 .include "words/n_to_r.asm"
                 
                 ; Stack
                 ; move n items from data stack to return stack
                 VE_N_TO_R:
000822 ff03          .dw $ff03
000823 3e6e
000824 0072          .db "n>r",0
000825 0815          .dw VE_HEAD
                     .set VE_HEAD = VE_N_TO_R
                 XT_N_TO_R:
000826 0827          .dw PFA_N_TO_R
                 PFA_N_TO_R:
000827 01fc          movw zl, tosl
000828 2f08          mov  temp0, tosl
                 PFA_N_TO_R1:
000829 9189
00082a 9199          loadtos
00082b 939f          push tosh
00082c 938f          push tosl
00082d 950a          dec temp0
00082e f7d1          brne PFA_N_TO_R1
00082f 93ef          push zl
000830 93ff          push zh
000831 9189
000832 9199          loadtos
000833 c8d8          jmp_ DO_NEXT
                 .include "words/n_r_from.asm"
                 
                 ; Stack
                 ; move n items from return stack to data stack
                 VE_N_R_FROM:
000834 ff03          .dw $ff03
000835 726e
000836 003e          .db "nr>",0
000837 0822          .dw VE_HEAD
                     .set VE_HEAD = VE_N_R_FROM
                 XT_N_R_FROM:
000838 0839          .dw PFA_N_R_FROM
                 PFA_N_R_FROM:
000839 939a
00083a 938a          savetos
00083b 91ff          pop zh
00083c 91ef          pop zl
00083d 2f0e          mov  temp0, zl
                 PFA_N_R_FROM1:
00083e 918f          pop tosl
00083f 919f          pop tosh
000840 939a
000841 938a          savetos
000842 950a          dec temp0
000843 f7d1          brne PFA_N_R_FROM1
000844 01cf          movw tosl, zl
000845 c8c6          jmp_ DO_NEXT
                 
                 .include "words/d-2star.asm"
                 
                 ; Arithmetics
                 ; shift a double cell left
                 VE_D2STAR:
000846 ff03          .dw $ff03
000847 3264
000848 002a          .db "d2*",0
000849 0834          .dw VE_HEAD
                     .set VE_HEAD = VE_D2STAR
                 XT_D2STAR:
00084a 084b          .dw PFA_D2STAR
                 PFA_D2STAR:
00084b 9109          ld temp0, Y+
00084c 9119          ld temp1, Y+
00084d 0f00          lsl temp0
00084e 1f11          rol temp1
00084f 1f88          rol tosl
000850 1f99          rol tosh
000851 931a          st -Y, temp1
000852 930a          st -Y, temp0
000853 c8b8          jmp_ DO_NEXT
                 .include "words/d-2slash.asm"
                 
                 ; Arithmetics
                 ; shift a double cell value right
                 VE_D2SLASH:
000854 ff03          .dw $ff03
000855 3264
000856 002f          .db "d2/",0
000857 0846          .dw VE_HEAD
                     .set VE_HEAD = VE_D2SLASH
                 XT_D2SLASH:
000858 0859          .dw PFA_D2SLASH
                 PFA_D2SLASH:
000859 9109          ld temp0, Y+
00085a 9119          ld temp1, Y+
00085b 9595          asr tosh
00085c 9587          ror tosl
00085d 9517          ror temp1
00085e 9507          ror temp0
00085f 931a          st -Y, temp1
000860 930a          st -Y, temp0
000861 c8aa          jmp_ DO_NEXT
                 .include "words/d-plus.asm"
                 
                 ; Arithmetics
                 ; add 2 double cell values
                 VE_DPLUS:
000862 ff02          .dw $ff02
000863 2b64          .db "d+"
000864 0854          .dw VE_HEAD
                     .set VE_HEAD = VE_DPLUS
                 XT_DPLUS:
000865 0866          .dw PFA_DPLUS
                 PFA_DPLUS:
000866 9129          ld temp2, Y+
000867 9139          ld temp3, Y+
                 
000868 90e9          ld temp4, Y+
000869 90f9          ld temp5, Y+
00086a 9149          ld temp6, Y+
00086b 9159          ld temp7, Y+
                 
00086c 0f24          add temp2, temp6
00086d 1f35          adc temp3, temp7
00086e 1d8e          adc tosl, temp4
00086f 1d9f          adc tosh, temp5
                     
000870 933a          st -Y, temp3
000871 932a          st -Y, temp2
000872 c899          jmp_ DO_NEXT
                 .include "words/d-minus.asm"
                 
                 ; Arithmetics
                 ; subtract d2 from d1 
                 VE_DMINUS:
000873 ff02          .dw $ff02
000874 2d64          .db "d-"
000875 0862          .dw VE_HEAD
                     .set VE_HEAD = VE_DMINUS
                 XT_DMINUS:
000876 0877          .dw PFA_DMINUS
                 PFA_DMINUS:
000877 9129          ld temp2, Y+
000878 9139          ld temp3, Y+
                 
000879 90e9          ld temp4, Y+
00087a 90f9          ld temp5, Y+
00087b 9149          ld temp6, Y+
00087c 9159          ld temp7, Y+
                 
00087d 1b42          sub temp6, temp2
00087e 0b53          sbc temp7, temp3
00087f 0ae8          sbc temp4, tosl
000880 0af9          sbc temp5, tosh
                 
000881 935a          st -Y, temp7
000882 934a          st -Y, temp6
000883 01c7          movw tosl, temp4
000884 c887          jmp_ DO_NEXT
                 .include "words/d-invert.asm"
                 
                 ; Arithmetics
                 ; invert all bits in the double cell value
                 VE_DINVERT:
000885 ff07          .dw $ff07
000886 6964
000887 766e
000888 7265
000889 0074          .db "dinvert",0
00088a 0873          .dw VE_HEAD
                     .set VE_HEAD = VE_DINVERT
                 XT_DINVERT:
00088b 088c          .dw PFA_DINVERT
                 PFA_DINVERT:
00088c 9109          ld temp0, Y+
00088d 9119          ld temp1, Y+
00088e 9580          com tosl
00088f 9590          com tosh
000890 9500          com temp0
000891 9510          com temp1
000892 931a          st -Y, temp1
000893 930a          st -Y, temp0
000894 c877          jmp_ DO_NEXT
                 .include "words/d-equal.asm"
                 
                 ; Compare
                 ; compares two double cell values
                 VE_DEQUAL:
000895 ff02          .dw $ff02
000896 3d64          .db "d="
000897 0885          .dw VE_HEAD
                     .set VE_HEAD = VE_DEQUAL
                 XT_DEQUAL:
000898 0108          .dw DO_COLON
                 PFA_DEQUAL:
000899 0876          .dw XT_DMINUS
00089a 06ad          .dw XT_OR
00089b 05ab          .dw XT_ZEROEQUAL
00089c 04a6          .dw XT_EXIT
                 .include "words/u-dot.asm"
                 
                 ; Numeric IO
                 ; unsigned PNO with single cell numbers
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_UDOT:
00089d ff02          .dw $ff02
00089e 2e75          .db "u."
00089f 0895          .dw VE_HEAD
                     .set VE_HEAD = VE_UDOT
                 XT_UDOT:
0008a0 0108          .dw DO_COLON
                 PFA_UDOT:
                 .endif
0008a1 05e5          .dw XT_ZERO
0008a2 0b98          .dw XT_UDDOT
0008a3 04a6          .dw XT_EXIT
                 ; : u.        ( us -- )    0 ud. ;
                 .include "words/u-dot-r.asm"
                 
                 ; Numeric IO
                 ; unsigned PNO with single cells numbers, right aligned in width w
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 
                 VE_UDOTR:
0008a4 ff03          .dw $ff03
0008a5 2e75
0008a6 0072          .db "u.r",0
0008a7 089d          .dw VE_HEAD
                     .set VE_HEAD = VE_UDOTR
                 XT_UDOTR:
0008a8 0108          .dw DO_COLON
                 PFA_UDOTR:
                 .endif
0008a9 05e5          .dw XT_ZERO
0008aa 0555          .dw XT_SWAP
0008ab 0ba1          .dw XT_UDDOTR
0008ac 04a6          .dw XT_EXIT
                 ; : u.r       ( s n -- )   0 swap ud.r ;
                 
                 .include "words/show-wordlist.asm"
                 
                 ; Tools
                 ; prints the name of the words in a wordlist
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SHOWWORDLIST:
0008ad ff0d          .dw $ff0d
0008ae 6873
0008af 776f
0008b0 772d
0008b1 726f
0008b2 6c64
0008b3 7369
0008b4 0074          .db "show-wordlist",0
0008b5 08a4          .dw VE_HEAD
                     .set VE_HEAD = VE_SHOWWORDLIST
                 XT_SHOWWORDLIST:
0008b6 0108          .dw DO_COLON
                 PFA_SHOWWORDLIST:
                 .endif
0008b7 04c6          .dw XT_DOLITERAL
0008b8 08bc          .dw XT_SHOWWORD
0008b9 0555          .dw XT_SWAP
0008ba 10ae          .dw XT_TRAVERSEWORDLIST
0008bb 04a6          .dw XT_EXIT
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 XT_SHOWWORD:
0008bc 0108          .dw DO_COLON
                 PFA_SHOWWORD:
                 .endif
0008bd 10c9          .dw XT_NAME2STRING
0008be 0c0e          .dw XT_ITYPE
0008bf 0c50          .dw XT_SPACE         ; ( -- addr n)
0008c0 05dc          .dw XT_TRUE
0008c1 04a6          .dw XT_EXIT
                 .include "words/words.asm"
                 
                 ; Tools
                 ; prints a list of all (visible) words in the dictionary
                 VE_WORDS:
0008c2 ff05          .dw $ff05
0008c3 6f77
0008c4 6472
0008c5 0073          .db "words",0
0008c6 08ad          .dw VE_HEAD
                     .set VE_HEAD = VE_WORDS
                 XT_WORDS:
0008c7 0108          .dw DO_COLON
                 PFA_WORDS:
0008c8 04c6          .dw XT_DOLITERAL
0008c9 0088          .dw CFG_ORDERLIST
0008ca 07e5          .dw XT_FETCHE
0008cb 08b6          .dw XT_SHOWWORDLIST
0008cc 04a6          .dw XT_EXIT
                 .include "dict/interrupt.inc"
                 
                 .include "words/int-on.asm"
                 
                 ; Interrupt
                 ; turns on all interrupts
                 VE_INTON:
0008cd ff04          .dw $ff04
0008ce 692b
0008cf 746e          .db "+int"
0008d0 08c2          .dw VE_HEAD
                     .set VE_HEAD = VE_INTON
                 XT_INTON:
0008d1 08d2          .dw PFA_INTON
                 PFA_INTON:
0008d2 9478          sei
0008d3 c838          jmp_ DO_NEXT
                 .include "words/int-off.asm"
                 
                 ; Interrupt
                 ; turns off all interrupts 
                 VE_INTOFF:
0008d4 ff04          .dw $ff04
0008d5 692d
0008d6 746e          .db "-int"
0008d7 08cd          .dw VE_HEAD
                     .set VE_HEAD = VE_INTOFF
                 XT_INTOFF:
0008d8 08d9          .dw PFA_INTOFF
                 PFA_INTOFF:
0008d9 94f8          cli
0008da c831          jmp_ DO_NEXT
                 .include "words/int-store.asm"
                 
                 ; Interrupt
                 ; stores XT as interrupt vector i
                 VE_INTSTORE:
0008db ff04          .dw $ff04
0008dc 6e69
0008dd 2174          .db "int!"
0008de 08d4          .dw VE_HEAD
                     .set VE_HEAD = VE_INTSTORE
                 XT_INTSTORE:
0008df 0108          .dw DO_COLON
                 PFA_INTSTORE:
0008e0 04c6          .dw XT_DOLITERAL
0008e1 0000          .dw intvec
0008e2 062e          .dw XT_PLUS
0008e3 07c1          .dw XT_STOREE
0008e4 04a6          .dw XT_EXIT
                 .include "words/int-fetch.asm"
                 
                 ; Interrupt
                 ; fetches XT from interrupt vector i
                 VE_INTFETCH:
0008e5 ff04          .dw $ff04
0008e6 6e69
0008e7 4074          .db "int@"
0008e8 08db          .dw VE_HEAD
                     .set VE_HEAD = VE_INTFETCH
                 XT_INTFETCH:
0008e9 0108          .dw DO_COLON
                 PFA_INTFETCH:
0008ea 04c6          .dw XT_DOLITERAL
0008eb 0000          .dw intvec
0008ec 062e          .dw XT_PLUS
0008ed 07e5          .dw XT_FETCHE
0008ee 04a6          .dw XT_EXIT
                 .include "words/int-trap.asm"
                 
                 ; Interrupt
                 ; trigger an interrupt
                 VE_INTTRAP:
0008ef ff08          .dw $ff08
0008f0 6e69
0008f1 2d74
0008f2 7274
0008f3 7061          .db "int-trap"
0008f4 08e5          .dw VE_HEAD
                     .set VE_HEAD = VE_INTTRAP
                 XT_INTTRAP:
0008f5 08f6          .dw PFA_INTTRAP
                 PFA_INTTRAP:
0008f6 9380 0216     sts intcur, tosl
0008f8 9189
0008f9 9199          loadtos
0008fa 9468          set ; set the interrupt flag for the inner interpreter
0008fb c810          jmp_ DO_NEXT
                 
                 .include "words/isr-exec.asm"
                 
                 ; Interrupt
                 ; executes an interrupt service routine
                 ;VE_ISREXEC:
                 ;    .dw $ff08
                 ;    .db "isr-exec"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_ISREXEC
                 XT_ISREXEC:
0008fc 0108          .dw DO_COLON
                 PFA_ISREXEC:
0008fd 04c6          .dw XT_DOLITERAL
0008fe 0216          .dw intcur
0008ff 0529          .dw XT_CFETCH
000900 04c6          .dw XT_DOLITERAL
000901 0000          .dw intvec
000902 062e          .dw XT_PLUS
000903 07e5          .dw XT_FETCHE
000904 04b0          .dw XT_EXECUTE
000905 0907          .dw XT_ISREND
000906 04a6          .dw XT_EXIT
                 .include "words/isr-end.asm"
                 
                 ; Interrupt
                 ; re-enables interrupts in an ISR
                 ;VE_ISREND:
                 ;    .dw $ff07
                 ;    .db "isr-end",0
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_ISREND
                 XT_ISREND:
000907 0908          .dw PFA_ISREND
                 PFA_ISREND:
000908 d002          rcall PFA_ISREND1 ; clear the interrupt flag for the controller
000909 940c 010c     jmp_ DO_NEXT
                 PFA_ISREND1:
00090b 9518          reti
                 
                 .include "words/pick.asm"
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_PICK:
00090c ff04          .dw $ff04
00090d 6970
00090e 6b63          .db "pick"
00090f 08ef          .dw VE_HEAD
                     .set VE_HEAD = VE_PICK
                 XT_PICK:
000910 0108          .dw DO_COLON
                 PFA_PICK:
                 .endif
000911 06c0          .dw XT_1PLUS
000912 09b9          .dw XT_CELLS
000913 0712          .dw XT_SP_FETCH
000914 062e          .dw XT_PLUS
000915 050a          .dw XT_FETCH
000916 04a6          .dw XT_EXIT
                 .include "words/dot-quote.asm"
                 
                 ; Compiler
                 ; compiles string into dictionary to be printed at runtime
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 
                 VE_DOTSTRING:
000917 0002          .dw $0002
000918 222e          .db ".",$22
000919 090c          .dw VE_HEAD
                     .set VE_HEAD = VE_DOTSTRING
                 XT_DOTSTRING:
00091a 0108          .dw DO_COLON
                 PFA_DOTSTRING:
                 .endif
00091b 0922          .dw XT_SQUOTE
00091c 01c7          .dw XT_COMPILE
00091d 0c0e          .dw XT_ITYPE
00091e 04a6          .dw XT_EXIT
                 .include "words/squote.asm"
                 
                 ; Compiler
                 ; compiles a string to flash, at runtime leaves ( -- flash-addr count) on stack
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SQUOTE:
00091f 0002        .dw $0002
000920 2273        .db "s",$22
000921 0917        .dw VE_HEAD
                   .set VE_HEAD = VE_SQUOTE
                 XT_SQUOTE:
000922 0108          .dw DO_COLON
                 PFA_SQUOTE:
                 .endif
000923 04c6          .dw XT_DOLITERAL
000924 0022          .dw 34   ; 0x22 
000925 0ded          .dw XT_PARSE       ; ( -- addr n)
000926 09ac          .dw XT_STATE
000927 050a          .dw XT_FETCH
000928 04bf          .dw XT_DOCONDBRANCH
000929 092b          DEST(PFA_SQUOTE1)
00092a 01f3            .dw XT_SLITERAL
                 PFA_SQUOTE1:
00092b 04a6          .dw XT_EXIT
                 
                 .include "words/fill.asm"
                 
                 ; Memory
                 ; fill u bytes memory beginning at a-addr with character c
                 VE_FILL:
00092c ff04          .dw $ff04
00092d 6966
00092e 6c6c          .db "fill"
00092f 091f          .dw VE_HEAD
                     .set VE_HEAD = VE_FILL
                 XT_FILL:
000930 0108          .dw DO_COLON
                 PFA_FILL:
000931 0572          .dw XT_ROT
000932 0572          .dw XT_ROT
000933 054a
000934 04bf          .dw XT_QDUP,XT_DOCONDBRANCH
000935 093d          DEST(PFA_FILL2)
000936 123f          .dw XT_BOUNDS
000937 0720          .dw XT_DODO
                 PFA_FILL1:
000938 0542          .dw XT_DUP
000939 0731          .dw XT_I
00093a 051e          .dw XT_CSTORE  ; ( -- c c-addr)
00093b 074e          .dw XT_DOLOOP
00093c 0938          .dw PFA_FILL1
                 PFA_FILL2:
00093d 056a          .dw XT_DROP
00093e 04a6          .dw XT_EXIT
                 
                 .include "words/environment.asm"
                 
                 ; System Value
                 ; word list identifier of the environmental search list
                 VE_ENVIRONMENT:
00093f ff0b          .dw $ff0b
000940 6e65
000941 6976
000942 6f72
000943 6d6e
000944 6e65
000945 0074          .db "environment",0
000946 092c          .dw VE_HEAD
                     .set VE_HEAD = VE_ENVIRONMENT
                 XT_ENVIRONMENT:
000947 04d4          .dw PFA_DOVARIABLE
                 PFA_ENVIRONMENT:
000948 007e          .dw EE_ENVIRONMENT
                 .include "words/env-wordlists.asm"
                 
                 ; Environment
                 ; maximum number of wordlists in the dictionary search order
                 VE_ENVWORDLISTS:
000949 ff09          .dw $ff09
00094a 6f77
00094b 6472
00094c 696c
00094d 7473
00094e 0073          .db "wordlists",0
00094f 0000          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENVWORDLISTS
                 XT_ENVWORDLISTS:
000950 0108          .dw DO_COLON
                 PFA_ENVWORDLISTS:
000951 04c6          .dw XT_DOLITERAL
000952 0008          .dw NUMWORDLISTS
000953 04a6          .dw XT_EXIT
                 .include "words/env-slashpad.asm"
                 
                 ; Environment
                 ; Size of the PAD buffer in bytes
                 VE_ENVSLASHPAD:
000954 ff04          .dw $ff04
000955 702f
000956 6461          .db "/pad"
000957 0949          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENVSLASHPAD
                 XT_ENVSLASHPAD:
000958 0108          .dw DO_COLON
                 PFA_ENVSLASHPAD:
000959 0712          .dw XT_SP_FETCH
00095a 09ec          .dw XT_PAD
00095b 0624          .dw XT_MINUS
00095c 04a6          .dw XT_EXIT
                 .include "words/env-slashhold.asm"
                 
                 ; Environment
                 ; size of the pictured numeric output buffer in bytes
                 VE_ENVSLASHHOLD:
00095d ff05          .dw $ff05
00095e 682f
00095f 6c6f
000960 0064          .db "/hold",0
000961 0954          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENVSLASHHOLD
                 XT_ENVSLASHHOLD:
000962 0108          .dw DO_COLON
                 PFA_ENVSLASHHOLD:
000963 09ec          .dw XT_PAD
000964 0a27          .dw XT_HERE
000965 0624          .dw XT_MINUS
000966 04a6          .dw XT_EXIT
                 .include "words/env-forthname.asm"
                 
                 ; Environment
                 ; flash address of the amforth name string
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_ENV_FORTHNAME:
000967 ff0a          .dw $ff0a
000968 6f66
000969 7472
00096a 2d68
00096b 616e
00096c 656d          .db "forth-name"
00096d 095d          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENV_FORTHNAME
                 XT_ENV_FORTHNAME:
00096e 0108          .dw DO_COLON
                 PFA_EN_FORTHNAME:
00096f 0bdb          .dw XT_DOSLITERAL
000970 0007          .dw 7
                 .endif
000971 6d61
000972 6f66
000973 7472
../../common\words/env-forthname.asm(22): warning: .cseg .db misalignment - padding zero byte
000974 0068          .db "amforth"
                 .if cpu_msp430==1
                 .endif
000975 04a6          .dw XT_EXIT
                 .include "words/env-forthversion.asm"
                 
                 ; Environment
                 ; version number of amforth
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_ENV_FORTHVERSION:
000976 ff07          .dw $ff07
000977 6576
000978 7372
000979 6f69
00097a 006e          .db "version",0
00097b 0967          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENV_FORTHVERSION
                 XT_ENV_FORTHVERSION:
00097c 0108          .dw DO_COLON
                 PFA_EN_FORTHVERSION:
                 .endif
00097d 04c6          .dw XT_DOLITERAL
00097e 003b          .dw 59
00097f 04a6          .dw XT_EXIT
                 .include "words/env-cpu.asm"
                 
                 ; Environment
                 ; flash address of the CPU identification string
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_ENV_CPU:
000980 ff03          .dw $ff03
000981 7063
000982 0075          .db "cpu",0
000983 0976          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENV_CPU
                 XT_ENV_CPU:
000984 0108          .dw DO_COLON
                 PFA_EN_CPU:
000985 04c6          .dw XT_DOLITERAL
000986 0075          .dw mcu_name
000987 0c3a          .dw XT_ICOUNT
                 .endif
000988 04a6          .dw XT_EXIT
                 .include "words/env-mcuinfo.asm"
                 
                 ; Environment
                 ; flash address of some CPU specific parameters
                 VE_ENV_MCUINFO:
000989 ff08          .dw $ff08
00098a 636d
00098b 2d75
00098c 6e69
00098d 6f66          .db "mcu-info"
00098e 0980          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENV_MCUINFO
                 XT_ENV_MCUINFO:
00098f 0108          .dw DO_COLON
                 PFA_EN_MCUINFO:
000990 04c6          .dw XT_DOLITERAL
000991 0071          .dw mcu_info
000992 04a6          .dw XT_EXIT
                 .include "words/env-usersize.asm"
                 
                 ; Environment
                 ; size of the USER area in bytes
                 VE_ENVUSERSIZE:
000993 ff05          .dw $ff05
000994 752f
000995 6573
000996 0072          .db "/user",0
000997 0989          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENVUSERSIZE
                 XT_ENVUSERSIZE:
000998 0108          .dw DO_COLON
                 PFA_ENVUSERSIZE:
000999 04c6          .dw XT_DOLITERAL
00099a 0026          .dw SYSUSERSIZE + APPUSERSIZE
00099b 04a6          .dw XT_EXIT
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/f_cpu.asm"
                 
                 ; System
                 ; put the cpu frequency in Hz on stack
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_F_CPU:
00099c ff05          .dw $ff05
00099d 5f66
00099e 7063
00099f 0075          .db "f_cpu",0
0009a0 093f          .dw VE_HEAD
                     .set VE_HEAD = VE_F_CPU
                 XT_F_CPU:
0009a1 0108          .dw DO_COLON
                 PFA_F_CPU:
                 .endif
0009a2 04c6          .dw XT_DOLITERAL
0009a3 0000          .dw (F_CPU % 65536)
0009a4 04c6          .dw XT_DOLITERAL
0009a5 00e1          .dw (F_CPU / 65536)
0009a6 04a6          .dw XT_EXIT
                 .include "words/state.asm"
                 
                 ; System Variable
                 ; system state
                 VE_STATE:
0009a7 ff05          .dw $ff05
0009a8 7473
0009a9 7461
0009aa 0065          .db "state",0
0009ab 099c          .dw VE_HEAD
                     .set VE_HEAD = VE_STATE
                 XT_STATE:
0009ac 04d4          .dw PFA_DOVARIABLE
                 PFA_STATE:
0009ad 021f          .dw ram_state
                 
                 .dseg
00021f           ram_state: .byte 2
                 .include "words/base.asm"
                 
                 ; Numeric IO
                 ; location of the cell containing the number conversion radix
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_BASE:
0009ae ff04          .dw $ff04
0009af 6162
0009b0 6573          .db "base"
0009b1 09a7          .dw VE_HEAD
                     .set VE_HEAD = VE_BASE
                 XT_BASE:
0009b2 04e7          .dw PFA_DOUSER
                 PFA_BASE:
                 .endif
0009b3 000c          .dw USER_BASE
                 
                 .include "words/cells.asm"
                 
                 ; Arithmetics
                 ; n2 is the size in address units of n1 cells
                 VE_CELLS:
0009b4 ff05          .dw $ff05
0009b5 6563
0009b6 6c6c
0009b7 0073          .db "cells",0
0009b8 09ae          .dw VE_HEAD
                     .set VE_HEAD = VE_CELLS
                 XT_CELLS:
0009b9 069d          .dw PFA_2STAR
                 .include "words/cellplus.asm"
                 
                 ; Arithmetics
                 ; add the size of an address-unit to a-addr1
                 VE_CELLPLUS:
0009ba ff05          .dw $ff05
0009bb 6563
0009bc 6c6c
0009bd 002b          .db "cell+",0
0009be 09b4          .dw VE_HEAD
                     .set VE_HEAD = VE_CELLPLUS
                 XT_CELLPLUS:
0009bf 09c0          .dw PFA_CELLPLUS
                 PFA_CELLPLUS:
0009c0 9602          adiw tosl, CELLSIZE
0009c1 940c 010c     jmp_ DO_NEXT
                 
                 .include "words/2dup.asm"
                 
                 ; Stack
                 ; Duplicate the 2 top elements
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_2DUP:
0009c3 ff04          .dw $ff04
0009c4 6432
0009c5 7075          .db "2dup"
0009c6 09ba          .dw VE_HEAD
                     .set VE_HEAD = VE_2DUP
                 XT_2DUP:
0009c7 0108          .dw DO_COLON
                 PFA_2DUP:
                 .endif
                 
0009c8 0560          .dw XT_OVER
0009c9 0560          .dw XT_OVER
0009ca 04a6          .dw XT_EXIT
                 .include "words/2drop.asm"
                 
                 ; Stack
                 ; Remove the 2 top elements
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_2DROP:
0009cb ff05          .dw $ff05
0009cc 6432
0009cd 6f72
0009ce 0070          .db "2drop",0
0009cf 09c3          .dw VE_HEAD
                     .set VE_HEAD = VE_2DROP
                 XT_2DROP:
0009d0 0108          .dw DO_COLON
                 PFA_2DROP:
                 .endif
0009d1 056a          .dw XT_DROP
0009d2 056a          .dw XT_DROP
0009d3 04a6          .dw XT_EXIT
                 
                 .include "words/tuck.asm"
                 
                 ; Stack
                 ; Copy the first (top) stack item below the second stack item. 
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_TUCK:
0009d4 ff04          .dw $ff04
0009d5 7574
0009d6 6b63          .db "tuck"
0009d7 09cb          .dw VE_HEAD
                     .set VE_HEAD = VE_TUCK
                 XT_TUCK:
0009d8 0108          .dw DO_COLON
                 PFA_TUCK:
                 .endif
0009d9 0555          .dw XT_SWAP
0009da 0560          .dw XT_OVER
0009db 04a6          .dw XT_EXIT
                 
                 .include "words/to-in.asm"
                 
                 ; System Variable
                 ; pointer to current read position in input buffer
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_TO_IN:
0009dc ff03          .dw $ff03
0009dd 693e
0009de 006e          .db ">in",0
0009df 09d4          .dw VE_HEAD
                     .set VE_HEAD = VE_TO_IN
                 XT_TO_IN:
0009e0 04e7          .dw PFA_DOUSER
                 PFA_TO_IN:
                 .endif
0009e1 0018          .dw USER_TO_IN
                 .include "words/sharptib.asm"
                 
                 ; System Variable
                 ; variable holding the number of characters in TIB
                 VE_NUMBERTIB:
0009e2 ff04          .dw $ff04
0009e3 7423
0009e4 6269          .db "#tib"
0009e5 09dc          .dw VE_HEAD
                     .set VE_HEAD  = VE_NUMBERTIB
                 XT_NUMBERTIB:
0009e6 04d4          .dw PFA_DOVARIABLE
                 PFA_NUMBERTIB:
0009e7 0221          .dw ram_sharptib
                 
                 .dseg
000221           ram_sharptib: .byte 2
                 .cseg
                  
                 .include "words/pad.asm"
                 
                 ; System Variable
                 ; Address of the temporary scratch buffer.
                 VE_PAD:
0009e8 ff03          .dw $ff03
0009e9 6170
0009ea 0064          .db "pad",0
0009eb 09e2          .dw VE_HEAD
                     .set VE_HEAD = VE_PAD
                 XT_PAD:
0009ec 0108          .dw DO_COLON
                 PFA_PAD:
0009ed 0a27          .dw XT_HERE
0009ee 04c6          .dw XT_DOLITERAL
0009ef 0064          .dw 100
0009f0 062e          .dw XT_PLUS
0009f1 04a6          .dw XT_EXIT
                 .include "words/emit.asm"
                 
                 ; Character IO
                 ; fetch the emit vector and execute it. should emit a character from TOS
                 VE_EMIT:
0009f2 ff04          .dw $ff04
0009f3 6d65
0009f4 7469          .db "emit"
0009f5 09e8          .dw VE_HEAD
                     .set VE_HEAD = VE_EMIT
                 XT_EMIT:
0009f6 106a          .dw PFA_DODEFER1
                 PFA_EMIT:
0009f7 000e          .dw USER_EMIT
0009f8 1033          .dw XT_UDEFERFETCH
0009f9 103f          .dw XT_UDEFERSTORE
                 .include "words/emitq.asm"
                 
                 ; Character IO
                 ; fetch emit? vector and execute it. should return the ready-to-send condition
                 VE_EMITQ:
0009fa ff05          .dw $ff05
0009fb 6d65
0009fc 7469
0009fd 003f          .db "emit?",0
0009fe 09f2          .dw VE_HEAD
                     .set VE_HEAD = VE_EMITQ
                 XT_EMITQ:
0009ff 106a          .dw PFA_DODEFER1
                 PFA_EMITQ:
000a00 0010          .dw USER_EMITQ
000a01 1033          .dw XT_UDEFERFETCH
000a02 103f          .dw XT_UDEFERSTORE
                 .include "words/key.asm"
                 
                 ; Character IO
                 ; fetch key vector and execute it, should leave a single character on TOS
                 VE_KEY:
000a03 ff03          .dw $ff03
000a04 656b
000a05 0079          .db "key",0
000a06 09fa          .dw VE_HEAD
                     .set VE_HEAD = VE_KEY
                 XT_KEY:
000a07 106a          .dw PFA_DODEFER1
                 PFA_KEY:
000a08 0012          .dw USER_KEY
000a09 1033          .dw XT_UDEFERFETCH
000a0a 103f          .dw XT_UDEFERSTORE
                 .include "words/keyq.asm"
                 
                 ; Character IO
                 ; fetch key? vector and execute it. should turn on key sender, if it is disabled/stopped
                 VE_KEYQ:
000a0b ff04          .dw $ff04
000a0c 656b
000a0d 3f79          .db "key?"
000a0e 0a03          .dw VE_HEAD
                     .set VE_HEAD = VE_KEYQ
                 XT_KEYQ:
000a0f 106a          .dw PFA_DODEFER1
                 PFA_KEYQ:
000a10 0014          .dw USER_KEYQ
000a11 1033          .dw XT_UDEFERFETCH
000a12 103f          .dw XT_UDEFERSTORE
                 
                 .include "words/dp.asm"
                 
                 ; System Value
                 ; address of the next free dictionary cell
                 VE_DP:
000a13 ff02          .dw $ff02
000a14 7064          .db "dp"
000a15 0a0b          .dw VE_HEAD
                     .set VE_HEAD = VE_DP
                 XT_DP:
000a16 0501          .dw PFA_DOVALUE1
                 PFA_DP:
000a17 0074          .dw EE_DP
000a18 100b          .dw XT_EDEFERFETCH
000a19 1015          .dw XT_EDEFERSTORE
                 .include "words/ehere.asm"
                 
                 ; System Value
                 ; address of the next free address in eeprom
                 VE_EHERE:
000a1a ff05          .dw $ff05
000a1b 6865
000a1c 7265
000a1d 0065          .db "ehere",0
000a1e 0a13          .dw VE_HEAD
                     .set VE_HEAD = VE_EHERE
                 XT_EHERE:
000a1f 0501          .dw PFA_DOVALUE1
                 PFA_EHERE:
000a20 0078          .dw EE_EHERE
000a21 100b          .dw XT_EDEFERFETCH
000a22 1015          .dw XT_EDEFERSTORE
                 .include "words/here.asm"
                 
                 ; System Value
                 ; address of the next free data space (RAM) cell
                 VE_HERE:
000a23 ff04          .dw $ff04
000a24 6568
000a25 6572          .db "here"
000a26 0a1a          .dw VE_HEAD
                     .set VE_HEAD = VE_HERE
                 XT_HERE:
000a27 0501          .dw PFA_DOVALUE1
                 PFA_HERE:
000a28 0076          .dw EE_HERE
000a29 100b          .dw XT_EDEFERFETCH
000a2a 1015          .dw XT_EDEFERSTORE
                 .include "words/allot.asm"
                 
                 ; System
                 ; allocate or release memory in RAM
                 VE_ALLOT:
000a2b ff05          .dw $ff05
000a2c 6c61
000a2d 6f6c
000a2e 0074          .db "allot",0
000a2f 0a23          .dw VE_HEAD
                     .set VE_HEAD = VE_ALLOT
                 XT_ALLOT:
000a30 0108          .dw DO_COLON
                 PFA_ALLOT:
000a31 0a27          .dw XT_HERE
000a32 062e          .dw XT_PLUS
000a33 0ff0          .dw XT_DOTO
000a34 0a28          .dw PFA_HERE
000a35 04a6          .dw XT_EXIT
                 
                 .include "words/bin.asm"
                 
                 ; Numeric IO
                 ; set base for numeric conversion to 10
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_BIN:
000a36 ff03          .dw $ff03
000a37 6962
000a38 006e          .db "bin",0
000a39 0a2b          .dw VE_HEAD
                     .set VE_HEAD = VE_BIN
                 XT_BIN:
000a3a 0108          .dw DO_COLON
                 PFA_BIN:
                 .endif
000a3b 04c6          .dw XT_DOLITERAL
000a3c 0002          .dw 2
000a3d 09b2          .dw XT_BASE
000a3e 0512          .dw XT_STORE
000a3f 04a6          .dw XT_EXIT
                 .include "words/decimal.asm"
                 
                 ; Numeric IO
                 ; set base for numeric conversion to 10
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DECIMAL:
000a40 ff07          .dw $ff07
000a41 6564
000a42 6963
000a43 616d
000a44 006c          .db "decimal",0
000a45 0a36          .dw VE_HEAD
                     .set VE_HEAD = VE_DECIMAL
                 XT_DECIMAL:
000a46 0108          .dw DO_COLON
                 PFA_DECIMAL:
                 .endif
000a47 04c6          .dw XT_DOLITERAL
000a48 000a          .dw 10
000a49 09b2          .dw XT_BASE
000a4a 0512          .dw XT_STORE
000a4b 04a6          .dw XT_EXIT
                 .include "words/hex.asm"
                 
                 ; Numeric IO
                 ; set base for numeric conversion to 10
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_HEX:
000a4c ff03          .dw $ff03
000a4d 6568
000a4e 0078          .db "hex",0
000a4f 0a40          .dw VE_HEAD
                     .set VE_HEAD = VE_HEX
                 XT_HEX:
000a50 0108          .dw DO_COLON
                 PFA_HEX:
                 .endif
000a51 04c6          .dw XT_DOLITERAL
000a52 0010          .dw 16
000a53 09b2          .dw XT_BASE
000a54 0512          .dw XT_STORE
000a55 04a6          .dw XT_EXIT
                 .include "words/bl.asm"
                 
                 ; Character IO
                 ; put ascii code of the blank to the stack
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_BL:
000a56 ff02          .dw $ff02
000a57 6c62          .db "bl"
000a58 0a4c          .dw VE_HEAD
                     .set VE_HEAD = VE_BL
                 XT_BL:
000a59 04d4          .dw PFA_DOVARIABLE
                 PFA_BL:
                 .endif
000a5a 0020          .dw 32
                 
                 .include "words/turnkey.asm"
                 
                 ; System Value
                 ; Deferred action during startup/reset
                 VE_TURNKEY:
000a5b ff07          .dw $ff07
000a5c 7574
000a5d 6e72
000a5e 656b
000a5f 0079          .db "turnkey",0
000a60 0a56          .dw VE_HEAD
                     .set VE_HEAD = VE_TURNKEY
                 XT_TURNKEY:
000a61 106a          .dw PFA_DODEFER1
                 PFA_TURNKEY:
000a62 007a          .dw EE_TURNKEY
000a63 100b          .dw XT_EDEFERFETCH
000a64 1015          .dw XT_EDEFERSTORE
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/slashmod.asm"
                 
                 ; Arithmetics
                 ; signed division n1/n2 with remainder and quotient
                 VE_SLASHMOD:
000a65 ff04          .dw $ff04
000a66 6d2f
000a67 646f          .db "/mod"
000a68 0a5b          .dw VE_HEAD
                     .set VE_HEAD = VE_SLASHMOD
                 XT_SLASHMOD:
000a69 0a6a          .dw PFA_SLASHMOD
                 PFA_SLASHMOD:
000a6a 019c          movw temp2, tosl
                     
000a6b 9109          ld temp0, Y+
000a6c 9119          ld temp1, Y+
                 
000a6d 2f41          mov	temp6,temp1	;move dividend High to sign register
000a6e 2743          eor	temp6,temp3	;xor divisor High with sign register
000a6f ff17          sbrs	temp1,7	;if MSB in dividend set
000a70 c004          rjmp	PFA_SLASHMOD_1
000a71 9510          com	temp1		;    change sign of dividend
000a72 9500          com	temp0		
000a73 5f0f          subi	temp0,low(-1)
000a74 4f1f          sbci	temp1,high(-1)
                 PFA_SLASHMOD_1:	
000a75 ff37          sbrs	temp3,7	;if MSB in divisor set
000a76 c004          rjmp	PFA_SLASHMOD_2
000a77 9530          com	temp3		;    change sign of divisor
000a78 9520          com	temp2		
000a79 5f2f          subi	temp2,low(-1)
000a7a 4f3f          sbci	temp3,high(-1)
000a7b 24ee      PFA_SLASHMOD_2:	clr	temp4	;clear remainder Low byte
000a7c 18ff          sub	temp5,temp5;clear remainder High byte and carry
000a7d e151          ldi	temp7,17	;init loop counter
                 
000a7e 1f00      PFA_SLASHMOD_3:	rol	temp0		;shift left dividend
000a7f 1f11          rol	temp1
000a80 955a          dec	temp7		;decrement counter
000a81 f439          brne	PFA_SLASHMOD_5		;if done
000a82 ff47          sbrs	temp6,7		;    if MSB in sign register set
000a83 c004          rjmp	PFA_SLASHMOD_4
000a84 9510          com	temp1	;        change sign of result
000a85 9500          com	temp0
000a86 5f0f          subi	temp0,low(-1)
000a87 4f1f          sbci	temp1,high(-1)
000a88 c00b      PFA_SLASHMOD_4:	rjmp PFA_SLASHMODmod_done			;    return
000a89 1cee      PFA_SLASHMOD_5:	rol	temp4	;shift dividend into remainder
000a8a 1cff          rol	temp5
000a8b 1ae2          sub	temp4,temp2	;remainder = remainder - divisor
000a8c 0af3          sbc	temp5,temp3	;
000a8d f420          brcc	PFA_SLASHMOD_6		;if result negative
000a8e 0ee2          add	temp4,temp2	;    restore remainder
000a8f 1ef3          adc	temp5,temp3
000a90 9488          clc			;    clear carry to be shifted into result
000a91 cfec          rjmp	PFA_SLASHMOD_3		;else
000a92 9408      PFA_SLASHMOD_6:	sec			;    set carry to be shifted into result
000a93 cfea          rjmp	PFA_SLASHMOD_3
                 
                 PFA_SLASHMODmod_done:
                     ; put remainder on stack
000a94 92fa          st -Y,temp5
000a95 92ea          st -Y,temp4
                 
                     ; put quotient on stack
000a96 01c8          movw tosl, temp0
000a97 940c 010c     jmp_ DO_NEXT
                 .include "words/uslashmod.asm"
                 
                 ; Arithmetics
                 ; unsigned division with remainder
                 VE_USLASHMOD:
000a99 ff05          .dw $ff05
000a9a 2f75
000a9b 6f6d
000a9c 0064          .db "u/mod",0
000a9d 0a65          .dw VE_HEAD
                     .set VE_HEAD = VE_USLASHMOD
                 XT_USLASHMOD:
000a9e 0108          .dw DO_COLON
                 PFA_USLASHMOD:
000a9f 0590          .dw XT_TO_R
000aa0 05e5          .dw XT_ZERO
000aa1 0587          .dw XT_R_FROM
000aa2 0653          .dw XT_UMSLASHMOD
000aa3 04a6          .dw XT_EXIT
                 .include "words/negate.asm"
                 
                 ; Logic
                 ; 2-complement
                 VE_NEGATE:
000aa4 ff06          .dw $ff06
000aa5 656e
000aa6 6167
000aa7 6574          .db "negate"
000aa8 0a99          .dw VE_HEAD
                     .set VE_HEAD = VE_NEGATE
                 XT_NEGATE:
000aa9 0108          .dw DO_COLON
                 PFA_NEGATE:
000aaa 068e          .dw XT_INVERT
000aab 06c0          .dw XT_1PLUS
000aac 04a6          .dw XT_EXIT
                 .include "words/slash.asm"
                 
                 ; Arithmetics
                 ; divide n1 by n2. giving the quotient
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 
                 VE_SLASH:
000aad ff01          .dw $ff01
000aae 002f          .db "/",0
000aaf 0aa4          .dw VE_HEAD
                     .set VE_HEAD = VE_SLASH
                 XT_SLASH:
000ab0 0108          .dw DO_COLON
                 PFA_SLASH:
                 .endif
000ab1 0a69          .dw XT_SLASHMOD
000ab2 0581          .dw XT_NIP
000ab3 04a6          .dw XT_EXIT
                 
                 .include "words/mod.asm"
                 
                 ; Arithmetics
                 ; divide n1 by n2 giving the remainder n3
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 
                 VE_MOD:
000ab4 ff03          .dw $ff03
000ab5 6f6d
000ab6 0064          .db "mod",0
000ab7 0aad          .dw VE_HEAD
                     .set VE_HEAD = VE_MOD
                 XT_MOD:
000ab8 0108          .dw DO_COLON
                 PFA_MOD:
                 .endif
000ab9 0a69          .dw XT_SLASHMOD
000aba 056a          .dw XT_DROP
000abb 04a6          .dw XT_EXIT
                 .include "words/abs.asm"
                 
                 ; Arithmetics
                 ; get the absolute value
                 VE_ABS:
000abc ff03          .dw $ff03
000abd 6261
000abe 0073          .db "abs",0
000abf 0ab4          .dw VE_HEAD
                     .set VE_HEAD = VE_ABS
                 XT_ABS:
000ac0 0ac1          .dw PFA_ABS
                 PFA_ABS:
000ac1 2399          tst tosh
000ac2 f41a          brpl PFA_ABS1
000ac3 9580          com tosl
000ac4 9590          com tosh
000ac5 9601          adiw tosl, 1
                 PFA_ABS1:
000ac6 940c 010c     jmp_ do_next
                 .include "words/min.asm"
                 
                 ; Compare
                 ; compare two values leave the smaller one
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 
                 VE_MIN:
000ac8 ff03          .dw $ff03
000ac9 696d
000aca 006e          .db "min",0
000acb 0abc          .dw VE_HEAD
                     .set VE_HEAD = VE_MIN
                 XT_MIN:
000acc 0108          .dw DO_COLON
                 PFA_MIN:
                 .endif
000acd 09c7          .dw XT_2DUP
000ace 0609          .dw XT_GREATER
000acf 04bf          .dw XT_DOCONDBRANCH
000ad0 0ad2          DEST(PFA_MIN1)
000ad1 0555          .dw XT_SWAP
                 PFA_MIN1:
000ad2 056a          .dw XT_DROP
000ad3 04a6          .dw XT_EXIT
                 .include "words/max.asm"
                 
                 ; Compare
                 ; compare two values, leave the bigger one
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_MAX:
000ad4 ff03          .dw $ff03
000ad5 616d
000ad6 0078          .db "max",0
000ad7 0ac8          .dw VE_HEAD
                     .set VE_HEAD = VE_MAX
                 XT_MAX:
000ad8 0108          .dw DO_COLON
                 PFA_MAX:
                 
                 .endif
000ad9 09c7          .dw XT_2DUP
000ada 05ff          .dw XT_LESS
000adb 04bf          .dw XT_DOCONDBRANCH
000adc 0ade          DEST(PFA_MAX1)
000add 0555          .dw XT_SWAP
                 PFA_MAX1:
000ade 056a          .dw XT_DROP
000adf 04a6          .dw XT_EXIT
                 .include "words/within.asm"
                 
                 ; Compare
                 ; check if n is within min..max
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_WITHIN:
000ae0 ff06          .dw $ff06
000ae1 6977
000ae2 6874
000ae3 6e69          .db "within"
000ae4 0ad4          .dw VE_HEAD
                     .set VE_HEAD = VE_WITHIN
                 XT_WITHIN:
000ae5 0108          .dw DO_COLON
                 PFA_WITHIN:
                 .endif
000ae6 0560          .dw XT_OVER
000ae7 0624          .dw XT_MINUS
000ae8 0590          .dw XT_TO_R
000ae9 0624          .dw XT_MINUS
000aea 0587          .dw XT_R_FROM
000aeb 05ed          .dw XT_ULESS
000aec 04a6          .dw XT_EXIT
                 
                 .include "words/to-upper.asm"
                 
                 ; String
                 ; if c is a lowercase letter convert it to uppercase
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_TOUPPER:
000aed ff07          .dw $ff07 
000aee 6f74
000aef 7075
000af0 6570
000af1 0072          .db "toupper",0
000af2 0ae0          .dw VE_HEAD
                     .set VE_HEAD = VE_TOUPPER
                 XT_TOUPPER:
000af3 0108          .dw DO_COLON 
                 PFA_TOUPPER:
                 .endif
000af4 0542          .dw XT_DUP 
000af5 04c6          .dw XT_DOLITERAL 
000af6 0061          .dw 'a' 
000af7 04c6          .dw XT_DOLITERAL 
000af8 007b          .dw 'z'+1
000af9 0ae5          .dw XT_WITHIN 
000afa 04bf          .dw XT_DOCONDBRANCH
000afb 0aff          DEST(PFA_TOUPPER0)
000afc 04c6          .dw XT_DOLITERAL
000afd 00df          .dw 223 ; inverse of 0x20: 0xdf
000afe 06a4          .dw XT_AND 
                 PFA_TOUPPER0:
000aff 04a6          .dw XT_EXIT 
                 .include "words/to-lower.asm"
                 
                 ; String
                 ; if C is an uppercase letter convert it to lowercase
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 
                 VE_TOLOWER:
000b00 ff07          .dw $ff07
000b01 6f74
000b02 6f6c
000b03 6577
000b04 0072          .db "tolower",0
000b05 0aed          .dw VE_HEAD
                     .set VE_HEAD = VE_TOLOWER
                 XT_TOLOWER:
000b06 0108          .dw DO_COLON
                 PFA_TOLOWER:
                 .endif
000b07 0542          .dw XT_DUP
000b08 04c6          .dw XT_DOLITERAL
000b09 0041          .dw 'A'
000b0a 04c6          .dw XT_DOLITERAL
000b0b 005b          .dw 'Z'+1
000b0c 0ae5          .dw XT_WITHIN
000b0d 04bf          .dw XT_DOCONDBRANCH
000b0e 0b12          DEST(PFA_TOLOWER0)
000b0f 04c6          .dw XT_DOLITERAL
000b10 0020          .dw 32
000b11 06ad          .dw XT_OR 
                 PFA_TOLOWER0:
000b12 04a6          .dw XT_EXIT 
                 ;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/hld.asm"
                 
                 ; Numeric IO
                 ; pointer to current write position in the Pictured Numeric Output buffer
                 VE_HLD:
000b13 ff03          .dw $ff03
000b14 6c68
000b15 0064          .db "hld",0
000b16 0b00          .dw VE_HEAD
                     .set VE_HEAD = VE_HLD
                 XT_HLD:
000b17 04d4          .dw PFA_DOVARIABLE
                 PFA_HLD:
000b18 0223          .dw ram_hld
                 
                 .dseg
000223           ram_hld: .byte 2
                 .cseg
                 .include "words/hold.asm"
                 
                 ; Numeric IO
                 ; prepend character to pictured numeric output buffer
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_HOLD:
000b19 ff04          .dw $ff04
000b1a 6f68
000b1b 646c          .db "hold"
000b1c 0b13          .dw VE_HEAD
                     .set VE_HEAD = VE_HOLD
                 XT_HOLD:
000b1d 0108          .dw DO_COLON
                 PFA_HOLD:
                 .endif
000b1e 0b17          .dw XT_HLD
000b1f 0542          .dw XT_DUP
000b20 050a          .dw XT_FETCH
000b21 06c6          .dw XT_1MINUS
000b22 0542          .dw XT_DUP
000b23 0590          .dw XT_TO_R
000b24 0555          .dw XT_SWAP
000b25 0512          .dw XT_STORE
000b26 0587          .dw XT_R_FROM
000b27 051e          .dw XT_CSTORE
000b28 04a6          .dw XT_EXIT
                 .include "words/less-sharp.asm" ; <#
                 
                 ; Numeric IO
                 ; initialize the pictured numeric output conversion process
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_L_SHARP:
000b29 ff02          .dw $ff02
000b2a 233c          .db "<#"
000b2b 0b19          .dw VE_HEAD
                     .set VE_HEAD = VE_L_SHARP
                 XT_L_SHARP:
000b2c 0108          .dw DO_COLON
                 PFA_L_SHARP:
                 .endif
000b2d 09ec          .dw XT_PAD
000b2e 0b17          .dw XT_HLD
000b2f 0512          .dw XT_STORE
000b30 04a6          .dw XT_EXIT
                 .include "words/sharp.asm"
                 
                 ; Numeric IO
                 ; pictured numeric output: convert one digit
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 
                 VE_SHARP:
000b31 ff01          .dw $ff01
000b32 0023          .db "#",0
000b33 0b29          .dw VE_HEAD
                     .set VE_HEAD = VE_SHARP
                 XT_SHARP:
000b34 0108          .dw DO_COLON
                 PFA_SHARP:
                 .endif
000b35 09b2          .dw XT_BASE
000b36 050a          .dw XT_FETCH
000b37 0bb1          .dw XT_UDSLASHMOD
000b38 0572          .dw XT_ROT
000b39 04c6          .dw XT_DOLITERAL
000b3a 0009          .dw 9
000b3b 0560          .dw XT_OVER
000b3c 05ff          .dw XT_LESS
000b3d 04bf          .dw XT_DOCONDBRANCH
000b3e 0b42          DEST(PFA_SHARP1)
000b3f 04c6          .dw XT_DOLITERAL
000b40 0007          .dw 7
000b41 062e          .dw XT_PLUS
                 PFA_SHARP1:
000b42 04c6          .dw XT_DOLITERAL
000b43 0030          .dw 48 ; ASCII 0
000b44 062e          .dw XT_PLUS
000b45 0b1d          .dw XT_HOLD
000b46 04a6          .dw XT_EXIT
                 ; : #    ( ud1 -- ud2 ) 
                 ;        base @ ud/mod rot 9 over < if 7 + then 30 + hold ; 
                 .include "words/sharp-s.asm"
                 
                 ; Numeric IO
                 ; pictured numeric output: convert all digits until 0 (zero) is reached
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SHARP_S:
000b47 ff02          .dw $ff02
000b48 7323          .db "#s"
000b49 0b31          .dw VE_HEAD
                     .set VE_HEAD = VE_SHARP_S
                 XT_SHARP_S:
000b4a 0108          .dw DO_COLON
                 PFA_SHARP_S:
                 .endif
                 NUMS1:
000b4b 0b34          .dw XT_SHARP
000b4c 09c7          .dw XT_2DUP
000b4d 06ad          .dw XT_OR
000b4e 05ab          .dw XT_ZEROEQUAL
000b4f 04bf          .dw XT_DOCONDBRANCH
000b50 0b4b          DEST(NUMS1) ; PFA_SHARP_S
000b51 04a6          .dw XT_EXIT
                 .include "words/sharp-greater.asm" ; #>
                 
                 ; Numeric IO
                 ; Pictured Numeric Output: convert PNO buffer into an string
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SHARP_G:
000b52 ff02          .dw $ff02
000b53 3e23          .db "#>"
000b54 0b47          .dw VE_HEAD
                     .set VE_HEAD = VE_SHARP_G
                 XT_SHARP_G:
000b55 0108          .dw DO_COLON
                 PFA_SHARP_G:
                 .endif
000b56 09d0          .dw XT_2DROP
000b57 0b17          .dw XT_HLD
000b58 050a          .dw XT_FETCH
000b59 09ec          .dw XT_PAD
000b5a 0560          .dw XT_OVER
000b5b 0624          .dw XT_MINUS
000b5c 04a6          .dw XT_EXIT
                 .include "words/sign.asm"
                 
                 ; Numeric IO
                 ; place a - in HLD if n is negative
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SIGN:
000b5d ff04          .dw $ff04
000b5e 6973
000b5f 6e67          .db "sign"
000b60 0b52          .dw VE_HEAD
                     .set VE_HEAD = VE_SIGN
                 XT_SIGN:
000b61 0108          .dw DO_COLON
                 PFA_SIGN:
                 .endif
000b62 05b2          .dw XT_ZEROLESS
000b63 04bf          .dw XT_DOCONDBRANCH
000b64 0b68          DEST(PFA_SIGN1)
000b65 04c6          .dw XT_DOLITERAL
000b66 002d          .dw 45 ; ascii -
000b67 0b1d          .dw XT_HOLD
                 PFA_SIGN1:
000b68 04a6          .dw XT_EXIT
                 .include "words/d-dot-r.asm"
                 
                 ; Numeric IO
                 ; singed PNO with double cell numbers, right aligned in width w
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DDOTR:
000b69 ff03          .dw $ff03
000b6a 2e64
000b6b 0072          .db "d.r",0
000b6c 0b5d          .dw VE_HEAD
                     .set VE_HEAD = VE_DDOTR
                 XT_DDOTR:
000b6d 0108          .dw DO_COLON
                 PFA_DDOTR:
                 
                 .endif
000b6e 0590          .dw XT_TO_R
000b6f 09d8          .dw XT_TUCK
000b70 112b          .dw XT_DABS
000b71 0b2c          .dw XT_L_SHARP
000b72 0b4a          .dw XT_SHARP_S
000b73 0572          .dw XT_ROT
000b74 0b61          .dw XT_SIGN
000b75 0b55          .dw XT_SHARP_G
000b76 0587          .dw XT_R_FROM
000b77 0560          .dw XT_OVER
000b78 0624          .dw XT_MINUS
000b79 0c59          .dw XT_SPACES
000b7a 0c69          .dw XT_TYPE
000b7b 04a6          .dw XT_EXIT
                 ; : d.r       ( d n -- )
                 ;             >r swap over dabs <# #s rot sign #> r> over - spaces type ;
                 .include "words/dot-r.asm"
                 
                 ; Numeric IO
                 ; singed PNO with single cell numbers, right aligned in width w
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DOTR:
000b7c ff02          .dw $ff02
000b7d 722e          .db ".r"
000b7e 0b69          .dw VE_HEAD
                     .set VE_HEAD = VE_DOTR
                 XT_DOTR:
000b7f 0108          .dw DO_COLON
                 PFA_DOTR:
                 
                 .endif
000b80 0590          .dw XT_TO_R
000b81 1248          .dw XT_S2D
000b82 0587          .dw XT_R_FROM
000b83 0b6d          .dw XT_DDOTR
000b84 04a6          .dw XT_EXIT
                 ; : .r        ( s n -- )  >r s>d r> d.r ;
                 .include "words/d-dot.asm"
                 
                 ; Numeric IO
                 ; singed PNO with double cell numbers
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DDOT:
000b85 ff02          .dw $ff02
000b86 2e64          .db "d."
000b87 0b7c          .dw VE_HEAD
                     .set VE_HEAD = VE_DDOT
                 XT_DDOT:
000b88 0108          .dw DO_COLON
                 PFA_DDOT:
                 
                 .endif
000b89 05e5          .dw XT_ZERO
000b8a 0b6d          .dw XT_DDOTR
000b8b 0c50          .dw XT_SPACE
000b8c 04a6          .dw XT_EXIT
                 ; : d.        ( d -- )    0 d.r space ;
                 .include "words/dot.asm"
                 
                 ; Numeric IO
                 ; singed PNO with single cell numbers
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 
                 VE_DOT:
000b8d ff01          .dw $ff01
000b8e 002e          .db ".",0
000b8f 0b85          .dw VE_HEAD
                     .set VE_HEAD = VE_DOT
                 XT_DOT:
000b90 0108          .dw DO_COLON
                 PFA_DOT:
                 .endif
000b91 1248          .dw XT_S2D
000b92 0b88          .dw XT_DDOT
000b93 04a6          .dw XT_EXIT
                 ; : .         ( s -- )    s>d d. ; 
                 .include "words/ud-dot.asm"
                 
                 ; Numeric IO
                 ; unsigned PNO with double cell numbers
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_UDDOT:
000b94 ff03          .dw $ff03
000b95 6475
000b96 002e          .db "ud.",0
000b97 0b8d          .dw VE_HEAD
                     .set VE_HEAD = VE_UDDOT
                 XT_UDDOT:
000b98 0108          .dw DO_COLON
                 PFA_UDDOT:
                 .endif
000b99 05e5          .dw XT_ZERO
000b9a 0ba1          .dw XT_UDDOTR
000b9b 0c50          .dw XT_SPACE
000b9c 04a6          .dw XT_EXIT
                 .include "words/ud-dot-r.asm"
                 
                 ; Numeric IO
                 ; unsigned PNO with double cell numbers, right aligned in width w
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 
                 VE_UDDOTR:
000b9d ff04          .dw $ff04
000b9e 6475
000b9f 722e          .db "ud.r"
000ba0 0b94          .dw VE_HEAD
                     .set VE_HEAD = VE_UDDOTR
                 XT_UDDOTR:
000ba1 0108          .dw DO_COLON
                 PFA_UDDOTR:
                 .endif
000ba2 0590          .dw XT_TO_R
000ba3 0b2c          .dw XT_L_SHARP
000ba4 0b4a          .dw XT_SHARP_S
000ba5 0b55          .dw XT_SHARP_G
000ba6 0587          .dw XT_R_FROM
000ba7 0560          .dw XT_OVER
000ba8 0624          .dw XT_MINUS
000ba9 0c59          .dw XT_SPACES
000baa 0c69          .dw XT_TYPE
000bab 04a6          .dw XT_EXIT
                 .include "words/ud-slash-mod.asm"
                 
                 ; Arithmetics
                 ; unsigned double cell division with remainder
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_UDSLASHMOD:
000bac ff06          .dw $ff06
000bad 6475
000bae 6d2f
000baf 646f          .db "ud/mod"
000bb0 0b9d          .dw VE_HEAD
                     .set VE_HEAD = VE_UDSLASHMOD
                 XT_UDSLASHMOD:
000bb1 0108          .dw DO_COLON
                 PFA_UDSLASHMOD:
                 .endif
000bb2 0590          .dw XT_TO_R
000bb3 05e5          .dw XT_ZERO
000bb4 0599          .dw XT_R_FETCH
000bb5 0653          .dw XT_UMSLASHMOD
000bb6 0587          .dw XT_R_FROM
000bb7 0555          .dw XT_SWAP
000bb8 0590          .dw XT_TO_R
000bb9 0653          .dw XT_UMSLASHMOD
000bba 0587          .dw XT_R_FROM
000bbb 04a6          .dw XT_EXIT
                 .include "words/digit-q.asm"
                 
                 ; Numeric IO
                 ; tries to convert a character to a number, set flag accordingly
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DIGITQ:
000bbc ff06          .dw $ff06 
000bbd 6964
000bbe 6967
000bbf 3f74          .db "digit?"
000bc0 0bac          .dw VE_HEAD
                     .set VE_HEAD = VE_DIGITQ
                 XT_DIGITQ:
000bc1 0108          .dw DO_COLON 
                 PFA_DIGITQ:
                 .endif
000bc2 0af3          .dw XT_TOUPPER
000bc3 0542
000bc4 04c6
000bc5 0039
000bc6 0609
000bc7 04c6
000bc8 0100          .DW XT_DUP,XT_DOLITERAL,57,XT_GREATER,XT_DOLITERAL,256
000bc9 06a4
000bca 062e
000bcb 0542
000bcc 04c6
000bcd 0140
000bce 0609          .DW XT_AND,XT_PLUS,XT_DUP,XT_DOLITERAL,320,XT_GREATER
000bcf 04c6
000bd0 0107
000bd1 06a4
000bd2 0624
000bd3 04c6
000bd4 0030          .DW XT_DOLITERAL,263,XT_AND,XT_MINUS,XT_DOLITERAL,48
000bd5 0624
000bd6 0542
000bd7 09b2
000bd8 050a
000bd9 05ed          .DW XT_MINUS,XT_DUP,XT_BASE,XT_FETCH,XT_ULESS
000bda 04a6          .DW XT_EXIT
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/do-sliteral.asm"
                 
                 ; String
                 ; runtime portion of sliteral
                 ;VE_DOSLITERAL:
                 ;  .dw $ff0a
                 ;  .db "(sliteral)"
                 ;  .dw VE_HEAD
                 ;  .set VE_HEAD = VE_DOSLITERAL
                 XT_DOSLITERAL:
000bdb 0108        .dw DO_COLON
                 PFA_DOSLITERAL:
000bdc 0599        .dw XT_R_FETCH   ; ( -- addr )
000bdd 0c3a        .dw XT_ICOUNT
000bde 0587        .dw XT_R_FROM
000bdf 0560        .dw XT_OVER     ; ( -- addr' n addr n)
000be0 06c0        .dw XT_1PLUS
000be1 0695        .dw XT_2SLASH   ; ( -- addr' n addr k )
000be2 062e        .dw XT_PLUS     ; ( -- addr' n addr'' )
000be3 06c0        .dw XT_1PLUS
000be4 0590        .dw XT_TO_R     ; ( -- )
000be5 04a6        .dw XT_EXIT
                 .include "words/scomma.asm"
                 
                 ; Compiler
                 ; compiles a string from RAM to Flash
                 VE_SCOMMA:
000be6 ff02        .dw $ff02
000be7 2c73        .db "s",$2c
000be8 0bbc        .dw VE_HEAD
                   .set VE_HEAD = VE_SCOMMA
                 XT_SCOMMA:
000be9 0108          .dw DO_COLON
                 PFA_SCOMMA:
000bea 0542          .dw XT_DUP
000beb 0bed          .dw XT_DOSCOMMA
000bec 04a6          .dw XT_EXIT
                 
                 ; ( addr len len' -- ) 
                 ; Compiler
                 ; compiles a string from RAM to Flash
                 ;VE_DOSCOMMA:
                 ;  .dw $ff04
                 ;  .db "(s",$2c,")"
                 ;  .dw VE_HEAD
                 ;  .set VE_HEAD = VE_DOSCOMMA
                 XT_DOSCOMMA:
000bed 0108          .dw DO_COLON
                 PFA_DOSCOMMA:
000bee 01d2          .dw XT_COMMA
000bef 0542          .dw XT_DUP   ; ( --addr len len)
000bf0 0695          .dw XT_2SLASH ; ( -- addr len len/2
000bf1 09d8          .dw XT_TUCK   ; ( -- addr len/2 len len/2
000bf2 069c          .dw XT_2STAR  ; ( -- addr len/2 len len'
000bf3 0624          .dw XT_MINUS  ; ( -- addr len/2 rem
000bf4 0590          .dw XT_TO_R
000bf5 05e5          .dw XT_ZERO
000bf6 0291          .dw XT_QDOCHECK
000bf7 04bf          .dw XT_DOCONDBRANCH
000bf8 0c00          .dw PFA_SCOMMA2
000bf9 0720          .dw XT_DODO
                 PFA_SCOMMA1:
000bfa 0542          .dw XT_DUP         ; ( -- addr addr )
000bfb 050a          .dw XT_FETCH       ; ( -- addr c1c2 )
000bfc 01d2          .dw XT_COMMA       ; ( -- addr )
000bfd 09bf          .dw XT_CELLPLUS    ; ( -- addr+cell )
000bfe 074e          .dw XT_DOLOOP
000bff 0bfa          .dw PFA_SCOMMA1
                 PFA_SCOMMA2:
000c00 0587          .dw XT_R_FROM
000c01 05b9          .dw XT_GREATERZERO
000c02 04bf          .dw XT_DOCONDBRANCH
000c03 0c07          .dw PFA_SCOMMA3
000c04 0542            .dw XT_DUP     ; well, tricky
000c05 0529            .dw XT_CFETCH
000c06 01d2            .dw XT_COMMA
                 PFA_SCOMMA3:
000c07 056a          .dw XT_DROP        ; ( -- )
000c08 04a6          .dw XT_EXIT
                 .include "words/itype.asm"
                 
                 ; Tools
                 ; reads string from flash and prints it
                 VE_ITYPE:
000c09 ff05          .dw $ff05
000c0a 7469
000c0b 7079
000c0c 0065          .db "itype",0
000c0d 0be6          .dw VE_HEAD
                     .set VE_HEAD = VE_ITYPE
                 XT_ITYPE:
000c0e 0108          .dw DO_COLON
                 PFA_ITYPE:
000c0f 0542          .dw XT_DUP    ; ( --addr len len)
000c10 0695          .dw XT_2SLASH ; ( -- addr len len/2
000c11 09d8          .dw XT_TUCK   ; ( -- addr len/2 len len/2
000c12 069c          .dw XT_2STAR  ; ( -- addr len/2 len len'
000c13 0624          .dw XT_MINUS  ; ( -- addr len/2 rem
000c14 0590          .dw XT_TO_R
000c15 05e5          .dw XT_ZERO
000c16 0291          .dw XT_QDOCHECK
000c17 04bf          .dw XT_DOCONDBRANCH
000c18 0c22          .dw PFA_ITYPE2
000c19 0720          .dw XT_DODO
                 PFA_ITYPE1:
000c1a 0542          .dw XT_DUP         ; ( -- addr addr )
000c1b 0818          .dw XT_FETCHI      ; ( -- addr c1c2 )
000c1c 0542          .dw XT_DUP
000c1d 0c2f          .dw XT_LOWEMIT
000c1e 0c2b          .dw XT_HIEMIT
000c1f 06c0          .dw XT_1PLUS    ; ( -- addr+cell )
000c20 074e          .dw XT_DOLOOP
000c21 0c1a          .dw PFA_ITYPE1
                 PFA_ITYPE2:
000c22 0587          .dw XT_R_FROM
000c23 05b9          .dw XT_GREATERZERO
000c24 04bf          .dw XT_DOCONDBRANCH
000c25 0c29          .dw PFA_ITYPE3
000c26 0542            .dw XT_DUP     ; make sure the drop below has always something to do
000c27 0818            .dw XT_FETCHI
000c28 0c2f            .dw XT_LOWEMIT
                 PFA_ITYPE3:
000c29 056a          .dw XT_DROP
000c2a 04a6          .dw XT_EXIT
                 
                 ; ( w -- )
                 ; R( -- )
                 ; content of cell fetched on stack.
                 ;VE_HIEMIT:
                 ;    .dw $ff06
                 ;    .db "hiemit"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_HIEMIT
                 XT_HIEMIT:
000c2b 0108          .dw DO_COLON
                 PFA_HIEMIT:
000c2c 077e          .dw XT_BYTESWAP
000c2d 0c2f          .dw XT_LOWEMIT
000c2e 04a6          .dw XT_EXIT
                 
                 ; ( w -- )
                 ; R( -- )
                 ; content of cell fetched on stack.
                 ;VE_LOWEMIT:
                 ;    .dw $ff07
                 ;    .db "lowemit"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_LOWEMIT
                 XT_LOWEMIT:
000c2f 0108          .dw DO_COLON
                 PFA_LOWEMIT:
000c30 04c6          .dw XT_DOLITERAL
000c31 00ff          .dw $00ff
000c32 06a4          .dw XT_AND
000c33 09f6          .dw XT_EMIT
000c34 04a6          .dw XT_EXIT
                 .include "words/icount.asm"
                 
                 ; Tools
                 ; get count information out of a counted string in flash
                 VE_ICOUNT:
000c35 ff06          .dw $ff06
000c36 6369
000c37 756f
000c38 746e          .db "icount"
000c39 0c09          .dw VE_HEAD
                     .set VE_HEAD = VE_ICOUNT
                 XT_ICOUNT:
000c3a 0108          .dw DO_COLON
                 PFA_ICOUNT:
000c3b 0542          .dw XT_DUP
000c3c 06c0          .dw XT_1PLUS
000c3d 0555          .dw XT_SWAP
000c3e 0818          .dw XT_FETCHI
000c3f 04a6          .dw XT_EXIT
                 .include "words/cr.asm"
                 
                 ; Character IO
                 ; cause subsequent output appear at the beginning of the next line
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_CR:
000c40 ff02          .dw 0xff02
000c41 7263          .db "cr"
000c42 0c35          .dw VE_HEAD
                     .set VE_HEAD = VE_CR
                 XT_CR:
000c43 0108          .dw DO_COLON
                 PFA_CR:
                 .endif
                 
000c44 04c6          .dw XT_DOLITERAL
000c45 000d          .dw 13
000c46 09f6          .dw XT_EMIT
000c47 04c6          .dw XT_DOLITERAL
000c48 000a          .dw 10
000c49 09f6          .dw XT_EMIT
000c4a 04a6          .dw XT_EXIT
                 .include "words/space.asm"
                 
                 ; Character IO
                 ; emits a space (bl)
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SPACE:
000c4b ff05          .dw $ff05
000c4c 7073
000c4d 6361
000c4e 0065          .db "space",0
000c4f 0c40          .dw VE_HEAD
                     .set VE_HEAD = VE_SPACE
                 XT_SPACE:
000c50 0108          .dw DO_COLON
                 PFA_SPACE:
                 .endif
000c51 0a59          .dw XT_BL
000c52 09f6          .dw XT_EMIT
000c53 04a6          .dw XT_EXIT
                 .include "words/spaces.asm"
                 
                 ; Character IO
                 ; emits n space(s) (bl)
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SPACES:
000c54 ff06          .dw $ff06
000c55 7073
000c56 6361
000c57 7365          .db "spaces"
000c58 0c4b          .dw VE_HEAD
                     .set VE_HEAD = VE_SPACES
                 XT_SPACES:
000c59 0108          .dw DO_COLON
                 PFA_SPACES:
                 
                 .endif
                 ;C SPACES   n --            output n spaces
                 ;   BEGIN DUP 0> WHILE SPACE 1- REPEAT DROP ;
000c5a 05e5
000c5b 0ad8      	.DW XT_ZERO, XT_MAX
000c5c 0542
000c5d 04bf      SPCS1:  .DW XT_DUP,XT_DOCONDBRANCH
000c5e 0c63              DEST(SPCS2)
000c5f 0c50
000c60 06c6
000c61 04b5              .DW XT_SPACE,XT_1MINUS,XT_DOBRANCH
000c62 0c5c              DEST(SPCS1)
000c63 056a
000c64 04a6      SPCS2:  .DW XT_DROP,XT_EXIT
                 .include "words/type.asm"
                 
                 ; Character IO
                 ; print a RAM based string
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_TYPE:
000c65 ff04          .dw $ff04
000c66 7974
000c67 6570          .db "type"
000c68 0c54          .dw VE_HEAD
                     .set VE_HEAD = VE_TYPE
                 XT_TYPE:
000c69 0108          .dw DO_COLON
                 PFA_TYPE:
                 
                 .endif
000c6a 123f          .dw XT_BOUNDS
000c6b 0291          .dw XT_QDOCHECK
000c6c 04bf          .dw XT_DOCONDBRANCH
000c6d 0c74          DEST(PFA_TYPE2)
000c6e 0720          .dw XT_DODO
                 PFA_TYPE1:
000c6f 0731          .dw XT_I
000c70 0529          .dw XT_CFETCH
000c71 09f6          .dw XT_EMIT
000c72 074e          .dw XT_DOLOOP
000c73 0c6f          DEST(PFA_TYPE1)
                 PFA_TYPE2:
000c74 04a6          .dw XT_EXIT
                 .include "words/tick.asm"
                 
                 ; Dictionary
                 ; search dictionary for name, return XT or throw an exception -13
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_TICK:
000c75 ff01          .dw $ff01
000c76 0027          .db "'",0
000c77 0c65          .dw VE_HEAD
                     .set VE_HEAD = VE_TICK
                 XT_TICK:
000c78 0108          .dw DO_COLON
                 PFA_TICK:
                 .endif
000c79 0e1b          .dw XT_PARSENAME
000c7a 0f19          .dw XT_DORECOGNIZER
000c7b 0f83          .dw XT_R_WORD
000c7c 1264          .dw XT_EQUAL
000c7d 04bf          .dw XT_DOCONDBRANCH
000c7e 0c81          DEST(PFA_TICK1)
000c7f 056a          .dw XT_DROP
000c80 04a6          .dw XT_EXIT
                 PFA_TICK1:
000c81 04c6          .dw XT_DOLITERAL
000c82 fff3          .dw -13
000c83 0ca7          .dw XT_THROW
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/handler.asm"
                 
                 ; Exceptions
                 ; USER variable used by catch/throw
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_HANDLER:
000c84 ff07          .dw $ff07
000c85 6168
000c86 646e
000c87 656c
000c88 0072          .db "handler",0
000c89 0c75          .dw VE_HEAD
                     .set VE_HEAD = VE_HANDLER
                 XT_HANDLER:
000c8a 04e7          .dw PFA_DOUSER
                 PFA_HANDLER:
                 .endif
000c8b 000a          .dw USER_HANDLER
                 .include "words/catch.asm"
                 
                 ; Exceptions
                 ; execute XT and check for exceptions.
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_CATCH:
000c8c ff05          .dw $ff05
000c8d 6163
000c8e 6374
000c8f 0068          .db "catch",0
000c90 0c84          .dw VE_HEAD
                     .set VE_HEAD = VE_CATCH
                 XT_CATCH:
000c91 0108          .dw DO_COLON
                 PFA_CATCH:
                 .endif
                 
                     ; sp@ >r
000c92 0712          .dw XT_SP_FETCH
000c93 0590          .dw XT_TO_R
                     ; handler @ >r
000c94 0c8a          .dw XT_HANDLER
000c95 050a          .dw XT_FETCH
000c96 0590          .dw XT_TO_R
                     ; rp@ handler !
000c97 06fb          .dw XT_RP_FETCH
000c98 0c8a          .dw XT_HANDLER
000c99 0512          .dw XT_STORE
000c9a 04b0          .dw XT_EXECUTE
                     ; r> handler !
000c9b 0587          .dw XT_R_FROM
000c9c 0c8a          .dw XT_HANDLER
000c9d 0512          .dw XT_STORE
000c9e 0587          .dw XT_R_FROM
000c9f 056a          .dw XT_DROP
000ca0 05e5          .dw XT_ZERO
000ca1 04a6          .dw XT_EXIT
                 .include "words/throw.asm"
                 
                 ; Exceptions
                 ; throw an exception
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_THROW:
000ca2 ff05          .dw $ff05
000ca3 6874
000ca4 6f72
000ca5 0077          .db "throw",0
000ca6 0c8c          .dw VE_HEAD
                     .set VE_HEAD = VE_THROW
                 XT_THROW:
000ca7 0108          .dw DO_COLON
                 PFA_THROW:
                 .endif
000ca8 0542          .dw XT_DUP
000ca9 05ab          .dw XT_ZEROEQUAL
000caa 04bf          .dw XT_DOCONDBRANCH
000cab 0cae          DEST(PFA_THROW1)
000cac 056a      	.dw XT_DROP
000cad 04a6      	.dw XT_EXIT
                 PFA_THROW1:
000cae 0c8a          .dw XT_HANDLER
000caf 050a          .dw XT_FETCH
000cb0 0705          .dw XT_RP_STORE
000cb1 0587          .dw XT_R_FROM
000cb2 0c8a          .dw XT_HANDLER
000cb3 0512          .dw XT_STORE
000cb4 0587          .dw XT_R_FROM
000cb5 0555          .dw XT_SWAP
000cb6 0590          .dw XT_TO_R
000cb7 071b          .dw XT_SP_STORE
000cb8 056a          .dw XT_DROP
000cb9 0587          .dw XT_R_FROM    
000cba 04a6          .dw XT_EXIT
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/cskip.asm"
                 
                 ; String
                 ; skips leading occurancies in string at addr1/n1 leaving addr2/n2 pointing to the 1st non-c character
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_CSKIP:
000cbb ff05          .dw $ff05
000cbc 7363
000cbd 696b
000cbe 0070          .db "cskip",0
000cbf 0ca2          .dw VE_HEAD
                     .set VE_HEAD = VE_CSKIP
                 XT_CSKIP:
000cc0 0108          .dw DO_COLON
                 PFA_CSKIP:
                 .endif
000cc1 0590          .dw XT_TO_R           ; ( -- addr1 n1 )
                 PFA_CSKIP1:
000cc2 0542          .dw XT_DUP            ; ( -- addr' n' n' )
000cc3 04bf          .dw XT_DOCONDBRANCH   ; ( -- addr' n')
000cc4 0cd0          DEST(PFA_CSKIP2)
000cc5 0560          .dw XT_OVER           ; ( -- addr' n' addr' )
000cc6 0529          .dw XT_CFETCH         ; ( -- addr' n' c' )
000cc7 0599          .dw XT_R_FETCH        ; ( -- addr' n' c' c )
000cc8 1264          .dw XT_EQUAL          ; ( -- addr' n' f )
000cc9 04bf          .dw XT_DOCONDBRANCH   ; ( -- addr' n')
000cca 0cd0          DEST(PFA_CSKIP2)
000ccb 04c6          .dw XT_DOLITERAL
000ccc 0001          .dw 1
000ccd 0e0c          .dw XT_SLASHSTRING
000cce 04b5          .dw XT_DOBRANCH
000ccf 0cc2          DEST(PFA_CSKIP1)
                 PFA_CSKIP2:
000cd0 0587          .dw XT_R_FROM
000cd1 056a          .dw XT_DROP           ; ( -- addr2 n2)
000cd2 04a6          .dw XT_EXIT
                 .include "words/cscan.asm"
                 
                 ; String
                 ; Scan string at addr1/n1 for the first occurance of c, leaving addr1/n2, char at n2 is first non-c character
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_CSCAN:
000cd3 ff05          .dw $ff05
000cd4 7363
000cd5 6163
../../common\words/cscan.asm(12): warning: .cseg .db misalignment - padding zero byte
000cd6 006e          .db "cscan"
000cd7 0cbb          .dw VE_HEAD
                     .set VE_HEAD = VE_CSCAN
                 XT_CSCAN:
000cd8 0108          .dw DO_COLON
                 PFA_CSCAN:
                 .endif
000cd9 0590          .dw XT_TO_R
000cda 0560          .dw XT_OVER
                 PFA_CSCAN1:
000cdb 0542          .dw XT_DUP
000cdc 0529          .dw XT_CFETCH
000cdd 0599          .dw XT_R_FETCH
000cde 1264          .dw XT_EQUAL
000cdf 05ab          .dw XT_ZEROEQUAL
000ce0 04bf          .dw XT_DOCONDBRANCH
000ce1 0ced          DEST(PFA_CSCAN2)
000ce2 0555            .dw XT_SWAP
000ce3 06c6            .dw XT_1MINUS
000ce4 0555            .dw XT_SWAP
000ce5 0560            .dw XT_OVER
000ce6 05b2            .dw XT_ZEROLESS ; not negative
000ce7 05ab            .dw XT_ZEROEQUAL
000ce8 04bf            .dw XT_DOCONDBRANCH
000ce9 0ced            DEST(PFA_CSCAN2)
000cea 06c0              .dw XT_1PLUS
000ceb 04b5              .dw XT_DOBRANCH
000cec 0cdb              DEST(PFA_CSCAN1)
                 PFA_CSCAN2:
000ced 0581          .dw XT_NIP
000cee 0560          .dw XT_OVER
000cef 0624          .dw XT_MINUS
000cf0 0587          .dw XT_R_FROM
000cf1 056a          .dw XT_DROP
000cf2 04a6          .dw XT_EXIT
                 
                 ; : my-cscan ( addr len c -- addr len' )
                 ;    >r over ( -- addr len addr )
                 ;    begin
                 ;      dup c@ r@ <> while
                 ;       swap 1- swap over 0 >=  while
                 ;        1+ 
                 ;     repeat then
                 ;     nip over - r> drop 
                 ; ;
                 .include "words/accept.asm"
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_ACCEPT:
000cf3 ff06          .dw $ff06
000cf4 6361
000cf5 6563
000cf6 7470          .db "accept"
000cf7 0cd3          .dw VE_HEAD
                     .set VE_HEAD = VE_ACCEPT
                 XT_ACCEPT:
000cf8 0108          .dw DO_COLON
                 PFA_ACCEPT:
                 
                 .endif
000cf9 0560
000cfa 062e
000cfb 06c6
000cfc 0560              .DW XT_OVER,XT_PLUS,XT_1MINUS,XT_OVER
000cfd 0a07
000cfe 0542
000cff 0d32
000d00 05ab
000d01 04bf      ACC1:   .DW XT_KEY,XT_DUP,XT_CRLFQ,XT_ZEROEQUAL,XT_DOCONDBRANCH
000d02 0d24              DEST(ACC5)
000d03 0542
000d04 04c6
000d05 0008
000d06 1264
000d07 04bf              .DW XT_DUP,XT_DOLITERAL,8,XT_EQUAL,XT_DOCONDBRANCH
000d08 0d1b              DEST(ACC3)
000d09 056a
000d0a 0572
000d0b 09c7
000d0c 0609
000d0d 0590
000d0e 0572
000d0f 0572
000d10 0587
000d11 04bf              .DW XT_DROP,XT_ROT,XT_2DUP,XT_GREATER,XT_TO_R,XT_ROT,XT_ROT,XT_R_FROM,XT_DOCONDBRANCH
000d12 0d19      	DEST(ACC6)
000d13 0d2a
000d14 06c6
000d15 0590
000d16 0560
000d17 0587
000d18 014c      	.DW XT_BS,XT_1MINUS,XT_TO_R,XT_OVER,XT_R_FROM,XT_UMAX
                 ACC6:
000d19 04b5              .DW XT_DOBRANCH
000d1a 0d22              DEST(ACC4)
000d1b 0542
000d1c 09f6
000d1d 0560
000d1e 051e
000d1f 06c0
000d20 0560
000d21 0158      ACC3:   .DW XT_DUP,XT_EMIT,XT_OVER,XT_CSTORE,XT_1PLUS,XT_OVER,XT_UMIN
000d22 04b5      ACC4:   .DW XT_DOBRANCH
000d23 0cfd              DEST(ACC1)
000d24 056a
000d25 0581
000d26 0555
000d27 0624
000d28 0c43
000d29 04a6      ACC5:   .DW XT_DROP,XT_NIP,XT_SWAP,XT_MINUS,XT_CR,XT_EXIT
                 
                 
                 ; ( --  ) 
                 ; System
                 ; send a backspace character to overwrite the current char
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 ;VE_BS:
                 ;    .dw $ff02
                 ;    .db "bs"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_BS
                 XT_BS:
000d2a 0108          .dw DO_COLON
                 .endif
000d2b 04c6          .dw XT_DOLITERAL
000d2c 0008          .dw 8
000d2d 0542          .dw XT_DUP
000d2e 09f6          .dw XT_EMIT
000d2f 0c50          .dw XT_SPACE
000d30 09f6          .dw XT_EMIT
000d31 04a6          .dw XT_EXIT
                 
                 
                 ; ( c -- f ) 
                 ; System
                 ; is the character a line end character?
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 ;VE_CRLFQ:
                 ;    .dw $ff02
                 ;    .db "crlf?"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_CRLFQ
                 XT_CRLFQ:
000d32 0108          .dw DO_COLON
                 .endif
000d33 0542          .dw XT_DUP
000d34 04c6          .dw XT_DOLITERAL
000d35 000d          .dw 13
000d36 1264          .dw XT_EQUAL
000d37 0555          .dw XT_SWAP
000d38 04c6          .dw XT_DOLITERAL
000d39 000a          .dw 10
000d3a 1264          .dw XT_EQUAL
000d3b 06ad          .dw XT_OR
000d3c 04a6          .dw XT_EXIT
                 .include "words/refill.asm"
                 
                 ; System
                 ; refills the input buffer
                 VE_REFILL:
000d3d ff06          .dw $ff06
000d3e 6572
000d3f 6966
000d40 6c6c          .db "refill"
000d41 0cf3          .dw VE_HEAD
                     .set VE_HEAD = VE_REFILL
                 XT_REFILL:
000d42 106a          .dw PFA_DODEFER1
                 PFA_REFILL:
000d43 001a          .dw USER_REFILL
000d44 1033          .dw XT_UDEFERFETCH
000d45 103f          .dw XT_UDEFERSTORE
                 
                 .include "words/char.asm"
                 
                 ; Tools
                 ; copy the first character of the next word onto the stack
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_CHAR:
000d46 ff04          .dw $ff04
000d47 6863
000d48 7261          .db "char"
000d49 0d3d          .dw VE_HEAD
                     .set VE_HEAD = VE_CHAR
                 XT_CHAR:
000d4a 0108          .dw DO_COLON
                 PFA_CHAR:
                 .endif
000d4b 0e1b          .dw XT_PARSENAME
000d4c 056a          .dw XT_DROP
000d4d 0529          .dw XT_CFETCH
000d4e 04a6          .dw XT_EXIT
                 .include "words/number.asm"
                 
                 ; Numeric IO
                 ; convert a string at addr to a number
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_NUMBER:
000d4f ff06          .dw $ff06
000d50 756e
000d51 626d
000d52 7265          .db "number"
000d53 0d46          .dw VE_HEAD
                     .set VE_HEAD = VE_NUMBER
                 XT_NUMBER:
000d54 0108          .dw DO_COLON
                 PFA_NUMBER:
                 .endif
000d55 09b2          .dw XT_BASE
000d56 050a          .dw XT_FETCH
000d57 0590          .dw XT_TO_R
000d58 0d9b          .dw XT_QSIGN
000d59 0590          .dw XT_TO_R
000d5a 0daf          .dw XT_SET_BASE
000d5b 0d9b          .dw XT_QSIGN
000d5c 0587          .dw XT_R_FROM
000d5d 06ad          .dw XT_OR
000d5e 0590          .dw XT_TO_R
                     ; check whether something is left
000d5f 0542          .dw XT_DUP
000d60 05ab          .dw XT_ZEROEQUAL
000d61 04bf          .dw XT_DOCONDBRANCH
000d62 0d6b          DEST(PFA_NUMBER0)
                       ; nothing is left. It cannot be a number at all
000d63 09d0            .dw XT_2DROP
000d64 0587            .dw XT_R_FROM
000d65 056a            .dw XT_DROP
000d66 0587            .dw XT_R_FROM
000d67 09b2            .dw XT_BASE
000d68 0512            .dw XT_STORE
000d69 05e5            .dw XT_ZERO
000d6a 04a6            .dw XT_EXIT
                 PFA_NUMBER0:
000d6b 07a4          .dw XT_2TO_R
000d6c 05e5          .dw XT_ZERO       ; starting value
000d6d 05e5          .dw XT_ZERO
000d6e 07b3          .dw XT_2R_FROM
000d6f 0dce          .dw XT_TO_NUMBER ; ( 0. addr len -- d addr' len'
                     ; check length of the remaining string.
                     ; if zero: a single cell number is entered
000d70 054a          .dw XT_QDUP
000d71 04bf          .dw XT_DOCONDBRANCH
000d72 0d8f          DEST(PFA_NUMBER1)
                     ; if equal 1: mayba a trailing dot? --> double cell number
000d73 04c6          .dw XT_DOLITERAL
000d74 0001          .dw 1
000d75 1264          .dw XT_EQUAL
000d76 04bf          .dw XT_DOCONDBRANCH
000d77 0d86          DEST(PFA_NUMBER2)
                 	; excatly one character is left
000d78 0529      	.dw XT_CFETCH
000d79 04c6      	.dw XT_DOLITERAL
000d7a 002e      	.dw 46 ; .
000d7b 1264      	.dw XT_EQUAL
000d7c 04bf      	.dw XT_DOCONDBRANCH
000d7d 0d87      	DEST(PFA_NUMBER6)
                 	; its a double cell number
                         ; incorporate sign into number
000d7e 0587      	.dw XT_R_FROM
000d7f 04bf              .dw XT_DOCONDBRANCH
000d80 0d82      	DEST(PFA_NUMBER3)
000d81 1138              .dw XT_DNEGATE
                 PFA_NUMBER3:
000d82 04c6      	.dw XT_DOLITERAL
000d83 0002      	.dw 2
000d84 04b5      	.dw XT_DOBRANCH
000d85 0d96      	DEST(PFA_NUMBER5)
                 PFA_NUMBER2:
000d86 056a      	.dw XT_DROP
                 PFA_NUMBER6:
000d87 09d0      	.dw XT_2DROP
000d88 0587      	.dw XT_R_FROM
000d89 056a      	.dw XT_DROP
000d8a 0587              .dw XT_R_FROM
000d8b 09b2              .dw XT_BASE
000d8c 0512              .dw XT_STORE
000d8d 05e5      	.dw XT_ZERO
000d8e 04a6      	.dw XT_EXIT
                 PFA_NUMBER1:
000d8f 09d0          .dw XT_2DROP ; remove the address
                     ; incorporate sign into number
000d90 0587          .dw XT_R_FROM
000d91 04bf          .dw XT_DOCONDBRANCH
000d92 0d94          DEST(PFA_NUMBER4)
000d93 0aa9          .dw XT_NEGATE
                 PFA_NUMBER4:
000d94 04c6          .dw XT_DOLITERAL
000d95 0001          .dw 1
                 PFA_NUMBER5:
000d96 0587          .dw XT_R_FROM
000d97 09b2          .dw XT_BASE
000d98 0512          .dw XT_STORE
000d99 05dc          .dw XT_TRUE
000d9a 04a6          .dw XT_EXIT
                 .include "words/q-sign.asm"
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 XT_QSIGN:
000d9b 0108          .dw DO_COLON 
                 PFA_QSIGN:        ; ( c -- ) 
                 .endif
000d9c 0560          .dw XT_OVER    ; ( -- addr len addr )
000d9d 0529          .dw XT_CFETCH
000d9e 04c6          .dw XT_DOLITERAL
000d9f 002d          .dw '-'
000da0 1264          .dw XT_EQUAL  ; ( -- addr len flag )
000da1 0542          .dw XT_DUP
000da2 0590          .dw XT_TO_R
000da3 04bf          .dw XT_DOCONDBRANCH
000da4 0da8          DEST(PFA_NUMBERSIGN_DONE)
000da5 04c6          .dw XT_DOLITERAL      ; skip sign character
000da6 0001          .dw 1
000da7 0e0c          .dw XT_SLASHSTRING
                 PFA_NUMBERSIGN_DONE:
000da8 0587          .dw XT_R_FROM
000da9 04a6          .dw XT_EXIT
                 .include "words/set-base.asm"
                 
                 ; Numeric IO
                 ; skip a numeric prefix character
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 XT_BASES:
000daa 04e1          .dw PFA_DOCONSTANT
                 .endif
000dab 000a
000dac 0010
000dad 0002
000dae 000a          .dw 10,16,2,10 ; last one could a 8 instead.
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 XT_SET_BASE:
000daf 0108          .dw DO_COLON 
                 PFA_SET_BASE:        ; ( adr1 len1 -- adr2 len2 ) 
                 .endif
000db0 0560          .dw XT_OVER
000db1 0529          .dw XT_CFETCH
000db2 04c6          .dw XT_DOLITERAL
000db3 0023          .dw 35
000db4 0624          .dw XT_MINUS
000db5 0542          .dw XT_DUP
000db6 05e5          .dw XT_ZERO
000db7 04c6          .dw XT_DOLITERAL
000db8 0004          .dw 4
000db9 0ae5          .dw XT_WITHIN
000dba 04bf          .dw XT_DOCONDBRANCH
000dbb 0dc6          DEST(SET_BASE1)
                 	.if cpu_msp430==1
                 	.endif
000dbc 0daa      	.dw XT_BASES
000dbd 062e      	.dw XT_PLUS
000dbe 0818      	.dw XT_FETCHI
000dbf 09b2      	.dw XT_BASE
000dc0 0512      	.dw XT_STORE
000dc1 04c6      	.dw XT_DOLITERAL
000dc2 0001      	.dw 1
000dc3 0e0c      	.dw XT_SLASHSTRING
000dc4 04b5      	.dw XT_DOBRANCH
000dc5 0dc7      	DEST(SET_BASE2)
                 SET_BASE1:
000dc6 056a      	.dw XT_DROP
                 SET_BASE2:
000dc7 04a6          .dw XT_EXIT 
                 
                 ; create bases 10 , 16 , 2 , 8 ,
                 ; : set-base 35 - dup 0 4 within if 
                 ;    bases + @i base ! 1 /string 
                 ;   else 
                 ;    drop
                 ;   then ;
                 .include "words/to-number.asm"
                 
                 ; Numeric IO
                 ; convert a string to a number  c-addr2/u2 is the unconverted string
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_TO_NUMBER:
000dc8 ff07          .dw $ff07
000dc9 6e3e
000dca 6d75
000dcb 6562
000dcc 0072          .db ">number",0
000dcd 0d4f          .dw VE_HEAD
                     .set VE_HEAD = VE_TO_NUMBER
                 XT_TO_NUMBER:
000dce 0108          .dw DO_COLON
                 
                 .endif
                 
000dcf 0542
000dd0 04bf      TONUM1: .DW XT_DUP,XT_DOCONDBRANCH
000dd1 0de7              DEST(TONUM3)
000dd2 0560
000dd3 0529
000dd4 0bc1              .DW XT_OVER,XT_CFETCH,XT_DIGITQ
000dd5 05ab
000dd6 04bf              .DW XT_ZEROEQUAL,XT_DOCONDBRANCH
000dd7 0dda              DEST(TONUM2)
000dd8 056a
000dd9 04a6              .DW XT_DROP,XT_EXIT
000dda 0590
000ddb 115d
000ddc 09b2
000ddd 050a
000dde 013d      TONUM2: .DW XT_TO_R,XT_2SWAP,XT_BASE,XT_FETCH,XT_UDSTAR
000ddf 0587
000de0 0135
000de1 115d              .DW XT_R_FROM,XT_MPLUS,XT_2SWAP
000de2 04c6
000de3 0001
000de4 0e0c
000de5 04b5              .DW XT_DOLITERAL,1,XT_SLASHSTRING,XT_DOBRANCH
000de6 0dcf              DEST(TONUM1)
000de7 04a6      TONUM3: .DW XT_EXIT
                 
                 ;C >NUMBER  ud adr u -- ud' adr' u'
                 ;C                      convert string to number
                 ;   BEGIN
                 ;   DUP WHILE
                 ;       OVER C@ DIGIT?
                 ;       0= IF DROP EXIT THEN
                 ;       >R 2SWAP BASE @ UD*
                 ;       R> M+ 2SWAP
                 ;       1 /STRING
                 ;   REPEAT ;
                 .include "words/parse.asm"
                 
                 ; String
                 ; in input buffer parse ccc delimited string by the delimiter char.
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_PARSE:
000de8 ff05          .dw $ff05
000de9 6170
000dea 7372
000deb 0065          .db "parse",0
000dec 0dc8          .dw VE_HEAD
                     .set VE_HEAD = VE_PARSE
                 XT_PARSE:
000ded 0108          .dw DO_COLON
                 PFA_PARSE:
                 .endif
000dee 0590          .dw XT_TO_R     ; ( -- )
000def 0e02          .dw XT_SOURCE   ; ( -- addr len)
000df0 09e0          .dw XT_TO_IN     ; ( -- addr len >in)
000df1 050a          .dw XT_FETCH
000df2 0e0c          .dw XT_SLASHSTRING ; ( -- addr' len' )
                 
000df3 0587          .dw XT_R_FROM      ; ( -- addr' len' c)
000df4 0cd8          .dw XT_CSCAN       ; ( -- addr' len'')
000df5 0542          .dw XT_DUP         ; ( -- addr' len'' len'')
000df6 06c0          .dw XT_1PLUS
000df7 09e0          .dw XT_TO_IN        ; ( -- addr' len'' len'' >in)
000df8 06ea          .dw XT_PLUSSTORE   ; ( -- addr' len')
000df9 04c6          .dw XT_DOLITERAL
000dfa 0001          .dw 1
000dfb 0e0c          .dw XT_SLASHSTRING
000dfc 04a6          .dw XT_EXIT
                 .include "words/source.asm"
                 
                 ; System
                 ; address and current length of the input buffer
                 VE_SOURCE:
000dfd ff06          .dw $FF06
000dfe 6f73
000dff 7275
000e00 6563          .db "source"
000e01 0de8          .dw VE_HEAD
                     .set VE_HEAD = VE_SOURCE
                 XT_SOURCE:
000e02 106a          .dw PFA_DODEFER1
                 PFA_SOURCE:
000e03 0016          .dw USER_SOURCE
000e04 1033          .dw XT_UDEFERFETCH
000e05 103f          .dw XT_UDEFERSTORE
                 
                 
                 .include "words/slash-string.asm"
                 
                 ; String
                 ; adjust string from addr1 to addr1+n, reduce length from u1 to u2 by n
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SLASHSTRING:
000e06 ff07          .dw $ff07
000e07 732f
000e08 7274
000e09 6e69
000e0a 0067          .db "/string",0
000e0b 0dfd          .dw VE_HEAD
                     .set VE_HEAD = VE_SLASHSTRING
                 XT_SLASHSTRING:
000e0c 0108          .dw DO_COLON
                 PFA_SLASHSTRING:
                 .endif
000e0d 0572          .dw XT_ROT
000e0e 0560          .dw XT_OVER
000e0f 062e          .dw XT_PLUS
000e10 0572          .dw XT_ROT
000e11 0572          .dw XT_ROT
000e12 0624          .dw XT_MINUS
000e13 04a6          .dw XT_EXIT
                 
                 .include "words/parse-name.asm"
                 
                 ; String
                 ; In the SOURCE buffer parse whitespace delimited string. Returns string address within SOURCE.
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 VE_PARSENAME:
000e14 ff0a          .dw $FF0A 
000e15 6170
000e16 7372
000e17 2d65
000e18 616e
000e19 656d          .db "parse-name"
000e1a 0e06          .dw VE_HEAD
                     .set VE_HEAD = VE_PARSENAME
                 XT_PARSENAME:
000e1b 0108          .dw DO_COLON 
                 PFA_PARSENAME:
                 .endif
000e1c 0a59          .dw XT_BL
000e1d 0e1f          .dw XT_SKIPSCANCHAR
000e1e 04a6          .dw XT_EXIT 
                 
                 ; ( c -- addr2 len2 ) 
                 ; String
                 ; skips char and scan what's left in source for char
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 ;VE_SKIPSCANCHAR:
                 ;    .dw $FF0A 
                 ;    .db "skipscanchar"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_SKIPSCANCHAR
                 XT_SKIPSCANCHAR:
000e1f 0108          .dw DO_COLON
                 PFA_SKIPSCANCHAR:
                 .endif
000e20 0590          .dw XT_TO_R
000e21 0e02          .dw XT_SOURCE 
000e22 09e0          .dw XT_TO_IN 
000e23 050a          .dw XT_FETCH 
000e24 0e0c          .dw XT_SLASHSTRING 
                 
000e25 0599          .dw XT_R_FETCH
000e26 0cc0          .dw XT_CSKIP
000e27 0587          .dw XT_R_FROM
000e28 0cd8          .dw XT_CSCAN
                 
                     ; adjust >IN
000e29 09c7          .dw XT_2DUP
000e2a 062e          .dw XT_PLUS
000e2b 0e02          .dw XT_SOURCE 
000e2c 056a          .dw XT_DROP
000e2d 0624          .dw XT_MINUS
000e2e 09e0          .dw XT_TO_IN
000e2f 0512          .dw XT_STORE
000e30 04a6          .dw XT_EXIT
                 .include "words/find-name.asm"
                 
                 ; Tools
                 ; search wordlists for an entry with the name from c-addr/len
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_FINDNAME:
000e31 ff09          .dw $ff09
000e32 6966
000e33 646e
000e34 6e2d
000e35 6d61
000e36 0065          .db "find-name",0
000e37 0e14          .dw VE_HEAD
                     .set VE_HEAD = VE_FINDNAME
                 XT_FINDNAME:
000e38 0108          .dw DO_COLON
                 PFA_FINDNAME:
                 .endif
000e39 04c6          .dw XT_DOLITERAL
000e3a 0e44          .dw XT_FINDNAMEA
000e3b 04c6          .dw XT_DOLITERAL
000e3c 0086          .dw CFG_ORDERLISTLEN
000e3d 041b          .dw XT_MAPSTACK
000e3e 05ab          .dw XT_ZEROEQUAL
000e3f 04bf          .dw XT_DOCONDBRANCH
000e40 0e43          DEST(PFA_FINDNAME1)
000e41 09d0            .dw XT_2DROP
000e42 05e5            .dw XT_ZERO
                 PFA_FINDNAME1:
000e43 04a6          .dw XT_EXIT
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 XT_FINDNAMEA:
000e44 0108          .dw DO_COLON
                 PFA_FINDNAMEA:
                 .endif
000e45 0590          .dw XT_TO_R
000e46 09c7          .dw XT_2DUP
000e47 0587          .dw XT_R_FROM
000e48 107c          .dw XT_SEARCH_WORDLIST
000e49 0542          .dw XT_DUP
000e4a 04bf          .dw XT_DOCONDBRANCH
000e4b 0e51          DEST(PFA_FINDNAMEA1)
000e4c 0590            .dw XT_TO_R
000e4d 0581            .dw XT_NIP
000e4e 0581            .dw XT_NIP
000e4f 0587            .dw XT_R_FROM
000e50 05dc            .dw XT_TRUE
                 PFA_FINDNAMEA1:
000e51 04a6          .dw XT_EXIT
                 
                 .include "words/prompt-ok.asm"
                 
                 ; System
                 ; send the READY prompt to the command line
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 ;VE_PROMPTOK:
                 ;    .dw $ff02
                 ;    .db "ok"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_PROMPTOK
                 XT_PROMPTOK:
000e52 0108          .dw DO_COLON
                 PFA_PROMPTOK:
000e53 0bdb          .dw XT_DOSLITERAL
000e54 0003          .dw 3
000e55 6f20
000e56 006b          .db " ok",0
                 .endif
000e57 0c0e          .dw XT_ITYPE
000e58 04a6          .dw XT_EXIT
                 .include "words/prompt-ready.asm"
                 
                 ; System
                 ; process the error prompt
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 ;VE_PROMPTRDY:
                 ;    .dw $ff04
                 ;    .db "p_er"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_PROMPTRDY
                 XT_PROMPTREADY:
000e59 0108          .dw DO_COLON
                 PFA_PROMPTREADY:
000e5a 0bdb          .dw XT_DOSLITERAL
000e5b 0002          .dw 2
000e5c 203e          .db "> "
                 .endif
000e5d 0c43          .dw XT_CR
000e5e 0c0e          .dw XT_ITYPE
000e5f 04a6          .dw XT_EXIT
                 .include "words/prompt-error.asm"
                 
                 ; System
                 ; process the error prompt
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 ;VE_PROMPTERROR:
                 ;    .dw $ff04
                 ;    .db "p_er"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_PROMPTERROR
                 XT_PROMPTERROR:
000e60 0108          .dw DO_COLON
                 PFA_PROMPTERROR:
000e61 0bdb      	.dw XT_DOSLITERAL
000e62 0004          .dw 4
000e63 3f20
000e64 203f          .db " ?? "
                 .endif
000e65 0c0e          .dw XT_ITYPE
000e66 09b2          .dw XT_BASE
000e67 050a          .dw XT_FETCH
000e68 0590          .dw XT_TO_R
000e69 0a46          .dw XT_DECIMAL
000e6a 0b90          .dw XT_DOT
000e6b 09e0          .dw XT_TO_IN
000e6c 050a          .dw XT_FETCH
000e6d 0b90          .dw XT_DOT
000e6e 0587          .dw XT_R_FROM
000e6f 09b2          .dw XT_BASE
000e70 0512          .dw XT_STORE
000e71 04a6          .dw XT_EXIT
                 
                 .include "words/quit.asm"
                 
                 ; System
                 ; main loop of amforth. accept - interpret in an endless loop
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_QUIT:
000e72 ff04          .dw $ff04
000e73 7571
000e74 7469          .db "quit"
000e75 0e31          .dw VE_HEAD
                     .set VE_HEAD = VE_QUIT
                 XT_QUIT:
000e76 0108          .dw DO_COLON
                 PFA_QUIT:
                 .endif
                 PFA_QUIT1:
000e77 02c8
000e78 02cf
000e79 0512          .dw XT_LP0,XT_LP,XT_STORE
000e7a 0ed8          .dw XT_SP0
000e7b 071b          .dw XT_SP_STORE
000e7c 0ee5          .dw XT_RP0
000e7d 0705          .dw XT_RP_STORE
000e7e 036a          .dw XT_LBRACKET
                 
                 PFA_QUIT2:
000e7f 09ac          .dw XT_STATE
000e80 050a          .dw XT_FETCH
000e81 05ab          .dw XT_ZEROEQUAL
000e82 04bf          .dw XT_DOCONDBRANCH
000e83 0e85          DEST(PFA_QUIT4)
000e84 0e59          .dw XT_PROMPTREADY
                 PFA_QUIT4:
000e85 0d42          .dw XT_REFILL
000e86 04bf          .dw XT_DOCONDBRANCH
000e87 0e7f          DEST(PFA_QUIT2)
000e88 04c6          .dw XT_DOLITERAL
000e89 0efe          .dw XT_INTERPRET
000e8a 0c91          .dw XT_CATCH
000e8b 054a          .dw XT_QDUP
000e8c 04bf          .dw XT_DOCONDBRANCH
000e8d 0e97          DEST(PFA_QUIT3)
000e8e 0542      	.dw XT_DUP
000e8f 04c6      	.dw XT_DOLITERAL
000e90 fffe      	.dw -2
000e91 05ff      	.dw XT_LESS
000e92 04bf      	.dw XT_DOCONDBRANCH
000e93 0e95      	DEST(PFA_QUIT5)
000e94 0e60      	.dw XT_PROMPTERROR
                 PFA_QUIT5:
000e95 04b5      	.dw XT_DOBRANCH
000e96 0e77      	DEST(PFA_QUIT1)
                 PFA_QUIT3:
000e97 0e52          .dw XT_PROMPTOK
000e98 04b5          .dw XT_DOBRANCH
000e99 0e7f          DEST(PFA_QUIT2)
000e9a 04a6          .dw XT_EXIT ; never reached
                 
                 .include "words/pause.asm"
                 
                 ; Multitasking
                 ; Fetch pause vector and execute it. may make a context/task switch
                 VE_PAUSE:
000e9b ff05          .dw $ff05
000e9c 6170
000e9d 7375
000e9e 0065          .db "pause",0
000e9f 0e72          .dw VE_HEAD
                     .set VE_HEAD = VE_PAUSE
                 XT_PAUSE:
000ea0 106a          .dw PFA_DODEFER1
                 PFA_PAUSE:
000ea1 0225          .dw ram_pause
000ea2 101f          .dw XT_RDEFERFETCH
000ea3 1029          .dw XT_RDEFERSTORE
                 
                 .dseg
000225           ram_pause: .byte 2
                 .cseg
                 .include "words/cold.asm"
                 
                 ; System
                 ; start up amforth.
                 VE_COLD:
000ea4 ff04          .dw $ff04
000ea5 6f63
000ea6 646c          .db "cold"
000ea7 0e9b          .dw VE_HEAD
                     .set VE_HEAD = VE_COLD
                 XT_COLD:
000ea8 0ea9          .dw PFA_COLD
                 PFA_COLD:
000ea9 b6a4          in_ mcu_boot, MCUSR
000eaa 2422          clr zerol
000eab 2433          clr zeroh
000eac be24          out_ MCUSR, zerol
                     ; clear RAM
000ead e0e0          ldi zl, low(ramstart)
000eae e0f2          ldi zh, high(ramstart)
                 clearloop:
000eaf 9221          st Z+, zerol
000eb0 30e0          cpi zl, low(sram_size+ramstart)
000eb1 f7e9          brne clearloop
000eb2 32f2          cpi zh, high(sram_size+ramstart)
000eb3 f7d9          brne clearloop
                     ; init first user data area
                     ; allocate space for User Area
                 .dseg
000227           ram_user1: .byte SYSUSERSIZE + APPUSERSIZE
                 .cseg
000eb4 e2e7          ldi zl, low(ram_user1)
000eb5 e0f2          ldi zh, high(ram_user1)
000eb6 012f          movw upl, zl
                     ; init return stack pointer
000eb7 ef0f          ldi temp0,low(rstackstart)
000eb8 bf0d          out_ SPL,temp0
000eb9 8304          std Z+4, temp0
000eba e211          ldi temp1,high(rstackstart)
000ebb bf1e          out_ SPH,temp1
000ebc 8315          std Z+5, temp1
                 
                     ; init parameter stack pointer
000ebd eacf          ldi yl,low(stackstart)
000ebe 83c6          std Z+6, yl
000ebf e2d1          ldi yh,high(stackstart)
000ec0 83d7          std Z+7, yh
                 
                     ; load Forth IP with starting word
000ec1 ecaa          ldi XL, low(PFA_WARM)
000ec2 e0be          ldi XH, high(PFA_WARM)
                     ; its a far jump...
000ec3 940c 010c     jmp_ DO_NEXT
                 .include "words/warm.asm"
                 
                 ; System
                 ; initialize amforth further. executes turnkey operation and go to quit
                 VE_WARM:
000ec5 ff04          .dw $ff04
000ec6 6177
000ec7 6d72          .db "warm"
000ec8 0ea4          .dw VE_HEAD
                     .set VE_HEAD = VE_WARM
                 XT_WARM:
000ec9 0108          .dw DO_COLON
                 PFA_WARM:
000eca 11a3          .dw XT_INITUSER
000ecb 04c6          .dw XT_DOLITERAL
000ecc 0fd5          .dw XT_NOOP
000ecd 04c6          .dw XT_DOLITERAL
000ece 0ea0          .dw XT_PAUSE
000ecf 104a          .dw XT_DEFERSTORE
000ed0 036a          .dw XT_LBRACKET
000ed1 0a61          .dw XT_TURNKEY
000ed2 0e76          .dw XT_QUIT
000ed3 04a6          .dw XT_EXIT
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/sp0.asm"
                 
                 ; Stack
                 ; start address of the data stack
                 VE_SP0:
000ed4 ff03          .dw $ff03
000ed5 7073
000ed6 0030          .db "sp0",0
000ed7 0ec5          .dw VE_HEAD
                     .set VE_HEAD = VE_SP0
                 XT_SP0:
000ed8 0501          .dw PFA_DOVALUE1
                 PFA_SP0:
000ed9 0006          .dw USER_SP0
000eda 1033          .dw XT_UDEFERFETCH
000edb 103f          .dw XT_UDEFERSTORE
                 
                 ; ( -- addr) 
                 ; Stack
                 ; address of user variable to store top-of-stack for inactive tasks
                 VE_SP:
000edc ff02          .dw $ff02
000edd 7073          .db "sp"
000ede 0ed4          .dw VE_HEAD
                     .set VE_HEAD = VE_SP
                 XT_SP:
000edf 04e7          .dw PFA_DOUSER
                 PFA_SP:
000ee0 0008          .dw USER_SP
                 .include "words/rp0.asm"
                 
                 ; Stack
                 ; start address of return stack
                 VE_RP0:
000ee1 ff03          .dw $ff03
000ee2 7072
000ee3 0030          .db "rp0",0
000ee4 0edc          .dw VE_HEAD
                     .set VE_HEAD = VE_RP0
                 XT_RP0:
000ee5 0108          .dw DO_COLON
                 PFA_RP0:
000ee6 0ee9          .dw XT_DORP0
000ee7 050a          .dw XT_FETCH
000ee8 04a6          .dw XT_EXIT
                 
                 ; ( -- addr) 
                 ; Stack
                 ; user variable of the address of the initial return stack
                 ;VE_DORP0:
                 ;    .dw $ff05
                 ;    .db "(rp0)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DORP0
                 XT_DORP0:
000ee9 04e7          .dw PFA_DOUSER
                 PFA_DORP0:
000eea 0004          .dw USER_RP
                 .include "words/depth.asm"
                 
                 ; Stack
                 ; number of single-cell values contained in the data stack before n was placed on the stack.
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DEPTH:
000eeb ff05          .dw $ff05
000eec 6564
000eed 7470
000eee 0068          .db "depth",0
000eef 0ee1          .dw VE_HEAD
                     .set VE_HEAD = VE_DEPTH
                 XT_DEPTH:
000ef0 0108          .dw DO_COLON
                 PFA_DEPTH:
                 .endif
000ef1 0ed8          .dw XT_SP0
000ef2 0712          .dw XT_SP_FETCH
000ef3 0624          .dw XT_MINUS
000ef4 0695          .dw XT_2SLASH
000ef5 06c6          .dw XT_1MINUS
000ef6 04a6          .dw XT_EXIT
                 .include "words/interpret.asm"
                 
                 ; System
                 ; Interpret SOURCE word by word.
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_INTERPRET:
000ef7 ff09          .dw $ff09
000ef8 6e69
000ef9 6574
000efa 7072
000efb 6572
000efc 0074          .db "interpret",0
000efd 0eeb          .dw VE_HEAD
                     .set VE_HEAD = VE_INTERPRET
                 XT_INTERPRET:
000efe 0108          .dw DO_COLON
                 .endif
                 PFA_INTERPRET:
000eff 0e1b          .dw XT_PARSENAME ; ( -- addr len )
000f00 0542          .dw XT_DUP   ; ( -- addr len flag)
000f01 04bf          .dw XT_DOCONDBRANCH
000f02 0f0e          DEST(PFA_INTERPRET2)
000f03 0f19            .dw XT_DORECOGNIZER
000f04 09ac            .dw XT_STATE
000f05 050a            .dw XT_FETCH
000f06 04bf            .dw XT_DOCONDBRANCH
000f07 0f09          DEST(PFA_INTERPRET1)
000f08 1002            .dw XT_ICELLPLUS   ; we need the compile action
                 PFA_INTERPRET1:
000f09 0818            .dw XT_FETCHI
000f0a 04b0            .dw XT_EXECUTE
000f0b 0fad            .dw XT_QSTACK
000f0c 04b5          .dw XT_DOBRANCH
000f0d 0eff          DEST(PFA_INTERPRET)
                 PFA_INTERPRET2:
000f0e 09d0          .dw XT_2DROP
000f0f 04a6          .dw XT_EXIT
                 .include "words/do-recognizer.asm"
                 
                 ; System
                 ; walk the recognizer stack
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DORECOGNIZER:
000f10 ff0d          .dw $ff0d
000f11 6f64
000f12 722d
000f13 6365
000f14 676f
000f15 696e
000f16 657a
000f17 0072          .db "do-recognizer",0
000f18 0ef7          .dw VE_HEAD
                     .set VE_HEAD = VE_DORECOGNIZER
                 XT_DORECOGNIZER:
000f19 0108          .dw DO_COLON
                 PFA_DORECOGNIZER:
                 .endif
000f1a 04c6          .dw XT_DOLITERAL
000f1b 0f25          .dw XT_DORECOGNIZER_A
000f1c 04c6          .dw XT_DOLITERAL
000f1d 0098          .dw CFG_RECOGNIZERLISTLEN
000f1e 041b          .dw XT_MAPSTACK
000f1f 05ab          .dw XT_ZEROEQUAL
000f20 04bf          .dw XT_DOCONDBRANCH
000f21 0f24          DEST(PFA_DORECOGNIZER1)
000f22 09d0            .dw XT_2DROP
000f23 0fa0            .dw XT_R_FAIL
                 PFA_DORECOGNIZER1:
000f24 04a6          .dw XT_EXIT
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 ; ( addr len XT -- addr len [ r:table -1 | 0 ] )
                 XT_DORECOGNIZER_A:
000f25 0108         .dw DO_COLON
                 PFA_DORECOGNIZER_A:
                 .endif
000f26 0572         .dw XT_ROT  ; -- len xt addr
000f27 0572         .dw XT_ROT  ; -- xt addr len
000f28 09c7         .dw XT_2DUP 
000f29 07a4         .dw XT_2TO_R
000f2a 0572         .dw XT_ROT  ; -- addr len xt
000f2b 04b0         .dw XT_EXECUTE ; -- i*x r:foo | r:fail
000f2c 07b3         .dw XT_2R_FROM
000f2d 0572         .dw XT_ROT
000f2e 0542         .dw XT_DUP
000f2f 0fa0         .dw XT_R_FAIL
000f30 1264         .dw XT_EQUAL
000f31 04bf         .dw XT_DOCONDBRANCH
000f32 0f36         DEST(PFA_DORECOGNIZER_A1)
000f33 056a           .dw XT_DROP
000f34 05e5           .dw XT_ZERO
000f35 04a6           .dw XT_EXIT
                 PFA_DORECOGNIZER_A1:
000f36 0581         .dw XT_NIP 
000f37 0581         .dw XT_NIP
000f38 05dc         .dw XT_TRUE
000f39 04a6         .dw XT_EXIT
                 
                 ; : do-recognizer ( addr len -- i*x r:table|r:fail )
                 ;    \ ( addr len -- addr len 0 | i*x r:table -1 )
                 ;    [: rot rot 2dup 2>r rot execute 2r> rot 
                 ;          dup r:fail = ( -- addr len r:table f )
                 ;          if drop 0 else nip nip -1 then
                 ;    ;] 
                 ;    EE_RECOGNIZERLISTLEN map-stack ( -- i*x addr len r:table f )
                 ;    0= if \ a recognizer did the job, remove addr/len
                 ;     2drop r:fail 
                 ;    then
                 ;
                 .include "words/r-intnumber.asm"
                 
                 ; Interpreter
                 ; Method table for single cell integers
                 
                 
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_R_NUM:
000f3a ff05          .dw $ff05
000f3b 3a72
000f3c 756e
000f3d 006d          .db "r:num",0
000f3e 0f10          .dw VE_HEAD
                     .set VE_HEAD = VE_R_NUM
                 XT_R_NUM:
000f3f 04e1          .dw PFA_DOCONSTANT
                 PFA_R_NUM:
                 .endif
000f40 0fd5          .dw XT_NOOP    ; interpret
000f41 01e8          .dw XT_LITERAL ; compile
000f42 0f4c          .dw XT_FAILNUM ; postpone
                 
                 ; ( -- addr )
                 ; Interpreter
                 ; Method table for double cell integers
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_R_DNUM:
000f43 ff06          .dw $ff06
000f44 3a72
000f45 6e64
000f46 6d75          .db "r:dnum"
000f47 0f3a          .dw VE_HEAD
                     .set VE_HEAD = VE_R_DNUM
                 XT_R_DNUM:
000f48 04e1          .dw PFA_DOCONSTANT
                 PFA_R_DNUM:
                 .endif
000f49 0fd5          .dw XT_NOOP     ; interpret
000f4a 1258          .dw XT_2LITERAL ; compile
000f4b 0f52          .dw XT_FAILDNUM ; postpone
                 
                 ; ( -- addr )
                 ; Interpreter
                 ; Method to print a number and throw exception "invalid postpone"
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 ;VE_FAILNUM:
                 ;    .dw $ff06
                 ;    .db "fail:i"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_FAILNUM
                 XT_FAILNUM:
000f4c 0108          .dw DO_COLON
                 PFA_FAILNUM:
                 .endif
000f4d 0b90          .dw XT_DOT
000f4e 04c6          .dw XT_DOLITERAL
000f4f ffd0          .dw -48
000f50 0ca7          .dw XT_THROW
000f51 04a6          .dw XT_EXIT
                 
                 ; ( -- addr )
                 ; Interpreter
                 ; Method to print a double cell number and throw exception "invalid postpone"
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 VE_FAILDNUM:
                 ;    .dw $ff06
                 ;    .db "fail:d"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_FAILDNUM
                 XT_FAILDNUM:
000f52 0108          .dw DO_COLON
                 PFA_FAILDNUM:
                 .endif
000f53 0b88          .dw XT_DDOT
000f54 04c6          .dw XT_DOLITERAL
000f55 ffd0          .dw -48
000f56 0ca7          .dw XT_THROW
000f57 04a6          .dw XT_EXIT
                 
                 ; ( addr len -- f )
                 ; Interpreter
                 ; recognizer for integer numbers
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 VE_REC_NUM:
000f58 ff07          .dw $ff07
000f59 6572
000f5a 3a63
000f5b 756e
000f5c 006d          .db "rec:num",0
000f5d 0f43          .dw VE_HEAD
                     .set VE_HEAD = VE_REC_NUM
                 XT_REC_NUM:
000f5e 0108          .dw DO_COLON
                 PFA_REC_NUM:
                 .endif
                     ; try converting to a number
000f5f 0d54          .dw XT_NUMBER
000f60 04bf          .dw XT_DOCONDBRANCH
000f61 0f6b          DEST(PFA_REC_NONUMBER)
000f62 04c6          .dw XT_DOLITERAL
000f63 0001          .dw 1
000f64 1264          .dw XT_EQUAL
000f65 04bf          .dw XT_DOCONDBRANCH
000f66 0f69          DEST(PFA_REC_INTNUM2)
000f67 0f3f            .dw XT_R_NUM
000f68 04a6            .dw XT_EXIT
                 PFA_REC_INTNUM2:
000f69 0f48            .dw XT_R_DNUM
000f6a 04a6            .dw XT_EXIT
                 PFA_REC_NONUMBER:
000f6b 0fa0          .dw XT_R_FAIL
000f6c 04a6          .dw XT_EXIT
                 .include "words/r-word.asm"
                 
                 ; Interpreter
                 ; search for a word
                 .if cpu_msp430==1
                 .endif
                 .if cpu_avr8==1
                 VE_REC_WORD:
000f6d ff08          .dw $ff08
000f6e 6572
000f6f 3a63
000f70 6f77
000f71 6472          .db "rec:word"
000f72 0f58          .dw VE_HEAD
                     .set VE_HEAD = VE_REC_WORD
                 XT_REC_WORD:
000f73 0108          .dw DO_COLON
                 PFA_REC_WORD:
                 .endif
000f74 0e38          .DW XT_FINDNAME
000f75 0542          .dw XT_DUP
000f76 05ab          .dw XT_ZEROEQUAL
000f77 04bf          .dw XT_DOCONDBRANCH
000f78 0f7c          DEST(PFA_REC_WORD_FOUND)
000f79 056a              .dw XT_DROP
000f7a 0fa0      	.dw XT_R_FAIL
000f7b 04a6      	.dw XT_EXIT
                 PFA_REC_WORD_FOUND:
000f7c 0f83          .dw XT_R_WORD
                 
000f7d 04a6          .dw XT_EXIT
                 
                 ; ( -- addr )
                 ; Interpreter
                 ; actions to handle execution tokens and their flags
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_R_WORD:
000f7e ff06          .dw $ff06
000f7f 3a72
000f80 6f77
000f81 6472          .db "r:word"
000f82 0f6d          .dw VE_HEAD
                     .set VE_HEAD = VE_R_WORD
                 XT_R_WORD:
000f83 04e1          .dw PFA_DOCONSTANT
                 PFA_R_WORD:
                 .endif
000f84 0f87          .dw XT_R_WORD_INTERPRET
000f85 0f8b          .dw XT_R_WORD_COMPILE
000f86 0f93          .dw XT_R_WORD_POSTPONE
                 
                 ; ( XT flags -- )
                 ; Interpreter
                 ; interpret method for WORD recognizer
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 XT_R_WORD_INTERPRET:
000f87 0108          .dw DO_COLON
                 PFA_R_WORD_INTERPRET:
                 .endif
000f88 056a          .dw XT_DROP ; the flags are in the way
000f89 04b0          .dw XT_EXECUTE
000f8a 04a6          .dw XT_EXIT
                 
                 ; ( XT flags -- )
                 ; Interpreter
                 ; Compile method for WORD recognizer
                 .if cpu_msp430==1
                 .endif
                 .if cpu_avr8==1
                 XT_R_WORD_COMPILE:
000f8b 0108          .dw DO_COLON
                 PFA_R_WORD_COMPILE:
                 .endif
000f8c 05b2          .dw XT_ZEROLESS
000f8d 04bf          .dw XT_DOCONDBRANCH
000f8e 0f91          DEST(PFA_R_WORD_COMPILE1)
000f8f 01d2      	.dw XT_COMMA
000f90 04a6              .dw XT_EXIT
                 PFA_R_WORD_COMPILE1:
000f91 04b0              .dw XT_EXECUTE
000f92 04a6          .dw XT_EXIT
                 
                 ; ( XT flags -- )
                 ; Interpreter
                 ; Postpone method for WORD recognizer
                 .if cpu_msp430==1
                 .endif
                 .if cpu_avr8==1
                 XT_R_WORD_POSTPONE:
000f93 0108          .dw DO_COLON
                 PFA_R_WORD_POSTPONE:
                 .endif
000f94 05b2          .dw XT_ZEROLESS
000f95 04bf          .dw XT_DOCONDBRANCH
000f96 0f99          DEST(PFA_R_WORD_POSTPONE1)
000f97 01c7            .dw XT_COMPILE
000f98 01c7            .dw XT_COMPILE
                 PFA_R_WORD_POSTPONE1:
000f99 01d2          .dw XT_COMMA
000f9a 04a6          .dw XT_EXIT
                 .include "words/r-fail.asm"
                 
                 ; Interpreter
                 ; there is no parser for this recognizer, this is the default and failsafe part
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_R_FAIL:
000f9b ff06          .dw $ff06
000f9c 3a72
000f9d 6166
000f9e 6c69          .db "r:fail"
000f9f 0f7e          .dw VE_HEAD
                     .set VE_HEAD = VE_R_FAIL
                 XT_R_FAIL:
000fa0 04e1          .dw PFA_DOCONSTANT
                 PFA_R_FAIL:
                 .endif
000fa1 0fa4          .dw XT_FAIL  ; interpret
000fa2 0fa4          .dw XT_FAIL  ; compile
000fa3 0fa4          .dw XT_FAIL  ; postpone
                 
                 ; ( addr len -- )
                 ; Interpreter
                 ; default failure action: throw exception -13.
                 .if cpu_msp430==1
                 .endif
                 .if cpu_avr8==1
                 ;VE_FAIL:
                 ;    .dw $ff04
                 ;    .db "fail"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_FAIL
                 XT_FAIL:
000fa4 0108          .dw DO_COLON
                 PFA_FAIL:
                 .endif
000fa5 04c6          .dw XT_DOLITERAL
000fa6 fff3          .dw -13
000fa7 0ca7          .dw XT_THROW
                 
                 .include "words/q-stack.asm"
                 
                 ; Tools
                 ; check data stack depth and exit to quit if underrun
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_QSTACK:
000fa8 ff06          .dw $ff06
000fa9 733f
000faa 6174
000fab 6b63          .db "?stack"
000fac 0f9b          .dw VE_HEAD
                     .set VE_HEAD = VE_QSTACK
                 XT_QSTACK:
000fad 0108          .dw DO_COLON
                 PFA_QSTACK:
                 .endif
000fae 0ef0          .dw XT_DEPTH
000faf 05b2          .dw XT_ZEROLESS
000fb0 04bf          .dw XT_DOCONDBRANCH
000fb1 0fb5          DEST(PFA_QSTACK1)
000fb2 04c6            .dw XT_DOLITERAL
000fb3 fffc            .dw -4
000fb4 0ca7            .dw XT_THROW
                 PFA_QSTACK1:
000fb5 04a6          .dw XT_EXIT
                 .include "words/ver.asm"
                 
                 ; Tools
                 ; print the version string
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DOT_VER:
000fb6 ff03          .dw $ff03
000fb7 6576
../../common\words/ver.asm(12): warning: .cseg .db misalignment - padding zero byte
000fb8 0072          .db "ver"
000fb9 0fa8          .dw VE_HEAD
                     .set VE_HEAD = VE_DOT_VER
                 XT_DOT_VER:
000fba 0108          .dw DO_COLON
                 PFA_DOT_VER:
                 .endif
000fbb 096e          .dw XT_ENV_FORTHNAME
000fbc 0c0e          .dw XT_ITYPE
000fbd 0c50          .dw XT_SPACE
000fbe 09b2          .dw XT_BASE
000fbf 050a          .dw XT_FETCH
                 
000fc0 097c          .dw XT_ENV_FORTHVERSION
000fc1 0a46          .dw XT_DECIMAL
000fc2 1248          .dw XT_S2D
000fc3 0b2c          .dw XT_L_SHARP
000fc4 0b34          .dw XT_SHARP
000fc5 04c6          .dw XT_DOLITERAL
000fc6 002e          .dw '.'
000fc7 0b1d          .dw XT_HOLD
000fc8 0b4a          .dw XT_SHARP_S
000fc9 0b55          .dw XT_SHARP_G
000fca 0c69          .dw XT_TYPE
000fcb 09b2          .dw XT_BASE
000fcc 0512          .dw XT_STORE
000fcd 0c50          .dw XT_SPACE
000fce 0984          .dw XT_ENV_CPU
000fcf 0c0e          .dw XT_ITYPE
                 
000fd0 04a6          .dw XT_EXIT
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/noop.asm"
                 
                 ; Tools
                 ; do nothing
                 VE_NOOP:
000fd1 ff04          .dw $ff04
000fd2 6f6e
000fd3 706f          .db "noop"
000fd4 0fb6          .dw VE_HEAD
                     .set VE_HEAD = VE_NOOP
                 XT_NOOP:
000fd5 0fd6          .dw PFA_NOOP
                 PFA_NOOP:
000fd6 940c 010c     jmp_ DO_NEXT
                 .include "words/unused.asm"
                 
                 ; Tools
                 ; Amount of available RAM (incl. PAD)
                 VE_UNUSED:
000fd8 ff06          .dw $ff06
000fd9 6e75
000fda 7375
000fdb 6465          .db "unused"
000fdc 0fd1          .dw VE_HEAD
                     .set VE_HEAD = VE_UNUSED
                 XT_UNUSED:
000fdd 0108          .dw DO_COLON
                 PFA_UNUSED:
000fde 0712          .dw XT_SP_FETCH
000fdf 0a27          .dw XT_HERE
000fe0 0624          .dw XT_MINUS
000fe1 04a6          .dw XT_EXIT
                 
                 .include "words/to.asm"
                 
                 ; Tools
                 ; store the TOS to the named value (eeprom cell)
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_TO:
000fe2 0002          .dw $0002
000fe3 6f74          .db "to"
000fe4 0fd8          .dw VE_HEAD
                     .set VE_HEAD = VE_TO
                 XT_TO:
000fe5 0108          .dw DO_COLON
                 PFA_TO:
                 .endif
000fe6 0c78          .dw XT_TICK
000fe7 1251          .dw XT_TO_BODY
000fe8 09ac          .dw XT_STATE
000fe9 050a          .dw XT_FETCH
000fea 04bf          .dw XT_DOCONDBRANCH
000feb 0ff6          DEST(PFA_TO1)
000fec 01c7          .dw XT_COMPILE
000fed 0ff0          .dw XT_DOTO
000fee 01d2          .dw XT_COMMA
000fef 04a6          .dw XT_EXIT
                 
                 ; ( n -- ) (R: IP -- IP+1)
                 ; Tools
                 ; runtime portion of to
                 ;VE_DOTO:
                 ;    .dw $ff04
                 ;    .db "(to)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOTO
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 XT_DOTO:
000ff0 0108          .dw DO_COLON
                 PFA_DOTO:
                 .endif
000ff1 0587          .dw XT_R_FROM
000ff2 0542          .dw XT_DUP
000ff3 1002          .dw XT_ICELLPLUS
000ff4 0590          .dw XT_TO_R
000ff5 0818          .dw XT_FETCHI
                 PFA_TO1:
000ff6 0542          .dw XT_DUP
000ff7 1002          .dw XT_ICELLPLUS
000ff8 1002          .dw XT_ICELLPLUS
000ff9 0818          .dw XT_FETCHI
000ffa 04b0          .dw XT_EXECUTE
000ffb 04a6          .dw XT_EXIT
                 .include "words/i-cellplus.asm"
                 
                 ; Compiler
                 ; skip to the next cell in flash
                 VE_ICELLPLUS:
000ffc ff07          .dw $FF07
000ffd 2d69
000ffe 6563
000fff 6c6c
001000 002b          .db "i-cell+",0
001001 0fe2          .dw VE_HEAD
                     .set VE_HEAD = VE_ICELLPLUS
                 XT_ICELLPLUS:
001002 0108          .dw DO_COLON
                 PFA_ICELLPLUS:
001003 06c0          .dw XT_1PLUS
001004 04a6          .dw XT_EXIT
                 
                 .include "words/edefer-fetch.asm"
                 
                 ; System
                 ; does the real defer@ for eeprom defers
                 VE_EDEFERFETCH:
001005 ff07          .dw $ff07
001006 6445
001007 6665
001008 7265
001009 0040          .db "Edefer@",0
00100a 0ffc          .dw VE_HEAD
                     .set VE_HEAD = VE_EDEFERFETCH
                 XT_EDEFERFETCH:
00100b 0108          .dw DO_COLON
                 PFA_EDEFERFETCH:
00100c 0818          .dw XT_FETCHI
00100d 07e5          .dw XT_FETCHE
00100e 04a6          .dw XT_EXIT
                 .include "words/edefer-store.asm"
                 
                 ; System
                 ; does the real defer! for eeprom defers
                 VE_EDEFERSTORE:
00100f ff07          .dw $ff07
001010 6445
001011 6665
001012 7265
001013 0021          .db "Edefer!",0
001014 1005          .dw VE_HEAD
                     .set VE_HEAD = VE_EDEFERSTORE
                 XT_EDEFERSTORE:
001015 0108          .dw DO_COLON
                 PFA_EDEFERSTORE:
001016 0818          .dw XT_FETCHI
001017 07c1          .dw XT_STOREE
001018 04a6          .dw XT_EXIT
                 .include "words/rdefer-fetch.asm"
                 
                 ; System
                 ; The defer@ for ram defers
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_RDEFERFETCH:
001019 ff07          .dw $ff07
00101a 6452
00101b 6665
00101c 7265
00101d 0040          .db "Rdefer@",0
00101e 100f          .dw VE_HEAD
                     .set VE_HEAD = VE_RDEFERFETCH
                 XT_RDEFERFETCH:
00101f 0108          .dw DO_COLON
                 PFA_RDEFERFETCH:
                 .endif
001020 0818          .dw XT_FETCHI
001021 050a          .dw XT_FETCH
001022 04a6          .dw XT_EXIT
                 .include "words/rdefer-store.asm"
                 
                 ; System
                 ; The defer! for ram defers
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_RDEFERSTORE:
001023 ff07          .dw $ff07
001024 6452
001025 6665
001026 7265
001027 0021          .db "Rdefer!",0
001028 1019          .dw VE_HEAD
                     .set VE_HEAD = VE_RDEFERSTORE
                 XT_RDEFERSTORE:
001029 0108          .dw DO_COLON
                 PFA_RDEFERSTORE:
                 .endif
00102a 0818          .dw XT_FETCHI
00102b 0512          .dw XT_STORE
00102c 04a6          .dw XT_EXIT
                 
                 .include "words/udefer-fetch.asm"
                 
                 ; System
                 ; does the real defer@ for user based defers
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_UDEFERFETCH:
00102d ff07          .dw $ff07
00102e 6455
00102f 6665
001030 7265
001031 0040          .db "Udefer@",0
001032 1023          .dw VE_HEAD
                     .set VE_HEAD = VE_UDEFERFETCH
                 XT_UDEFERFETCH:
001033 0108          .dw DO_COLON
                 PFA_UDEFERFETCH:
                 .endif
001034 0818          .dw XT_FETCHI
001035 0787          .dw XT_UP_FETCH
001036 062e          .dw XT_PLUS
001037 050a          .dw XT_FETCH
001038 04a6          .dw XT_EXIT
                 .include "words/udefer-store.asm"
                 
                 ; System
                 ; does the real defer! for user based defers
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_UDEFERSTORE:
001039 ff07          .dw $ff07
00103a 6455
00103b 6665
00103c 7265
00103d 0021          .db "Udefer!",0
00103e 102d          .dw VE_HEAD
                     .set VE_HEAD = VE_UDEFERSTORE
                 XT_UDEFERSTORE:
00103f 0108          .dw DO_COLON
                 PFA_UDEFERSTORE:
                 .endif
                 
001040 0818          .dw XT_FETCHI
001041 0787          .dw XT_UP_FETCH
001042 062e          .dw XT_PLUS
001043 0512          .dw XT_STORE
001044 04a6          .dw XT_EXIT
                 
                 .include "words/defer-store.asm"
                 
                 ; System
                 ; stores xt1 as the xt to be executed when xt2 is called
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DEFERSTORE:
001045 ff06          .dw $ff06
001046 6564
001047 6566
001048 2172          .db "defer!"
001049 1039          .dw VE_HEAD
                     .set VE_HEAD = VE_DEFERSTORE
                 XT_DEFERSTORE:
00104a 0108          .dw DO_COLON
                 PFA_DEFERSTORE:
                 .endif
00104b 1251          .dw XT_TO_BODY
00104c 0542          .dw XT_DUP
00104d 1002          .dw XT_ICELLPLUS
00104e 1002          .dw XT_ICELLPLUS
00104f 0818          .dw XT_FETCHI
001050 04b0          .dw XT_EXECUTE
001051 04a6          .dw XT_EXIT
                 
                 .include "words/defer-fetch.asm"
                 
                 ; System
                 ; returns the XT associated with the given XT
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DEFERFETCH:
001052 ff06          .dw $ff06
001053 6564
001054 6566
001055 4072          .db "defer@"
001056 1045          .dw VE_HEAD
                     .set VE_HEAD = VE_DEFERFETCH
                 XT_DEFERFETCH:
001057 0108          .dw DO_COLON
                 PFA_DEFERFETCH:
                 .endif
001058 1251          .dw XT_TO_BODY 
001059 0542          .dw XT_DUP
00105a 1002          .dw XT_ICELLPLUS
00105b 0818          .dw XT_FETCHI
00105c 04b0          .dw XT_EXECUTE
00105d 04a6          .dw XT_EXIT
                 .include "words/do-defer.asm"
                 
                 ; System
                 ; runtime of defer
                 VE_DODEFER:
00105e ff07          .dw $ff07
00105f 6428
001060 6665
001061 7265
001062 0029          .db "(defer)", 0
001063 1052          .dw VE_HEAD
                     .set VE_HEAD = VE_DODEFER
                 XT_DODEFER:
001064 0108          .dw DO_COLON
                 PFA_DODEFER:
001065 01a1          .dw XT_DOCREATE
001066 0305          .dw XT_REVEAL
001067 01c7          .dw XT_COMPILE
001068 106a          .dw PFA_DODEFER1
001069 04a6          .dw XT_EXIT
                 PFA_DODEFER1:
00106a 940e 0329     call_ DO_DODOES
00106c 0542          .dw XT_DUP
00106d 1002          .dw XT_ICELLPLUS
00106e 0818          .dw XT_FETCHI
00106f 04b0          .dw XT_EXECUTE 
001070 04b0          .dw XT_EXECUTE
001071 04a6          .dw XT_EXIT
                 
                 ; : (defer) <builds does> dup i-cell+ @i execute execute ;
                 
                 
                 .include "words/search-wordlist.asm"
                 
                 ; Search Order
                 ; searches the word list wid for the word at c-addr/len
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SEARCH_WORDLIST:
001072 ff0f          .dw $ff0f
001073 6573
001074 7261
001075 6863
001076 772d
001077 726f
001078 6c64
001079 7369
00107a 0074          .db "search-wordlist",0
00107b 105e          .dw VE_HEAD
                     .set VE_HEAD = VE_SEARCH_WORDLIST
                 XT_SEARCH_WORDLIST:
00107c 0108          .dw DO_COLON
                 PFA_SEARCH_WORDLIST:
                 .endif
00107d 0590          .dw XT_TO_R
00107e 05e5          .dw XT_ZERO
00107f 04c6          .dw XT_DOLITERAL
001080 1091          .dw XT_ISWORD
001081 0587          .dw XT_R_FROM
001082 10ae          .dw XT_TRAVERSEWORDLIST
001083 0542          .dw XT_DUP
001084 05ab          .dw XT_ZEROEQUAL
001085 04bf          .dw XT_DOCONDBRANCH
001086 108b          DEST(PFA_SEARCH_WORDLIST1)
001087 09d0             .dw XT_2DROP
001088 056a             .dw XT_DROP
001089 05e5             .dw XT_ZERO
00108a 04a6             .dw XT_EXIT
                 PFA_SEARCH_WORDLIST1:
                       ; ... get the XT ...
00108b 0542            .dw XT_DUP
00108c 10d5            .dw XT_NFA2CFA
                       ; .. and get the header flag
00108d 0555            .dw XT_SWAP
00108e 0173            .dw XT_NAME2FLAGS
00108f 0160            .dw XT_IMMEDIATEQ
001090 04a6          .dw XT_EXIT
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 XT_ISWORD:
001091 0108          .dw DO_COLON
                 PFA_ISWORD:
                 .endif
                     ; ( c-addr len 0 nt -- c-addr len 0 true| nt false )
001092 0590          .dw XT_TO_R
001093 056a          .dw XT_DROP
001094 09c7          .dw XT_2DUP
001095 0599          .dw XT_R_FETCH  ; -- addr len addr len nt
001096 10c9          .dw XT_NAME2STRING
001097 10df          .dw XT_ICOMPARE      ; (-- addr len f )
001098 04bf          .dw XT_DOCONDBRANCH
001099 109f          DEST(PFA_ISWORD3)
                       ; not now
00109a 0587            .dw XT_R_FROM
00109b 056a            .dw XT_DROP
00109c 05e5            .dw XT_ZERO
00109d 05dc            .dw XT_TRUE         ; maybe next word
00109e 04a6            .dw XT_EXIT
                 PFA_ISWORD3:
                       ; we found the word, now clean up iteration data ...
00109f 09d0            .dw XT_2DROP
0010a0 0587            .dw XT_R_FROM
0010a1 05e5            .dw XT_ZERO       ; finish traverse-wordlist
0010a2 04a6            .dw XT_EXIT
                 .include "words/traverse-wordlist.asm"
                 
                 ; Tools Ext (2012)
                 ; call the xt for every member of the wordlist wid until xt returns false
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_TRAVERSEWORDLIST:
0010a3 ff11          .dw $ff11
0010a4 7274
0010a5 7661
0010a6 7265
0010a7 6573
0010a8 772d
0010a9 726f
0010aa 6c64
0010ab 7369
0010ac 0074          .db "traverse-wordlist",0
0010ad 1072          .dw VE_HEAD
                     .set VE_HEAD = VE_TRAVERSEWORDLIST
                 XT_TRAVERSEWORDLIST:
0010ae 0108          .dw DO_COLON
                 PFA_TRAVERSEWORDLIST:
                 
                 .endif
0010af 07e5          .dw XT_FETCHE
                 PFA_TRAVERSEWORDLIST1:
0010b0 0542          .dw XT_DUP           ; ( -- xt nt nt )
0010b1 04bf          .dw XT_DOCONDBRANCH  ; ( -- nt ) is nfa = counted string
0010b2 10bf          DEST(PFA_TRAVERSEWORDLIST2)
0010b3 09c7          .dw XT_2DUP
0010b4 07a4          .dw XT_2TO_R
0010b5 0555          .dw XT_SWAP
0010b6 04b0          .dw XT_EXECUTE
0010b7 07b3          .dw XT_2R_FROM
0010b8 0572          .dw XT_ROT
0010b9 04bf          .dw XT_DOCONDBRANCH
0010ba 10bf          DEST(PFA_TRAVERSEWORDLIST2)
0010bb 0481          .dw XT_NFA2LFA
0010bc 0818          .dw XT_FETCHI
0010bd 04b5          .dw XT_DOBRANCH      ; ( -- addr )
0010be 10b0          DEST(PFA_TRAVERSEWORDLIST1)       ; ( -- addr )
                 PFA_TRAVERSEWORDLIST2:
0010bf 09d0          .dw XT_2DROP
0010c0 04a6          .dw XT_EXIT
                 
                 ; : traverse-wordlist ( i*x xt wid -- i*x' ) 
                 ;        begin @ dup 
                 ;        while 
                 ;          2dup 2>r 
                 ;          cell + swap execute ( i*x nt -- i*x' f ) 
                 ;          2r> rot 
                 ;        while repeat then 2drop ; 
                 .include "words/name2string.asm"
                 
                 ; Tools Ext (2012)
                 ; get a (flash) string from a name token nt
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_NAME2STRING:
0010c1 ff0b          .dw $ff0b
0010c2 616e
0010c3 656d
0010c4 733e
0010c5 7274
0010c6 6e69
0010c7 0067          .db "name>string",0
0010c8 10a3          .dw VE_HEAD
                     .set VE_HEAD = VE_NAME2STRING
                 XT_NAME2STRING:
0010c9 0108          .dw DO_COLON
                 PFA_NAME2STRING:
                 
                 .endif
0010ca 0c3a          .dw XT_ICOUNT   ; ( -- addr n )
0010cb 04c6          .dw XT_DOLITERAL
0010cc 00ff          .dw 255
0010cd 06a4          .dw XT_AND      ; mask immediate bit
0010ce 04a6          .dw XT_EXIT
                 .include "words/nfa2cfa.asm"
                 
                 ; Tools
                 ; get the XT from a name token
                 VE_NFA2CFA:
0010cf ff07          .dw $ff07
0010d0 666e
0010d1 3e61
0010d2 6663
../../avr8\words/nfa2cfa.asm(6): warning: .cseg .db misalignment - padding zero byte
0010d3 0061          .db "nfa>cfa"
0010d4 10c1          .dw VE_HEAD
                     .set VE_HEAD = VE_NFA2CFA
                 XT_NFA2CFA:
0010d5 0108          .dw DO_COLON
                 PFA_NFA2CFA:
0010d6 0481          .dw XT_NFA2LFA ; skip to link field
0010d7 06c0          .dw XT_1PLUS   ; next is the execution token
0010d8 04a6          .dw XT_EXIT
                 .include "words/icompare.asm"
                 
                 ; Tools
                 ; compares string in RAM with string in flash. f is zero if equal like COMPARE
                 VE_ICOMPARE:
0010d9 ff08          .dw $ff08
0010da 6369
0010db 6d6f
0010dc 6170
0010dd 6572          .db "icompare"
0010de 10cf          .dw VE_HEAD
                     .set VE_HEAD = VE_ICOMPARE
                 XT_ICOMPARE:
0010df 0108          .dw DO_COLON
                 PFA_ICOMPARE:
0010e0 0590          .dw XT_TO_R    ; ( -- r-addr r-len f-addr)
0010e1 0560          .dw XT_OVER    ; ( -- r-addr r-len f-addr r-len)
0010e2 0587          .dw XT_R_FROM  ; ( -- r-addr r-len f-addr r-len f-len )
0010e3 05a4          .dw XT_NOTEQUAL ; ( -- r-addr r-len f-addr flag )
0010e4 04bf          .dw XT_DOCONDBRANCH
0010e5 10ea          .dw PFA_ICOMPARE_SAMELEN
0010e6 09d0            .dw XT_2DROP
0010e7 056a            .dw XT_DROP
0010e8 05dc            .dw XT_TRUE
0010e9 04a6            .dw XT_EXIT
                 PFA_ICOMPARE_SAMELEN:
0010ea 0555          .dw XT_SWAP ; ( -- r-addr f-addr len )
0010eb 05e5          .dw XT_ZERO
0010ec 0291          .dw XT_QDOCHECK
0010ed 04bf          .dw XT_DOCONDBRANCH
0010ee 110d          .dw PFA_ICOMPARE_DONE
0010ef 0720          .dw XT_DODO
                 PFA_ICOMPARE_LOOP:
                     ; ( r-addr f-addr --)
0010f0 0560          .dw XT_OVER
0010f1 050a          .dw XT_FETCH
                 .if WANT_IGNORECASE == 1
                 .endif
0010f2 0560          .dw XT_OVER
0010f3 0818          .dw XT_FETCHI ; ( -- r-addr f-addr r-cc f- cc)
                 .if WANT_IGNORECASE == 1
                 .endif
                     ; flash strings are zero-padded at the last cell
                     ; that means: if the flash cell is less $0100, than mask the
                     ; high byte in the ram cell
0010f4 0542          .dw XT_DUP
                     ;.dw XT_BYTESWAP
0010f5 04c6          .dw XT_DOLITERAL
0010f6 0100          .dw $100
0010f7 05ed          .dw XT_ULESS
0010f8 04bf          .dw XT_DOCONDBRANCH
0010f9 10fe          .dw PFA_ICOMPARE_LASTCELL
0010fa 0555          .dw XT_SWAP
0010fb 04c6          .dw XT_DOLITERAL
0010fc 00ff          .dw $00FF
0010fd 06a4          .dw XT_AND  ; the final swap can be omitted
                 PFA_ICOMPARE_LASTCELL:
0010fe 05a4          .dw XT_NOTEQUAL
0010ff 04bf          .dw XT_DOCONDBRANCH
001100 1105          .dw PFA_ICOMPARE_NEXTLOOP
001101 09d0          .dw XT_2DROP
001102 05dc          .dw XT_TRUE
001103 0759          .dw XT_UNLOOP
001104 04a6          .dw XT_EXIT
                 PFA_ICOMPARE_NEXTLOOP:
001105 06c0          .dw XT_1PLUS
001106 0555          .dw XT_SWAP
001107 09bf          .dw XT_CELLPLUS
001108 0555          .dw XT_SWAP
001109 04c6          .dw XT_DOLITERAL
00110a 0002          .dw 2
00110b 073f          .dw XT_DOPLUSLOOP
00110c 10f0          .dw PFA_ICOMPARE_LOOP
                 PFA_ICOMPARE_DONE:
00110d 09d0          .dw XT_2DROP
00110e 05e5          .dw XT_ZERO
00110f 04a6          .dw XT_EXIT
                 
                 .if WANT_IGNORECASE == 1
                 .endif
                 
                 .include "words/star.asm"
                 
                 ; Arithmetics
                 ; multiply routine
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_STAR:
001110 ff01          .dw $ff01
001111 002a          .db "*",0
001112 10d9          .dw VE_HEAD
                     .set VE_HEAD = VE_STAR
                 XT_STAR:
001113 0108          .dw DO_COLON
                 PFA_STAR:
                 .endif
                 
001114 0637          .dw XT_MSTAR
001115 056a          .dw XT_DROP
001116 04a6          .dw XT_EXIT
                 .include "words/j.asm"
                 
                 ; Compiler
                 ; loop counter of outer loop
                 VE_J:
001117 ff01          .dw $FF01
001118 006a          .db "j",0
001119 1110          .dw VE_HEAD
                     .set VE_HEAD = VE_J
                 XT_J:
00111a 0108          .dw DO_COLON
                 PFA_J:
00111b 06fb          .dw XT_RP_FETCH
00111c 04c6          .dw XT_DOLITERAL
00111d 0007          .dw 7
00111e 062e          .dw XT_PLUS
00111f 050a          .dw XT_FETCH
001120 06fb          .dw XT_RP_FETCH
001121 04c6          .dw XT_DOLITERAL
001122 0009          .dw 9
001123 062e          .dw XT_PLUS
001124 050a          .dw XT_FETCH
001125 062e          .dw XT_PLUS
001126 04a6          .dw XT_EXIT
                 
                 .include "words/dabs.asm"
                 
                 ; Arithmetics
                 ; double cell absolute value
                 VE_DABS:
001127 ff04          .dw $ff04
001128 6164
001129 7362          .db "dabs"
00112a 1117          .dw VE_HEAD
                     .set VE_HEAD = VE_DABS
                 XT_DABS:
00112b 0108          .dw DO_COLON
                 PFA_DABS:
00112c 0542          .dw XT_DUP
00112d 05b2          .dw XT_ZEROLESS
00112e 04bf          .dw XT_DOCONDBRANCH
00112f 1131          .dw PFA_DABS1
001130 1138          .dw XT_DNEGATE
                 PFA_DABS1:
001131 04a6          .dw XT_EXIT
                 ; : dabs      ( ud1 -- +d2 ) dup 0< if dnegate then ;
                 .include "words/dnegate.asm"
                 
                 ; Arithmetics
                 ; double cell negation
                 VE_DNEGATE:
001132 ff07          .dw $ff07
001133 6e64
001134 6765
001135 7461
001136 0065          .db "dnegate",0
001137 1127          .dw VE_HEAD
                     .set VE_HEAD = VE_DNEGATE
                 XT_DNEGATE:
001138 0108          .dw DO_COLON
                 PFA_DNEGATE:
001139 088b          .dw XT_DINVERT
00113a 04c6          .dw XT_DOLITERAL
00113b 0001          .dw 1
00113c 05e5          .dw XT_ZERO
00113d 0865          .dw XT_DPLUS
00113e 04a6          .dw XT_EXIT
                 ; : dnegate   ( ud1 -- ud2 ) dinvert 1. d+ ;
                 .include "words/cmove.asm"
                 
                 ; Memory
                 ; copy data in RAM, from lower to higher addresses
                 VE_CMOVE:
00113f ff05          .dw $ff05
001140 6d63
001141 766f
001142 0065          .db "cmove",0
001143 1132          .dw VE_HEAD
                     .set VE_HEAD  = VE_CMOVE
                 XT_CMOVE:
001144 1145          .dw PFA_CMOVE
                 PFA_CMOVE:
001145 93bf          push xh
001146 93af          push xl
001147 91e9          ld zl, Y+
001148 91f9          ld zh, Y+ ; addr-to
001149 91a9          ld xl, Y+
00114a 91b9          ld xh, Y+ ; addr-from
00114b 2f09          mov temp0, tosh
00114c 2b08          or temp0, tosl
00114d f021          brbs 1, PFA_CMOVE1
                 PFA_CMOVE2:
00114e 911d          ld temp1, X+
00114f 9311          st Z+, temp1
001150 9701          sbiw tosl, 1
001151 f7e1          brbc 1, PFA_CMOVE2
                 PFA_CMOVE1:
001152 91af          pop xl
001153 91bf          pop xh
001154 9189
001155 9199          loadtos
001156 940c 010c     jmp_ DO_NEXT
                 .include "words/2swap.asm"
                 
                 ; Stack
                 ; Exchange the two top cell pairs
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_2SWAP:
001158 ff05          .dw $ff05
001159 7332
00115a 6177
00115b 0070          .db "2swap",0
00115c 113f          .dw VE_HEAD
                     .set VE_HEAD = VE_2SWAP
                 XT_2SWAP:
00115d 0108          .dw DO_COLON
                 PFA_2SWAP:
                 
                 .endif
00115e 0572          .dw XT_ROT
00115f 0590          .dw XT_TO_R
001160 0572          .dw XT_ROT
001161 0587          .dw XT_R_FROM
001162 04a6          .dw XT_EXIT
                 
                 .include "words/tib.asm"
                 
                 ; System Variable
                 ; terminal input buffer address
                 VE_TIB:
001163 ff03          .dw $ff03
001164 6974
001165 0062          .db "tib",0
001166 1158          .dw VE_HEAD
                     .set VE_HEAD = VE_TIB
                 XT_TIB:
001167 04d4          .dw PFA_DOVARIABLE
                 PFA_TIB:
001168 024d          .dw ram_tib
                     
                 .dseg
00024d           ram_tib: .byte TIBSIZE
                 .cseg
                 ; ( -- f ) 
                 ; System
                 ; refills the input buffer
                 VE_REFILLTIB:
001169 ff0a          .dw $ff0a
00116a 6572
00116b 6966
00116c 6c6c
00116d 742d
00116e 6269          .db "refill-tib"
00116f 1163          .dw VE_HEAD
                     .set VE_HEAD = VE_REFILLTIB
                 XT_REFILLTIB:
001170 0108          .dw DO_COLON
                 PFA_REFILLTIB:
001171 1167          .dw XT_TIB
001172 04c6          .dw XT_DOLITERAL
001173 005a          .dw TIBSIZE
001174 0cf8          .dw XT_ACCEPT
001175 09e6          .dw XT_NUMBERTIB
001176 0512          .dw XT_STORE
001177 05e5          .dw XT_ZERO
001178 09e0          .dw XT_TO_IN
001179 0512          .dw XT_STORE
00117a 05dc          .dw XT_TRUE ; -1
00117b 04a6          .dw XT_EXIT
                 
                 ; ( -- addr n ) 
                 ; System
                 ; address and current length of the input buffer
                 VE_SOURCETIB:
00117c ff0a          .dw $FF0A
00117d 6f73
00117e 7275
00117f 6563
001180 742d
001181 6269          .db "source-tib"
001182 1169          .dw VE_HEAD
                     .set VE_HEAD = VE_SOURCETIB
                 XT_SOURCETIB:
001183 0108          .dw DO_COLON
                 PFA_SOURCETIB:
001184 1167          .dw XT_TIB
001185 09e6          .dw XT_NUMBERTIB
001186 050a          .dw XT_FETCH
001187 04a6          .dw XT_EXIT
                 
                 .include "words/init-user.asm"
                 
                 ; Tools
                 ; copy len cells from eeprom to ram
                 VE_EE2RAM:
001188 ff06        .dw $ff06
001189 6565
00118a 723e
00118b 6d61        .db "ee>ram"
00118c 117c        .dw VE_HEAD
                   .set VE_HEAD = VE_EE2RAM
                 XT_EE2RAM:
00118d 0108        .dw DO_COLON
                 PFA_EE2RAM:          ; ( -- )
00118e 05e5          .dw XT_ZERO
00118f 0720          .dw XT_DODO
                 PFA_EE2RAM_1:
                     ; ( -- e-addr r-addr )
001190 0560          .dw XT_OVER
001191 07e5          .dw XT_FETCHE
001192 0560          .dw XT_OVER
001193 0512          .dw XT_STORE
001194 09bf          .dw XT_CELLPLUS
001195 0555          .dw XT_SWAP
001196 09bf          .dw XT_CELLPLUS
001197 0555          .dw XT_SWAP
001198 074e          .dw XT_DOLOOP
001199 1190          .dw PFA_EE2RAM_1
                 PFA_EE2RAM_2:
00119a 09d0          .dw XT_2DROP
00119b 04a6          .dw XT_EXIT
                 
                 ; ( -- )
                 ; Tools
                 ; setup the default user area from eeprom
                 VE_INITUSER:
00119c ff09        .dw $ff09
00119d 6e69
00119e 7469
00119f 752d
0011a0 6573
0011a1 0072        .db "init-user",0
0011a2 1188        .dw VE_HEAD
                   .set VE_HEAD = VE_INITUSER
                 XT_INITUSER:
0011a3 0108        .dw DO_COLON
                 PFA_INITUSER:          ; ( -- )
0011a4 04c6          .dw XT_DOLITERAL
0011a5 00a8          .dw EE_INITUSER
0011a6 0787          .dw XT_UP_FETCH
0011a7 04c6          .dw XT_DOLITERAL
0011a8 001c          .dw SYSUSERSIZE
0011a9 0695          .dw XT_2SLASH
0011aa 118d          .dw XT_EE2RAM
0011ab 04a6          .dw XT_EXIT
                 .include "dict/compiler2.inc"
                 
                 ; included almost independently from each other
                 ; on a include-per-use basis
                 ;
                 .if DICT_COMPILER2 == 0
                 .set DICT_COMPILER2 = 1
                 
                 .include "words/set-current.asm"
                 
                 ; Search Order
                 ; set current word list to the given word list wid
                 VE_SET_CURRENT:
0011ac ff0b          .dw $ff0b
0011ad 6573
0011ae 2d74
0011af 7563
0011b0 7272
0011b1 6e65
0011b2 0074          .db "set-current",0
0011b3 119c          .dw VE_HEAD
                     .set VE_HEAD = VE_SET_CURRENT
                 XT_SET_CURRENT:
0011b4 0108          .dw DO_COLON
                 PFA_SET_CURRENT:
0011b5 04c6          .dw XT_DOLITERAL
0011b6 0082          .dw EE_CURRENT
0011b7 07c1          .dw XT_STOREE
0011b8 04a6          .dw XT_EXIT
                 .include "words/wordlist.asm"
                 
                 ; Search Order
                 ; create a new, empty wordlist
                 VE_WORDLIST:
0011b9 ff08          .dw $ff08
0011ba 6f77
0011bb 6472
0011bc 696c
0011bd 7473          .db "wordlist"
0011be 11ac          .dw VE_HEAD
                     .set VE_HEAD = VE_WORDLIST
                 XT_WORDLIST:
0011bf 0108          .dw DO_COLON
                 PFA_WORDLIST:
0011c0 0a1f          .dw XT_EHERE
0011c1 05e5          .dw XT_ZERO
0011c2 0560          .dw XT_OVER
0011c3 07c1          .dw XT_STOREE
0011c4 0542          .dw XT_DUP
0011c5 09bf          .dw XT_CELLPLUS
0011c6 0ff0          .dw XT_DOTO
0011c7 0a20          .dw PFA_EHERE
0011c8 04a6          .dw XT_EXIT
                 
                 .include "words/only.asm"
                 
                 ; Search Order
                 ; replace the order list with the system default list
                 VE_ONLY:
0011c9 ff04          .dw $ff04
0011ca 6e6f
0011cb 796c          .db "only"
0011cc 11b9          .dw VE_HEAD
                     .set VE_HEAD = VE_ONLY
                 XT_ONLY:
0011cd 0108          .dw DO_COLON
                 PFA_ONLY:
0011ce 04c6          .dw XT_DOLITERAL
0011cf 0084          .dw EE_FORTHWORDLIST
0011d0 04c6          .dw XT_DOLITERAL
0011d1 0001          .dw 1
0011d2 11e8          .dw XT_SET_ORDER
0011d3 04a6          .dw XT_EXIT
                 .include "words/forth-wordlist.asm"
                 
                 ; Search Order
                 ; get the system default word list
                 VE_FORTH_WORDLIST:
0011d4 ff0e          .dw $ff0e
0011d5 6f66
0011d6 7472
0011d7 2d68
0011d8 6f77
0011d9 6472
0011da 696c
0011db 7473          .db "forth-wordlist"
0011dc 11c9          .dw VE_HEAD
                     .set VE_HEAD = VE_FORTH_WORDLIST
                 XT_FORTH_WORDLIST:
0011dd 0501          .dw PFA_DOVALUE1
                 PFA_FORTH_WORDLIST:
0011de 0080          .dw EE_WL_FORTH
0011df 100b          .dw XT_EDEFERFETCH
0011e0 1015          .dw XT_EDEFERSTORE
                 .include "words/set-order.asm"
                 
                 ; Search Order
                 ; replace the search order list
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SET_ORDER:
0011e1 ff09          .dw $ff09
0011e2 6573
0011e3 2d74
0011e4 726f
0011e5 6564
0011e6 0072          .db "set-order",0
0011e7 11d4          .dw VE_HEAD
                     .set VE_HEAD = VE_SET_ORDER
                 XT_SET_ORDER:
0011e8 0108          .dw DO_COLON
                 PFA_SET_ORDER:
                 .endif
0011e9 04c6          .dw XT_DOLITERAL
0011ea 0086          .dw CFG_ORDERLISTLEN
0011eb 0404          .dw XT_SET_STACK
0011ec 04a6          .dw XT_EXIT
                 
                 .include "words/set-recognizer.asm"
                 
                 ; Interpreter
                 ; replace the recognizer list
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SET_RECOGNIZERS:
0011ed ff0f          .dw $ff0f
0011ee 6573
0011ef 2d74
0011f0 6572
0011f1 6f63
0011f2 6e67
0011f3 7a69
0011f4 7265
0011f5 0073          .db "set-recognizers",0
0011f6 11e1          .dw VE_HEAD
                     .set VE_HEAD = VE_SET_RECOGNIZERS
                 XT_SET_RECOGNIZERS:
0011f7 0108          .dw DO_COLON
                 PFA_SET_RECOGNIZERS:
                 .endif
0011f8 04c6          .dw XT_DOLITERAL
0011f9 0098          .dw CFG_RECOGNIZERLISTLEN
0011fa 0404          .dw XT_SET_STACK
0011fb 04a6          .dw XT_EXIT
                 
                 .include "words/get-recognizer.asm"
                 
                 ; Interpreter
                 ; Get the current recognizer list
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_GET_RECOGNIZERS:
0011fc ff0f          .dw $ff0f
0011fd 6567
0011fe 2d74
0011ff 6572
001200 6f63
001201 6e67
001202 7a69
001203 7265
001204 0073          .db "get-recognizers",0
001205 11ed          .dw VE_HEAD
                     .set VE_HEAD = VE_GET_RECOGNIZERS
                 XT_GET_RECOGNIZERS:
001206 0108          .dw DO_COLON
                 PFA_GET_RECOGNIZERS:
                 .endif
001207 04c6          .dw XT_DOLITERAL
001208 0098          .dw CFG_RECOGNIZERLISTLEN
001209 03e3          .dw XT_GET_STACK
00120a 04a6          .dw XT_EXIT
                 .include "words/code.asm"
                 
                 ; Compiler
                 ; create named entry in the dictionary, XT is the data field
                 VE_CODE:
00120b ff04          .dw $ff04
00120c 6f63
00120d 6564          .db "code"
00120e 11fc          .dw VE_HEAD
                     .set VE_HEAD = VE_CODE
                 XT_CODE:
00120f 0108          .dw DO_COLON
                 PFA_CODE:
001210 01a1          .dw XT_DOCREATE
001211 0305          .dw XT_REVEAL
001212 0a16          .dw XT_DP
001213 1002          .dw XT_ICELLPLUS
001214 01d2          .dw XT_COMMA
001215 04a6          .dw XT_EXIT
                 .include "words/end-code.asm"
                 
                 ; Compiler
                 ; finish a code definition
                 VE_ENDCODE:
001216 ff08          .dw $ff08
001217 6e65
001218 2d64
001219 6f63
00121a 6564          .db "end-code"
00121b 120b          .dw VE_HEAD
                     .set VE_HEAD = VE_ENDCODE
                 XT_ENDCODE:
00121c 0108          .dw DO_COLON
                 PFA_ENDCODE:
00121d 01c7          .dw XT_COMPILE
00121e 940c          .dw $940c
00121f 01c7          .dw XT_COMPILE
001220 010c          .dw DO_NEXT
001221 04a6          .dw XT_EXIT
                 .include "words/marker.asm"
                 
                 ; System Value
                 ; The eeprom address until which MARKER saves and restores the eeprom data.
                 VE_MARKER:
001222 ff08          .dw $ff08
001223 6d28
001224 7261
001225 656b
001226 2972          .db "(marker)"
001227 1216          .dw VE_HEAD
                     .set VE_HEAD = VE_MARKER
                 XT_MARKER:
001228 0501          .dw PFA_DOVALUE1
                 PFA_MARKER:
001229 00a6          .dw EE_MARKER
00122a 100b          .dw XT_EDEFERFETCH
00122b 1015          .dw XT_EDEFERSTORE
                 .include "words/postpone.asm"
                 
                 ; Compiler
                 ; Append the compilation semantics of "name" to the dictionary
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_POSTPONE:
00122c 0008          .dw $0008
00122d 6f70
00122e 7473
00122f 6f70
001230 656e          .db "postpone"
001231 1222          .dw VE_HEAD
                     .set VE_HEAD = VE_POSTPONE
                 XT_POSTPONE:
001232 0108          .dw DO_COLON
                 PFA_POSTPONE:
                 .endif
001233 0e1b          .dw XT_PARSENAME
001234 0f19          .dw XT_DORECOGNIZER
001235 1002          .dw XT_ICELLPLUS 
001236 1002          .dw XT_ICELLPLUS
001237 0818          .dw XT_FETCHI
001238 04b0          .dw XT_EXECUTE
001239 04a6          .dw XT_EXIT
                 .endif
                 .include "words/bounds.asm"
                 
                 ; Tools
                 ; convert a string to an address range
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_BOUNDS:
00123a ff06          .dw $ff06
00123b 6f62
00123c 6e75
00123d 7364          .db "bounds"
00123e 122c          .dw VE_HEAD
                     .set VE_HEAD = VE_BOUNDS
                 XT_BOUNDS:
00123f 0108          .dw DO_COLON
                 PFA_BOUNDS:
                 .endif
001240 0560          .dw XT_OVER
001241 062e          .dw XT_PLUS
001242 0555          .dw XT_SWAP
001243 04a6          .dw XT_EXIT
                 .include "words/s-to-d.asm"
                 
                 ; Conversion
                 ; extend (signed) single cell value to double cell
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_S2D:
001244 ff03          .dw $ff03
001245 3e73
001246 0064          .db "s>d",0
001247 123a          .dw VE_HEAD
                     .set VE_HEAD = VE_S2D
                 XT_S2D:
001248 0108          .dw DO_COLON
                 PFA_S2D:
                 .endif
001249 0542          .dw XT_DUP
00124a 05b2          .dw XT_ZEROLESS
00124b 04a6          .dw XT_EXIT
                 .include "words/to-body.asm"
                 
                 ; Core
                 ; get body from XT
                 VE_TO_BODY:
00124c ff05          .dw $ff05
00124d 623e
00124e 646f
00124f 0079          .db ">body",0
001250 1244          .dw VE_HEAD
                     .set VE_HEAD = VE_TO_BODY
                 XT_TO_BODY:
001251 06c1          .dw PFA_1PLUS
                 .elif AMFORTH_NRWW_SIZE>4000
                 .elif AMFORTH_NRWW_SIZE>2000
                 .else
                 .endif
                 ; now colon words
                 ;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/2literal.asm"
                 
                 ; Compiler
                 ; compile a cell pair literal in colon definitions
                 VE_2LITERAL:
001252 0008          .dw $0008
001253 6c32
001254 7469
001255 7265
001256 6c61          .db "2literal"
001257 124c          .dw VE_HEAD
                     .set VE_HEAD = VE_2LITERAL
                 XT_2LITERAL:
001258 0108          .dw DO_COLON
                 PFA_2LITERAL:
001259 0555          .dw XT_SWAP
00125a 01c7          .dw XT_COMPILE
00125b 04c6          .dw XT_DOLITERAL
00125c 01d2          .dw XT_COMMA
00125d 01c7          .dw XT_COMPILE
00125e 04c6          .dw XT_DOLITERAL
00125f 01d2          .dw XT_COMMA
                     
001260 04a6          .dw XT_EXIT
                 .include "words/equal.asm"
                 
                 ; Compare
                 ; compares two values for equality
                 VE_EQUAL:
001261 ff01          .dw $ff01
001262 003d          .db "=",0
001263 1252          .dw VE_HEAD
                     .set VE_HEAD = VE_EQUAL
                 XT_EQUAL:
001264 0108          .dw DO_COLON
                 PFA_EQUAL:
001265 0624          .dw XT_MINUS
001266 05ab          .dw XT_ZEROEQUAL
001267 04a6          .dw XT_EXIT
                 .include "words/num-constants.asm"
                 
                 .endif
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_ONE:
001268 ff01          .dw $ff01
001269 0031          .db "1",0
00126a 1261          .dw VE_HEAD
                     .set VE_HEAD = VE_ONE
                 XT_ONE:
00126b 04d4          .dw PFA_DOVARIABLE
                 PFA_ONE:
                 .endif
00126c 0001              .DW 1
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_TWO:
00126d ff01          .dw $ff01
00126e 0032          .db "2",0
00126f 1268          .dw VE_HEAD
                     .set VE_HEAD = VE_TWO
                 XT_TWO:
001270 04d4          .dw PFA_DOVARIABLE
                 PFA_TWO:
                 .endif
001271 0002              .DW 2
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_MINUSONE:
001272 ff02          .dw $ff02
001273 312d          .db "-1"
001274 126d          .dw VE_HEAD
                     .set VE_HEAD = VE_MINUSONE
                 XT_MINUSONE:
001275 04d4          .dw PFA_DOVARIABLE
                 PFA_MINUSONE:
                 .endif
001276 ffff              .DW -1
                 .include "dict_appl_core.inc"
                 
                 ; do not delete it!
                 
                 
                 .set DPSTART = pc
                 .set flashlast = pc
                 
                 .dseg
                 HERESTART:
                 .eseg
                 .include "amforth-eeprom.inc"
000072 ff ff     
                 EE_DP:
000074 77 12         .dw DPSTART      ; Dictionary Pointer
                 EE_HERE:
000076 a7 02         .dw HERESTART    ; Memory Allocation
                 EE_EHERE:
000078 c6 00         .dw EHERESTART     ; EEProm Memory Allocation
                 EE_TURNKEY:
00007a 8f 04         .dw XT_APPLTURNKEY  ; TURNKEY
                 EE_STOREI:
00007c 01 08         .dw XT_DO_STOREI  ; Store a cell into flash
                 
                 EE_ENVIRONMENT:
00007e 93 09         .dw VE_ENVHEAD   ; environmental queries
                 EE_WL_FORTH:
000080 84 00         .dw EE_FORTHWORDLIST; forth-wordlist
                 EE_CURRENT:
000082 84 00         .dw EE_FORTHWORDLIST
                 EE_FORTHWORDLIST:
000084 72 12         .dw VE_HEAD      ; pre-defined (compiled in) wordlist
                 CFG_ORDERLISTLEN:
000086 01 00         .dw 1
                 CFG_ORDERLIST: ; list of wordlist id, exactly numwordlist entries
000088 84 00         .dw EE_FORTHWORDLIST      ; get/set-order
00008a               .byte  (NUMWORDLISTS-1)*CELLSIZE ; one slot is already used
                 CFG_RECOGNIZERLISTLEN:
000098 02 00         .dw 2
                 CFG_RECOGNIZERLIST:
00009a 73 0f         .dw XT_REC_WORD
00009c 5e 0f         .dw XT_REC_NUM
00009e               .byte  (NUMRECOGNIZERS-2)*CELLSIZE ; two slots are already used
                 
                 EE_WLSCOPE:
0000a2 43 04         .dw XT_GET_CURRENT  ; default wordlist scope
                 
                 ; LEAVE stack is between data stack and return stack.
                 EE_LP0:
0000a4 b0 21         .dw stackstart+1
                 
                 ; MARKER saves everything up to here. Nothing beyond gets saved
                 EE_MARKER:
0000a6 a6 00         .dw EE_MARKER
                 
                 ; default user area
                 EE_INITUSER:
0000a8 00 00         .dw 0  ; USER_STATE
0000aa 00 00         .dw 0  ; USER_FOLLOWER
0000ac ff 21         .dw rstackstart  ; USER_RP
0000ae af 21         .dw stackstart   ; USER_SP0
0000b0 af 21         .dw stackstart   ; USER_SP
                     
0000b2 00 00         .dw 0  ; USER_HANDLER
0000b4 0a 00         .dw 10 ; USER_BASE
                     
0000b6 ce 00         .dw XT_TX  ; USER_EMIT
0000b8 dc 00         .dw XT_TXQ ; USER_EMITQ
0000ba a4 00         .dw XT_RX  ; USER_KEY
0000bc be 00         .dw XT_RXQ ; USER_KEYQ
0000be 83 11         .dw XT_SOURCETIB ; USER_SKEY
0000c0 00 00         .dw 0            ; USER_G_IN
0000c2 70 11         .dw XT_REFILLTIB ; USER_REFILL  
                 
                 ; calculate baud rate error
                 .equ UBRR_VAL   = ((F_CPU+BAUD*8)/(BAUD*16)-1)  ; smart round
                 .equ BAUD_REAL  = (F_CPU/(16*(UBRR_VAL+1)))     ; effective baud rate
                 .equ BAUD_ERROR = ((BAUD_REAL*1000)/BAUD-1000)  ; error in pro mille
                 
                 .if ((BAUD_ERROR>BAUD_MAXERROR) || (BAUD_ERROR<-BAUD_MAXERROR))       
                 .endif
                 EE_UBRRVAL:
0000c4 17 00         .dw UBRR_VAL     ; BAUDRATE
                 ; 1st free address in EEPROM.
                 EHERESTART:
                 
                 .cseg


RESOURCE USE INFORMATION
------------------------

Notice:
The register and instruction counts are symbol table hit counts,
and hence implicitly used resources are not counted, eg, the
'lpm' instruction without operands implicitly uses r0 and z,
none of which are counted.

x,y,z are separate entities in the symbol table and are
counted separately from r26..r31 here.

.dseg memory usage only counts static data declared with .byte

"ATmega2561" register use summary:
r0 :  21 r1 :   5 r2 :   8 r3 :  11 r4 :   4 r5 :   1 r6 :   0 r7 :   0 
r8 :   0 r9 :   0 r10:   1 r11:   0 r12:   0 r13:   0 r14:  22 r15:  20 
r16:  75 r17:  52 r18:  52 r19:  37 r20:  13 r21:  38 r22:  11 r23:   4 
r24: 185 r25: 132 r26:  39 r27:  21 r28:   7 r29:   4 r30:  79 r31:  39 
x  :   4 y  : 199 z  :  39 
Registers used: 28 out of 35 (80.0%)

"ATmega2561" instruction use summary:
.lds  :   0 .sts  :   0 adc   :  21 add   :  16 adiw  :  18 and   :   4 
andi  :   3 asr   :   2 bclr  :   0 bld   :   0 brbc  :   2 brbs  :   7 
brcc  :   2 brcs  :   1 break :   0 breq  :   6 brge  :   1 brhc  :   0 
brhs  :   0 brid  :   0 brie  :   0 brlo  :   1 brlt  :   3 brmi  :   3 
brne  :  12 brpl  :   1 brsh  :   0 brtc  :   0 brts  :   1 brvc  :   0 
brvs  :   2 bset  :   0 bst   :   0 call  :   1 cbi   :   0 cbr   :   0 
clc   :   1 clh   :   0 cli   :   5 cln   :   0 clr   :  18 cls   :   0 
clt   :   1 clv   :   0 clz   :   0 com   :  16 cp    :  10 cpc   :  10 
cpi   :   2 cpse  :   0 dec   :  10 eicall:   1 eijmp :   0 elpm  :  16 
eor   :   3 fmul  :   0 fmuls :   0 fmulsu:   0 icall :   0 ijmp  :   1 
in    :  15 inc   :   2 jmp   :  10 ld    : 133 ldd   :   4 ldi   :  29 
lds   :   2 lpm   :   0 lsl   :  14 lsr   :   1 mov   :  11 movw  :  65 
mul   :   5 muls  :   1 mulsu :   2 neg   :   0 nop   :   1 or    :   9 
ori   :   0 out   :  27 pop   :  50 push  :  42 rcall :  69 ret   :   6 
reti  :   2 rjmp  : 102 rol   :  32 ror   :   5 sbc   :   9 sbci  :   3 
sbi   :   3 sbic  :   3 sbis  :   0 sbiw  :   7 sbr   :   0 sbrc  :   4 
sbrs  :   3 sec   :   1 seh   :   0 sei   :   1 sen   :   0 ser   :   3 
ses   :   0 set   :   2 sev   :   0 sez   :   0 sleep :   0 spm   :   2 
st    :  71 std   :   8 sts   :   3 sub   :   6 subi  :   3 swap  :   0 
tst   :   1 wdr   :   0 
Instructions used: 76 out of 116 (65.5%)

"ATmega2561" memory use summary [bytes]:
Segment   Begin    End      Code   Data   Used    Size   Use%
---------------------------------------------------------------
[.cseg] 0x000000 0x03e07e   1976  12812  14788  262144   5.6%
[.dseg] 0x000200 0x0002a7      0    167    167    8192   2.0%
[.eseg] 0x000000 0x0000c6      0    198    198    4096   4.8%

Assembly complete, 0 errors, 5 warnings
