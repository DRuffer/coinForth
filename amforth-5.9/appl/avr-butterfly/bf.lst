
AVRASM ver. 2.1.52  bf.asm Fri Jul 10 18:43:15 2015

bf.asm(5): Including file '../../avr8\preamble.inc'
../../avr8\preamble.inc(2): Including file '../../avr8\macros.asm'
../../avr8\macros.asm(6): Including file '../../avr8\user.inc'
../../avr8\preamble.inc(6): Including file '../../avr8/devices/atmega169\device.asm'
../../avr8/devices/atmega169\device.asm(6): Including file '../../avr8/Atmel/Appnotes2\m169def.inc'
bf.asm(8): Including file '../../avr8\drivers/usart.asm'
../../avr8\drivers/usart.asm(30): Including file '../../avr8\drivers/usart_common.asm'
../../avr8\drivers/usart_common.asm(5): Including file '../../avr8\drivers/usart-isr-rx.asm'
../../avr8\drivers/usart_common.asm(17): Including file '../../avr8\words/usart-tx-poll.asm'
../../avr8\drivers/usart_common.asm(22): Including file '../../avr8\words/ubrr.asm'
../../avr8\drivers/usart_common.asm(23): Including file '../../avr8\words/usart.asm'
bf.asm(10): Including file '../../avr8\amforth.asm'
../../avr8\amforth.asm(12): Including file '../../avr8\drivers/generic-isr.asm'
../../avr8\amforth.asm(14): Including file '../../avr8\dict/rww.inc'
../../avr8\dict/rww.inc(1): Including file '../../avr8\words/mplus.asm'
../../avr8\dict/rww.inc(2): Including file '../../common\words/ud-star.asm'
../../avr8\dict/rww.inc(3): Including file '../../common\words/umax.asm'
../../avr8\dict/rww.inc(4): Including file '../../common\words/umin.asm'
../../avr8\dict/rww.inc(5): Including file '../../avr8\words/immediate-q.asm'
../../avr8\dict/rww.inc(6): Including file '../../avr8\words/name2flags.asm'
../../avr8\dict/rww.inc(7): Including file '../../common\words/name2interpret.asm'
../../avr8\dict/rww.inc(8): Including file '../../common\words/name2compile.asm'
../../avr8\dict/rww.inc(15): Including file '../../avr8\dict/appl_2k.inc'
../../avr8\dict/appl_2k.inc(1): Including file '../../avr8\words/d-2star.asm'
../../avr8\dict/appl_2k.inc(2): Including file '../../avr8\words/d-2slash.asm'
../../avr8\dict/appl_2k.inc(3): Including file '../../avr8\words/d-plus.asm'
../../avr8\dict/appl_2k.inc(4): Including file '../../avr8\words/d-minus.asm'
../../avr8\dict/appl_2k.inc(5): Including file '../../avr8\words/d-invert.asm'
../../avr8\dict/appl_2k.inc(6): Including file '../../avr8\words/d-equal.asm'
../../avr8\dict/appl_2k.inc(7): Including file '../../common\words/u-dot.asm'
../../avr8\dict/appl_2k.inc(8): Including file '../../common\words/u-dot-r.asm'
../../avr8\dict/appl_2k.inc(10): Including file '../../common\words/show-wordlist.asm'
../../avr8\dict/appl_2k.inc(11): Including file '../../avr8\words/words.asm'
../../avr8\dict/appl_2k.inc(12): Including file '../../avr8\dict/interrupt.inc'
../../avr8\dict/interrupt.inc(2): Including file '../../avr8\words/int-on.asm'
../../avr8\dict/interrupt.inc(3): Including file '../../avr8\words/int-off.asm'
../../avr8\dict/interrupt.inc(4): Including file '../../avr8\words/int-store.asm'
../../avr8\dict/interrupt.inc(5): Including file '../../avr8\words/int-fetch.asm'
../../avr8\dict/interrupt.inc(6): Including file '../../avr8\words/int-trap.asm'
../../avr8\dict/interrupt.inc(8): Including file '../../avr8\words/isr-exec.asm'
../../avr8\dict/interrupt.inc(9): Including file '../../avr8\words/isr-end.asm'
../../avr8\dict/appl_2k.inc(14): Including file '../../common\words/pick.asm'
../../avr8\dict/appl_2k.inc(15): Including file '../../common\words/dot-quote.asm'
../../avr8\dict/appl_2k.inc(16): Including file '../../common\words/squote.asm'
../../avr8\dict/appl_2k.inc(18): Including file '../../avr8\words/fill.asm'
../../avr8\dict/appl_2k.inc(19): Including file '../../avr8\dict/compiler1.inc'
../../avr8\dict/compiler1.inc(2): Including file '../../avr8\words/docreate.asm'
../../avr8\dict/compiler1.inc(3): Including file '../../common\words/backslash.asm'
../../avr8\dict/compiler1.inc(4): Including file '../../common\words/l-paren.asm'
../../avr8\dict/compiler1.inc(6): Including file '../../common\words/compile.asm'
../../avr8\dict/compiler1.inc(7): Including file '../../avr8\words/comma.asm'
../../avr8\dict/compiler1.inc(8): Including file '../../common\words/brackettick.asm'
../../avr8\dict/compiler1.inc(11): Including file '../../common\words/literal.asm'
../../avr8\dict/compiler1.inc(12): Including file '../../common\words/sliteral.asm'
../../avr8\dict/compiler1.inc(13): Including file '../../avr8\words/g-mark.asm'
../../avr8\dict/compiler1.inc(14): Including file '../../avr8\words/g-resolve.asm'
../../avr8\dict/compiler1.inc(15): Including file '../../avr8\words/l_mark.asm'
../../avr8\dict/compiler1.inc(16): Including file '../../avr8\words/l_resolve.asm'
../../avr8\dict/compiler1.inc(18): Including file '../../common\words/ahead.asm'
../../avr8\dict/compiler1.inc(19): Including file '../../common\words/if.asm'
../../avr8\dict/compiler1.inc(20): Including file '../../common\words/else.asm'
../../avr8\dict/compiler1.inc(21): Including file '../../common\words/then.asm'
../../avr8\dict/compiler1.inc(22): Including file '../../common\words/begin.asm'
../../avr8\dict/compiler1.inc(23): Including file '../../common\words/while.asm'
../../avr8\dict/compiler1.inc(24): Including file '../../common\words/repeat.asm'
../../avr8\dict/compiler1.inc(25): Including file '../../common\words/until.asm'
../../avr8\dict/compiler1.inc(26): Including file '../../common\words/again.asm'
../../avr8\dict/compiler1.inc(27): Including file '../../common\words/do.asm'
../../avr8\dict/compiler1.inc(28): Including file '../../common\words/loop.asm'
../../avr8\dict/compiler1.inc(29): Including file '../../common\words/plusloop.asm'
../../avr8\dict/compiler1.inc(30): Including file '../../common\words/leave.asm'
../../avr8\dict/compiler1.inc(31): Including file '../../common\words/qdo.asm'
../../avr8\dict/compiler1.inc(32): Including file '../../common\words/endloop.asm'
../../avr8\dict/compiler1.inc(34): Including file '../../common\words/l-from.asm'
../../avr8\dict/compiler1.inc(35): Including file '../../common\words/to-l.asm'
../../avr8\dict/compiler1.inc(36): Including file '../../avr8\words/lp0.asm'
../../avr8\dict/compiler1.inc(37): Including file '../../avr8\words/lp.asm'
../../avr8\dict/compiler1.inc(39): Including file '../../avr8\words/create.asm'
../../avr8\dict/compiler1.inc(40): Including file '../../avr8\words/header.asm'
../../avr8\dict/compiler1.inc(41): Including file '../../avr8\words/wlscope.asm'
../../avr8\dict/compiler1.inc(42): Including file '../../avr8\words/reveal.asm'
../../avr8\dict/compiler1.inc(43): Including file '../../avr8\words/latest.asm'
../../avr8\dict/compiler1.inc(44): Including file '../../avr8\words/does.asm'
../../avr8\dict/compiler1.inc(45): Including file '../../common\words/colon.asm'
../../avr8\dict/compiler1.inc(46): Including file '../../avr8\words/colon-noname.asm'
../../avr8\dict/compiler1.inc(47): Including file '../../common\words/semicolon.asm'
../../avr8\dict/compiler1.inc(48): Including file '../../common\words/right-bracket.asm'
../../avr8\dict/compiler1.inc(49): Including file '../../common\words/left-bracket.asm'
../../avr8\dict/compiler1.inc(50): Including file '../../common\words/variable.asm'
../../avr8\dict/compiler1.inc(51): Including file '../../common\words/constant.asm'
../../avr8\dict/compiler1.inc(52): Including file '../../avr8\words/user.asm'
../../avr8\dict/compiler1.inc(54): Including file '../../avr8\words/recurse.asm'
../../avr8\dict/compiler1.inc(55): Including file '../../avr8\words/immediate.asm'
../../avr8\dict/compiler1.inc(57): Including file '../../common\words/bracketchar.asm'
../../avr8\dict/compiler1.inc(58): Including file '../../common\words/abort-string.asm'
../../avr8\dict/compiler1.inc(59): Including file '../../common\words/abort.asm'
../../avr8\dict/compiler1.inc(60): Including file '../../common\words/q-abort.asm'
../../avr8\dict/compiler1.inc(62): Including file '../../common\words/get-stack.asm'
../../avr8\dict/compiler1.inc(63): Including file '../../common\words/set-stack.asm'
../../avr8\dict/compiler1.inc(64): Including file '../../common\words/map-stack.asm'
../../avr8\dict/compiler1.inc(65): Including file '../../avr8\words/get-current.asm'
../../avr8\dict/compiler1.inc(66): Including file '../../common\words/get-order.asm'
../../avr8\dict/compiler1.inc(68): Including file '../../avr8\words/compare.asm'
../../avr8\dict/compiler1.inc(69): Including file '../../avr8\words/nfa2lfa.asm'
../../avr8\dict/appl_2k.inc(21): Including file '../../avr8\words/environment.asm'
../../avr8\dict/appl_2k.inc(22): Including file '../../avr8\words/env-wordlists.asm'
../../avr8\dict/appl_2k.inc(23): Including file '../../avr8\words/env-slashpad.asm'
../../avr8\dict/appl_2k.inc(24): Including file '../../avr8\words/env-slashhold.asm'
../../avr8\dict/appl_2k.inc(25): Including file '../../common\words/env-forthname.asm'
../../avr8\dict/appl_2k.inc(26): Including file '../../common\words/env-forthversion.asm'
../../avr8\dict/appl_2k.inc(27): Including file '../../common\words/env-cpu.asm'
../../avr8\dict/appl_2k.inc(28): Including file '../../avr8\words/env-mcuinfo.asm'
../../avr8\dict/appl_2k.inc(29): Including file '../../avr8\words/env-usersize.asm'
../../avr8\dict/appl_2k.inc(31): Including file '../../common\words/f_cpu.asm'
../../avr8\dict/appl_2k.inc(32): Including file '../../avr8\words/state.asm'
../../avr8\dict/appl_2k.inc(33): Including file '../../common\words/base.asm'
../../avr8\dict/appl_2k.inc(35): Including file '../../avr8\words/cells.asm'
../../avr8\dict/appl_2k.inc(36): Including file '../../avr8\words/cellplus.asm'
../../avr8\dict/appl_2k.inc(38): Including file '../../common\words/2dup.asm'
../../avr8\dict/appl_2k.inc(39): Including file '../../common\words/2drop.asm'
../../avr8\dict/appl_2k.inc(41): Including file '../../common\words/tuck.asm'
../../avr8\dict/appl_2k.inc(43): Including file '../../common\words/to-in.asm'
../../avr8\dict/appl_2k.inc(44): Including file '../../avr8\words/sharptib.asm'
../../avr8\dict/appl_2k.inc(45): Including file '../../avr8\words/pad.asm'
../../avr8\dict/appl_2k.inc(46): Including file '../../avr8\words/emit.asm'
../../avr8\dict/appl_2k.inc(47): Including file '../../avr8\words/emitq.asm'
../../avr8\dict/appl_2k.inc(48): Including file '../../avr8\words/key.asm'
../../avr8\dict/appl_2k.inc(49): Including file '../../avr8\words/keyq.asm'
../../avr8\dict/appl_2k.inc(51): Including file '../../avr8\words/dp.asm'
../../avr8\dict/appl_2k.inc(52): Including file '../../avr8\words/ehere.asm'
../../avr8\dict/appl_2k.inc(53): Including file '../../avr8\words/here.asm'
../../avr8\dict/appl_2k.inc(54): Including file '../../avr8\words/allot.asm'
../../avr8\dict/appl_2k.inc(56): Including file '../../common\words/bin.asm'
../../avr8\dict/appl_2k.inc(57): Including file '../../common\words/decimal.asm'
../../avr8\dict/appl_2k.inc(58): Including file '../../common\words/hex.asm'
../../avr8\dict/appl_2k.inc(59): Including file '../../common\words/bl.asm'
../../avr8\dict/appl_2k.inc(61): Including file '../../avr8\words/turnkey.asm'
../../avr8\dict/appl_2k.inc(63): Including file '../../avr8\words/slashmod.asm'
../../avr8\dict/appl_2k.inc(64): Including file '../../avr8\words/uslashmod.asm'
../../avr8\dict/appl_2k.inc(65): Including file '../../avr8\words/negate.asm'
../../avr8\dict/appl_2k.inc(66): Including file '../../common\words/slash.asm'
../../avr8\dict/appl_2k.inc(67): Including file '../../common\words/mod.asm'
../../avr8\dict/appl_2k.inc(68): Including file '../../avr8\words/abs.asm'
../../avr8\dict/appl_2k.inc(69): Including file '../../common\words/min.asm'
../../avr8\dict/appl_2k.inc(70): Including file '../../common\words/max.asm'
../../avr8\dict/appl_2k.inc(71): Including file '../../common\words/within.asm'
../../avr8\dict/appl_2k.inc(73): Including file '../../common\words/to-upper.asm'
../../avr8\dict/appl_2k.inc(74): Including file '../../common\words/to-lower.asm'
../../avr8\dict/appl_2k.inc(76): Including file '../../avr8\words/hld.asm'
../../avr8\dict/appl_2k.inc(77): Including file '../../common\words/hold.asm'
../../avr8\dict/appl_2k.inc(78): Including file '../../common\words/less-sharp.asm'
../../avr8\dict/appl_2k.inc(79): Including file '../../common\words/sharp.asm'
../../avr8\dict/appl_2k.inc(80): Including file '../../common\words/sharp-s.asm'
../../avr8\dict/appl_2k.inc(81): Including file '../../common\words/sharp-greater.asm'
../../avr8\dict/appl_2k.inc(82): Including file '../../common\words/sign.asm'
../../avr8\dict/appl_2k.inc(83): Including file '../../common\words/d-dot-r.asm'
../../avr8\dict/appl_2k.inc(84): Including file '../../common\words/dot-r.asm'
../../avr8\dict/appl_2k.inc(85): Including file '../../common\words/d-dot.asm'
../../avr8\dict/appl_2k.inc(86): Including file '../../common\words/dot.asm'
../../avr8\dict/appl_2k.inc(87): Including file '../../common\words/ud-dot.asm'
../../avr8\dict/appl_2k.inc(88): Including file '../../common\words/ud-dot-r.asm'
../../avr8\dict/appl_2k.inc(89): Including file '../../common\words/ud-slash-mod.asm'
../../avr8\dict/appl_2k.inc(90): Including file '../../common\words/digit-q.asm'
../../avr8\dict/appl_2k.inc(92): Including file '../../avr8\words/do-sliteral.asm'
../../avr8\dict/appl_2k.inc(93): Including file '../../avr8\words/scomma.asm'
../../avr8\dict/appl_2k.inc(94): Including file '../../avr8\words/itype.asm'
../../avr8\dict/appl_2k.inc(95): Including file '../../avr8\words/icount.asm'
../../avr8\dict/appl_2k.inc(96): Including file '../../common\words/cr.asm'
../../avr8\dict/appl_2k.inc(97): Including file '../../common\words/space.asm'
../../avr8\dict/appl_2k.inc(98): Including file '../../common\words/spaces.asm'
../../avr8\dict/appl_2k.inc(99): Including file '../../common\words/type.asm'
../../avr8\dict/appl_2k.inc(100): Including file '../../common\words/tick.asm'
../../avr8\dict/appl_2k.inc(102): Including file '../../common\words/handler.asm'
../../avr8\dict/appl_2k.inc(103): Including file '../../common\words/catch.asm'
../../avr8\dict/appl_2k.inc(104): Including file '../../common\words/throw.asm'
../../avr8\dict/appl_2k.inc(106): Including file '../../common\words/cskip.asm'
../../avr8\dict/appl_2k.inc(107): Including file '../../common\words/cscan.asm'
../../avr8\dict/appl_2k.inc(108): Including file '../../common\words/accept.asm'
../../avr8\dict/appl_2k.inc(109): Including file '../../avr8\words/refill.asm'
../../avr8\dict/appl_2k.inc(110): Including file '../../common\words/char.asm'
../../avr8\dict/appl_2k.inc(111): Including file '../../common\words/number.asm'
../../avr8\dict/appl_2k.inc(112): Including file '../../common\words/q-sign.asm'
../../avr8\dict/appl_2k.inc(113): Including file '../../common\words/set-base.asm'
../../avr8\dict/appl_2k.inc(114): Including file '../../common\words/to-number.asm'
../../avr8\dict/appl_2k.inc(115): Including file '../../common\words/parse.asm'
../../avr8\dict/appl_2k.inc(116): Including file '../../avr8\words/source.asm'
../../avr8\dict/appl_2k.inc(117): Including file '../../common\words/slash-string.asm'
../../avr8\dict/appl_2k.inc(118): Including file '../../common\words/parse-name.asm'
../../avr8\dict/appl_2k.inc(119): Including file '../../common\words/find-name.asm'
../../avr8\dict/appl_2k.inc(121): Including file '../../common\words/quit.asm'
../../avr8\dict/appl_2k.inc(122): Including file '../../common\words/prompt-ok.asm'
../../avr8\dict/appl_2k.inc(123): Including file '../../common\words/prompt-ready.asm'
../../avr8\dict/appl_2k.inc(124): Including file '../../common\words/prompt-error.asm'
../../avr8\dict/appl_2k.inc(125): Including file '../../avr8\words/pause.asm'
../../avr8\dict/appl_2k.inc(126): Including file '../../avr8\words/cold.asm'
../../avr8\dict/appl_2k.inc(127): Including file '../../avr8\words/warm.asm'
../../avr8\dict/appl_2k.inc(129): Including file '../../avr8\words/sp0.asm'
../../avr8\dict/appl_2k.inc(130): Including file '../../avr8\words/rp0.asm'
../../avr8\dict/appl_2k.inc(131): Including file '../../common\words/depth.asm'
../../avr8\dict/appl_2k.inc(132): Including file '../../common\words/do-recognizer.asm'
../../avr8\dict/appl_2k.inc(133): Including file '../../common\words/interpret.asm'
../../avr8\dict/appl_2k.inc(134): Including file '../../common\words/r-intnumber.asm'
../../avr8\dict/appl_2k.inc(135): Including file '../../common\words/r-word.asm'
../../avr8\dict/appl_2k.inc(136): Including file '../../common\words/r-fail.asm'
../../avr8\dict/appl_2k.inc(138): Including file '../../common\words/q-stack.asm'
../../avr8\dict/appl_2k.inc(139): Including file '../../common\words/ver.asm'
../../avr8\dict/appl_2k.inc(141): Including file '../../avr8\words/noop.asm'
../../avr8\dict/appl_2k.inc(142): Including file '../../avr8\words/unused.asm'
../../avr8\dict/appl_2k.inc(144): Including file '../../common\words/to.asm'
../../avr8\dict/appl_2k.inc(145): Including file '../../avr8\words/i-cellplus.asm'
../../avr8\dict/appl_2k.inc(147): Including file '../../avr8\words/edefer-fetch.asm'
../../avr8\dict/appl_2k.inc(148): Including file '../../avr8\words/edefer-store.asm'
../../avr8\dict/appl_2k.inc(149): Including file '../../common\words/rdefer-fetch.asm'
../../avr8\dict/appl_2k.inc(150): Including file '../../common\words/rdefer-store.asm'
../../avr8\dict/appl_2k.inc(151): Including file '../../common\words/udefer-fetch.asm'
../../avr8\dict/appl_2k.inc(152): Including file '../../common\words/udefer-store.asm'
../../avr8\dict/appl_2k.inc(153): Including file '../../common\words/defer-store.asm'
../../avr8\dict/appl_2k.inc(154): Including file '../../common\words/defer-fetch.asm'
../../avr8\dict/appl_2k.inc(155): Including file '../../avr8\words/do-defer.asm'
../../avr8\dict/appl_2k.inc(157): Including file '../../common\words/search-wordlist.asm'
../../avr8\dict/appl_2k.inc(158): Including file '../../common\words/traverse-wordlist.asm'
../../avr8\dict/appl_2k.inc(159): Including file '../../common\words/name2string.asm'
../../avr8\dict/appl_2k.inc(160): Including file '../../avr8\words/nfa2cfa.asm'
../../avr8\dict/appl_2k.inc(161): Including file '../../avr8\words/icompare.asm'
../../avr8\dict/appl_2k.inc(163): Including file '../../common\words/star.asm'
../../avr8\dict/appl_2k.inc(164): Including file '../../avr8\words/j.asm'
../../avr8\dict/appl_2k.inc(166): Including file '../../avr8\words/dabs.asm'
../../avr8\dict/appl_2k.inc(167): Including file '../../avr8\words/dnegate.asm'
../../avr8\dict/appl_2k.inc(168): Including file '../../avr8\words/cmove.asm'
../../avr8\dict/appl_2k.inc(169): Including file '../../common\words/2swap.asm'
../../avr8\dict/appl_2k.inc(171): Including file '../../avr8\words/tib.asm'
../../avr8\dict/appl_2k.inc(173): Including file '../../avr8\words/init-user.asm'
../../avr8\dict/appl_2k.inc(174): Including file '../../common\words/bounds.asm'
../../avr8\dict/appl_2k.inc(175): Including file '../../common\words/s-to-d.asm'
../../avr8\dict/appl_2k.inc(176): Including file '../../avr8\words/to-body.asm'
../../avr8\amforth.asm(15): Including file 'dict_appl.inc'
dict_appl.inc(5): Including file 'words/applturnkey.asm'
../../avr8\amforth.asm(23): Including file '../../avr8\amforth-interpreter.asm'
../../avr8\amforth.asm(24): Including file '../../avr8\dict/nrww.inc'
../../avr8\dict/nrww.inc(4): Including file '../../avr8\words/exit.asm'
../../avr8\dict/nrww.inc(5): Including file '../../avr8\words/execute.asm'
../../avr8\dict/nrww.inc(6): Including file '../../avr8\words/dobranch.asm'
../../avr8\dict/nrww.inc(7): Including file '../../avr8\words/docondbranch.asm'
../../avr8\dict/nrww.inc(10): Including file '../../avr8\words/doliteral.asm'
../../avr8\dict/nrww.inc(11): Including file '../../avr8\words/dovariable.asm'
../../avr8\dict/nrww.inc(12): Including file '../../avr8\words/doconstant.asm'
../../avr8\dict/nrww.inc(13): Including file '../../avr8\words/douser.asm'
../../avr8\dict/nrww.inc(14): Including file '../../avr8\words/do-value.asm'
../../avr8\dict/nrww.inc(15): Including file '../../avr8\words/fetch.asm'
../../avr8\dict/nrww.inc(16): Including file '../../avr8\words/store.asm'
../../avr8\dict/nrww.inc(17): Including file '../../avr8\words/cstore.asm'
../../avr8\dict/nrww.inc(18): Including file '../../avr8\words/cfetch.asm'
../../avr8\dict/nrww.inc(19): Including file '../../avr8\words/fetch-u.asm'
../../avr8\dict/nrww.inc(20): Including file '../../avr8\words/store-u.asm'
../../avr8\dict/nrww.inc(23): Including file '../../avr8\words/dup.asm'
../../avr8\dict/nrww.inc(24): Including file '../../avr8\words/qdup.asm'
../../avr8\dict/nrww.inc(25): Including file '../../avr8\words/swap.asm'
../../avr8\dict/nrww.inc(26): Including file '../../avr8\words/over.asm'
../../avr8\dict/nrww.inc(27): Including file '../../avr8\words/drop.asm'
../../avr8\dict/nrww.inc(28): Including file '../../avr8\words/rot.asm'
../../avr8\dict/nrww.inc(29): Including file '../../avr8\words/nip.asm'
../../avr8\dict/nrww.inc(31): Including file '../../avr8\words/r_from.asm'
../../avr8\dict/nrww.inc(32): Including file '../../avr8\words/to_r.asm'
../../avr8\dict/nrww.inc(33): Including file '../../avr8\words/r_fetch.asm'
../../avr8\dict/nrww.inc(36): Including file '../../common\words/not-equal.asm'
../../avr8\dict/nrww.inc(37): Including file '../../avr8\words/equalzero.asm'
../../avr8\dict/nrww.inc(38): Including file '../../avr8\words/lesszero.asm'
../../avr8\dict/nrww.inc(39): Including file '../../avr8\words/greaterzero.asm'
../../avr8\dict/nrww.inc(40): Including file '../../avr8\words/d-greaterzero.asm'
../../avr8\dict/nrww.inc(41): Including file '../../avr8\words/d-lesszero.asm'
../../avr8\dict/nrww.inc(43): Including file '../../avr8\words/true.asm'
../../avr8\dict/nrww.inc(44): Including file '../../avr8\words/zero.asm'
../../avr8\dict/nrww.inc(45): Including file '../../avr8\words/uless.asm'
../../avr8\dict/nrww.inc(46): Including file '../../common\words/u-greater.asm'
../../avr8\dict/nrww.inc(47): Including file '../../avr8\words/less.asm'
../../avr8\dict/nrww.inc(48): Including file '../../avr8\words/greater.asm'
../../avr8\dict/nrww.inc(50): Including file '../../avr8\words/log2.asm'
../../avr8\dict/nrww.inc(51): Including file '../../avr8\words/minus.asm'
../../avr8\dict/nrww.inc(52): Including file '../../avr8\words/plus.asm'
../../avr8\dict/nrww.inc(53): Including file '../../avr8\words/mstar.asm'
../../avr8\dict/nrww.inc(54): Including file '../../avr8\words/umslashmod.asm'
../../avr8\dict/nrww.inc(55): Including file '../../avr8\words/umstar.asm'
../../avr8\dict/nrww.inc(57): Including file '../../avr8\words/invert.asm'
../../avr8\dict/nrww.inc(58): Including file '../../avr8\words/2slash.asm'
../../avr8\dict/nrww.inc(59): Including file '../../avr8\words/2star.asm'
../../avr8\dict/nrww.inc(60): Including file '../../avr8\words/and.asm'
../../avr8\dict/nrww.inc(61): Including file '../../avr8\words/or.asm'
../../avr8\dict/nrww.inc(62): Including file '../../avr8\words/xor.asm'
../../avr8\dict/nrww.inc(64): Including file '../../avr8\words/1plus.asm'
../../avr8\dict/nrww.inc(65): Including file '../../avr8\words/1minus.asm'
../../avr8\dict/nrww.inc(66): Including file '../../avr8\words/lshift.asm'
../../avr8\dict/nrww.inc(67): Including file '../../avr8\words/rshift.asm'
../../avr8\dict/nrww.inc(68): Including file '../../avr8\words/plusstore.asm'
../../avr8\dict/nrww.inc(70): Including file '../../avr8\words/rpfetch.asm'
../../avr8\dict/nrww.inc(71): Including file '../../avr8\words/rpstore.asm'
../../avr8\dict/nrww.inc(72): Including file '../../avr8\words/spfetch.asm'
../../avr8\dict/nrww.inc(73): Including file '../../avr8\words/spstore.asm'
../../avr8\dict/nrww.inc(75): Including file '../../avr8\words/dodo.asm'
../../avr8\dict/nrww.inc(76): Including file '../../avr8\words/i.asm'
../../avr8\dict/nrww.inc(77): Including file '../../avr8\words/doplusloop.asm'
../../avr8\dict/nrww.inc(78): Including file '../../avr8\words/doloop.asm'
../../avr8\dict/nrww.inc(79): Including file '../../avr8\words/unloop.asm'
../../avr8\dict/nrww.inc(83): Including file '../../avr8\words/cmove_g.asm'
../../avr8\dict/nrww.inc(84): Including file '../../avr8\words/byteswap.asm'
../../avr8\dict/nrww.inc(85): Including file '../../avr8\words/up.asm'
../../avr8\dict/nrww.inc(86): Including file '../../avr8\words/1ms.asm'
../../avr8\dict/nrww.inc(87): Including file '../../avr8\words/2to_r.asm'
../../avr8\dict/nrww.inc(88): Including file '../../avr8\words/2r_from.asm'
../../avr8\dict/nrww.inc(90): Including file '../../avr8\words/store-e.asm'
../../avr8\dict/nrww.inc(91): Including file '../../avr8\words/fetch-e.asm'
../../avr8\dict/nrww.inc(92): Including file '../../avr8\words/store-i.asm'
../../avr8\dict/nrww.inc(96): Including file '../../avr8\words/store-i_nrww.asm'
../../avr8\dict/nrww.inc(98): Including file '../../avr8\words/fetch-i.asm'
../../avr8\dict/nrww.inc(105): Including file '../../avr8\dict/core_2k.inc'
../../avr8\dict/nrww.inc(111): Including file '../../avr8\words/2literal.asm'
../../avr8\dict/nrww.inc(112): Including file '../../avr8\words/equal.asm'
../../avr8\dict/nrww.inc(113): Including file '../../common\words/num-constants.asm'
../../avr8\amforth.asm(25): Including file 'dict_appl_core.inc'
../../avr8\amforth.asm(36): Including file '../../avr8\amforth-eeprom.inc'
                 
                 
                 ; file see ../template/template.asm. You may want to
                 ; copy that file to this one and edit it afterwards.
                 
                 .include "preamble.inc"
                 
                 .include "macros.asm"
                 
                 .set DICT_COMPILER2 = 0 ;
                 .set cpu_msp430 = 0
                 .set cpu_avr8   = 1
                 
                 .include "user.inc"
                 
                 ; 
                 
                 ; used by the multitasker
                 .set USER_STATE    = 0
                 .set USER_FOLLOWER = 2
                 
                 ; stackpointer, used by mulitasker
                 .set USER_RP      = 4
                 .set USER_SP0     = 6
                 .set USER_SP      = 8
                 
                 ; excpection handling
                 .set USER_HANDLER = 10
                 
                 ; numeric IO
                 .set USER_BASE  = 12
                 
                 ; character IO 
                 .set USER_EMIT  = 14
                 .set USER_EMITQ = 16
                 .set USER_KEY   = 18
                 .set USER_KEYQ  = 20
                 
                 .set USER_SOURCE  = 22
                 .set USER_TO_IN   = 24
                 .set USER_REFILL  = 26
                 
                 .set SYSUSERSIZE = 28
                 ; 
                 
                   .def zerol = r2
                   .def zeroh = r3
                   .def upl = r4
                   .def uph = r5
                 
                   .def al  = r6
                   .def ah  = r7
                   .def bl  = r8
                   .def bh  = r9
                 
                 ; internal
                   .def mcu_boot      = r10
                   .def erase_counter = r11
                 
                   .def temp4 = r14
                   .def temp5 = r15
                 
                   .def temp0 = r16
                   .def temp1 = r17
                   .def temp2 = r18
                   .def temp3 = r19
                 
                   .def temp6 = r20
                   .def temp7 = r21
                 
                   .def tosl = r24
                   .def tosh = r25
                 
                   .def wl = r22
                   .def wh = r23
                 
                 .macro loadtos
                     ld tosl, Y+
                     ld tosh, Y+
                 .endmacro
                 
                 .macro savetos
                     st -Y, tosh
                     st -Y, tosl
                 .endmacro
                 
                 .macro in_
                 .if (@1 < $40)
                   in @0,@1
                 .else
                   lds @0,@1
                 .endif
                 .endmacro
                 
                 .macro out_
                 .if (@0 < $40)
                   out @0,@1
                 .else
                   sts @0,@1
                 .endif
                 .endmacro
                 
                 .macro sbi_
                 .if (@0 < $40)
                   sbi @0,@1
                 .else
                   in_ @2,@0
                   ori @2,exp2(@1)
                   out_ @0,@2
                 .endif
                 .endmacro
                 
                 .macro cbi_
                 .if (@0 < $40)
                   cbi @0,@1
                 .else
                   in_ @2,@0
                   andi @2,~(exp2(@1))
                   out_ @0,@2
                 .endif
                 .endmacro
                 
                 .macro jmp_
                 	; a more flexible macro
                     .ifdef @0
                     .if (@0-pc > 2040) || (pc-@0>2040)
                 	jmp @0
                 	.else
                 	rjmp @0
                 	.endif
                 	.else
                 	jmp @0
                 	.endif
                 .endmacro
                 .macro call_
                 	; a more flexible macro
                     .ifdef @0
                     .if (@0-pc > 2040) || (pc-@0>2040)
                 	call @0
                 	.else
                 	rcall @0
                 	.endif
                 	.else
                 	call @0
                 	.endif
                 .endmacro
                 
                 ;               F_CPU
                 ;    µsec   16000000   14745600    8000000  1000000
                 ;    1            16      14,74          8        1
                 ;    10          160     147,45         80       10
                 ;    100        1600    1474,56        800      100
                 ;    1000      16000   14745,6        8000     1000
                 ;
                 ; cycles = µsec * f_cpu / 1e6
                 ; n_loops=cycles/5
                 ;
                 ;     cycles already used will be subtracted from the delay
                 ;     the waittime resolution is 1 cycle (delay from exact to +1 cycle)
                 ;     the maximum delay at 20MHz (50ns/clock) is 38350ns
                 ;     waitcount register must specify an immediate register
                 ;
                 ; busy waits a specfied amount of microseconds
                 .macro   delay
                       .set cycles = ( ( @0 * F_CPU ) / 1000000 )
                       .if (cycles > ( 256 * 255 * 4 + 2))
                         .error "MACRO delay - too many cycles to burn"
                       .else
                         .if (cycles > 6)
                           .set  loop_cycles = (cycles / 4)      
                           ldi   zl,low(loop_cycles)
                           ldi   zh,high(loop_cycles)
                           sbiw  Z, 1
                           brne  pc-1
                           .set  cycles = (cycles - (loop_cycles * 4))
                         .endif
                         .if (cycles > 0)
                           .if   (cycles & 4)
                             rjmp  pc+1
                             rjmp  pc+1
                           .endif
                           .if   (cycles & 2)
                             rjmp  pc+1
                           .endif
                           .if   (cycles & 1)
                             nop
                           .endif
                         .endif
                       .endif
                 .endmacro
                 
                 ; portability macros, they come from the msp430 branches
                 
                 .macro DEST
                     .dw @0
                 .endm
                 
                 ; controller specific file selected via include
                 ; directory definition when calling the assembler (-I)
                 .include "device.asm"
                 
                 ; Built using part description XML file version 300
                 ; generated automatically, do not edit
                 
                 .list
                 
                 .equ ramstart =  $100
                 .equ CELLSIZE = 2
                 .macro readflashcell
                 	lsl zl
                 	rol zh
                 	lpm @0, Z+
                 	lpm @1, Z+
                 .endmacro
                 .macro writeflashcell
                 	lsl zl
                 	rol zh
                 .endmacro
                 
                 ; the following definitions are shortcuts for the respective forth source segments if set to 1
                 .set WANT_AD_CONVERTER = 0
                 .set WANT_ANALOG_COMPARATOR = 0
                 .set WANT_BOOT_LOAD = 0
                 .set WANT_CPU = 0
                 .set WANT_EEPROM = 0
                 .set WANT_EXTERNAL_INTERRUPT = 0
                 .set WANT_JTAG = 0
                 .set WANT_LCD = 0
                 .set WANT_PORTA = 0
                 .set WANT_PORTB = 0
                 .set WANT_PORTC = 0
                 .set WANT_PORTD = 0
                 .set WANT_PORTE = 0
                 .set WANT_PORTF = 0
                 .set WANT_PORTG = 0
                 .set WANT_SPI = 0
                 .set WANT_TIMER_COUNTER_0 = 0
                 .set WANT_TIMER_COUNTER_1 = 0
                 .set WANT_TIMER_COUNTER_2 = 0
                 .set WANT_USART0 = 0
                 .set WANT_USI = 0
                 .set WANT_WATCHDOG = 0
                 
                 
                 .ifndef SPMEN
                 .endif
                 
                 .ifndef SPMCSR
                 .endif
                 
                 .ifndef EEPE
                  .equ EEPE = EEWE
                 .endif
                 
                 .ifndef EEMPE
                  .equ EEMPE = EEMWE
                 .endif
                 .equ intvecsize = 2 ; please verify; flash size: 16384 bytes
                 .equ pclen = 2 ; please verify
                 .overlap
                 .equ INTVECTORS = 23
                 .org $002
000002 d0c1      	 rcall isr ; External Interrupt Request 0
                 .org $004
000004 d0bf      	 rcall isr ; Pin Change Interrupt Request 0
                 .org $006
000006 d0bd      	 rcall isr ; Pin Change Interrupt Request 1
                 .org $008
000008 d0bb      	 rcall isr ; Timer/Counter2 Compare Match
                 .org $00A
00000a d0b9      	 rcall isr ; Timer/Counter2 Overflow
                 .org $00C
00000c d0b7      	 rcall isr ; Timer/Counter1 Capture Event
                 .org $00E
00000e d0b5      	 rcall isr ; Timer/Counter1 Compare Match A
                 .org $010
000010 d0b3      	 rcall isr ; Timer/Counter Compare Match B
                 .org $012
000012 d0b1      	 rcall isr ; Timer/Counter1 Overflow
                 .org $014
000014 d0af      	 rcall isr ; Timer/Counter0 Compare Match
                 .org $016
000016 d0ad      	 rcall isr ; Timer/Counter0 Overflow
                 .org $018
000018 d0ab      	 rcall isr ; SPI Serial Transfer Complete
                 .org $01A
00001a d0a9      	 rcall isr ; USART0, Rx Complete
                 .org $01C
00001c d0a7      	 rcall isr ; USART0 Data register Empty
                 .org $01E
00001e d0a5      	 rcall isr ; USART0, Tx Complete
                 .org $020
000020 d0a3      	 rcall isr ; USI Start Condition
                 .org $022
000022 d0a1      	 rcall isr ; USI Overflow
                 .org $024
000024 d09f      	 rcall isr ; Analog Comparator
                 .org $026
000026 d09d      	 rcall isr ; ADC Conversion Complete
                 .org $028
000028 d09b      	 rcall isr ; EEPROM Ready
                 .org $02A
00002a d099      	 rcall isr ; Store Program Memory Read
                 .org $02C
00002c d097      	 rcall isr ; LCD Start of Frame
                 .nooverlap
                 mcu_info:
                 mcu_ramsize:
00002d 0400      	.dw 1024
                 mcu_eepromsize:
00002e 0200      	.dw 512
                 mcu_maxdp:
00002f 1c00      	.dw 7168 ; minimum of 0x1C00 (from XML) and 0xffff
                 mcu_numints:
000030 0017      	.dw 23
                 mcu_name:
000031 0009      	.dw  9
000032 5441
000033 656d
000034 6167
000035 3631
000036 0039      	.db "ATmega169",0
                 .set codestart=pc
                 
                 ; some defaults, change them in your application master file
                 ; see template.asm for an example
                 
                 .set AMFORTH_RO_SEG = NRWW_START_ADDR
                 
                 ; receiving is asynchron, so an interrupt queue is useful.
                 .set WANT_ISR_RX = 1
                 
                 ; case insensitve dictionary lookup.
                 .set WANT_IGNORECASE = 0
                 
                 ; map all memories to one address space. Details in the
                 ; technical guide
                 .set WANT_UNIFIED = 0
                 
                 ; terminal input buffer
                 .set TIBSIZE  = 90    ; ANS94 needs at least 80 characters per line
                 
                 ; USER variables *in addition* to system ones
                 .set APPUSERSIZE = 10  ; size of application specific user area in bytes
                 
                 ; addresses of various data segments
                 .set rstackstart = RAMEND      ; start address of return stack, grows downward
                 .set stackstart  = RAMEND - 80 ; start address of data stack, grows downward
                 ; change only if you know what to you do
                 .set NUMWORDLISTS = 8 ; number of word lists in the searh order, at least 8
                 .set NUMRECOGNIZERS = 4 ; total number of recognizers, two are always used.
                 
                 ; 10 per mille (1 per cent) is ok.
                 .set BAUD = 38400
                 .set BAUD_MAXERROR = 10
                 
                 ; Dictionary setup
                 .set VE_HEAD = $0000
                 .set VE_ENVHEAD = $0000
                 
                 
                 .equ F_CPU = 8000000
                 .include "drivers/usart.asm"
                 
                 .equ BAUDRATE_LOW = UBRRL+$20
                 .equ BAUDRATE_HIGH = UBRRH+$20
                 .equ USART_C = UCSRC+$20
                 .equ USART_B = UCSRB+$20
                 .equ USART_A = UCSRA+$20
                 .equ USART_DATA = UDR+$20
                 .equ bm_USARTC_en   = 1 << 7
                 
                 ; some generic constants
                 .equ bm_USART_RXRD = 1 << RXC
                 .equ bm_USART_TXRD = 1 << UDRE
                 .equ bm_ENABLE_TX  = 1 << TXEN
                 .equ bm_ENABLE_RX  = 1 << RXEN
                 .equ bm_ENABLE_INT_RX = 1<<RXCIE
                 .equ bm_ENABLE_INT_TX = 1<<UDRE
                 
                 .equ bm_ASYNC       = 0 << 6
                 .equ bm_SYNC        = 1 << 6
                 .equ bm_NO_PARITY   = 0 << 4
                 .equ bm_EVEN_PARITY = 2 << 4
                 .equ bm_ODD_PARITY  = 3 << 4
                 .equ bm_1STOPBIT    = 0 << 3
                 .equ bm_2STOPBIT    = 1 << 3
                 .equ bm_5BIT        = 0 << 1
                 .equ bm_6BIT        = 1 << 1
                 .equ bm_7BIT        = 2 << 1
                 .equ bm_8BIT        = 3 << 1
                 
                 .include "drivers/usart_common.asm"
                 
                 .set USART_C_VALUE = bm_ASYNC | bm_NO_PARITY | bm_1STOPBIT | bm_8BIT
                 .if WANT_ISR_RX == 1
                   .set USART_B_VALUE = bm_ENABLE_TX | bm_ENABLE_RX | bm_ENABLE_INT_RX
                   .include "drivers/usart-isr-rx.asm"
                 
                 
                 ; sizes have to be powers of 2!
                 .equ usart_rx_size = $10
                 .equ usart_rx_mask = usart_rx_size - 1
                 .dseg
000100           usart_rx_data: .byte usart_rx_size+2
000112           usart_rx_in: .byte 2
000114           usart_rx_out: .byte 2
                 
                 .cseg
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 ; forth code:
                 ; : rx-isr USART_DATA c@
                 ;    usart_rx_data usart_rx_in c@ dup >r
                 ;    + !
                 ;    r> 1+ usart_rx_mask and usart_rx_in c!
                 ; ;
                 ; setup with
                 ; ' rx-isr URXCaddr int!
                 usart_rx_isr:
000037 93af        push xl
000038 b7af        in xl, SREG
000039 93af        push xl
00003a 93bf        push xh
00003b 93ef        push zl
00003c 93ff        push zh
                 
00003d 91b0 00e6   lds xh, USART_DATA
                 usart_rx_store:
00003f 91a0 0112   lds xl, usart_rx_in
000041 e0e0        ldi zl, low(usart_rx_data)
000042 e0f1        ldi zh, high(usart_rx_data)
000043 0fea        add zl, xl
000044 1df3        adc zh, zeroh
000045 83b0        st Z, xh
                 
000046 95a3        inc xl
000047 70af        andi xl,usart_rx_mask
                 
000048 93a0 0112   sts usart_rx_in, xl
                 
                 usart_rx_isr_finish:
00004a 91ff        pop zh
00004b 91ef        pop zl
00004c 91bf        pop xh
00004d 91af        pop xl
00004e bfaf        out SREG, xl
00004f 91af        pop xl
000050 9518        reti
                 
                 .set usartpc = pc
                 .org URXCaddr
00001a c01c        jmp_ usart_rx_isr
                 .org usartpc
                 
                 
                 ; ( -- ) Hardware Access
                 ; R( --)
                 ; initialize usart
                 ;VE_USART_INIT_RX:
                 ;  .dw $ff06
                 ;  .db "+usart"
                 ;  .dw VE_HEAD
                 ;  .set VE_HEAD = VE_USART_INIT_RX
                 XT_USART_INIT_RX_ISR:
000051 1c00        .dw DO_COLON
                 PFA_USART_INIT_RX_ISR:          ; ( -- )
000052 1d4e        .dw XT_ZERO
000053 1c37        .dw XT_DOLITERAL
000054 0112        .dw usart_rx_in
000055 1c87        .dw XT_CSTORE
000056 1d4e        .dw XT_ZERO
000057 1c37        .dw XT_DOLITERAL
000058 0114        .dw usart_rx_out
000059 1c87        .dw XT_CSTORE
                 
00005a 1c1a        .dw XT_EXIT
                 
                 ; ( -- c)
                 ; MCU
                 ; get 1 character from input queue, wait if needed using interrupt driver
                 VE_RX_ISR:
00005b ff06          .dw $ff06
00005c 7872
00005d 692d
00005e 7273          .db "rx-isr"
00005f 0000          .dw VE_HEAD
                     .set VE_HEAD = VE_RX_ISR
                 XT_RX_ISR:
000060 1c00          .dw DO_COLON
                 PFA_RX_ISR:
000061 007a        .dw XT_RXQ_ISR
000062 1c30        .dw XT_DOCONDBRANCH
000063 0061        .dw PFA_RX_ISR
000064 1c37        .dw XT_DOLITERAL
000065 0114        .dw usart_rx_out
000066 1c92        .dw XT_CFETCH
000067 1cab        .dw XT_DUP
000068 1e29        .dw XT_1PLUS
000069 1c37        .dw XT_DOLITERAL
00006a 000f        .dw usart_rx_mask
00006b 1e0d        .dw XT_AND
00006c 1c37        .dw XT_DOLITERAL
00006d 0114        .dw usart_rx_out
00006e 1c87        .dw XT_CSTORE
00006f 1c37        .dw XT_DOLITERAL
000070 0100        .dw usart_rx_data
000071 1d97        .dw XT_PLUS
000072 1c92        .dw XT_CFETCH
000073 1c1a        .dw XT_EXIT
                 
                 ; ( -- f)  
                 ; MCU
                 ; check if unread characters are in the input queue using interrupt driver
                 VE_RXQ_ISR:
000074 ff07          .dw $ff07
000075 7872
000076 2d3f
000077 7369
000078 0072          .db "rx?-isr",0
000079 005b          .dw VE_HEAD
                     .set VE_HEAD = VE_RXQ_ISR
                 XT_RXQ_ISR:
00007a 1c00          .dw DO_COLON
                 PFA_RXQ_ISR:
00007b 0a89        .dw XT_PAUSE
00007c 1c37        .dw XT_DOLITERAL
00007d 0114        .dw usart_rx_out
00007e 1c92        .dw XT_CFETCH
00007f 1c37        .dw XT_DOLITERAL
000080 0112        .dw usart_rx_in
000081 1c92        .dw XT_CFETCH
000082 1d0d        .dw XT_NOTEQUAL
000083 1c1a        .dw XT_EXIT
                   .set XT_RX  = XT_RX_ISR
                   .set XT_RXQ = XT_RXQ_ISR
                   .set XT_USART_INIT_RX = XT_USART_INIT_RX_ISR
                 .else
                 .endif
                 
                 .include "words/usart-tx-poll.asm"
                 
                 ; MCU
                 ; check availability and send one character to the terminal using register poll
                 VE_TX_POLL:
000084 ff07          .dw $ff07
000085 7874
000086 702d
000087 6c6f
000088 006c          .db "tx-poll",0
000089 0074          .dw VE_HEAD
                     .set VE_HEAD = VE_TX_POLL
                 XT_TX_POLL:
00008a 1c00          .dw DO_COLON
                 PFA_TX_POLL:
                   ; wait for data ready
00008b 0098        .dw XT_TXQ_POLL
00008c 1c30        .dw XT_DOCONDBRANCH
00008d 008b        .dw PFA_TX_POLL
                   ; send to usart
00008e 1c37        .dw XT_DOLITERAL
00008f 00e6        .dw USART_DATA
000090 1c87        .dw XT_CSTORE
000091 1c1a        .dw XT_EXIT
                 
                 ; ( -- f) MCU
                 ; MCU
                 ; check if a character can be send using register poll
                 VE_TXQ_POLL:
000092 ff08          .dw $ff08
000093 7874
000094 2d3f
000095 6f70
000096 6c6c          .db "tx?-poll"
000097 0084          .dw VE_HEAD
                     .set VE_HEAD = VE_TXQ_POLL
                 XT_TXQ_POLL:
000098 1c00          .dw DO_COLON
                 PFA_TXQ_POLL:
000099 0a89        .dw XT_PAUSE
00009a 1c37        .dw XT_DOLITERAL
00009b 00e0        .dw USART_A
00009c 1c92        .dw XT_CFETCH
00009d 1c37        .dw XT_DOLITERAL
00009e 0020        .dw bm_USART_TXRD
00009f 1e0d        .dw XT_AND
0000a0 1c1a        .dw XT_EXIT
                 .set XT_TX  = XT_TX_POLL
                 .set XT_TXQ = XT_TXQ_POLL
                 .set XT_USART_INIT_TX = 0
                 
                 .include "words/ubrr.asm"
                 
                 ; MCU
                 ; returns usart UBRR settings
                 VE_UBRR:
0000a1 ff04        .dw $ff04
0000a2 6275
0000a3 7272        .db "ubrr"
0000a4 0092        .dw VE_HEAD
                   .set VE_HEAD = VE_UBRR
                 XT_UBRR:
0000a5 1c69        .dw PFA_DOVALUE1
                 PFA_UBRR:          ; ( -- )
0000a6 0080        .dw EE_UBRRVAL
0000a7 0bf4        .dw XT_EDEFERFETCH
0000a8 0bfe        .dw XT_EDEFERSTORE
                 .include "words/usart.asm"
                 
                 ; MCU
                 ; initialize usart
                 VE_USART:
0000a9 ff06        .dw $ff06
0000aa 752b
0000ab 6173
0000ac 7472        .db "+usart"
0000ad 00a1        .dw VE_HEAD
                   .set VE_HEAD = VE_USART
                 XT_USART:
0000ae 1c00        .dw DO_COLON
                 PFA_USART:          ; ( -- )
                 
0000af 1c37        .dw XT_DOLITERAL
0000b0 0098        .dw USART_B_VALUE
0000b1 1c37        .dw XT_DOLITERAL
0000b2 00e1        .dw USART_B
0000b3 1c87        .dw XT_CSTORE
                 
0000b4 1c37        .dw XT_DOLITERAL
0000b5 0006        .dw USART_C_VALUE
0000b6 1c37        .dw XT_DOLITERAL
0000b7 00e2        .dw USART_C | bm_USARTC_en
0000b8 1c87        .dw XT_CSTORE
                 
0000b9 00a5        .dw XT_UBRR
0000ba 1cab        .dw XT_DUP
0000bb 1ee7        .dw XT_BYTESWAP
0000bc 1c37        .dw XT_DOLITERAL
0000bd 00e5        .dw BAUDRATE_HIGH
0000be 1c87        .dw XT_CSTORE
0000bf 1c37        .dw XT_DOLITERAL
0000c0 00e4        .dw BAUDRATE_LOW
0000c1 1c87        .dw XT_CSTORE
                 .if XT_USART_INIT_RX!=0
0000c2 0051        .dw XT_USART_INIT_RX
                 .endif
                 .if XT_USART_INIT_TX!=0
                 .endif
                 
0000c3 1c1a        .dw XT_EXIT
                 
                 .include "amforth.asm"
                 
                 ;;;;
                 ;;;; GPL V2 (only)
                 
                 .set AMFORTH_NRWW_SIZE=(FLASHEND-AMFORTH_RO_SEG)*2
                 
                 .set corepc = pc
                 .org $0000
000000 940c 0a92   jmp_ PFA_COLD
                 
                 .org corepc
                 .include "drivers/generic-isr.asm"
                 
                 .dseg
000116           intcur: .byte 1
                 .eseg
000000           intvec: .byte INTVECTORS * CELLSIZE
                 .cseg
                 
                 ; interrupt routine gets called (again) by rcall! This gives the
                 ; address of the int-vector on the stack.
                 isr:
0000c4 920a          st -Y, r0
0000c5 b60f          in r0, SREG
0000c6 920a          st -Y, r0
                 .if (pclen==3)
                 .endif
0000c7 900f          pop r0
0000c8 900f          pop r0          ; = intnum * intvectorsize + 1 (address following the rcall)
0000c9 940a          dec r0
                 .if intvecsize == 1 ;
                 .endif
0000ca 9200 0116     sts intcur, r0
0000cc 9009          ld r0, Y+
0000cd be0f          out SREG, r0
0000ce 9009          ld r0, Y+
0000cf 9468          set ; set the interrupt flag for the inner interpreter
0000d0 9508          ret ; returns the interrupt, the rcall stack frame is removed!
                 
                 ; lower part of the dictionary
                 .include "dict/rww.inc"
                 
                 
                 ; Arithmetics
                 ; add a number to a double cell
                 VE_MPLUS:
0000d1 ff02          .dw $ff02
0000d2 2b6d          .db "m+"
0000d3 00a9          .dw VE_HEAD
                     .set VE_HEAD = VE_MPLUS
                 XT_MPLUS:
0000d4 1c00          .dw DO_COLON
                 PFA_MPLUS:
0000d5 0da3          .dw XT_S2D
0000d6 015b          .dw XT_DPLUS
0000d7 1c1a          .dw XT_EXIT
                 .include "words/ud-star.asm"
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_UDSTAR:
0000d8 ff03          .dw $ff03
0000d9 6475
../../common\words/ud-star.asm(9): warning: .cseg .db misalignment - padding zero byte
0000da 002a          .db "ud*"
0000db 00d1          .dw VE_HEAD
                     .set VE_HEAD = VE_UDSTAR
                 XT_UDSTAR:
0000dc 1c00          .dw DO_COLON
                 PFA_UDSTAR:
                 
                 .endif
                 ;Z UD*      ud1 d2 -- ud3      32*16->32 multiply
                 ;   XT_DUP >R UM* DROP  XT_SWAP R> UM* ROT + ;
                 
0000dd 1cab
0000de 1cf9
0000df 1dda
0000e0 1cd3              .DW XT_DUP,XT_TO_R,XT_UMSTAR,XT_DROP
0000e1 1cbe
0000e2 1cf0
0000e3 1dda
0000e4 1cdb
0000e5 1d97
0000e6 1c1a              .DW XT_SWAP,XT_R_FROM,XT_UMSTAR,XT_ROT,XT_PLUS,XT_EXIT
                 .include "words/umax.asm"
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_UMAX:
0000e7 ff04          .dw $ff04
0000e8 6d75
0000e9 7861          .db "umax"
0000ea 00d8          .dw VE_HEAD
                     .set VE_HEAD = VE_UMAX
                 XT_UMAX:
0000eb 1c00          .dw DO_COLON
                 PFA_UMAX:
                 .endif
                 
0000ec 05b0
0000ed 1d56              .DW XT_2DUP,XT_ULESS
0000ee 1c30      	.dw XT_DOCONDBRANCH
0000ef 00f1      	 DEST(UMAX1)
0000f0 1cbe              .DW XT_SWAP
0000f1 1cd3      UMAX1:  .DW XT_DROP
0000f2 1c1a      	.dw XT_EXIT
                 .include "words/umin.asm"
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_UMIN:
0000f3 ff04          .dw $ff04
0000f4 6d75
0000f5 6e69          .db "umin"
0000f6 00e7          .dw VE_HEAD
                     .set VE_HEAD = VE_UMIN
                 XT_UMIN:
0000f7 1c00          .dw DO_COLON
                 PFA_UMIN:
                 .endif
0000f8 05b0
0000f9 1d61              .DW XT_2DUP,XT_UGREATER
0000fa 1c30      	.dw XT_DOCONDBRANCH
0000fb 00fd      	DEST(UMIN1)
0000fc 1cbe              .DW XT_SWAP
0000fd 1cd3      UMIN1:  .DW XT_DROP
0000fe 1c1a      	.dw XT_EXIT
                 .include "words/immediate-q.asm"
                 
                 ; Tools
                 ; get count information out of a counted string in flash
                 ;VE_IMMEDIATEQ:
                 ;    .dw $ff06
                 ;    .db "immediate?"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_IMMEDIATEQ
                 XT_IMMEDIATEQ:
0000ff 1c00          .dw DO_COLON
                 PFA_IMMEDIATEQ:
000100 1c37          .dw XT_DOLITERAL
000101 8000          .dw $8000
000102 1e0d          .dw XT_AND
000103 1d14          .dw XT_ZEROEQUAL
000104 1c30          .dw XT_DOCONDBRANCH
000105 0109          DEST(IMMEDIATEQ1)
000106 1c37           .dw XT_DOLITERAL
000107 0001           .dw 1
000108 1c1a           .dw XT_EXIT
                 IMMEDIATEQ1:
                     ; not immediate
000109 1d45          .dw XT_TRUE
00010a 1c1a          .dw XT_EXIT
                 .include "words/name2flags.asm"
                 
                 ; Tools
                 ; get the flags from a name token
                 VE_NAME2FLAGS:
00010b ff0a          .dw $ff0a
00010c 616e
00010d 656d
00010e 663e
00010f 616c
000110 7367          .db "name>flags"
000111 00f3          .dw VE_HEAD
                     .set VE_HEAD = VE_NAME2FLAGS
                 XT_NAME2FLAGS:
000112 1c00          .dw DO_COLON
                 PFA_NAME2FLAGS:
000113 1fba          .dw XT_FETCHI ; skip to link field
000114 1c37          .dw XT_DOLITERAL
000115 ff00          .dw $ff00
000116 1e0d          .dw XT_AND
000117 1c1a          .dw XT_EXIT
                 .include "words/name2interpret.asm"
                 
                 ; Tools (ext)
                 ; get the execution token from the name token
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_NAME2INTERPRET:
000118 ff0e          .dw $ff0e
000119 616e
00011a 656d
00011b 693e
00011c 746e
00011d 7265
00011e 7270
00011f 7465          .db "name>interpret"
000120 010b          .dw VE_HEAD
                     .set VE_HEAD = VE_NAME2INTERPRET
                 XT_NAME2INTERPRET:
000121 1c00          .dw DO_COLON
                 PFA_NAME2INTERPRET:
                 .endif
000122 0cbe          .dw XT_NFA2CFA
000123 1c1a          .dw XT_EXIT
                 .include "words/name2compile.asm"
                 
                 ; Tools (ext)
                 ; get the execution token from the name token in compile state
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_NAME2COMPILE:
000124 ff0c          .dw $ff0c
000125 616e
000126 656d
000127 633e
000128 6d6f
000129 6970
00012a 656c          .db "name>compile"
00012b 0118          .dw VE_HEAD
                     .set VE_HEAD = VE_NAME2COMPILE
                 XT_NAME2COMPILE:
00012c 1c00          .dw DO_COLON
                 PFA_NAME2COMPILE:
                 .endif
00012d 1cab          .dw XT_DUP
00012e 0cbe          .dw XT_NFA2CFA
00012f 1cbe          .dw XT_SWAP
000130 0112          .dw XT_NAME2FLAGS
000131 00ff          .dw XT_IMMEDIATEQ
000132 1c30          .dw XT_DOCONDBRANCH
000133 0137          DEST(NAME2COMPILE1)
000134 1c37      	.dw XT_DOLITERAL
000135 0272      	.dw XT_COMMA
000136 1c1a      	.dw XT_EXIT
                 NAME2COMPILE1:
000137 1c37      	.dw XT_DOLITERAL
000138 1c24      	.dw XT_EXECUTE
000139 1c1a          .dw XT_EXIT
                 
                 .if AMFORTH_NRWW_SIZE > 8000
                 .elif AMFORTH_NRWW_SIZE > 4000
                 .elif AMFORTH_NRWW_SIZE > 2000
                 .include "dict/appl_2k.inc"
                 
                 
                 ; Arithmetics
                 ; shift a double cell left
                 VE_D2STAR:
00013a ff03          .dw $ff03
00013b 3264
00013c 002a          .db "d2*",0
00013d 0124          .dw VE_HEAD
                     .set VE_HEAD = VE_D2STAR
                 XT_D2STAR:
00013e 013f          .dw PFA_D2STAR
                 PFA_D2STAR:
00013f 9109          ld temp0, Y+
000140 9119          ld temp1, Y+
000141 0f00          lsl temp0
000142 1f11          rol temp1
000143 1f88          rol tosl
000144 1f99          rol tosh
000145 931a          st -Y, temp1
000146 930a          st -Y, temp0
000147 940c 1c04     jmp_ DO_NEXT
                 .include "words/d-2slash.asm"
                 
                 ; Arithmetics
                 ; shift a double cell value right
                 VE_D2SLASH:
000149 ff03          .dw $ff03
00014a 3264
00014b 002f          .db "d2/",0
00014c 013a          .dw VE_HEAD
                     .set VE_HEAD = VE_D2SLASH
                 XT_D2SLASH:
00014d 014e          .dw PFA_D2SLASH
                 PFA_D2SLASH:
00014e 9109          ld temp0, Y+
00014f 9119          ld temp1, Y+
000150 9595          asr tosh
000151 9587          ror tosl
000152 9517          ror temp1
000153 9507          ror temp0
000154 931a          st -Y, temp1
000155 930a          st -Y, temp0
000156 940c 1c04     jmp_ DO_NEXT
                 .include "words/d-plus.asm"
                 
                 ; Arithmetics
                 ; add 2 double cell values
                 VE_DPLUS:
000158 ff02          .dw $ff02
000159 2b64          .db "d+"
00015a 0149          .dw VE_HEAD
                     .set VE_HEAD = VE_DPLUS
                 XT_DPLUS:
00015b 015c          .dw PFA_DPLUS
                 PFA_DPLUS:
00015c 9129          ld temp2, Y+
00015d 9139          ld temp3, Y+
                 
00015e 90e9          ld temp4, Y+
00015f 90f9          ld temp5, Y+
000160 9149          ld temp6, Y+
000161 9159          ld temp7, Y+
                 
000162 0f24          add temp2, temp6
000163 1f35          adc temp3, temp7
000164 1d8e          adc tosl, temp4
000165 1d9f          adc tosh, temp5
                     
000166 933a          st -Y, temp3
000167 932a          st -Y, temp2
000168 940c 1c04     jmp_ DO_NEXT
                 .include "words/d-minus.asm"
                 
                 ; Arithmetics
                 ; subtract d2 from d1 
                 VE_DMINUS:
00016a ff02          .dw $ff02
00016b 2d64          .db "d-"
00016c 0158          .dw VE_HEAD
                     .set VE_HEAD = VE_DMINUS
                 XT_DMINUS:
00016d 016e          .dw PFA_DMINUS
                 PFA_DMINUS:
00016e 9129          ld temp2, Y+
00016f 9139          ld temp3, Y+
                 
000170 90e9          ld temp4, Y+
000171 90f9          ld temp5, Y+
000172 9149          ld temp6, Y+
000173 9159          ld temp7, Y+
                 
000174 1b42          sub temp6, temp2
000175 0b53          sbc temp7, temp3
000176 0ae8          sbc temp4, tosl
000177 0af9          sbc temp5, tosh
                 
000178 935a          st -Y, temp7
000179 934a          st -Y, temp6
00017a 01c7          movw tosl, temp4
00017b 940c 1c04     jmp_ DO_NEXT
                 .include "words/d-invert.asm"
                 
                 ; Arithmetics
                 ; invert all bits in the double cell value
                 VE_DINVERT:
00017d ff07          .dw $ff07
00017e 6964
00017f 766e
000180 7265
000181 0074          .db "dinvert",0
000182 016a          .dw VE_HEAD
                     .set VE_HEAD = VE_DINVERT
                 XT_DINVERT:
000183 0184          .dw PFA_DINVERT
                 PFA_DINVERT:
000184 9109          ld temp0, Y+
000185 9119          ld temp1, Y+
000186 9580          com tosl
000187 9590          com tosh
000188 9500          com temp0
000189 9510          com temp1
00018a 931a          st -Y, temp1
00018b 930a          st -Y, temp0
00018c 940c 1c04     jmp_ DO_NEXT
                 .include "words/d-equal.asm"
                 
                 ; Compare
                 ; compares two double cell values
                 VE_DEQUAL:
00018e ff02          .dw $ff02
00018f 3d64          .db "d="
000190 017d          .dw VE_HEAD
                     .set VE_HEAD = VE_DEQUAL
                 XT_DEQUAL:
000191 1c00          .dw DO_COLON
                 PFA_DEQUAL:
000192 016d          .dw XT_DMINUS
000193 1e16          .dw XT_OR
000194 1d14          .dw XT_ZEROEQUAL
000195 1c1a          .dw XT_EXIT
                 .include "words/u-dot.asm"
                 
                 ; Numeric IO
                 ; unsigned PNO with single cell numbers
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_UDOT:
000196 ff02          .dw $ff02
000197 2e75          .db "u."
000198 018e          .dw VE_HEAD
                     .set VE_HEAD = VE_UDOT
                 XT_UDOT:
000199 1c00          .dw DO_COLON
                 PFA_UDOT:
                 .endif
00019a 1d4e          .dw XT_ZERO
00019b 0781          .dw XT_UDDOT
00019c 1c1a          .dw XT_EXIT
                 ; : u.        ( us -- )    0 ud. ;
                 .include "words/u-dot-r.asm"
                 
                 ; Numeric IO
                 ; unsigned PNO with single cells numbers, right aligned in width w
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 
                 VE_UDOTR:
00019d ff03          .dw $ff03
00019e 2e75
00019f 0072          .db "u.r",0
0001a0 0196          .dw VE_HEAD
                     .set VE_HEAD = VE_UDOTR
                 XT_UDOTR:
0001a1 1c00          .dw DO_COLON
                 PFA_UDOTR:
                 .endif
0001a2 1d4e          .dw XT_ZERO
0001a3 1cbe          .dw XT_SWAP
0001a4 078a          .dw XT_UDDOTR
0001a5 1c1a          .dw XT_EXIT
                 ; : u.r       ( s n -- )   0 swap ud.r ;
                 
                 .include "words/show-wordlist.asm"
                 
                 ; Tools
                 ; prints the name of the words in a wordlist
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SHOWWORDLIST:
0001a6 ff0d          .dw $ff0d
0001a7 6873
0001a8 776f
0001a9 772d
0001aa 726f
0001ab 6c64
0001ac 7369
0001ad 0074          .db "show-wordlist",0
0001ae 019d          .dw VE_HEAD
                     .set VE_HEAD = VE_SHOWWORDLIST
                 XT_SHOWWORDLIST:
0001af 1c00          .dw DO_COLON
                 PFA_SHOWWORDLIST:
                 .endif
0001b0 1c37          .dw XT_DOLITERAL
0001b1 01b5          .dw XT_SHOWWORD
0001b2 1cbe          .dw XT_SWAP
0001b3 0c97          .dw XT_TRAVERSEWORDLIST
0001b4 1c1a          .dw XT_EXIT
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 XT_SHOWWORD:
0001b5 1c00          .dw DO_COLON
                 PFA_SHOWWORD:
                 .endif
0001b6 0cb2          .dw XT_NAME2STRING
0001b7 07f7          .dw XT_ITYPE
0001b8 0839          .dw XT_SPACE         ; ( -- addr n)
0001b9 1d45          .dw XT_TRUE
0001ba 1c1a          .dw XT_EXIT
                 .include "words/words.asm"
                 
                 ; Tools
                 ; prints a list of all (visible) words in the dictionary
                 VE_WORDS:
0001bb ff05          .dw $ff05
0001bc 6f77
0001bd 6472
0001be 0073          .db "words",0
0001bf 01a6          .dw VE_HEAD
                     .set VE_HEAD = VE_WORDS
                 XT_WORDS:
0001c0 1c00          .dw DO_COLON
                 PFA_WORDS:
0001c1 1c37          .dw XT_DOLITERAL
0001c2 0044          .dw CFG_ORDERLIST
0001c3 1f4d          .dw XT_FETCHE
0001c4 01af          .dw XT_SHOWWORDLIST
0001c5 1c1a          .dw XT_EXIT
                 .include "dict/interrupt.inc"
                 
                 .include "words/int-on.asm"
                 
                 ; Interrupt
                 ; turns on all interrupts
                 VE_INTON:
0001c6 ff04          .dw $ff04
0001c7 692b
0001c8 746e          .db "+int"
0001c9 01bb          .dw VE_HEAD
                     .set VE_HEAD = VE_INTON
                 XT_INTON:
0001ca 01cb          .dw PFA_INTON
                 PFA_INTON:
0001cb 9478          sei
0001cc 940c 1c04     jmp_ DO_NEXT
                 .include "words/int-off.asm"
                 
                 ; Interrupt
                 ; turns off all interrupts 
                 VE_INTOFF:
0001ce ff04          .dw $ff04
0001cf 692d
0001d0 746e          .db "-int"
0001d1 01c6          .dw VE_HEAD
                     .set VE_HEAD = VE_INTOFF
                 XT_INTOFF:
0001d2 01d3          .dw PFA_INTOFF
                 PFA_INTOFF:
0001d3 94f8          cli
0001d4 940c 1c04     jmp_ DO_NEXT
                 .include "words/int-store.asm"
                 
                 ; Interrupt
                 ; stores XT as interrupt vector i
                 VE_INTSTORE:
0001d6 ff04          .dw $ff04
0001d7 6e69
0001d8 2174          .db "int!"
0001d9 01ce          .dw VE_HEAD
                     .set VE_HEAD = VE_INTSTORE
                 XT_INTSTORE:
0001da 1c00          .dw DO_COLON
                 PFA_INTSTORE:
0001db 1c37          .dw XT_DOLITERAL
0001dc 0000          .dw intvec
0001dd 1d97          .dw XT_PLUS
0001de 1f29          .dw XT_STOREE
0001df 1c1a          .dw XT_EXIT
                 .include "words/int-fetch.asm"
                 
                 ; Interrupt
                 ; fetches XT from interrupt vector i
                 VE_INTFETCH:
0001e0 ff04          .dw $ff04
0001e1 6e69
0001e2 4074          .db "int@"
0001e3 01d6          .dw VE_HEAD
                     .set VE_HEAD = VE_INTFETCH
                 XT_INTFETCH:
0001e4 1c00          .dw DO_COLON
                 PFA_INTFETCH:
0001e5 1c37          .dw XT_DOLITERAL
0001e6 0000          .dw intvec
0001e7 1d97          .dw XT_PLUS
0001e8 1f4d          .dw XT_FETCHE
0001e9 1c1a          .dw XT_EXIT
                 .include "words/int-trap.asm"
                 
                 ; Interrupt
                 ; trigger an interrupt
                 VE_INTTRAP:
0001ea ff08          .dw $ff08
0001eb 6e69
0001ec 2d74
0001ed 7274
0001ee 7061          .db "int-trap"
0001ef 01e0          .dw VE_HEAD
                     .set VE_HEAD = VE_INTTRAP
                 XT_INTTRAP:
0001f0 01f1          .dw PFA_INTTRAP
                 PFA_INTTRAP:
0001f1 9380 0116     sts intcur, tosl
0001f3 9189
0001f4 9199          loadtos
0001f5 9468          set ; set the interrupt flag for the inner interpreter
0001f6 940c 1c04     jmp_ DO_NEXT
                 
                 .include "words/isr-exec.asm"
                 
                 ; Interrupt
                 ; executes an interrupt service routine
                 ;VE_ISREXEC:
                 ;    .dw $ff08
                 ;    .db "isr-exec"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_ISREXEC
                 XT_ISREXEC:
0001f8 1c00          .dw DO_COLON
                 PFA_ISREXEC:
0001f9 1c37          .dw XT_DOLITERAL
0001fa 0116          .dw intcur
0001fb 1c92          .dw XT_CFETCH
0001fc 1c37          .dw XT_DOLITERAL
0001fd 0000          .dw intvec
0001fe 1d97          .dw XT_PLUS
0001ff 1f4d          .dw XT_FETCHE
000200 1c24          .dw XT_EXECUTE
000201 0203          .dw XT_ISREND
000202 1c1a          .dw XT_EXIT
                 .include "words/isr-end.asm"
                 
                 ; Interrupt
                 ; re-enables interrupts in an ISR
                 ;VE_ISREND:
                 ;    .dw $ff07
                 ;    .db "isr-end",0
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_ISREND
                 XT_ISREND:
000203 0204          .dw PFA_ISREND
                 PFA_ISREND:
000204 d002          rcall PFA_ISREND1 ; clear the interrupt flag for the controller
000205 940c 1c04     jmp_ DO_NEXT
                 PFA_ISREND1:
000207 9518          reti
                 
                 .include "words/pick.asm"
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_PICK:
000208 ff04          .dw $ff04
000209 6970
00020a 6b63          .db "pick"
00020b 01ea          .dw VE_HEAD
                     .set VE_HEAD = VE_PICK
                 XT_PICK:
00020c 1c00          .dw DO_COLON
                 PFA_PICK:
                 .endif
00020d 1e29          .dw XT_1PLUS
00020e 05a2          .dw XT_CELLS
00020f 1e7b          .dw XT_SP_FETCH
000210 1d97          .dw XT_PLUS
000211 1c73          .dw XT_FETCH
000212 1c1a          .dw XT_EXIT
                 .include "words/dot-quote.asm"
                 
                 ; Compiler
                 ; compiles string into dictionary to be printed at runtime
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 
                 VE_DOTSTRING:
000213 0002          .dw $0002
000214 222e          .db ".",$22
000215 0208          .dw VE_HEAD
                     .set VE_HEAD = VE_DOTSTRING
                 XT_DOTSTRING:
000216 1c00          .dw DO_COLON
                 PFA_DOTSTRING:
                 .endif
000217 021e          .dw XT_SQUOTE
000218 0267          .dw XT_COMPILE
000219 07f7          .dw XT_ITYPE
00021a 1c1a          .dw XT_EXIT
                 .include "words/squote.asm"
                 
                 ; Compiler
                 ; compiles a string to flash, at runtime leaves ( -- flash-addr count) on stack
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SQUOTE:
00021b 0002        .dw $0002
00021c 2273        .db "s",$22
00021d 0213        .dw VE_HEAD
                   .set VE_HEAD = VE_SQUOTE
                 XT_SQUOTE:
00021e 1c00          .dw DO_COLON
                 PFA_SQUOTE:
                 .endif
00021f 1c37          .dw XT_DOLITERAL
000220 0022          .dw 34   ; 0x22 
000221 09d6          .dw XT_PARSE       ; ( -- addr n)
000222 0595          .dw XT_STATE
000223 1c73          .dw XT_FETCH
000224 1c30          .dw XT_DOCONDBRANCH
000225 0227          DEST(PFA_SQUOTE1)
000226 0293            .dw XT_SLITERAL
                 PFA_SQUOTE1:
000227 1c1a          .dw XT_EXIT
                 
                 .include "words/fill.asm"
                 
                 ; Memory
                 ; fill u bytes memory beginning at a-addr with character c
                 VE_FILL:
000228 ff04          .dw $ff04
000229 6966
00022a 6c6c          .db "fill"
00022b 021b          .dw VE_HEAD
                     .set VE_HEAD = VE_FILL
                 XT_FILL:
00022c 1c00          .dw DO_COLON
                 PFA_FILL:
00022d 1cdb          .dw XT_ROT
00022e 1cdb          .dw XT_ROT
00022f 1cb3
000230 1c30          .dw XT_QDUP,XT_DOCONDBRANCH
000231 0239          DEST(PFA_FILL2)
000232 0d9a          .dw XT_BOUNDS
000233 1e89          .dw XT_DODO
                 PFA_FILL1:
000234 1cab          .dw XT_DUP
000235 1e9a          .dw XT_I
000236 1c87          .dw XT_CSTORE  ; ( -- c c-addr)
000237 1eb7          .dw XT_DOLOOP
000238 0234          .dw PFA_FILL1
                 PFA_FILL2:
000239 1cd3          .dw XT_DROP
00023a 1c1a          .dw XT_EXIT
                 .include "dict/compiler1.inc"
                 
                 .include "words/docreate.asm"
                 
                 ; Compiler
                 ; parse the input and create an empty vocabulary entry without XT and data field (PF)
                 VE_DOCREATE:
00023b ff08          .dw $ff08
00023c 6328
00023d 6572
00023e 7461
00023f 2965          .db "(create)"
000240 0228          .dw VE_HEAD
                     .set VE_HEAD = VE_DOCREATE
                 XT_DOCREATE:
000241 1c00          .dw DO_COLON
                 PFA_DOCREATE:
000242 0a04          .dw XT_PARSENAME
000243 039c          .dw XT_WLSCOPE
000244 1cab          .dw XT_DUP
000245 1cf9          .dw XT_TO_R
000246 0381          .dw XT_HEADER
000247 1cf0          .dw XT_R_FROM
                 .dseg
000117           COLON_SMUDGE: .byte 4
                 .cseg
000248 1c37          .dw XT_DOLITERAL
000249 0119          .dw COLON_SMUDGE+2
00024a 1c7b          .dw XT_STORE		; save wid
00024b 1c37          .dw XT_DOLITERAL
00024c 0117          .dw COLON_SMUDGE+0
00024d 1c7b          .dw XT_STORE		; save NFA
                 
00024e 1c1a          .dw XT_EXIT
                 .include "words/backslash.asm"
                 
                 ; Compiler
                 ; everything up to the end of the current line is a comment
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_BACKSLASH:
00024f 0001          .dw $0001
000250 005c          .db $5c,0
000251 023b          .dw VE_HEAD
                     .set VE_HEAD = VE_BACKSLASH
                 XT_BACKSLASH:
000252 1c00          .dw DO_COLON
                 PFA_BACKSLASH:
                 .endif
000253 09eb          .dw XT_SOURCE
000254 1cea          .dw XT_NIP
000255 05c9          .dw XT_TO_IN
000256 1c7b          .dw XT_STORE
000257 1c1a          .dw XT_EXIT
                 .include "words/l-paren.asm"
                 
                 ; Compiler
                 ; skip everything up to the closing bracket on the same line
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_LPAREN:
000258 0001          .dw $0001
000259 0028          .db "(" ,0
00025a 024f          .dw VE_HEAD
                     .set VE_HEAD = VE_LPAREN
                 XT_LPAREN:
00025b 1c00          .dw DO_COLON
                 PFA_LPAREN:
                 .endif
00025c 1c37          .dw XT_DOLITERAL
00025d 0029          .dw ')'
00025e 09d6          .dw XT_PARSE
00025f 05b9          .dw XT_2DROP
000260 1c1a          .dw XT_EXIT
                 
                 .include "words/compile.asm"
                 
                 ; Dictionary
                 ; read the following cell from the dictionary and append it to the current dictionary position.
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_COMPILE:
000261 ff07          .dw $ff07
000262 6f63
000263 706d
000264 6c69
000265 0065          .db "compile",0
000266 0258          .dw  VE_HEAD
                     .set VE_HEAD = VE_COMPILE
                 XT_COMPILE:
000267 1c00          .dw DO_COLON
                 PFA_COMPILE:
                 .endif
000268 1cf0          .dw XT_R_FROM
000269 1cab          .dw XT_DUP
00026a 0beb          .dw XT_ICELLPLUS
00026b 1cf9          .dw XT_TO_R
00026c 1fba          .dw XT_FETCHI
00026d 0272          .dw XT_COMMA
00026e 1c1a          .dw XT_EXIT
                 .include "words/comma.asm"
                 
                 ; Dictionary
                 ; compile 16 bit into flash at DP
                 VE_COMMA:
00026f ff01          .dw $ff01
000270 002c          .db ',',0 ; ,
000271 0261          .dw VE_HEAD
                     .set VE_HEAD = VE_COMMA
                 XT_COMMA:
000272 1c00          .dw DO_COLON
                 PFA_COMMA:
000273 05ff          .dw XT_DP
000274 1f61          .dw XT_STOREI
000275 05ff          .dw XT_DP
000276 1e29          .dw XT_1PLUS
000277 0bd9          .dw XT_DOTO
000278 0600          .dw PFA_DP
000279 1c1a          .dw XT_EXIT
                 .include "words/brackettick.asm"
                 
                 ; Compiler
                 ; what ' does in the interpreter mode, do in colon definitions
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_BRACKETTICK:
00027a 0003          .dw $0003
00027b 275b
00027c 005d          .db "[']",0
00027d 026f          .dw VE_HEAD
                     .set VE_HEAD = VE_BRACKETTICK
                 XT_BRACKETTICK:
00027e 1c00          .dw DO_COLON
                 PFA_BRACKETTICK:
                 .endif
00027f 0861          .dw XT_TICK
000280 0288          .dw XT_LITERAL
000281 1c1a          .dw XT_EXIT
                 
                 
                 .include "words/literal.asm"
                 
                 ; Compiler
                 ; compile a literal in colon defintions
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_LITERAL:
000282 0007          .dw $0007
000283 696c
000284 6574
000285 6172
000286 006c          .db "literal",0
000287 027a          .dw VE_HEAD
                     .set VE_HEAD = VE_LITERAL
                 XT_LITERAL:
000288 1c00          .dw DO_COLON
                 PFA_LITERAL:
                 .endif
000289 0267              .DW XT_COMPILE
00028a 1c37              .DW XT_DOLITERAL
00028b 0272              .DW XT_COMMA
00028c 1c1a              .DW XT_EXIT
                 .include "words/sliteral.asm"
                 
                 ; String
                 ; compiles a string to flash, at runtime leaves ( -- flash-addr count) on stack
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SLITERAL:
00028d 0008        .dw $0008
00028e 6c73
00028f 7469
000290 7265
000291 6c61        .db "sliteral"
000292 0282        .dw VE_HEAD
                   .set VE_HEAD = VE_SLITERAL
                 XT_SLITERAL:
000293 1c00          .dw DO_COLON
                 PFA_SLITERAL:
                 .endif
000294 0267          .dw XT_COMPILE
000295 07c4          .dw XT_DOSLITERAL    ; ( -- addr n)
000296 07d2          .dw XT_SCOMMA
000297 1c1a          .dw XT_EXIT
                 .include "words/g-mark.asm"
                 
                 ; Compiler
                 ; places current dictionary position for backward resolves
                 ;VE_GMARK:
                 ;    .dw $ff05
                 ;    .db ">mark"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_GMARK
                 XT_GMARK:
000298 1c00          .dw DO_COLON
                 PFA_GMARK:
000299 05ff          .dw XT_DP
00029a 0267          .dw XT_COMPILE
00029b ffff          .dw -1           ; ffff does not erase flash
00029c 1c1a          .dw XT_EXIT
                 .include "words/g-resolve.asm"
                 
                 ; Compiler
                 ; resolve backward jumps
                 ;VE_GRESOLVE:
                 ;    .dw $ff08
                 ;    .db ">resolve"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_GRESOLVE
                 XT_GRESOLVE:
00029d 1c00          .dw DO_COLON
                 PFA_GRESOLVE:
00029e 0b96          .dw XT_QSTACK
00029f 05ff          .dw XT_DP
0002a0 1cbe          .dw XT_SWAP
0002a1 1f61          .dw XT_STOREI
0002a2 1c1a          .dw XT_EXIT
                 .include "words/l_mark.asm"
                 
                 ; Compiler
                 ; place destination for backward branch
                 ;VE_LMARK:
                 ;    .dw $ff05
                 ;    .db "<mark"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_LMARK
                 XT_LMARK:
0002a3 1c00          .dw DO_COLON
                 PFA_LMARK:
0002a4 05ff          .dw XT_DP
0002a5 1c1a          .dw XT_EXIT
                 .include "words/l_resolve.asm"
                 
                 ; Compiler
                 ; resolve backward branch
                 ;VE_LRESOLVE:
                 ;    .dw $ff08
                 ;    .db "<resolve"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_LRESOLVE
                 XT_LRESOLVE:
0002a6 1c00          .dw DO_COLON
                 PFA_LRESOLVE:
0002a7 0b96          .dw XT_QSTACK
0002a8 0272          .dw XT_COMMA
0002a9 1c1a          .dw XT_EXIT
                 
                 .include "words/ahead.asm"
                 
                 ; Compiler
                 ; do a unconditional branch
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_AHEAD:
0002aa 0005          .dw $0005
0002ab 6861
0002ac 6165
0002ad 0064          .db "ahead",0
0002ae 028d          .dw VE_HEAD
                     .set VE_HEAD = VE_AHEAD
                 XT_AHEAD:
0002af 1c00          .dw DO_COLON
                 PFA_AHEAD:
                 .endif
0002b0 0267          .dw XT_COMPILE
0002b1 1c29          .dw XT_DOBRANCH
0002b2 0298          .dw XT_GMARK
0002b3 1c1a          .dw XT_EXIT
                 .include "words/if.asm"
                 
                 ; Compiler
                 ; start conditional branch
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_IF:
0002b4 0002          .dw $0002
0002b5 6669          .db "if"
0002b6 02aa          .dw VE_HEAD
                     .set VE_HEAD = VE_IF
                 XT_IF:
0002b7 1c00          .dw DO_COLON
                 PFA_IF:
                 .endif
0002b8 0267          .dw XT_COMPILE
0002b9 1c30          .dw XT_DOCONDBRANCH
0002ba 0298          .dw XT_GMARK
0002bb 1c1a          .dw XT_EXIT
                 .include "words/else.asm"
                 
                 ; Compiler
                 ; resolve the forward reference and place a new unresolved forward reference
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_ELSE:
0002bc 0004          .dw $0004
0002bd 6c65
0002be 6573          .db "else"
0002bf 02b4          .dw VE_HEAD
                     .set VE_HEAD = VE_ELSE
                 XT_ELSE:
0002c0 1c00          .dw DO_COLON
                 PFA_ELSE:
                 .endif
0002c1 0267          .dw XT_COMPILE
0002c2 1c29          .dw XT_DOBRANCH
0002c3 0298          .dw XT_GMARK
0002c4 1cbe          .dw XT_SWAP
0002c5 029d          .dw XT_GRESOLVE
0002c6 1c1a          .dw XT_EXIT
                 .include "words/then.asm"
                 
                 ; Compiler
                 ; finish if
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_THEN:
0002c7 0004          .dw $0004
0002c8 6874
0002c9 6e65          .db "then"
0002ca 02bc          .dw VE_HEAD
                     .set VE_HEAD = VE_THEN
                 XT_THEN:
0002cb 1c00          .dw DO_COLON
                 PFA_THEN:
                 .endif
0002cc 029d          .dw XT_GRESOLVE
0002cd 1c1a          .dw XT_EXIT
                 .include "words/begin.asm"
                 
                 ; Compiler
                 ; put the next location for a transfer of control onto the control flow stack
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_BEGIN:
0002ce 0005          .dw $0005
0002cf 6562
0002d0 6967
0002d1 006e          .db "begin",0
0002d2 02c7          .dw VE_HEAD
                     .set VE_HEAD = VE_BEGIN
                 XT_BEGIN:
0002d3 1c00          .dw DO_COLON
                 PFA_BEGIN:
                 .endif
0002d4 02a3          .dw XT_LMARK
0002d5 1c1a          .dw XT_EXIT
                 .include "words/while.asm"
                 
                 ; Compiler
                 ; at runtime skip until repeat if non-true
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_WHILE:
0002d6 0005          .dw $0005
0002d7 6877
0002d8 6c69
0002d9 0065          .db "while",0
0002da 02ce          .dw VE_HEAD
                     .set VE_HEAD = VE_WHILE
                 XT_WHILE:
0002db 1c00          .dw DO_COLON
                 PFA_WHILE:
                 .endif
0002dc 02b7          .dw XT_IF
0002dd 1cbe          .dw XT_SWAP
0002de 1c1a          .dw XT_EXIT
                 .include "words/repeat.asm"
                 
                 ; Compiler
                 ; continue execution at dest, resolve orig
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_REPEAT:
0002df 0006          .dw $0006
0002e0 6572
0002e1 6570
0002e2 7461          .db "repeat"
0002e3 02d6          .dw VE_HEAD
                     .set VE_HEAD = VE_REPEAT
                 XT_REPEAT:
0002e4 1c00          .dw DO_COLON
                 PFA_REPEAT:
                 .endif
0002e5 02f8          .dw XT_AGAIN
0002e6 02cb          .dw XT_THEN
0002e7 1c1a          .dw XT_EXIT
                 .include "words/until.asm"
                 
                 ; Compiler
                 ; finish begin with conditional branch, leaves the loop if true flag at runtime
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_UNTIL:
0002e8 0005          .dw $0005
0002e9 6e75
0002ea 6974
0002eb 006c          .db "until",0
0002ec 02df          .dw VE_HEAD
                     .set VE_HEAD = VE_UNTIL
                 XT_UNTIL:
0002ed 1c00          .dw DO_COLON
                 PFA_UNTIL:
                 .endif
0002ee 1c37          .dw XT_DOLITERAL
0002ef 1c30          .dw XT_DOCONDBRANCH
0002f0 0272          .dw XT_COMMA
                 
0002f1 02a6          .dw XT_LRESOLVE
0002f2 1c1a          .dw XT_EXIT
                 .include "words/again.asm"
                 
                 ; Compiler
                 ; compile a jump back to dest
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_AGAIN:
0002f3 0005          .dw $0005
0002f4 6761
0002f5 6961
0002f6 006e          .db "again",0
0002f7 02e8          .dw VE_HEAD
                     .set VE_HEAD = VE_AGAIN
                 XT_AGAIN:
0002f8 1c00          .dw DO_COLON
                 PFA_AGAIN:
                 .endif
0002f9 0267          .dw XT_COMPILE
0002fa 1c29          .dw XT_DOBRANCH
0002fb 02a6          .dw XT_LRESOLVE
0002fc 1c1a          .dw XT_EXIT
                 .include "words/do.asm"
                 
                 ; Compiler
                 ; start do .. [+]loop
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DO:
0002fd 0002          .dw $0002
0002fe 6f64          .db "do"
0002ff 02f3          .dw VE_HEAD
                     .set VE_HEAD = VE_DO
                 XT_DO:
000300 1c00          .dw DO_COLON
                 PFA_DO:
                 
                 .endif
000301 0267          .dw XT_COMPILE
000302 1e89          .dw XT_DODO
000303 02a3          .dw XT_LMARK
000304 1d4e          .dw XT_ZERO
000305 035b          .dw XT_TO_L
000306 1c1a          .dw XT_EXIT
                 .include "words/loop.asm"
                 
                 ; Compiler
                 ; compile (loop) and resolve the backward branch
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_LOOP:
000307 0004          .dw $0004
000308 6f6c
000309 706f          .db "loop"
00030a 02fd          .dw VE_HEAD
                     .set VE_HEAD = VE_LOOP
                 XT_LOOP:
00030b 1c00          .dw DO_COLON
                 PFA_LOOP:
                 .endif
00030c 0267          .dw XT_COMPILE
00030d 1eb7          .dw XT_DOLOOP
00030e 0342          .dw XT_ENDLOOP
00030f 1c1a          .dw XT_EXIT
                 .include "words/plusloop.asm"
                 
                 ; Compiler
                 ; compile (+loop) and resolve branches
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_PLUSLOOP:
000310 0005          .dw $0005
000311 6c2b
000312 6f6f
000313 0070          .db "+loop",0
000314 0307          .dw VE_HEAD
                     .set VE_HEAD = VE_PLUSLOOP
                 XT_PLUSLOOP:
000315 1c00          .dw DO_COLON
                 PFA_PLUSLOOP:
                 .endif
000316 0267          .dw XT_COMPILE
000317 1ea8          .dw XT_DOPLUSLOOP
000318 0342          .dw XT_ENDLOOP
000319 1c1a          .dw XT_EXIT
                 .include "words/leave.asm"
                 
                 ; Compiler
                 ; immediatly leave the current DO..LOOP
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_LEAVE:
00031a 0005         .dw $0005
00031b 656c
00031c 7661
00031d 0065         .db "leave",0
00031e 0310         .dw VE_HEAD
                    .set VE_HEAD = VE_LEAVE
                 XT_LEAVE:
00031f 1c00          .dw DO_COLON
                 PFA_LEAVE:
                 .endif
000320 0267
000321 1ec2          .DW XT_COMPILE,XT_UNLOOP
000322 02af
000323 035b
000324 1c1a          .DW XT_AHEAD,XT_TO_L,XT_EXIT
                 .include "words/qdo.asm"
                 
                 ; Compiler
                 ; start a ?do .. [+]loop control structure
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 VE_QDO:
000325 0003          .dw $0003
000326 643f
000327 006f          .db "?do",0
000328 031a          .dw VE_HEAD
                     .set VE_HEAD = VE_QDO
                 XT_QDO:
000329 1c00          .dw DO_COLON
                 PFA_QDO:
                 .endif
00032a 0267          .dw XT_COMPILE
00032b 0331          .dw XT_QDOCHECK
00032c 02b7          .dw XT_IF
00032d 0300          .dw XT_DO
00032e 1cbe          .dw XT_SWAP    ; DO sets a 0 marker on the leave stack
00032f 035b          .dw XT_TO_L    ; then follows at the end.
000330 1c1a          .dw XT_EXIT
                 
                 ; there is no special runtime for ?do, the do runtime
                 ; gets wrapped with the sequence
                 ; ... ?do-check if do ..... loop then
                 ; with
                 ; : ?do-check ( n1 n2 -- n1 n2 true | false )
                 ;   2dup = dup >r if 2drop then r> invert ;
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 XT_QDOCHECK:
000331 1c00          .dw DO_COLON
                 PFA_QDOCHECK:
                 .endif
000332 05b0          .dw XT_2DUP
000333 1fd3          .dw XT_EQUAL
000334 1cab          .dw XT_DUP
000335 1cf9          .dw XT_TO_R
000336 1c30          .dw XT_DOCONDBRANCH
000337 0339          DEST(PFA_QDOCHECK1)
000338 05b9          .dw XT_2DROP
                 PFA_QDOCHECK1:
000339 1cf0          .dw XT_R_FROM
00033a 1df7          .dw XT_INVERT
00033b 1c1a          .dw XT_EXIT
                 .include "words/endloop.asm"
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_ENDLOOP:
00033c ff07          .dw $ff07
00033d 6e65
00033e 6c64
00033f 6f6f
000340 0070          .db "endloop",0
000341 0325          .dw VE_HEAD
                     .set VE_HEAD = VE_ENDLOOP
                 XT_ENDLOOP:
000342 1c00          .dw DO_COLON
                 PFA_ENDLOOP:
                 .endif
                 ;Z ENDLOOP   adrs xt --   L: 0 a1 a2 .. aN --
                 ;   <resolve                backward loop
                 ;   BEGIN L> ?DUP WHILE POSTPONE THEN REPEAT ;
                 ;                                 resolve LEAVEs
                 ; This is a common factor of LOOP and +LOOP.
                 
000343 02a6              .DW XT_LRESOLVE
000344 034f
000345 1cb3
000346 1c30      LOOP1:  .DW XT_L_FROM,XT_QDUP,XT_DOCONDBRANCH
000347 034b               DEST(LOOP2)
000348 02cb              .DW XT_THEN
000349 1c29      	.dw XT_DOBRANCH
00034a 0344               DEST(LOOP1)
00034b 1c1a      LOOP2:  .DW XT_EXIT
                 ; leave address stack
                 .include "words/l-from.asm"
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_L_FROM:
00034c ff02          .dw $ff02
00034d 3e6c          .db "l>"
00034e 033c          .dw VE_HEAD
                     .set VE_HEAD = VE_L_FROM
                 XT_L_FROM:
00034f 1c00          .dw DO_COLON
                 PFA_L_FROM:
                 
                 .endif
                 ;Z L>   -- x   L: x --      move from leave stack
                 ;   LP @ @  -2 LP +! ;
                 
000350 036f          .dw XT_LP
000351 1c73          .dw XT_FETCH
000352 1c73          .dw XT_FETCH
000353 1c37          .dw XT_DOLITERAL
000354 fffe          .dw -2
000355 036f          .dw XT_LP
000356 1e53          .dw XT_PLUSSTORE
000357 1c1a          .dw XT_EXIT
                 .include "words/to-l.asm"
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_TO_L:
000358 ff02          .dw $ff02
000359 6c3e          .db ">l"
00035a 034c          .dw VE_HEAD
                     .set VE_HEAD = VE_TO_L
                 XT_TO_L:
00035b 1c00          .dw DO_COLON
                 PFA_TO_L:
                 .endif
                 ;Z >L   x --   L: -- x        move to leave stack
                 ;   CELL LP +!  LP @ ! ;      (L stack grows up)
                 
00035c 1c37              .dw XT_DOLITERAL
00035d 0002      	.dw 2
00035e 036f      	.dw XT_LP
00035f 1e53      	.dw XT_PLUSSTORE
000360 036f      	.dw XT_LP
000361 1c73      	.dw XT_FETCH
000362 1c7b      	.dw XT_STORE
000363 1c1a      	.dw XT_EXIT
                 .include "words/lp0.asm"
                 
                 ; Stack
                 ; start address of leave stack
                 VE_LP0:
000364 ff03          .dw $ff03
000365 706c
000366 0030          .db "lp0",0
000367 0358          .dw VE_HEAD
                     .set VE_HEAD = VE_LP0
                 XT_LP0:
000368 1c69          .dw PFA_DOVALUE1
                 PFA_LP0:
000369 0060          .dw EE_LP0
00036a 0bf4          .dw XT_EDEFERFETCH
00036b 0bfe          .dw XT_EDEFERSTORE
                 .include "words/lp.asm"
                 
                 ; System Variable
                 ; leave stack pointer
                 VE_LP:
00036c ff02          .dw $ff02
00036d 706c          .db "lp"
00036e 0364          .dw VE_HEAD
                     .set VE_HEAD = VE_LP
                 XT_LP:
00036f 1c42          .dw PFA_DOVARIABLE
                 PFA_LP:
000370 011b          .dw ram_lp
                 
                 .dseg
00011b           ram_lp: .byte 2
                 .cseg
                 
                 
                 .include "words/create.asm"
                 
                 ; Dictionary
                 ; create a dictionary header. XT is (constant), with the address of the data field of name
                 VE_CREATE:
000371 ff06          .dw $ff06
000372 7263
000373 6165
000374 6574          .db "create"
000375 036c          .dw VE_HEAD
                     .set VE_HEAD = VE_CREATE
                 XT_CREATE:
000376 1c00          .dw DO_COLON
                 PFA_CREATE:
000377 0241          .dw XT_DOCREATE
000378 03a5          .dw XT_REVEAL
000379 0267          .dw XT_COMPILE
00037a 1c4c          .dw PFA_DOCONSTANT
00037b 1c1a          .dw XT_EXIT
                 .include "words/header.asm"
                 
                 ; Compiler
                 ; creates the vocabulary header without XT and data field (PF) in the wordlist wid
                 VE_HEADER:
00037c ff06          .dw $ff06
00037d 6568
00037e 6461
00037f 7265          .db "header"
000380 0371          .dw VE_HEAD
                     .set VE_HEAD = VE_HEADER
                 XT_HEADER:
000381 1c00          .dw DO_COLON
                 PFA_HEADER:
000382 05ff          .dw XT_DP           ; the new Name Field
000383 1cf9          .dw XT_TO_R
000384 1cf9          .dw XT_TO_R		; ( R: NFA WID )
000385 1cab          .dw XT_DUP    
000386 1d22          .dw XT_GREATERZERO 
000387 1c30          .dw XT_DOCONDBRANCH
000388 0393          .dw PFA_HEADER1
000389 1cab          .dw XT_DUP
00038a 1c37          .dw XT_DOLITERAL
00038b ff00          .dw $ff00           ; all flags are off (e.g. immediate)
00038c 1e16          .dw XT_OR
00038d 07d6          .dw XT_DOSCOMMA
                     ; make the link to the previous entry in this wordlist
00038e 1cf0          .dw XT_R_FROM
00038f 1f4d          .dw XT_FETCHE
000390 0272          .dw XT_COMMA
000391 1cf0          .dw XT_R_FROM
000392 1c1a          .dw XT_EXIT
                 
                 PFA_HEADER1:
                     ; -16: attempt to use zero length string as a name
000393 1c37          .dw XT_DOLITERAL
000394 fff0          .dw -16
000395 0890          .dw XT_THROW
                 
                 .include "words/wlscope.asm"
                 
                 ; Compiler
                 ; dynamically place a word in a wordlist. The word name may be changed.
                 VE_WLSCOPE:
000396 ff07          .dw $ff07
000397 6c77
000398 6373
000399 706f
00039a 0065          .db "wlscope",0
00039b 037c          .dw VE_HEAD
                     .set VE_HEAD = VE_WLSCOPE
                 XT_WLSCOPE:
00039c 0c53          .dw PFA_DODEFER1
                 PFA_WLSCOPE:
00039d 005e          .dw EE_WLSCOPE
00039e 0bf4          .dw XT_EDEFERFETCH
00039f 0bfe          .dw XT_EDEFERSTORE
                 
                 ; wlscope, "wordlist scope" ( addr len -- addr' len' wid ), is a deferred word
                 ; which enables the AmForth application to choose the wordlist ( wid ) for the
                 ; new voc entry based on the input ( addr len ) string. The name of the new voc
                 ; entry ( addr' len' ) may be different from the input string. Note that all
                 ; created voc entry types pass through the wlscope mechanism. The default
                 ; wlscope action passes the input string to the output without modification and
                 ; uses get-current to select the wid.
                 .include "words/reveal.asm"
                 
                 ; Dictionary
                 ; makes an entry in a wordlist visible, if not already done.
                 VE_REVEAL:
0003a0 ff06          .dw $ff06
0003a1 6572
0003a2 6576
0003a3 6c61          .db "reveal"
0003a4 0396          .dw VE_HEAD
                     .set VE_HEAD = VE_REVEAL
                 XT_REVEAL:
0003a5 1c00          .dw DO_COLON
                 PFA_REVEAL:
0003a6 1c37          .dw XT_DOLITERAL
0003a7 0117          .dw COLON_SMUDGE+0
0003a8 1c73          .dw XT_FETCH
0003a9 1cb3          .dw XT_QDUP
0003aa 1c30          .dw XT_DOCONDBRANCH
0003ab 03b4          .dw PFA_REVEAL1
                 ;
0003ac 1c37          .dw XT_DOLITERAL
0003ad 0119          .dw COLON_SMUDGE+2
0003ae 1c73          .dw XT_FETCH		; ( NFA WID )
0003af 1f29          .dw XT_STOREE
                     ; prevent duplicate actions and cooperate with :noname
0003b0 1d4e          .dw XT_ZERO
0003b1 1c37          .dw XT_DOLITERAL
0003b2 0117          .dw COLON_SMUDGE+0
0003b3 1c7b          .dw XT_STORE
                 PFA_REVEAL1:
0003b4 1c1a          .dw XT_EXIT
                 .include "words/latest.asm"
                 
                 ; System Variable
                 ; system LATEST
                 VE_LATEST:
0003b5 ff06          .dw $ff06
0003b6 616c
0003b7 6574
0003b8 7473          .db "latest"
0003b9 03a0          .dw VE_HEAD
                     .set VE_HEAD = VE_LATEST
                 XT_LATEST:
0003ba 1c42          .dw PFA_DOVARIABLE
                 PFA_LATEST:
0003bb 011d          .dw ram_LATEST
                 
                 .dseg
00011d           ram_LATEST: .byte 2
                 .cseg
                 .include "words/does.asm"
                 
                 ; Compiler
                 ; organize the XT replacement to call other colon code
                 VE_DOES:
0003bc 0005          .dw $0005
0003bd 6f64
0003be 7365
0003bf 003e          .db "does>",0
0003c0 03b5          .dw VE_HEAD
                     .set VE_HEAD = VE_DOES
                 XT_DOES:
0003c1 1c00          .dw DO_COLON
                 PFA_DOES:
0003c2 0267          .dw XT_COMPILE
0003c3 03d4          .dw XT_DODOES
0003c4 0267          .dw XT_COMPILE  ; create a code snippet to be used in an embedded XT
0003c5 940e          .dw $940e       ; the address of this compiled
0003c6 0267          .dw XT_COMPILE  ; code will replace the XT of the 
0003c7 03c9          .dw DO_DODOES   ; word that CREATE created
0003c8 1c1a          .dw XT_EXIT     ; 
                 
                 DO_DODOES: ; ( -- PFA )
0003c9 939a
0003ca 938a          savetos
0003cb 01cb          movw tosl, wl
0003cc 9601          adiw tosl, 1
                     ; the following takes the address from a real uC-call
                 .if (pclen==3)
                 .endif
0003cd 917f          pop wh
0003ce 916f          pop wl
                 
0003cf 93bf          push XH
0003d0 93af          push XL
0003d1 01db          movw XL, wl
0003d2 940c 1c04     jmp_ DO_NEXT
                 
                 ; ( -- )
                 ; System
                 ; replace the XT written by CREATE to call the code that follows does>
                 ;VE_DODOES:
                 ;   .dw $ff07
                 ;   .db "(does>)"
                 ;   .set VE_HEAD = VE_DODOES
                 XT_DODOES:
0003d4 1c00          .dw DO_COLON
                 PFA_DODOES:
0003d5 1cf0          .dw XT_R_FROM
0003d6 1c37          .dw XT_DOLITERAL
0003d7 0119          .dw COLON_SMUDGE+2
0003d8 1c73          .dw XT_FETCH
0003d9 1f4d          .dw XT_FETCHE
0003da 0522          .dw XT_NFA2LFA
0003db 1e29          .dw XT_1PLUS   ; lfa>xt
                 
0003dc 1f61          .dw XT_STOREI
0003dd 1c1a          .dw XT_EXIT
                 .include "words/colon.asm"
                 
                 ; Compiler
                 ; create a named entry in the dictionary, XT is DO_COLON
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_COLON:
0003de ff01          .dw $ff01
0003df 003a          .db ":",0
0003e0 03bc          .dw VE_HEAD
                     .set VE_HEAD = VE_COLON
                 XT_COLON:
0003e1 1c00          .dw DO_COLON
                 PFA_COLON:
                 .endif
0003e2 0241          .dw XT_DOCREATE
0003e3 03ec          .dw XT_COLONNONAME
0003e4 1cd3          .dw XT_DROP
0003e5 1c1a          .dw XT_EXIT
                 .include "words/colon-noname.asm"
                 
                 ; Compiler
                 ; create an unnamed entry in the dictionary, XT is DO_COLON
                 VE_COLONNONAME:
0003e6 ff07          .dw $ff07
0003e7 6e3a
0003e8 6e6f
0003e9 6d61
0003ea 0065          .db ":noname",0
0003eb 03de          .dw VE_HEAD
                     .set VE_HEAD = VE_COLONNONAME
                 XT_COLONNONAME:
0003ec 1c00          .dw DO_COLON
                 PFA_COLONNONAME:
0003ed 05ff          .dw XT_DP
0003ee 1cab          .dw XT_DUP
0003ef 03ba          .dw XT_LATEST
0003f0 1c7b          .dw XT_STORE
                 
0003f1 0267          .dw XT_COMPILE
0003f2 1c00          .dw DO_COLON
                 
0003f3 0401          .dw XT_RBRACKET
0003f4 1c1a          .dw XT_EXIT
                 .include "words/semicolon.asm"
                 
                 ; Compiler
                 ; finish colon defintion, compiles (exit) and returns to interpret state 
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 
                 VE_SEMICOLON:
0003f5 0001          .dw $0001
0003f6 003b          .db $3b,0
0003f7 03e6          .dw VE_HEAD
                     .set VE_HEAD = VE_SEMICOLON
                 XT_SEMICOLON:
0003f8 1c00          .dw DO_COLON
                 PFA_SEMICOLON:
                 .endif
0003f9 0267          .dw XT_COMPILE
0003fa 1c1a          .dw XT_EXIT
0003fb 040a          .dw XT_LBRACKET
0003fc 03a5          .dw XT_REVEAL
0003fd 1c1a          .dw XT_EXIT
                 .include "words/right-bracket.asm"
                 
                 ; Compiler
                 ; enter compiler mode
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_RBRACKET:
0003fe ff01          .dw $ff01
0003ff 005d          .db "]",0
000400 03f5          .dw VE_HEAD
                     .set VE_HEAD = VE_RBRACKET
                 XT_RBRACKET:
000401 1c00          .dw DO_COLON
                 PFA_RBRACKET:
                 .endif
000402 1c37          .dw XT_DOLITERAL
000403 0001          .dw 1
000404 0595          .dw XT_STATE
000405 1c7b          .dw XT_STORE
000406 1c1a          .dw XT_EXIT
                 .include "words/left-bracket.asm"
                 
                 ; Compiler
                 ; enter interpreter mode
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_LBRACKET:
000407 0001          .dw $0001
000408 005b          .db "[",0
000409 03fe          .dw VE_HEAD
                     .set VE_HEAD = VE_LBRACKET
                 XT_LBRACKET:
00040a 1c00          .dw DO_COLON
                 PFA_LBRACKET:
                 .endif
00040b 1d4e          .dw XT_ZERO
00040c 0595          .dw XT_STATE
00040d 1c7b          .dw XT_STORE
00040e 1c1a          .dw XT_EXIT
                 .include "words/variable.asm"
                 
                 ; Compiler
                 ; create a dictionary entry for a variable and allocate 1 cell RAM
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 VE_VARIABLE:
00040f ff08          .dw $ff08
000410 6176
000411 6972
000412 6261
000413 656c          .db "variable"
000414 0407          .dw VE_HEAD
                     .set VE_HEAD = VE_VARIABLE
                 XT_VARIABLE:
000415 1c00          .dw DO_COLON
                 PFA_VARIABLE:
                 .endif
000416 0610          .dw XT_HERE
000417 0422          .dw XT_CONSTANT
000418 1c37          .dw XT_DOLITERAL
000419 0002          .dw 2
00041a 0619          .dw XT_ALLOT
00041b 1c1a          .dw XT_EXIT
                 .include "words/constant.asm"
                 
                 ; Compiler
                 ; create a constant in the dictionary
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 VE_CONSTANT:
00041c ff08          .dw $ff08
00041d 6f63
00041e 736e
00041f 6174
000420 746e          .db "constant"
000421 040f          .dw VE_HEAD
                     .set VE_HEAD = VE_CONSTANT
                 XT_CONSTANT:
000422 1c00          .dw DO_COLON
                 PFA_CONSTANT:
                 .endif
000423 0241          .dw XT_DOCREATE
000424 03a5          .dw XT_REVEAL
000425 0267          .dw XT_COMPILE
000426 1c42          .dw PFA_DOVARIABLE
000427 0272          .dw XT_COMMA
000428 1c1a          .dw XT_EXIT
                 .include "words/user.asm"
                 
                 ; Compiler
                 ; create a dictionary entry for a user variable at offset n
                 VE_USER:
000429 ff04          .dw $ff04
00042a 7375
00042b 7265          .db "user"
00042c 041c          .dw VE_HEAD
                     .set VE_HEAD = VE_USER
                 XT_USER:
00042d 1c00          .dw DO_COLON
                 PFA_USER:
00042e 0241          .dw XT_DOCREATE
00042f 03a5          .dw XT_REVEAL
                 
000430 0267          .dw XT_COMPILE
000431 1c52          .dw PFA_DOUSER
000432 0272          .dw XT_COMMA
000433 1c1a          .dw XT_EXIT
                 
                 .include "words/recurse.asm"
                 
                 ; Compiler
                 ; compile the XT of the word currently being defined into the dictionary
                 VE_RECURSE:
000434 0007          .dw $0007
000435 6572
000436 7563
000437 7372
000438 0065          .db "recurse",0
000439 0429          .dw VE_HEAD
                     .set VE_HEAD = VE_RECURSE
                 XT_RECURSE:
00043a 1c00          .dw DO_COLON
                 PFA_RECURSE:
00043b 03ba          .dw XT_LATEST
00043c 1c73          .dw XT_FETCH
00043d 0272          .dw XT_COMMA
00043e 1c1a          .dw XT_EXIT
                 .include "words/immediate.asm"
                 
                 ; Compiler
                 ; set immediate flag for the most recent word definition
                 VE_IMMEDIATE:
00043f ff09          .dw $ff09
000440 6d69
000441 656d
000442 6964
000443 7461
000444 0065          .db "immediate",0
000445 0434          .dw VE_HEAD
                     .set VE_HEAD = VE_IMMEDIATE
                 XT_IMMEDIATE:
000446 1c00          .dw DO_COLON
                 PFA_IMMEDIATE:
000447 04e3          .dw XT_GET_CURRENT
000448 1f4d          .dw XT_FETCHE
000449 1cab          .dw XT_DUP
00044a 1fba          .dw XT_FETCHI
00044b 1c37          .dw XT_DOLITERAL
00044c 7fff          .dw $7fff
00044d 1e0d          .dw XT_AND
00044e 1cbe          .dw XT_SWAP
00044f 1f61          .dw XT_STOREI
000450 1c1a          .dw XT_EXIT
                 
                 .include "words/bracketchar.asm"
                 
                 ; Tools
                 ; skip leading space delimites, place the first character of the word on the stack
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_BRACKETCHAR:
000451 0006          .dw $0006
000452 635b
000453 6168
000454 5d72          .db "[char]"
000455 043f          .dw VE_HEAD
                     .set VE_HEAD = VE_BRACKETCHAR
                 XT_BRACKETCHAR:
000456 1c00          .dw DO_COLON
                 PFA_BRACKETCHAR:
                 .endif
000457 0267          .dw XT_COMPILE
000458 1c37          .dw XT_DOLITERAL
000459 0933          .dw XT_CHAR
00045a 0272          .dw XT_COMMA
00045b 1c1a          .dw XT_EXIT
                 .include "words/abort-string.asm"
                 
                 ;C         i*x x1 --       R: j*x --      x1<>0
                 ;   POSTPONE IS" POSTPONE ?ABORT ; IMMEDIATE
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_ABORTQUOTE:
00045c 0006          .dw $0006
00045d 6261
00045e 726f
00045f 2274          .db "abort",'"'
000460 0451          .dw VE_HEAD
                     .set VE_HEAD = VE_ABORTQUOTE
                 XT_ABORTQUOTE:
000461 1c00          .dw DO_COLON
                 PFA_ABORTQUOTE:
                 .endif
000462 021e          .dw XT_SQUOTE
000463 0267          .dw XT_COMPILE
000464 0474          .dw XT_QABORT
000465 1c1a          .DW XT_EXIT
                 .include "words/abort.asm"
                 
                 ; Exceptions
                 ; send an exception -1
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_ABORT:
000466 ff05          .dw $ff05
000467 6261
000468 726f
000469 0074          .db "abort",0
00046a 045c          .dw VE_HEAD
                     .set VE_HEAD = VE_ABORT
                 XT_ABORT:
00046b 1c00          .dw DO_COLON
                 PFA_ABORT:
                 .endif
00046c 1c37          .dw XT_DOLITERAL
00046d ffff          .dw -1
00046e 0890          .dw XT_THROW
                 .include "words/q-abort.asm"
                 
                 ;   ROT IF ITYPE ABORT THEN 2DROP ;
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_QABORT:
00046f ff06          .dw $ff06
000470 613f
000471 6f62
000472 7472          .db "?abort"
000473 0466          .dw VE_HEAD
                     .set VE_HEAD = VE_QABORT
                 XT_QABORT:
000474 1c00          .dw DO_COLON
                 PFA_QABORT:
                 
                 .endif
000475 1cdb
000476 1c30              .DW XT_ROT,XT_DOCONDBRANCH
000477 047a              DEST(QABO1)
000478 07f7
000479 046b              .DW XT_ITYPE,XT_ABORT
00047a 05b9
00047b 1c1a      QABO1:  .DW XT_2DROP,XT_EXIT
                 
                 .include "words/get-stack.asm"
                 
                 ; Tools
                 ; Get a stack from EEPROM
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_GET_STACK:
00047c ff09          .dw $ff09
00047d 6567
00047e 2d74
00047f 7473
000480 6361
000481 006b          .db "get-stack",0
000482 046f          .dw VE_HEAD
                     .set VE_HEAD = VE_GET_STACK
                 XT_GET_STACK:
000483 1c00          .dw DO_COLON
                 PFA_N_FETCH_E:
                 .endif
000484 1cab          .dw XT_DUP
000485 05a8          .dw XT_CELLPLUS
000486 1cbe          .dw XT_SWAP
000487 1f4d          .dw XT_FETCHE
000488 1cab          .dw XT_DUP
000489 1cf9          .dw XT_TO_R
00048a 1d4e          .dw XT_ZERO
00048b 1cbe          .dw XT_SWAP    ; go from bigger to smaller addresses
00048c 0331          .dw XT_QDOCHECK
00048d 1c30          .dw XT_DOCONDBRANCH
00048e 049a          DEST(PFA_N_FETCH_E2)
00048f 1e89          .dw XT_DODO
                 PFA_N_FETCH_E1:
                     ; ( ee-addr )
000490 1e9a          .dw XT_I
000491 1e2f          .dw XT_1MINUS
000492 05a2          .dw XT_CELLS ; ( -- ee-addr i*2 )
000493 1cc9          .dw XT_OVER  ; ( -- ee-addr i*2 ee-addr )
000494 1d97          .dw XT_PLUS  ; ( -- ee-addr ee-addr+i
000495 1f4d          .dw XT_FETCHE ;( -- ee-addr item_i )
000496 1cbe          .dw XT_SWAP   ;( -- item_i ee-addr )
000497 1d45          .dw XT_TRUE  ; shortcut for -1
000498 1ea8          .dw XT_DOPLUSLOOP
000499 0490          DEST(PFA_N_FETCH_E1)
                 PFA_N_FETCH_E2:
00049a 05b9          .dw XT_2DROP
00049b 1cf0          .dw XT_R_FROM
00049c 1c1a          .dw XT_EXIT
                 
                 .include "words/set-stack.asm"
                 
                 ; Tools
                 ; Write a stack to EEPROM
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SET_STACK:
00049d ff09          .dw $ff09
00049e 6573
00049f 2d74
0004a0 7473
0004a1 6361
0004a2 006b          .db "set-stack",0
0004a3 047c          .dw VE_HEAD
                     .set VE_HEAD = VE_SET_STACK
                 XT_SET_STACK:
0004a4 1c00          .dw DO_COLON
                 PFA_SET_STACK:
                 .endif
0004a5 05b0          .dw XT_2DUP
0004a6 1f29          .dw XT_STOREE ; ( -- i_n .. i_0 n e-addr )
0004a7 1cbe          .dw XT_SWAP    
0004a8 1d4e          .dw XT_ZERO
0004a9 0331          .dw XT_QDOCHECK
0004aa 1c30          .dw XT_DOCONDBRANCH
0004ab 04b2          DEST(PFA_SET_STACK2)
0004ac 1e89          .dw XT_DODO
                 PFA_SET_STACK1:
0004ad 05a8          .dw XT_CELLPLUS ; ( -- i_x e-addr )
0004ae 05c1          .dw XT_TUCK      ; ( -- e-addr i_x e-addr
0004af 1f29          .dw XT_STOREE
0004b0 1eb7          .dw XT_DOLOOP
0004b1 04ad          DEST(PFA_SET_STACK1)
                 PFA_SET_STACK2:
0004b2 1cd3          .dw XT_DROP
0004b3 1c1a          .dw XT_EXIT
                 
                 .include "words/map-stack.asm"
                 
                 ; Tools
                 ; Iterate over a stack
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_MAPSTACK:
0004b4 ff09          .dw $ff09
0004b5 616d
0004b6 2d70
0004b7 7473
0004b8 6361
0004b9 006b          .db "map-stack",0
0004ba 049d          .dw VE_HEAD
                     .set VE_HEAD = VE_MAPSTACK
                 XT_MAPSTACK:
0004bb 1c00          .dw DO_COLON
                 PFA_MAPSTACK:
                 .endif
0004bc 1cab          .dw XT_DUP
0004bd 05a8          .dw XT_CELLPLUS
0004be 1cbe          .dw XT_SWAP
0004bf 1f4d          .dw XT_FETCHE
0004c0 05a2          .dw XT_CELLS
0004c1 0d9a          .dw XT_BOUNDS
0004c2 0331          .dw XT_QDOCHECK
0004c3 1c30          .dw XT_DOCONDBRANCH
0004c4 04d8          DEST(PFA_MAPSTACK3)
0004c5 1e89          .dw XT_DODO
                 PFA_MAPSTACK1:
0004c6 1e9a            .dw XT_I
0004c7 1f4d            .dw XT_FETCHE   ; -- i*x XT id
0004c8 1cbe            .dw XT_SWAP
0004c9 1cf9            .dw XT_TO_R
0004ca 1d02            .dw XT_R_FETCH
0004cb 1c24            .dw XT_EXECUTE  ; i*x id -- j*y true | i*x false
0004cc 1cb3            .dw XT_QDUP
0004cd 1c30            .dw XT_DOCONDBRANCH
0004ce 04d3            DEST(PFA_MAPSTACK2)
0004cf 1cf0               .dw XT_R_FROM
0004d0 1cd3               .dw XT_DROP
0004d1 1ec2               .dw XT_UNLOOP
0004d2 1c1a               .dw XT_EXIT
                 PFA_MAPSTACK2:
0004d3 1cf0            .dw XT_R_FROM
0004d4 1c37            .dw XT_DOLITERAL
0004d5 0002            .dw 2
0004d6 1ea8            .dw XT_DOPLUSLOOP
0004d7 04c6            DEST(PFA_MAPSTACK1)
                 PFA_MAPSTACK3:
0004d8 1cd3          .dw XT_DROP
0004d9 1d4e          .dw XT_ZERO
0004da 1c1a          .dw XT_EXIT
                 
                 ;
                 ; : map-stack ( i*x XT e-addr -- j*y )
                 ;     dup cell+ swap @e cells bounds ?do 
                 ;       ( -- i*x XT )
                 ;       i @e swap >r r@ execute
                 ;       ?dup if r> drop unloop exit then
                 ;       r>
                 ;     2 +loop drop 0
                 ;
                 .include "words/get-current.asm"
                 
                 ; Search Order
                 ; get the wid of the current compilation word list
                 VE_GET_CURRENT:
0004db ff0b          .dw $ff0b
0004dc 6567
0004dd 2d74
0004de 7563
0004df 7272
0004e0 6e65
0004e1 0074          .db "get-current",0
0004e2 04b4          .dw VE_HEAD
                     .set VE_HEAD = VE_GET_CURRENT
                 XT_GET_CURRENT:
0004e3 1c00          .dw DO_COLON
                 PFA_GET_CURRENT:
0004e4 1c37          .dw XT_DOLITERAL
0004e5 003e          .dw EE_CURRENT
0004e6 1f4d          .dw XT_FETCHE
0004e7 1c1a          .dw XT_EXIT
                 .include "words/get-order.asm"
                 
                 ; Search Order
                 ; Get the current search order word list
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_GET_ORDER:
0004e8 ff09          .dw $ff09
0004e9 6567
0004ea 2d74
0004eb 726f
0004ec 6564
0004ed 0072          .db "get-order",0
0004ee 04db          .dw VE_HEAD
                     .set VE_HEAD = VE_GET_ORDER
                 XT_GET_ORDER:
0004ef 1c00          .dw DO_COLON
                 PFA_GET_ORDER:
                 .endif
0004f0 1c37          .dw XT_DOLITERAL
0004f1 0042          .dw CFG_ORDERLISTLEN
0004f2 0483          .dw XT_GET_STACK
0004f3 1c1a          .dw XT_EXIT
                 
                 .include "words/compare.asm"
                 
                 ; String
                 ; compares two strings in RAM
                 VE_COMPARE:
0004f4 ff07          .dw $ff07
0004f5 6f63
0004f6 706d
0004f7 7261
0004f8 0065          .db "compare",0
0004f9 04e8          .dw VE_HEAD
                     .set VE_HEAD = VE_COMPARE
                 XT_COMPARE:
0004fa 04fb          .dw PFA_COMPARE
                 PFA_COMPARE:
0004fb 93bf          push xh
0004fc 93af          push xl
0004fd 018c          movw temp0, tosl
0004fe 9189
0004ff 9199          loadtos
000500 01dc          movw xl, tosl
000501 9189
000502 9199          loadtos
000503 019c          movw temp2, tosl
000504 9189
000505 9199          loadtos
000506 01fc          movw zl, tosl
                 PFA_COMPARE_LOOP:
000507 90ed          ld temp4, X+
000508 90f1          ld temp5, Z+
000509 14ef          cp temp4, temp5
00050a f451          brne PFA_COMPARE_NOTEQUAL
00050b 950a          dec temp0
00050c f019          breq PFA_COMPARE_ENDREACHED2
00050d 952a          dec temp2
00050e f7c1          brne PFA_COMPARE_LOOP
00050f c001          rjmp PFA_COMPARE_ENDREACHED
                 PFA_COMPARE_ENDREACHED2:
000510 952a          dec temp2
                 PFA_COMPARE_ENDREACHED:
000511 2b02          or temp0, temp2
000512 f411          brne PFA_COMPARE_CHECKLASTCHAR
000513 2788          clr tosl
000514 c002          rjmp PFA_COMPARE_DONE
                 PFA_COMPARE_CHECKLASTCHAR:
                 PFA_COMPARE_NOTEQUAL:
000515 ef8f          ser tosl
000516 c000          rjmp PFA_COMPARE_DONE
                 
                 PFA_COMPARE_DONE:
000517 2f98          mov tosh, tosl
000518 91af          pop xl
000519 91bf          pop xh
00051a 940c 1c04     jmp_ DO_NEXT
                 .include "words/nfa2lfa.asm"
                 
                 ; System
                 ; get the link field address from the name field address
                 VE_NFA2LFA:
00051c ff07         .dw $ff07
00051d 666e
00051e 3e61
00051f 666c
000520 0061         .db "nfa>lfa",0
000521 04f4         .dw VE_HEAD
                    .set VE_HEAD = VE_NFA2LFA
                 XT_NFA2LFA:
000522 1c00          .dw DO_COLON
                 PFA_NFA2LFA:
000523 0cb2          .dw XT_NAME2STRING
000524 1e29          .dw XT_1PLUS
000525 1dfe          .dw XT_2SLASH
000526 1d97          .dw XT_PLUS
000527 1c1a          .dw XT_EXIT
                 
                 .include "words/environment.asm"
                 
                 ; System Value
                 ; word list identifier of the environmental search list
                 VE_ENVIRONMENT:
000528 ff0b          .dw $ff0b
000529 6e65
00052a 6976
00052b 6f72
00052c 6d6e
00052d 6e65
00052e 0074          .db "environment",0
00052f 051c          .dw VE_HEAD
                     .set VE_HEAD = VE_ENVIRONMENT
                 XT_ENVIRONMENT:
000530 1c42          .dw PFA_DOVARIABLE
                 PFA_ENVIRONMENT:
000531 003a          .dw EE_ENVIRONMENT
                 .include "words/env-wordlists.asm"
                 
                 ; Environment
                 ; maximum number of wordlists in the dictionary search order
                 VE_ENVWORDLISTS:
000532 ff09          .dw $ff09
000533 6f77
000534 6472
000535 696c
000536 7473
000537 0073          .db "wordlists",0
000538 0000          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENVWORDLISTS
                 XT_ENVWORDLISTS:
000539 1c00          .dw DO_COLON
                 PFA_ENVWORDLISTS:
00053a 1c37          .dw XT_DOLITERAL
00053b 0008          .dw NUMWORDLISTS
00053c 1c1a          .dw XT_EXIT
                 .include "words/env-slashpad.asm"
                 
                 ; Environment
                 ; Size of the PAD buffer in bytes
                 VE_ENVSLASHPAD:
00053d ff04          .dw $ff04
00053e 702f
00053f 6461          .db "/pad"
000540 0532          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENVSLASHPAD
                 XT_ENVSLASHPAD:
000541 1c00          .dw DO_COLON
                 PFA_ENVSLASHPAD:
000542 1e7b          .dw XT_SP_FETCH
000543 05d5          .dw XT_PAD
000544 1d8d          .dw XT_MINUS
000545 1c1a          .dw XT_EXIT
                 .include "words/env-slashhold.asm"
                 
                 ; Environment
                 ; size of the pictured numeric output buffer in bytes
                 VE_ENVSLASHHOLD:
000546 ff05          .dw $ff05
000547 682f
000548 6c6f
000549 0064          .db "/hold",0
00054a 053d          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENVSLASHHOLD
                 XT_ENVSLASHHOLD:
00054b 1c00          .dw DO_COLON
                 PFA_ENVSLASHHOLD:
00054c 05d5          .dw XT_PAD
00054d 0610          .dw XT_HERE
00054e 1d8d          .dw XT_MINUS
00054f 1c1a          .dw XT_EXIT
                 .include "words/env-forthname.asm"
                 
                 ; Environment
                 ; flash address of the amforth name string
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_ENV_FORTHNAME:
000550 ff0a          .dw $ff0a
000551 6f66
000552 7472
000553 2d68
000554 616e
000555 656d          .db "forth-name"
000556 0546          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENV_FORTHNAME
                 XT_ENV_FORTHNAME:
000557 1c00          .dw DO_COLON
                 PFA_EN_FORTHNAME:
000558 07c4          .dw XT_DOSLITERAL
000559 0007          .dw 7
                 .endif
00055a 6d61
00055b 6f66
00055c 7472
../../common\words/env-forthname.asm(22): warning: .cseg .db misalignment - padding zero byte
00055d 0068          .db "amforth"
                 .if cpu_msp430==1
                 .endif
00055e 1c1a          .dw XT_EXIT
                 .include "words/env-forthversion.asm"
                 
                 ; Environment
                 ; version number of amforth
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_ENV_FORTHVERSION:
00055f ff07          .dw $ff07
000560 6576
000561 7372
000562 6f69
000563 006e          .db "version",0
000564 0550          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENV_FORTHVERSION
                 XT_ENV_FORTHVERSION:
000565 1c00          .dw DO_COLON
                 PFA_EN_FORTHVERSION:
                 .endif
000566 1c37          .dw XT_DOLITERAL
000567 003b          .dw 59
000568 1c1a          .dw XT_EXIT
                 .include "words/env-cpu.asm"
                 
                 ; Environment
                 ; flash address of the CPU identification string
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_ENV_CPU:
000569 ff03          .dw $ff03
00056a 7063
00056b 0075          .db "cpu",0
00056c 055f          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENV_CPU
                 XT_ENV_CPU:
00056d 1c00          .dw DO_COLON
                 PFA_EN_CPU:
00056e 1c37          .dw XT_DOLITERAL
00056f 0031          .dw mcu_name
000570 0823          .dw XT_ICOUNT
                 .endif
000571 1c1a          .dw XT_EXIT
                 .include "words/env-mcuinfo.asm"
                 
                 ; Environment
                 ; flash address of some CPU specific parameters
                 VE_ENV_MCUINFO:
000572 ff08          .dw $ff08
000573 636d
000574 2d75
000575 6e69
000576 6f66          .db "mcu-info"
000577 0569          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENV_MCUINFO
                 XT_ENV_MCUINFO:
000578 1c00          .dw DO_COLON
                 PFA_EN_MCUINFO:
000579 1c37          .dw XT_DOLITERAL
00057a 002d          .dw mcu_info
00057b 1c1a          .dw XT_EXIT
                 .include "words/env-usersize.asm"
                 
                 ; Environment
                 ; size of the USER area in bytes
                 VE_ENVUSERSIZE:
00057c ff05          .dw $ff05
00057d 752f
00057e 6573
00057f 0072          .db "/user",0
000580 0572          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENVUSERSIZE
                 XT_ENVUSERSIZE:
000581 1c00          .dw DO_COLON
                 PFA_ENVUSERSIZE:
000582 1c37          .dw XT_DOLITERAL
000583 0026          .dw SYSUSERSIZE + APPUSERSIZE
000584 1c1a          .dw XT_EXIT
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/f_cpu.asm"
                 
                 ; System
                 ; put the cpu frequency in Hz on stack
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_F_CPU:
000585 ff05          .dw $ff05
000586 5f66
000587 7063
000588 0075          .db "f_cpu",0
000589 0528          .dw VE_HEAD
                     .set VE_HEAD = VE_F_CPU
                 XT_F_CPU:
00058a 1c00          .dw DO_COLON
                 PFA_F_CPU:
                 .endif
00058b 1c37          .dw XT_DOLITERAL
00058c 1200          .dw (F_CPU % 65536)
00058d 1c37          .dw XT_DOLITERAL
00058e 007a          .dw (F_CPU / 65536)
00058f 1c1a          .dw XT_EXIT
                 .include "words/state.asm"
                 
                 ; System Variable
                 ; system state
                 VE_STATE:
000590 ff05          .dw $ff05
000591 7473
000592 7461
000593 0065          .db "state",0
000594 0585          .dw VE_HEAD
                     .set VE_HEAD = VE_STATE
                 XT_STATE:
000595 1c42          .dw PFA_DOVARIABLE
                 PFA_STATE:
000596 011f          .dw ram_state
                 
                 .dseg
00011f           ram_state: .byte 2
                 .include "words/base.asm"
                 
                 ; Numeric IO
                 ; location of the cell containing the number conversion radix
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_BASE:
000597 ff04          .dw $ff04
000598 6162
000599 6573          .db "base"
00059a 0590          .dw VE_HEAD
                     .set VE_HEAD = VE_BASE
                 XT_BASE:
00059b 1c52          .dw PFA_DOUSER
                 PFA_BASE:
                 .endif
00059c 000c          .dw USER_BASE
                 
                 .include "words/cells.asm"
                 
                 ; Arithmetics
                 ; n2 is the size in address units of n1 cells
                 VE_CELLS:
00059d ff05          .dw $ff05
00059e 6563
00059f 6c6c
0005a0 0073          .db "cells",0
0005a1 0597          .dw VE_HEAD
                     .set VE_HEAD = VE_CELLS
                 XT_CELLS:
0005a2 1e06          .dw PFA_2STAR
                 .include "words/cellplus.asm"
                 
                 ; Arithmetics
                 ; add the size of an address-unit to a-addr1
                 VE_CELLPLUS:
0005a3 ff05          .dw $ff05
0005a4 6563
0005a5 6c6c
0005a6 002b          .db "cell+",0
0005a7 059d          .dw VE_HEAD
                     .set VE_HEAD = VE_CELLPLUS
                 XT_CELLPLUS:
0005a8 05a9          .dw PFA_CELLPLUS
                 PFA_CELLPLUS:
0005a9 9602          adiw tosl, CELLSIZE
0005aa 940c 1c04     jmp_ DO_NEXT
                 
                 .include "words/2dup.asm"
                 
                 ; Stack
                 ; Duplicate the 2 top elements
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_2DUP:
0005ac ff04          .dw $ff04
0005ad 6432
0005ae 7075          .db "2dup"
0005af 05a3          .dw VE_HEAD
                     .set VE_HEAD = VE_2DUP
                 XT_2DUP:
0005b0 1c00          .dw DO_COLON
                 PFA_2DUP:
                 .endif
                 
0005b1 1cc9          .dw XT_OVER
0005b2 1cc9          .dw XT_OVER
0005b3 1c1a          .dw XT_EXIT
                 .include "words/2drop.asm"
                 
                 ; Stack
                 ; Remove the 2 top elements
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_2DROP:
0005b4 ff05          .dw $ff05
0005b5 6432
0005b6 6f72
0005b7 0070          .db "2drop",0
0005b8 05ac          .dw VE_HEAD
                     .set VE_HEAD = VE_2DROP
                 XT_2DROP:
0005b9 1c00          .dw DO_COLON
                 PFA_2DROP:
                 .endif
0005ba 1cd3          .dw XT_DROP
0005bb 1cd3          .dw XT_DROP
0005bc 1c1a          .dw XT_EXIT
                 
                 .include "words/tuck.asm"
                 
                 ; Stack
                 ; Copy the first (top) stack item below the second stack item. 
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_TUCK:
0005bd ff04          .dw $ff04
0005be 7574
0005bf 6b63          .db "tuck"
0005c0 05b4          .dw VE_HEAD
                     .set VE_HEAD = VE_TUCK
                 XT_TUCK:
0005c1 1c00          .dw DO_COLON
                 PFA_TUCK:
                 .endif
0005c2 1cbe          .dw XT_SWAP
0005c3 1cc9          .dw XT_OVER
0005c4 1c1a          .dw XT_EXIT
                 
                 .include "words/to-in.asm"
                 
                 ; System Variable
                 ; pointer to current read position in input buffer
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_TO_IN:
0005c5 ff03          .dw $ff03
0005c6 693e
0005c7 006e          .db ">in",0
0005c8 05bd          .dw VE_HEAD
                     .set VE_HEAD = VE_TO_IN
                 XT_TO_IN:
0005c9 1c52          .dw PFA_DOUSER
                 PFA_TO_IN:
                 .endif
0005ca 0018          .dw USER_TO_IN
                 .include "words/sharptib.asm"
                 
                 ; System Variable
                 ; variable holding the number of characters in TIB
                 VE_NUMBERTIB:
0005cb ff04          .dw $ff04
0005cc 7423
0005cd 6269          .db "#tib"
0005ce 05c5          .dw VE_HEAD
                     .set VE_HEAD  = VE_NUMBERTIB
                 XT_NUMBERTIB:
0005cf 1c42          .dw PFA_DOVARIABLE
                 PFA_NUMBERTIB:
0005d0 0121          .dw ram_sharptib
                 
                 .dseg
000121           ram_sharptib: .byte 2
                 .cseg
                  
                 .include "words/pad.asm"
                 
                 ; System Variable
                 ; Address of the temporary scratch buffer.
                 VE_PAD:
0005d1 ff03          .dw $ff03
0005d2 6170
0005d3 0064          .db "pad",0
0005d4 05cb          .dw VE_HEAD
                     .set VE_HEAD = VE_PAD
                 XT_PAD:
0005d5 1c00          .dw DO_COLON
                 PFA_PAD:
0005d6 0610          .dw XT_HERE
0005d7 1c37          .dw XT_DOLITERAL
0005d8 0064          .dw 100
0005d9 1d97          .dw XT_PLUS
0005da 1c1a          .dw XT_EXIT
                 .include "words/emit.asm"
                 
                 ; Character IO
                 ; fetch the emit vector and execute it. should emit a character from TOS
                 VE_EMIT:
0005db ff04          .dw $ff04
0005dc 6d65
0005dd 7469          .db "emit"
0005de 05d1          .dw VE_HEAD
                     .set VE_HEAD = VE_EMIT
                 XT_EMIT:
0005df 0c53          .dw PFA_DODEFER1
                 PFA_EMIT:
0005e0 000e          .dw USER_EMIT
0005e1 0c1c          .dw XT_UDEFERFETCH
0005e2 0c28          .dw XT_UDEFERSTORE
                 .include "words/emitq.asm"
                 
                 ; Character IO
                 ; fetch emit? vector and execute it. should return the ready-to-send condition
                 VE_EMITQ:
0005e3 ff05          .dw $ff05
0005e4 6d65
0005e5 7469
0005e6 003f          .db "emit?",0
0005e7 05db          .dw VE_HEAD
                     .set VE_HEAD = VE_EMITQ
                 XT_EMITQ:
0005e8 0c53          .dw PFA_DODEFER1
                 PFA_EMITQ:
0005e9 0010          .dw USER_EMITQ
0005ea 0c1c          .dw XT_UDEFERFETCH
0005eb 0c28          .dw XT_UDEFERSTORE
                 .include "words/key.asm"
                 
                 ; Character IO
                 ; fetch key vector and execute it, should leave a single character on TOS
                 VE_KEY:
0005ec ff03          .dw $ff03
0005ed 656b
0005ee 0079          .db "key",0
0005ef 05e3          .dw VE_HEAD
                     .set VE_HEAD = VE_KEY
                 XT_KEY:
0005f0 0c53          .dw PFA_DODEFER1
                 PFA_KEY:
0005f1 0012          .dw USER_KEY
0005f2 0c1c          .dw XT_UDEFERFETCH
0005f3 0c28          .dw XT_UDEFERSTORE
                 .include "words/keyq.asm"
                 
                 ; Character IO
                 ; fetch key? vector and execute it. should turn on key sender, if it is disabled/stopped
                 VE_KEYQ:
0005f4 ff04          .dw $ff04
0005f5 656b
0005f6 3f79          .db "key?"
0005f7 05ec          .dw VE_HEAD
                     .set VE_HEAD = VE_KEYQ
                 XT_KEYQ:
0005f8 0c53          .dw PFA_DODEFER1
                 PFA_KEYQ:
0005f9 0014          .dw USER_KEYQ
0005fa 0c1c          .dw XT_UDEFERFETCH
0005fb 0c28          .dw XT_UDEFERSTORE
                 
                 .include "words/dp.asm"
                 
                 ; System Value
                 ; address of the next free dictionary cell
                 VE_DP:
0005fc ff02          .dw $ff02
0005fd 7064          .db "dp"
0005fe 05f4          .dw VE_HEAD
                     .set VE_HEAD = VE_DP
                 XT_DP:
0005ff 1c69          .dw PFA_DOVALUE1
                 PFA_DP:
000600 0030          .dw EE_DP
000601 0bf4          .dw XT_EDEFERFETCH
000602 0bfe          .dw XT_EDEFERSTORE
                 .include "words/ehere.asm"
                 
                 ; System Value
                 ; address of the next free address in eeprom
                 VE_EHERE:
000603 ff05          .dw $ff05
000604 6865
000605 7265
000606 0065          .db "ehere",0
000607 05fc          .dw VE_HEAD
                     .set VE_HEAD = VE_EHERE
                 XT_EHERE:
000608 1c69          .dw PFA_DOVALUE1
                 PFA_EHERE:
000609 0034          .dw EE_EHERE
00060a 0bf4          .dw XT_EDEFERFETCH
00060b 0bfe          .dw XT_EDEFERSTORE
                 .include "words/here.asm"
                 
                 ; System Value
                 ; address of the next free data space (RAM) cell
                 VE_HERE:
00060c ff04          .dw $ff04
00060d 6568
00060e 6572          .db "here"
00060f 0603          .dw VE_HEAD
                     .set VE_HEAD = VE_HERE
                 XT_HERE:
000610 1c69          .dw PFA_DOVALUE1
                 PFA_HERE:
000611 0032          .dw EE_HERE
000612 0bf4          .dw XT_EDEFERFETCH
000613 0bfe          .dw XT_EDEFERSTORE
                 .include "words/allot.asm"
                 
                 ; System
                 ; allocate or release memory in RAM
                 VE_ALLOT:
000614 ff05          .dw $ff05
000615 6c61
000616 6f6c
000617 0074          .db "allot",0
000618 060c          .dw VE_HEAD
                     .set VE_HEAD = VE_ALLOT
                 XT_ALLOT:
000619 1c00          .dw DO_COLON
                 PFA_ALLOT:
00061a 0610          .dw XT_HERE
00061b 1d97          .dw XT_PLUS
00061c 0bd9          .dw XT_DOTO
00061d 0611          .dw PFA_HERE
00061e 1c1a          .dw XT_EXIT
                 
                 .include "words/bin.asm"
                 
                 ; Numeric IO
                 ; set base for numeric conversion to 10
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_BIN:
00061f ff03          .dw $ff03
000620 6962
000621 006e          .db "bin",0
000622 0614          .dw VE_HEAD
                     .set VE_HEAD = VE_BIN
                 XT_BIN:
000623 1c00          .dw DO_COLON
                 PFA_BIN:
                 .endif
000624 1c37          .dw XT_DOLITERAL
000625 0002          .dw 2
000626 059b          .dw XT_BASE
000627 1c7b          .dw XT_STORE
000628 1c1a          .dw XT_EXIT
                 .include "words/decimal.asm"
                 
                 ; Numeric IO
                 ; set base for numeric conversion to 10
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DECIMAL:
000629 ff07          .dw $ff07
00062a 6564
00062b 6963
00062c 616d
00062d 006c          .db "decimal",0
00062e 061f          .dw VE_HEAD
                     .set VE_HEAD = VE_DECIMAL
                 XT_DECIMAL:
00062f 1c00          .dw DO_COLON
                 PFA_DECIMAL:
                 .endif
000630 1c37          .dw XT_DOLITERAL
000631 000a          .dw 10
000632 059b          .dw XT_BASE
000633 1c7b          .dw XT_STORE
000634 1c1a          .dw XT_EXIT
                 .include "words/hex.asm"
                 
                 ; Numeric IO
                 ; set base for numeric conversion to 10
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_HEX:
000635 ff03          .dw $ff03
000636 6568
000637 0078          .db "hex",0
000638 0629          .dw VE_HEAD
                     .set VE_HEAD = VE_HEX
                 XT_HEX:
000639 1c00          .dw DO_COLON
                 PFA_HEX:
                 .endif
00063a 1c37          .dw XT_DOLITERAL
00063b 0010          .dw 16
00063c 059b          .dw XT_BASE
00063d 1c7b          .dw XT_STORE
00063e 1c1a          .dw XT_EXIT
                 .include "words/bl.asm"
                 
                 ; Character IO
                 ; put ascii code of the blank to the stack
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_BL:
00063f ff02          .dw $ff02
000640 6c62          .db "bl"
000641 0635          .dw VE_HEAD
                     .set VE_HEAD = VE_BL
                 XT_BL:
000642 1c42          .dw PFA_DOVARIABLE
                 PFA_BL:
                 .endif
000643 0020          .dw 32
                 
                 .include "words/turnkey.asm"
                 
                 ; System Value
                 ; Deferred action during startup/reset
                 VE_TURNKEY:
000644 ff07          .dw $ff07
000645 7574
000646 6e72
000647 656b
000648 0079          .db "turnkey",0
000649 063f          .dw VE_HEAD
                     .set VE_HEAD = VE_TURNKEY
                 XT_TURNKEY:
00064a 0c53          .dw PFA_DODEFER1
                 PFA_TURNKEY:
00064b 0036          .dw EE_TURNKEY
00064c 0bf4          .dw XT_EDEFERFETCH
00064d 0bfe          .dw XT_EDEFERSTORE
                 
                 .include "words/slashmod.asm"
                 
                 ; Arithmetics
                 ; signed division n1/n2 with remainder and quotient
                 VE_SLASHMOD:
00064e ff04          .dw $ff04
00064f 6d2f
000650 646f          .db "/mod"
000651 0644          .dw VE_HEAD
                     .set VE_HEAD = VE_SLASHMOD
                 XT_SLASHMOD:
000652 0653          .dw PFA_SLASHMOD
                 PFA_SLASHMOD:
000653 019c          movw temp2, tosl
                     
000654 9109          ld temp0, Y+
000655 9119          ld temp1, Y+
                 
000656 2f41          mov	temp6,temp1	;move dividend High to sign register
000657 2743          eor	temp6,temp3	;xor divisor High with sign register
000658 ff17          sbrs	temp1,7	;if MSB in dividend set
000659 c004          rjmp	PFA_SLASHMOD_1
00065a 9510          com	temp1		;    change sign of dividend
00065b 9500          com	temp0		
00065c 5f0f          subi	temp0,low(-1)
00065d 4f1f          sbci	temp1,high(-1)
                 PFA_SLASHMOD_1:	
00065e ff37          sbrs	temp3,7	;if MSB in divisor set
00065f c004          rjmp	PFA_SLASHMOD_2
000660 9530          com	temp3		;    change sign of divisor
000661 9520          com	temp2		
000662 5f2f          subi	temp2,low(-1)
000663 4f3f          sbci	temp3,high(-1)
000664 24ee      PFA_SLASHMOD_2:	clr	temp4	;clear remainder Low byte
000665 18ff          sub	temp5,temp5;clear remainder High byte and carry
000666 e151          ldi	temp7,17	;init loop counter
                 
000667 1f00      PFA_SLASHMOD_3:	rol	temp0		;shift left dividend
000668 1f11          rol	temp1
000669 955a          dec	temp7		;decrement counter
00066a f439          brne	PFA_SLASHMOD_5		;if done
00066b ff47          sbrs	temp6,7		;    if MSB in sign register set
00066c c004          rjmp	PFA_SLASHMOD_4
00066d 9510          com	temp1	;        change sign of result
00066e 9500          com	temp0
00066f 5f0f          subi	temp0,low(-1)
000670 4f1f          sbci	temp1,high(-1)
000671 c00b      PFA_SLASHMOD_4:	rjmp PFA_SLASHMODmod_done			;    return
000672 1cee      PFA_SLASHMOD_5:	rol	temp4	;shift dividend into remainder
000673 1cff          rol	temp5
000674 1ae2          sub	temp4,temp2	;remainder = remainder - divisor
000675 0af3          sbc	temp5,temp3	;
000676 f420          brcc	PFA_SLASHMOD_6		;if result negative
000677 0ee2          add	temp4,temp2	;    restore remainder
000678 1ef3          adc	temp5,temp3
000679 9488          clc			;    clear carry to be shifted into result
00067a cfec          rjmp	PFA_SLASHMOD_3		;else
00067b 9408      PFA_SLASHMOD_6:	sec			;    set carry to be shifted into result
00067c cfea          rjmp	PFA_SLASHMOD_3
                 
                 PFA_SLASHMODmod_done:
                     ; put remainder on stack
00067d 92fa          st -Y,temp5
00067e 92ea          st -Y,temp4
                 
                     ; put quotient on stack
00067f 01c8          movw tosl, temp0
000680 940c 1c04     jmp_ DO_NEXT
                 .include "words/uslashmod.asm"
                 
                 ; Arithmetics
                 ; unsigned division with remainder
                 VE_USLASHMOD:
000682 ff05          .dw $ff05
000683 2f75
000684 6f6d
000685 0064          .db "u/mod",0
000686 064e          .dw VE_HEAD
                     .set VE_HEAD = VE_USLASHMOD
                 XT_USLASHMOD:
000687 1c00          .dw DO_COLON
                 PFA_USLASHMOD:
000688 1cf9          .dw XT_TO_R
000689 1d4e          .dw XT_ZERO
00068a 1cf0          .dw XT_R_FROM
00068b 1dbc          .dw XT_UMSLASHMOD
00068c 1c1a          .dw XT_EXIT
                 .include "words/negate.asm"
                 
                 ; Logic
                 ; 2-complement
                 VE_NEGATE:
00068d ff06          .dw $ff06
00068e 656e
00068f 6167
000690 6574          .db "negate"
000691 0682          .dw VE_HEAD
                     .set VE_HEAD = VE_NEGATE
                 XT_NEGATE:
000692 1c00          .dw DO_COLON
                 PFA_NEGATE:
000693 1df7          .dw XT_INVERT
000694 1e29          .dw XT_1PLUS
000695 1c1a          .dw XT_EXIT
                 .include "words/slash.asm"
                 
                 ; Arithmetics
                 ; divide n1 by n2. giving the quotient
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 
                 VE_SLASH:
000696 ff01          .dw $ff01
000697 002f          .db "/",0
000698 068d          .dw VE_HEAD
                     .set VE_HEAD = VE_SLASH
                 XT_SLASH:
000699 1c00          .dw DO_COLON
                 PFA_SLASH:
                 .endif
00069a 0652          .dw XT_SLASHMOD
00069b 1cea          .dw XT_NIP
00069c 1c1a          .dw XT_EXIT
                 
                 .include "words/mod.asm"
                 
                 ; Arithmetics
                 ; divide n1 by n2 giving the remainder n3
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 
                 VE_MOD:
00069d ff03          .dw $ff03
00069e 6f6d
00069f 0064          .db "mod",0
0006a0 0696          .dw VE_HEAD
                     .set VE_HEAD = VE_MOD
                 XT_MOD:
0006a1 1c00          .dw DO_COLON
                 PFA_MOD:
                 .endif
0006a2 0652          .dw XT_SLASHMOD
0006a3 1cd3          .dw XT_DROP
0006a4 1c1a          .dw XT_EXIT
                 .include "words/abs.asm"
                 
                 ; Arithmetics
                 ; get the absolute value
                 VE_ABS:
0006a5 ff03          .dw $ff03
0006a6 6261
0006a7 0073          .db "abs",0
0006a8 069d          .dw VE_HEAD
                     .set VE_HEAD = VE_ABS
                 XT_ABS:
0006a9 06aa          .dw PFA_ABS
                 PFA_ABS:
0006aa 2399          tst tosh
0006ab f41a          brpl PFA_ABS1
0006ac 9580          com tosl
0006ad 9590          com tosh
0006ae 9601          adiw tosl, 1
                 PFA_ABS1:
0006af 940c 1c04     jmp_ do_next
                 .include "words/min.asm"
                 
                 ; Compare
                 ; compare two values leave the smaller one
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 
                 VE_MIN:
0006b1 ff03          .dw $ff03
0006b2 696d
0006b3 006e          .db "min",0
0006b4 06a5          .dw VE_HEAD
                     .set VE_HEAD = VE_MIN
                 XT_MIN:
0006b5 1c00          .dw DO_COLON
                 PFA_MIN:
                 .endif
0006b6 05b0          .dw XT_2DUP
0006b7 1d72          .dw XT_GREATER
0006b8 1c30          .dw XT_DOCONDBRANCH
0006b9 06bb          DEST(PFA_MIN1)
0006ba 1cbe          .dw XT_SWAP
                 PFA_MIN1:
0006bb 1cd3          .dw XT_DROP
0006bc 1c1a          .dw XT_EXIT
                 .include "words/max.asm"
                 
                 ; Compare
                 ; compare two values, leave the bigger one
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_MAX:
0006bd ff03          .dw $ff03
0006be 616d
0006bf 0078          .db "max",0
0006c0 06b1          .dw VE_HEAD
                     .set VE_HEAD = VE_MAX
                 XT_MAX:
0006c1 1c00          .dw DO_COLON
                 PFA_MAX:
                 
                 .endif
0006c2 05b0          .dw XT_2DUP
0006c3 1d68          .dw XT_LESS
0006c4 1c30          .dw XT_DOCONDBRANCH
0006c5 06c7          DEST(PFA_MAX1)
0006c6 1cbe          .dw XT_SWAP
                 PFA_MAX1:
0006c7 1cd3          .dw XT_DROP
0006c8 1c1a          .dw XT_EXIT
                 .include "words/within.asm"
                 
                 ; Compare
                 ; check if n is within min..max
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_WITHIN:
0006c9 ff06          .dw $ff06
0006ca 6977
0006cb 6874
0006cc 6e69          .db "within"
0006cd 06bd          .dw VE_HEAD
                     .set VE_HEAD = VE_WITHIN
                 XT_WITHIN:
0006ce 1c00          .dw DO_COLON
                 PFA_WITHIN:
                 .endif
0006cf 1cc9          .dw XT_OVER
0006d0 1d8d          .dw XT_MINUS
0006d1 1cf9          .dw XT_TO_R
0006d2 1d8d          .dw XT_MINUS
0006d3 1cf0          .dw XT_R_FROM
0006d4 1d56          .dw XT_ULESS
0006d5 1c1a          .dw XT_EXIT
                 
                 .include "words/to-upper.asm"
                 
                 ; String
                 ; if c is a lowercase letter convert it to uppercase
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_TOUPPER:
0006d6 ff07          .dw $ff07 
0006d7 6f74
0006d8 7075
0006d9 6570
0006da 0072          .db "toupper",0
0006db 06c9          .dw VE_HEAD
                     .set VE_HEAD = VE_TOUPPER
                 XT_TOUPPER:
0006dc 1c00          .dw DO_COLON 
                 PFA_TOUPPER:
                 .endif
0006dd 1cab          .dw XT_DUP 
0006de 1c37          .dw XT_DOLITERAL 
0006df 0061          .dw 'a' 
0006e0 1c37          .dw XT_DOLITERAL 
0006e1 007b          .dw 'z'+1
0006e2 06ce          .dw XT_WITHIN 
0006e3 1c30          .dw XT_DOCONDBRANCH
0006e4 06e8          DEST(PFA_TOUPPER0)
0006e5 1c37          .dw XT_DOLITERAL
0006e6 00df          .dw 223 ; inverse of 0x20: 0xdf
0006e7 1e0d          .dw XT_AND 
                 PFA_TOUPPER0:
0006e8 1c1a          .dw XT_EXIT 
                 .include "words/to-lower.asm"
                 
                 ; String
                 ; if C is an uppercase letter convert it to lowercase
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 
                 VE_TOLOWER:
0006e9 ff07          .dw $ff07
0006ea 6f74
0006eb 6f6c
0006ec 6577
0006ed 0072          .db "tolower",0
0006ee 06d6          .dw VE_HEAD
                     .set VE_HEAD = VE_TOLOWER
                 XT_TOLOWER:
0006ef 1c00          .dw DO_COLON
                 PFA_TOLOWER:
                 .endif
0006f0 1cab          .dw XT_DUP
0006f1 1c37          .dw XT_DOLITERAL
0006f2 0041          .dw 'A'
0006f3 1c37          .dw XT_DOLITERAL
0006f4 005b          .dw 'Z'+1
0006f5 06ce          .dw XT_WITHIN
0006f6 1c30          .dw XT_DOCONDBRANCH
0006f7 06fb          DEST(PFA_TOLOWER0)
0006f8 1c37          .dw XT_DOLITERAL
0006f9 0020          .dw 32
0006fa 1e16          .dw XT_OR 
                 PFA_TOLOWER0:
0006fb 1c1a          .dw XT_EXIT 
                 ;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/hld.asm"
                 
                 ; Numeric IO
                 ; pointer to current write position in the Pictured Numeric Output buffer
                 VE_HLD:
0006fc ff03          .dw $ff03
0006fd 6c68
0006fe 0064          .db "hld",0
0006ff 06e9          .dw VE_HEAD
                     .set VE_HEAD = VE_HLD
                 XT_HLD:
000700 1c42          .dw PFA_DOVARIABLE
                 PFA_HLD:
000701 0123          .dw ram_hld
                 
                 .dseg
000123           ram_hld: .byte 2
                 .cseg
                 .include "words/hold.asm"
                 
                 ; Numeric IO
                 ; prepend character to pictured numeric output buffer
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_HOLD:
000702 ff04          .dw $ff04
000703 6f68
000704 646c          .db "hold"
000705 06fc          .dw VE_HEAD
                     .set VE_HEAD = VE_HOLD
                 XT_HOLD:
000706 1c00          .dw DO_COLON
                 PFA_HOLD:
                 .endif
000707 0700          .dw XT_HLD
000708 1cab          .dw XT_DUP
000709 1c73          .dw XT_FETCH
00070a 1e2f          .dw XT_1MINUS
00070b 1cab          .dw XT_DUP
00070c 1cf9          .dw XT_TO_R
00070d 1cbe          .dw XT_SWAP
00070e 1c7b          .dw XT_STORE
00070f 1cf0          .dw XT_R_FROM
000710 1c87          .dw XT_CSTORE
000711 1c1a          .dw XT_EXIT
                 .include "words/less-sharp.asm" ; <#
                 
                 ; Numeric IO
                 ; initialize the pictured numeric output conversion process
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_L_SHARP:
000712 ff02          .dw $ff02
000713 233c          .db "<#"
000714 0702          .dw VE_HEAD
                     .set VE_HEAD = VE_L_SHARP
                 XT_L_SHARP:
000715 1c00          .dw DO_COLON
                 PFA_L_SHARP:
                 .endif
000716 05d5          .dw XT_PAD
000717 0700          .dw XT_HLD
000718 1c7b          .dw XT_STORE
000719 1c1a          .dw XT_EXIT
                 .include "words/sharp.asm"
                 
                 ; Numeric IO
                 ; pictured numeric output: convert one digit
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 
                 VE_SHARP:
00071a ff01          .dw $ff01
00071b 0023          .db "#",0
00071c 0712          .dw VE_HEAD
                     .set VE_HEAD = VE_SHARP
                 XT_SHARP:
00071d 1c00          .dw DO_COLON
                 PFA_SHARP:
                 .endif
00071e 059b          .dw XT_BASE
00071f 1c73          .dw XT_FETCH
000720 079a          .dw XT_UDSLASHMOD
000721 1cdb          .dw XT_ROT
000722 1c37          .dw XT_DOLITERAL
000723 0009          .dw 9
000724 1cc9          .dw XT_OVER
000725 1d68          .dw XT_LESS
000726 1c30          .dw XT_DOCONDBRANCH
000727 072b          DEST(PFA_SHARP1)
000728 1c37          .dw XT_DOLITERAL
000729 0007          .dw 7
00072a 1d97          .dw XT_PLUS
                 PFA_SHARP1:
00072b 1c37          .dw XT_DOLITERAL
00072c 0030          .dw 48 ; ASCII 0
00072d 1d97          .dw XT_PLUS
00072e 0706          .dw XT_HOLD
00072f 1c1a          .dw XT_EXIT
                 ; : #    ( ud1 -- ud2 ) 
                 ;        base @ ud/mod rot 9 over < if 7 + then 30 + hold ; 
                 .include "words/sharp-s.asm"
                 
                 ; Numeric IO
                 ; pictured numeric output: convert all digits until 0 (zero) is reached
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SHARP_S:
000730 ff02          .dw $ff02
000731 7323          .db "#s"
000732 071a          .dw VE_HEAD
                     .set VE_HEAD = VE_SHARP_S
                 XT_SHARP_S:
000733 1c00          .dw DO_COLON
                 PFA_SHARP_S:
                 .endif
                 NUMS1:
000734 071d          .dw XT_SHARP
000735 05b0          .dw XT_2DUP
000736 1e16          .dw XT_OR
000737 1d14          .dw XT_ZEROEQUAL
000738 1c30          .dw XT_DOCONDBRANCH
000739 0734          DEST(NUMS1) ; PFA_SHARP_S
00073a 1c1a          .dw XT_EXIT
                 .include "words/sharp-greater.asm" ; #>
                 
                 ; Numeric IO
                 ; Pictured Numeric Output: convert PNO buffer into an string
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SHARP_G:
00073b ff02          .dw $ff02
00073c 3e23          .db "#>"
00073d 0730          .dw VE_HEAD
                     .set VE_HEAD = VE_SHARP_G
                 XT_SHARP_G:
00073e 1c00          .dw DO_COLON
                 PFA_SHARP_G:
                 .endif
00073f 05b9          .dw XT_2DROP
000740 0700          .dw XT_HLD
000741 1c73          .dw XT_FETCH
000742 05d5          .dw XT_PAD
000743 1cc9          .dw XT_OVER
000744 1d8d          .dw XT_MINUS
000745 1c1a          .dw XT_EXIT
                 .include "words/sign.asm"
                 
                 ; Numeric IO
                 ; place a - in HLD if n is negative
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SIGN:
000746 ff04          .dw $ff04
000747 6973
000748 6e67          .db "sign"
000749 073b          .dw VE_HEAD
                     .set VE_HEAD = VE_SIGN
                 XT_SIGN:
00074a 1c00          .dw DO_COLON
                 PFA_SIGN:
                 .endif
00074b 1d1b          .dw XT_ZEROLESS
00074c 1c30          .dw XT_DOCONDBRANCH
00074d 0751          DEST(PFA_SIGN1)
00074e 1c37          .dw XT_DOLITERAL
00074f 002d          .dw 45 ; ascii -
000750 0706          .dw XT_HOLD
                 PFA_SIGN1:
000751 1c1a          .dw XT_EXIT
                 .include "words/d-dot-r.asm"
                 
                 ; Numeric IO
                 ; singed PNO with double cell numbers, right aligned in width w
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DDOTR:
000752 ff03          .dw $ff03
000753 2e64
000754 0072          .db "d.r",0
000755 0746          .dw VE_HEAD
                     .set VE_HEAD = VE_DDOTR
                 XT_DDOTR:
000756 1c00          .dw DO_COLON
                 PFA_DDOTR:
                 
                 .endif
000757 1cf9          .dw XT_TO_R
000758 05c1          .dw XT_TUCK
000759 0d14          .dw XT_DABS
00075a 0715          .dw XT_L_SHARP
00075b 0733          .dw XT_SHARP_S
00075c 1cdb          .dw XT_ROT
00075d 074a          .dw XT_SIGN
00075e 073e          .dw XT_SHARP_G
00075f 1cf0          .dw XT_R_FROM
000760 1cc9          .dw XT_OVER
000761 1d8d          .dw XT_MINUS
000762 0842          .dw XT_SPACES
000763 0852          .dw XT_TYPE
000764 1c1a          .dw XT_EXIT
                 ; : d.r       ( d n -- )
                 ;             >r swap over dabs <# #s rot sign #> r> over - spaces type ;
                 .include "words/dot-r.asm"
                 
                 ; Numeric IO
                 ; singed PNO with single cell numbers, right aligned in width w
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DOTR:
000765 ff02          .dw $ff02
000766 722e          .db ".r"
000767 0752          .dw VE_HEAD
                     .set VE_HEAD = VE_DOTR
                 XT_DOTR:
000768 1c00          .dw DO_COLON
                 PFA_DOTR:
                 
                 .endif
000769 1cf9          .dw XT_TO_R
00076a 0da3          .dw XT_S2D
00076b 1cf0          .dw XT_R_FROM
00076c 0756          .dw XT_DDOTR
00076d 1c1a          .dw XT_EXIT
                 ; : .r        ( s n -- )  >r s>d r> d.r ;
                 .include "words/d-dot.asm"
                 
                 ; Numeric IO
                 ; singed PNO with double cell numbers
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DDOT:
00076e ff02          .dw $ff02
00076f 2e64          .db "d."
000770 0765          .dw VE_HEAD
                     .set VE_HEAD = VE_DDOT
                 XT_DDOT:
000771 1c00          .dw DO_COLON
                 PFA_DDOT:
                 
                 .endif
000772 1d4e          .dw XT_ZERO
000773 0756          .dw XT_DDOTR
000774 0839          .dw XT_SPACE
000775 1c1a          .dw XT_EXIT
                 ; : d.        ( d -- )    0 d.r space ;
                 .include "words/dot.asm"
                 
                 ; Numeric IO
                 ; singed PNO with single cell numbers
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 
                 VE_DOT:
000776 ff01          .dw $ff01
000777 002e          .db ".",0
000778 076e          .dw VE_HEAD
                     .set VE_HEAD = VE_DOT
                 XT_DOT:
000779 1c00          .dw DO_COLON
                 PFA_DOT:
                 .endif
00077a 0da3          .dw XT_S2D
00077b 0771          .dw XT_DDOT
00077c 1c1a          .dw XT_EXIT
                 ; : .         ( s -- )    s>d d. ; 
                 .include "words/ud-dot.asm"
                 
                 ; Numeric IO
                 ; unsigned PNO with double cell numbers
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_UDDOT:
00077d ff03          .dw $ff03
00077e 6475
00077f 002e          .db "ud.",0
000780 0776          .dw VE_HEAD
                     .set VE_HEAD = VE_UDDOT
                 XT_UDDOT:
000781 1c00          .dw DO_COLON
                 PFA_UDDOT:
                 .endif
000782 1d4e          .dw XT_ZERO
000783 078a          .dw XT_UDDOTR
000784 0839          .dw XT_SPACE
000785 1c1a          .dw XT_EXIT
                 .include "words/ud-dot-r.asm"
                 
                 ; Numeric IO
                 ; unsigned PNO with double cell numbers, right aligned in width w
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 
                 VE_UDDOTR:
000786 ff04          .dw $ff04
000787 6475
000788 722e          .db "ud.r"
000789 077d          .dw VE_HEAD
                     .set VE_HEAD = VE_UDDOTR
                 XT_UDDOTR:
00078a 1c00          .dw DO_COLON
                 PFA_UDDOTR:
                 .endif
00078b 1cf9          .dw XT_TO_R
00078c 0715          .dw XT_L_SHARP
00078d 0733          .dw XT_SHARP_S
00078e 073e          .dw XT_SHARP_G
00078f 1cf0          .dw XT_R_FROM
000790 1cc9          .dw XT_OVER
000791 1d8d          .dw XT_MINUS
000792 0842          .dw XT_SPACES
000793 0852          .dw XT_TYPE
000794 1c1a          .dw XT_EXIT
                 .include "words/ud-slash-mod.asm"
                 
                 ; Arithmetics
                 ; unsigned double cell division with remainder
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_UDSLASHMOD:
000795 ff06          .dw $ff06
000796 6475
000797 6d2f
000798 646f          .db "ud/mod"
000799 0786          .dw VE_HEAD
                     .set VE_HEAD = VE_UDSLASHMOD
                 XT_UDSLASHMOD:
00079a 1c00          .dw DO_COLON
                 PFA_UDSLASHMOD:
                 .endif
00079b 1cf9          .dw XT_TO_R
00079c 1d4e          .dw XT_ZERO
00079d 1d02          .dw XT_R_FETCH
00079e 1dbc          .dw XT_UMSLASHMOD
00079f 1cf0          .dw XT_R_FROM
0007a0 1cbe          .dw XT_SWAP
0007a1 1cf9          .dw XT_TO_R
0007a2 1dbc          .dw XT_UMSLASHMOD
0007a3 1cf0          .dw XT_R_FROM
0007a4 1c1a          .dw XT_EXIT
                 .include "words/digit-q.asm"
                 
                 ; Numeric IO
                 ; tries to convert a character to a number, set flag accordingly
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DIGITQ:
0007a5 ff06          .dw $ff06 
0007a6 6964
0007a7 6967
0007a8 3f74          .db "digit?"
0007a9 0795          .dw VE_HEAD
                     .set VE_HEAD = VE_DIGITQ
                 XT_DIGITQ:
0007aa 1c00          .dw DO_COLON 
                 PFA_DIGITQ:
                 .endif
0007ab 06dc          .dw XT_TOUPPER
0007ac 1cab
0007ad 1c37
0007ae 0039
0007af 1d72
0007b0 1c37
0007b1 0100          .DW XT_DUP,XT_DOLITERAL,57,XT_GREATER,XT_DOLITERAL,256
0007b2 1e0d
0007b3 1d97
0007b4 1cab
0007b5 1c37
0007b6 0140
0007b7 1d72          .DW XT_AND,XT_PLUS,XT_DUP,XT_DOLITERAL,320,XT_GREATER
0007b8 1c37
0007b9 0107
0007ba 1e0d
0007bb 1d8d
0007bc 1c37
0007bd 0030          .DW XT_DOLITERAL,263,XT_AND,XT_MINUS,XT_DOLITERAL,48
0007be 1d8d
0007bf 1cab
0007c0 059b
0007c1 1c73
0007c2 1d56          .DW XT_MINUS,XT_DUP,XT_BASE,XT_FETCH,XT_ULESS
0007c3 1c1a          .DW XT_EXIT
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/do-sliteral.asm"
                 
                 ; String
                 ; runtime portion of sliteral
                 ;VE_DOSLITERAL:
                 ;  .dw $ff0a
                 ;  .db "(sliteral)"
                 ;  .dw VE_HEAD
                 ;  .set VE_HEAD = VE_DOSLITERAL
                 XT_DOSLITERAL:
0007c4 1c00        .dw DO_COLON
                 PFA_DOSLITERAL:
0007c5 1d02        .dw XT_R_FETCH   ; ( -- addr )
0007c6 0823        .dw XT_ICOUNT
0007c7 1cf0        .dw XT_R_FROM
0007c8 1cc9        .dw XT_OVER     ; ( -- addr' n addr n)
0007c9 1e29        .dw XT_1PLUS
0007ca 1dfe        .dw XT_2SLASH   ; ( -- addr' n addr k )
0007cb 1d97        .dw XT_PLUS     ; ( -- addr' n addr'' )
0007cc 1e29        .dw XT_1PLUS
0007cd 1cf9        .dw XT_TO_R     ; ( -- )
0007ce 1c1a        .dw XT_EXIT
                 .include "words/scomma.asm"
                 
                 ; Compiler
                 ; compiles a string from RAM to Flash
                 VE_SCOMMA:
0007cf ff02        .dw $ff02
0007d0 2c73        .db "s",$2c
0007d1 07a5        .dw VE_HEAD
                   .set VE_HEAD = VE_SCOMMA
                 XT_SCOMMA:
0007d2 1c00          .dw DO_COLON
                 PFA_SCOMMA:
0007d3 1cab          .dw XT_DUP
0007d4 07d6          .dw XT_DOSCOMMA
0007d5 1c1a          .dw XT_EXIT
                 
                 ; ( addr len len' -- ) 
                 ; Compiler
                 ; compiles a string from RAM to Flash
                 ;VE_DOSCOMMA:
                 ;  .dw $ff04
                 ;  .db "(s",$2c,")"
                 ;  .dw VE_HEAD
                 ;  .set VE_HEAD = VE_DOSCOMMA
                 XT_DOSCOMMA:
0007d6 1c00          .dw DO_COLON
                 PFA_DOSCOMMA:
0007d7 0272          .dw XT_COMMA
0007d8 1cab          .dw XT_DUP   ; ( --addr len len)
0007d9 1dfe          .dw XT_2SLASH ; ( -- addr len len/2
0007da 05c1          .dw XT_TUCK   ; ( -- addr len/2 len len/2
0007db 1e05          .dw XT_2STAR  ; ( -- addr len/2 len len'
0007dc 1d8d          .dw XT_MINUS  ; ( -- addr len/2 rem
0007dd 1cf9          .dw XT_TO_R
0007de 1d4e          .dw XT_ZERO
0007df 0331          .dw XT_QDOCHECK
0007e0 1c30          .dw XT_DOCONDBRANCH
0007e1 07e9          .dw PFA_SCOMMA2
0007e2 1e89          .dw XT_DODO
                 PFA_SCOMMA1:
0007e3 1cab          .dw XT_DUP         ; ( -- addr addr )
0007e4 1c73          .dw XT_FETCH       ; ( -- addr c1c2 )
0007e5 0272          .dw XT_COMMA       ; ( -- addr )
0007e6 05a8          .dw XT_CELLPLUS    ; ( -- addr+cell )
0007e7 1eb7          .dw XT_DOLOOP
0007e8 07e3          .dw PFA_SCOMMA1
                 PFA_SCOMMA2:
0007e9 1cf0          .dw XT_R_FROM
0007ea 1d22          .dw XT_GREATERZERO
0007eb 1c30          .dw XT_DOCONDBRANCH
0007ec 07f0          .dw PFA_SCOMMA3
0007ed 1cab            .dw XT_DUP     ; well, tricky
0007ee 1c92            .dw XT_CFETCH
0007ef 0272            .dw XT_COMMA
                 PFA_SCOMMA3:
0007f0 1cd3          .dw XT_DROP        ; ( -- )
0007f1 1c1a          .dw XT_EXIT
                 .include "words/itype.asm"
                 
                 ; Tools
                 ; reads string from flash and prints it
                 VE_ITYPE:
0007f2 ff05          .dw $ff05
0007f3 7469
0007f4 7079
0007f5 0065          .db "itype",0
0007f6 07cf          .dw VE_HEAD
                     .set VE_HEAD = VE_ITYPE
                 XT_ITYPE:
0007f7 1c00          .dw DO_COLON
                 PFA_ITYPE:
0007f8 1cab          .dw XT_DUP    ; ( --addr len len)
0007f9 1dfe          .dw XT_2SLASH ; ( -- addr len len/2
0007fa 05c1          .dw XT_TUCK   ; ( -- addr len/2 len len/2
0007fb 1e05          .dw XT_2STAR  ; ( -- addr len/2 len len'
0007fc 1d8d          .dw XT_MINUS  ; ( -- addr len/2 rem
0007fd 1cf9          .dw XT_TO_R
0007fe 1d4e          .dw XT_ZERO
0007ff 0331          .dw XT_QDOCHECK
000800 1c30          .dw XT_DOCONDBRANCH
000801 080b          .dw PFA_ITYPE2
000802 1e89          .dw XT_DODO
                 PFA_ITYPE1:
000803 1cab          .dw XT_DUP         ; ( -- addr addr )
000804 1fba          .dw XT_FETCHI      ; ( -- addr c1c2 )
000805 1cab          .dw XT_DUP
000806 0818          .dw XT_LOWEMIT
000807 0814          .dw XT_HIEMIT
000808 1e29          .dw XT_1PLUS    ; ( -- addr+cell )
000809 1eb7          .dw XT_DOLOOP
00080a 0803          .dw PFA_ITYPE1
                 PFA_ITYPE2:
00080b 1cf0          .dw XT_R_FROM
00080c 1d22          .dw XT_GREATERZERO
00080d 1c30          .dw XT_DOCONDBRANCH
00080e 0812          .dw PFA_ITYPE3
00080f 1cab            .dw XT_DUP     ; make sure the drop below has always something to do
000810 1fba            .dw XT_FETCHI
000811 0818            .dw XT_LOWEMIT
                 PFA_ITYPE3:
000812 1cd3          .dw XT_DROP
000813 1c1a          .dw XT_EXIT
                 
                 ; ( w -- )
                 ; R( -- )
                 ; content of cell fetched on stack.
                 ;VE_HIEMIT:
                 ;    .dw $ff06
                 ;    .db "hiemit"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_HIEMIT
                 XT_HIEMIT:
000814 1c00          .dw DO_COLON
                 PFA_HIEMIT:
000815 1ee7          .dw XT_BYTESWAP
000816 0818          .dw XT_LOWEMIT
000817 1c1a          .dw XT_EXIT
                 
                 ; ( w -- )
                 ; R( -- )
                 ; content of cell fetched on stack.
                 ;VE_LOWEMIT:
                 ;    .dw $ff07
                 ;    .db "lowemit"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_LOWEMIT
                 XT_LOWEMIT:
000818 1c00          .dw DO_COLON
                 PFA_LOWEMIT:
000819 1c37          .dw XT_DOLITERAL
00081a 00ff          .dw $00ff
00081b 1e0d          .dw XT_AND
00081c 05df          .dw XT_EMIT
00081d 1c1a          .dw XT_EXIT
                 .include "words/icount.asm"
                 
                 ; Tools
                 ; get count information out of a counted string in flash
                 VE_ICOUNT:
00081e ff06          .dw $ff06
00081f 6369
000820 756f
000821 746e          .db "icount"
000822 07f2          .dw VE_HEAD
                     .set VE_HEAD = VE_ICOUNT
                 XT_ICOUNT:
000823 1c00          .dw DO_COLON
                 PFA_ICOUNT:
000824 1cab          .dw XT_DUP
000825 1e29          .dw XT_1PLUS
000826 1cbe          .dw XT_SWAP
000827 1fba          .dw XT_FETCHI
000828 1c1a          .dw XT_EXIT
                 .include "words/cr.asm"
                 
                 ; Character IO
                 ; cause subsequent output appear at the beginning of the next line
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_CR:
000829 ff02          .dw 0xff02
00082a 7263          .db "cr"
00082b 081e          .dw VE_HEAD
                     .set VE_HEAD = VE_CR
                 XT_CR:
00082c 1c00          .dw DO_COLON
                 PFA_CR:
                 .endif
                 
00082d 1c37          .dw XT_DOLITERAL
00082e 000d          .dw 13
00082f 05df          .dw XT_EMIT
000830 1c37          .dw XT_DOLITERAL
000831 000a          .dw 10
000832 05df          .dw XT_EMIT
000833 1c1a          .dw XT_EXIT
                 .include "words/space.asm"
                 
                 ; Character IO
                 ; emits a space (bl)
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SPACE:
000834 ff05          .dw $ff05
000835 7073
000836 6361
000837 0065          .db "space",0
000838 0829          .dw VE_HEAD
                     .set VE_HEAD = VE_SPACE
                 XT_SPACE:
000839 1c00          .dw DO_COLON
                 PFA_SPACE:
                 .endif
00083a 0642          .dw XT_BL
00083b 05df          .dw XT_EMIT
00083c 1c1a          .dw XT_EXIT
                 .include "words/spaces.asm"
                 
                 ; Character IO
                 ; emits n space(s) (bl)
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SPACES:
00083d ff06          .dw $ff06
00083e 7073
00083f 6361
000840 7365          .db "spaces"
000841 0834          .dw VE_HEAD
                     .set VE_HEAD = VE_SPACES
                 XT_SPACES:
000842 1c00          .dw DO_COLON
                 PFA_SPACES:
                 
                 .endif
                 ;C SPACES   n --            output n spaces
                 ;   BEGIN DUP 0> WHILE SPACE 1- REPEAT DROP ;
000843 1d4e
000844 06c1      	.DW XT_ZERO, XT_MAX
000845 1cab
000846 1c30      SPCS1:  .DW XT_DUP,XT_DOCONDBRANCH
000847 084c              DEST(SPCS2)
000848 0839
000849 1e2f
00084a 1c29              .DW XT_SPACE,XT_1MINUS,XT_DOBRANCH
00084b 0845              DEST(SPCS1)
00084c 1cd3
00084d 1c1a      SPCS2:  .DW XT_DROP,XT_EXIT
                 .include "words/type.asm"
                 
                 ; Character IO
                 ; print a RAM based string
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_TYPE:
00084e ff04          .dw $ff04
00084f 7974
000850 6570          .db "type"
000851 083d          .dw VE_HEAD
                     .set VE_HEAD = VE_TYPE
                 XT_TYPE:
000852 1c00          .dw DO_COLON
                 PFA_TYPE:
                 
                 .endif
000853 0d9a          .dw XT_BOUNDS
000854 0331          .dw XT_QDOCHECK
000855 1c30          .dw XT_DOCONDBRANCH
000856 085d          DEST(PFA_TYPE2)
000857 1e89          .dw XT_DODO
                 PFA_TYPE1:
000858 1e9a          .dw XT_I
000859 1c92          .dw XT_CFETCH
00085a 05df          .dw XT_EMIT
00085b 1eb7          .dw XT_DOLOOP
00085c 0858          DEST(PFA_TYPE1)
                 PFA_TYPE2:
00085d 1c1a          .dw XT_EXIT
                 .include "words/tick.asm"
                 
                 ; Dictionary
                 ; search dictionary for name, return XT or throw an exception -13
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_TICK:
00085e ff01          .dw $ff01
00085f 0027          .db "'",0
000860 084e          .dw VE_HEAD
                     .set VE_HEAD = VE_TICK
                 XT_TICK:
000861 1c00          .dw DO_COLON
                 PFA_TICK:
                 .endif
000862 0a04          .dw XT_PARSENAME
000863 0ae9          .dw XT_DORECOGNIZER
000864 0b6c          .dw XT_R_WORD
000865 1fd3          .dw XT_EQUAL
000866 1c30          .dw XT_DOCONDBRANCH
000867 086a          DEST(PFA_TICK1)
000868 1cd3          .dw XT_DROP
000869 1c1a          .dw XT_EXIT
                 PFA_TICK1:
00086a 1c37          .dw XT_DOLITERAL
00086b fff3          .dw -13
00086c 0890          .dw XT_THROW
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/handler.asm"
                 
                 ; Exceptions
                 ; USER variable used by catch/throw
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_HANDLER:
00086d ff07          .dw $ff07
00086e 6168
00086f 646e
000870 656c
000871 0072          .db "handler",0
000872 085e          .dw VE_HEAD
                     .set VE_HEAD = VE_HANDLER
                 XT_HANDLER:
000873 1c52          .dw PFA_DOUSER
                 PFA_HANDLER:
                 .endif
000874 000a          .dw USER_HANDLER
                 .include "words/catch.asm"
                 
                 ; Exceptions
                 ; execute XT and check for exceptions.
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_CATCH:
000875 ff05          .dw $ff05
000876 6163
000877 6374
000878 0068          .db "catch",0
000879 086d          .dw VE_HEAD
                     .set VE_HEAD = VE_CATCH
                 XT_CATCH:
00087a 1c00          .dw DO_COLON
                 PFA_CATCH:
                 .endif
                 
                     ; sp@ >r
00087b 1e7b          .dw XT_SP_FETCH
00087c 1cf9          .dw XT_TO_R
                     ; handler @ >r
00087d 0873          .dw XT_HANDLER
00087e 1c73          .dw XT_FETCH
00087f 1cf9          .dw XT_TO_R
                     ; rp@ handler !
000880 1e64          .dw XT_RP_FETCH
000881 0873          .dw XT_HANDLER
000882 1c7b          .dw XT_STORE
000883 1c24          .dw XT_EXECUTE
                     ; r> handler !
000884 1cf0          .dw XT_R_FROM
000885 0873          .dw XT_HANDLER
000886 1c7b          .dw XT_STORE
000887 1cf0          .dw XT_R_FROM
000888 1cd3          .dw XT_DROP
000889 1d4e          .dw XT_ZERO
00088a 1c1a          .dw XT_EXIT
                 .include "words/throw.asm"
                 
                 ; Exceptions
                 ; throw an exception
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_THROW:
00088b ff05          .dw $ff05
00088c 6874
00088d 6f72
00088e 0077          .db "throw",0
00088f 0875          .dw VE_HEAD
                     .set VE_HEAD = VE_THROW
                 XT_THROW:
000890 1c00          .dw DO_COLON
                 PFA_THROW:
                 .endif
000891 1cab          .dw XT_DUP
000892 1d14          .dw XT_ZEROEQUAL
000893 1c30          .dw XT_DOCONDBRANCH
000894 0897          DEST(PFA_THROW1)
000895 1cd3      	.dw XT_DROP
000896 1c1a      	.dw XT_EXIT
                 PFA_THROW1:
000897 0873          .dw XT_HANDLER
000898 1c73          .dw XT_FETCH
000899 1e6e          .dw XT_RP_STORE
00089a 1cf0          .dw XT_R_FROM
00089b 0873          .dw XT_HANDLER
00089c 1c7b          .dw XT_STORE
00089d 1cf0          .dw XT_R_FROM
00089e 1cbe          .dw XT_SWAP
00089f 1cf9          .dw XT_TO_R
0008a0 1e84          .dw XT_SP_STORE
0008a1 1cd3          .dw XT_DROP
0008a2 1cf0          .dw XT_R_FROM    
0008a3 1c1a          .dw XT_EXIT
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/cskip.asm"
                 
                 ; String
                 ; skips leading occurancies in string at addr1/n1 leaving addr2/n2 pointing to the 1st non-c character
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_CSKIP:
0008a4 ff05          .dw $ff05
0008a5 7363
0008a6 696b
0008a7 0070          .db "cskip",0
0008a8 088b          .dw VE_HEAD
                     .set VE_HEAD = VE_CSKIP
                 XT_CSKIP:
0008a9 1c00          .dw DO_COLON
                 PFA_CSKIP:
                 .endif
0008aa 1cf9          .dw XT_TO_R           ; ( -- addr1 n1 )
                 PFA_CSKIP1:
0008ab 1cab          .dw XT_DUP            ; ( -- addr' n' n' )
0008ac 1c30          .dw XT_DOCONDBRANCH   ; ( -- addr' n')
0008ad 08b9          DEST(PFA_CSKIP2)
0008ae 1cc9          .dw XT_OVER           ; ( -- addr' n' addr' )
0008af 1c92          .dw XT_CFETCH         ; ( -- addr' n' c' )
0008b0 1d02          .dw XT_R_FETCH        ; ( -- addr' n' c' c )
0008b1 1fd3          .dw XT_EQUAL          ; ( -- addr' n' f )
0008b2 1c30          .dw XT_DOCONDBRANCH   ; ( -- addr' n')
0008b3 08b9          DEST(PFA_CSKIP2)
0008b4 1c37          .dw XT_DOLITERAL
0008b5 0001          .dw 1
0008b6 09f5          .dw XT_SLASHSTRING
0008b7 1c29          .dw XT_DOBRANCH
0008b8 08ab          DEST(PFA_CSKIP1)
                 PFA_CSKIP2:
0008b9 1cf0          .dw XT_R_FROM
0008ba 1cd3          .dw XT_DROP           ; ( -- addr2 n2)
0008bb 1c1a          .dw XT_EXIT
                 .include "words/cscan.asm"
                 
                 ; String
                 ; Scan string at addr1/n1 for the first occurance of c, leaving addr1/n2, char at n2 is first non-c character
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_CSCAN:
0008bc ff05          .dw $ff05
0008bd 7363
0008be 6163
../../common\words/cscan.asm(12): warning: .cseg .db misalignment - padding zero byte
0008bf 006e          .db "cscan"
0008c0 08a4          .dw VE_HEAD
                     .set VE_HEAD = VE_CSCAN
                 XT_CSCAN:
0008c1 1c00          .dw DO_COLON
                 PFA_CSCAN:
                 .endif
0008c2 1cf9          .dw XT_TO_R
0008c3 1cc9          .dw XT_OVER
                 PFA_CSCAN1:
0008c4 1cab          .dw XT_DUP
0008c5 1c92          .dw XT_CFETCH
0008c6 1d02          .dw XT_R_FETCH
0008c7 1fd3          .dw XT_EQUAL
0008c8 1d14          .dw XT_ZEROEQUAL
0008c9 1c30          .dw XT_DOCONDBRANCH
0008ca 08d6          DEST(PFA_CSCAN2)
0008cb 1cbe            .dw XT_SWAP
0008cc 1e2f            .dw XT_1MINUS
0008cd 1cbe            .dw XT_SWAP
0008ce 1cc9            .dw XT_OVER
0008cf 1d1b            .dw XT_ZEROLESS ; not negative
0008d0 1d14            .dw XT_ZEROEQUAL
0008d1 1c30            .dw XT_DOCONDBRANCH
0008d2 08d6            DEST(PFA_CSCAN2)
0008d3 1e29              .dw XT_1PLUS
0008d4 1c29              .dw XT_DOBRANCH
0008d5 08c4              DEST(PFA_CSCAN1)
                 PFA_CSCAN2:
0008d6 1cea          .dw XT_NIP
0008d7 1cc9          .dw XT_OVER
0008d8 1d8d          .dw XT_MINUS
0008d9 1cf0          .dw XT_R_FROM
0008da 1cd3          .dw XT_DROP
0008db 1c1a          .dw XT_EXIT
                 
                 ; : my-cscan ( addr len c -- addr len' )
                 ;    >r over ( -- addr len addr )
                 ;    begin
                 ;      dup c@ r@ <> while
                 ;       swap 1- swap over 0 >=  while
                 ;        1+ 
                 ;     repeat then
                 ;     nip over - r> drop 
                 ; ;
                 .include "words/accept.asm"
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_ACCEPT:
0008dc ff06          .dw $ff06
0008dd 6361
0008de 6563
0008df 7470          .db "accept"
0008e0 08bc          .dw VE_HEAD
                     .set VE_HEAD = VE_ACCEPT
                 XT_ACCEPT:
0008e1 1c00          .dw DO_COLON
                 PFA_ACCEPT:
                 
                 .endif
0008e2 1cc9
0008e3 1d97
0008e4 1e2f
0008e5 1cc9              .DW XT_OVER,XT_PLUS,XT_1MINUS,XT_OVER
0008e6 05f0
0008e7 1cab
0008e8 091b
0008e9 1d14
0008ea 1c30      ACC1:   .DW XT_KEY,XT_DUP,XT_CRLFQ,XT_ZEROEQUAL,XT_DOCONDBRANCH
0008eb 090d              DEST(ACC5)
0008ec 1cab
0008ed 1c37
0008ee 0008
0008ef 1fd3
0008f0 1c30              .DW XT_DUP,XT_DOLITERAL,8,XT_EQUAL,XT_DOCONDBRANCH
0008f1 0904              DEST(ACC3)
0008f2 1cd3
0008f3 1cdb
0008f4 05b0
0008f5 1d72
0008f6 1cf9
0008f7 1cdb
0008f8 1cdb
0008f9 1cf0
0008fa 1c30              .DW XT_DROP,XT_ROT,XT_2DUP,XT_GREATER,XT_TO_R,XT_ROT,XT_ROT,XT_R_FROM,XT_DOCONDBRANCH
0008fb 0902      	DEST(ACC6)
0008fc 0913
0008fd 1e2f
0008fe 1cf9
0008ff 1cc9
000900 1cf0
000901 00eb      	.DW XT_BS,XT_1MINUS,XT_TO_R,XT_OVER,XT_R_FROM,XT_UMAX
                 ACC6:
000902 1c29              .DW XT_DOBRANCH
000903 090b              DEST(ACC4)
000904 1cab
000905 05df
000906 1cc9
000907 1c87
000908 1e29
000909 1cc9
00090a 00f7      ACC3:   .DW XT_DUP,XT_EMIT,XT_OVER,XT_CSTORE,XT_1PLUS,XT_OVER,XT_UMIN
00090b 1c29      ACC4:   .DW XT_DOBRANCH
00090c 08e6              DEST(ACC1)
00090d 1cd3
00090e 1cea
00090f 1cbe
000910 1d8d
000911 082c
000912 1c1a      ACC5:   .DW XT_DROP,XT_NIP,XT_SWAP,XT_MINUS,XT_CR,XT_EXIT
                 
                 
                 ; ( --  ) 
                 ; System
                 ; send a backspace character to overwrite the current char
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 ;VE_BS:
                 ;    .dw $ff02
                 ;    .db "bs"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_BS
                 XT_BS:
000913 1c00          .dw DO_COLON
                 .endif
000914 1c37          .dw XT_DOLITERAL
000915 0008          .dw 8
000916 1cab          .dw XT_DUP
000917 05df          .dw XT_EMIT
000918 0839          .dw XT_SPACE
000919 05df          .dw XT_EMIT
00091a 1c1a          .dw XT_EXIT
                 
                 
                 ; ( c -- f ) 
                 ; System
                 ; is the character a line end character?
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 ;VE_CRLFQ:
                 ;    .dw $ff02
                 ;    .db "crlf?"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_CRLFQ
                 XT_CRLFQ:
00091b 1c00          .dw DO_COLON
                 .endif
00091c 1cab          .dw XT_DUP
00091d 1c37          .dw XT_DOLITERAL
00091e 000d          .dw 13
00091f 1fd3          .dw XT_EQUAL
000920 1cbe          .dw XT_SWAP
000921 1c37          .dw XT_DOLITERAL
000922 000a          .dw 10
000923 1fd3          .dw XT_EQUAL
000924 1e16          .dw XT_OR
000925 1c1a          .dw XT_EXIT
                 .include "words/refill.asm"
                 
                 ; System
                 ; refills the input buffer
                 VE_REFILL:
000926 ff06          .dw $ff06
000927 6572
000928 6966
000929 6c6c          .db "refill"
00092a 08dc          .dw VE_HEAD
                     .set VE_HEAD = VE_REFILL
                 XT_REFILL:
00092b 0c53          .dw PFA_DODEFER1
                 PFA_REFILL:
00092c 001a          .dw USER_REFILL
00092d 0c1c          .dw XT_UDEFERFETCH
00092e 0c28          .dw XT_UDEFERSTORE
                 
                 .include "words/char.asm"
                 
                 ; Tools
                 ; copy the first character of the next word onto the stack
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_CHAR:
00092f ff04          .dw $ff04
000930 6863
000931 7261          .db "char"
000932 0926          .dw VE_HEAD
                     .set VE_HEAD = VE_CHAR
                 XT_CHAR:
000933 1c00          .dw DO_COLON
                 PFA_CHAR:
                 .endif
000934 0a04          .dw XT_PARSENAME
000935 1cd3          .dw XT_DROP
000936 1c92          .dw XT_CFETCH
000937 1c1a          .dw XT_EXIT
                 .include "words/number.asm"
                 
                 ; Numeric IO
                 ; convert a string at addr to a number
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_NUMBER:
000938 ff06          .dw $ff06
000939 756e
00093a 626d
00093b 7265          .db "number"
00093c 092f          .dw VE_HEAD
                     .set VE_HEAD = VE_NUMBER
                 XT_NUMBER:
00093d 1c00          .dw DO_COLON
                 PFA_NUMBER:
                 .endif
00093e 059b          .dw XT_BASE
00093f 1c73          .dw XT_FETCH
000940 1cf9          .dw XT_TO_R
000941 0984          .dw XT_QSIGN
000942 1cf9          .dw XT_TO_R
000943 0998          .dw XT_SET_BASE
000944 0984          .dw XT_QSIGN
000945 1cf0          .dw XT_R_FROM
000946 1e16          .dw XT_OR
000947 1cf9          .dw XT_TO_R
                     ; check whether something is left
000948 1cab          .dw XT_DUP
000949 1d14          .dw XT_ZEROEQUAL
00094a 1c30          .dw XT_DOCONDBRANCH
00094b 0954          DEST(PFA_NUMBER0)
                       ; nothing is left. It cannot be a number at all
00094c 05b9            .dw XT_2DROP
00094d 1cf0            .dw XT_R_FROM
00094e 1cd3            .dw XT_DROP
00094f 1cf0            .dw XT_R_FROM
000950 059b            .dw XT_BASE
000951 1c7b            .dw XT_STORE
000952 1d4e            .dw XT_ZERO
000953 1c1a            .dw XT_EXIT
                 PFA_NUMBER0:
000954 1f0c          .dw XT_2TO_R
000955 1d4e          .dw XT_ZERO       ; starting value
000956 1d4e          .dw XT_ZERO
000957 1f1b          .dw XT_2R_FROM
000958 09b7          .dw XT_TO_NUMBER ; ( 0. addr len -- d addr' len'
                     ; check length of the remaining string.
                     ; if zero: a single cell number is entered
000959 1cb3          .dw XT_QDUP
00095a 1c30          .dw XT_DOCONDBRANCH
00095b 0978          DEST(PFA_NUMBER1)
                     ; if equal 1: mayba a trailing dot? --> double cell number
00095c 1c37          .dw XT_DOLITERAL
00095d 0001          .dw 1
00095e 1fd3          .dw XT_EQUAL
00095f 1c30          .dw XT_DOCONDBRANCH
000960 096f          DEST(PFA_NUMBER2)
                 	; excatly one character is left
000961 1c92      	.dw XT_CFETCH
000962 1c37      	.dw XT_DOLITERAL
000963 002e      	.dw 46 ; .
000964 1fd3      	.dw XT_EQUAL
000965 1c30      	.dw XT_DOCONDBRANCH
000966 0970      	DEST(PFA_NUMBER6)
                 	; its a double cell number
                         ; incorporate sign into number
000967 1cf0      	.dw XT_R_FROM
000968 1c30              .dw XT_DOCONDBRANCH
000969 096b      	DEST(PFA_NUMBER3)
00096a 0d21              .dw XT_DNEGATE
                 PFA_NUMBER3:
00096b 1c37      	.dw XT_DOLITERAL
00096c 0002      	.dw 2
00096d 1c29      	.dw XT_DOBRANCH
00096e 097f      	DEST(PFA_NUMBER5)
                 PFA_NUMBER2:
00096f 1cd3      	.dw XT_DROP
                 PFA_NUMBER6:
000970 05b9      	.dw XT_2DROP
000971 1cf0      	.dw XT_R_FROM
000972 1cd3      	.dw XT_DROP
000973 1cf0              .dw XT_R_FROM
000974 059b              .dw XT_BASE
000975 1c7b              .dw XT_STORE
000976 1d4e      	.dw XT_ZERO
000977 1c1a      	.dw XT_EXIT
                 PFA_NUMBER1:
000978 05b9          .dw XT_2DROP ; remove the address
                     ; incorporate sign into number
000979 1cf0          .dw XT_R_FROM
00097a 1c30          .dw XT_DOCONDBRANCH
00097b 097d          DEST(PFA_NUMBER4)
00097c 0692          .dw XT_NEGATE
                 PFA_NUMBER4:
00097d 1c37          .dw XT_DOLITERAL
00097e 0001          .dw 1
                 PFA_NUMBER5:
00097f 1cf0          .dw XT_R_FROM
000980 059b          .dw XT_BASE
000981 1c7b          .dw XT_STORE
000982 1d45          .dw XT_TRUE
000983 1c1a          .dw XT_EXIT
                 .include "words/q-sign.asm"
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 XT_QSIGN:
000984 1c00          .dw DO_COLON 
                 PFA_QSIGN:        ; ( c -- ) 
                 .endif
000985 1cc9          .dw XT_OVER    ; ( -- addr len addr )
000986 1c92          .dw XT_CFETCH
000987 1c37          .dw XT_DOLITERAL
000988 002d          .dw '-'
000989 1fd3          .dw XT_EQUAL  ; ( -- addr len flag )
00098a 1cab          .dw XT_DUP
00098b 1cf9          .dw XT_TO_R
00098c 1c30          .dw XT_DOCONDBRANCH
00098d 0991          DEST(PFA_NUMBERSIGN_DONE)
00098e 1c37          .dw XT_DOLITERAL      ; skip sign character
00098f 0001          .dw 1
000990 09f5          .dw XT_SLASHSTRING
                 PFA_NUMBERSIGN_DONE:
000991 1cf0          .dw XT_R_FROM
000992 1c1a          .dw XT_EXIT
                 .include "words/set-base.asm"
                 
                 ; Numeric IO
                 ; skip a numeric prefix character
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 XT_BASES:
000993 1c4c          .dw PFA_DOCONSTANT
                 .endif
000994 000a
000995 0010
000996 0002
000997 000a          .dw 10,16,2,10 ; last one could a 8 instead.
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 XT_SET_BASE:
000998 1c00          .dw DO_COLON 
                 PFA_SET_BASE:        ; ( adr1 len1 -- adr2 len2 ) 
                 .endif
000999 1cc9          .dw XT_OVER
00099a 1c92          .dw XT_CFETCH
00099b 1c37          .dw XT_DOLITERAL
00099c 0023          .dw 35
00099d 1d8d          .dw XT_MINUS
00099e 1cab          .dw XT_DUP
00099f 1d4e          .dw XT_ZERO
0009a0 1c37          .dw XT_DOLITERAL
0009a1 0004          .dw 4
0009a2 06ce          .dw XT_WITHIN
0009a3 1c30          .dw XT_DOCONDBRANCH
0009a4 09af          DEST(SET_BASE1)
                 	.if cpu_msp430==1
                 	.endif
0009a5 0993      	.dw XT_BASES
0009a6 1d97      	.dw XT_PLUS
0009a7 1fba      	.dw XT_FETCHI
0009a8 059b      	.dw XT_BASE
0009a9 1c7b      	.dw XT_STORE
0009aa 1c37      	.dw XT_DOLITERAL
0009ab 0001      	.dw 1
0009ac 09f5      	.dw XT_SLASHSTRING
0009ad 1c29      	.dw XT_DOBRANCH
0009ae 09b0      	DEST(SET_BASE2)
                 SET_BASE1:
0009af 1cd3      	.dw XT_DROP
                 SET_BASE2:
0009b0 1c1a          .dw XT_EXIT 
                 
                 ; create bases 10 , 16 , 2 , 8 ,
                 ; : set-base 35 - dup 0 4 within if 
                 ;    bases + @i base ! 1 /string 
                 ;   else 
                 ;    drop
                 ;   then ;
                 .include "words/to-number.asm"
                 
                 ; Numeric IO
                 ; convert a string to a number  c-addr2/u2 is the unconverted string
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_TO_NUMBER:
0009b1 ff07          .dw $ff07
0009b2 6e3e
0009b3 6d75
0009b4 6562
0009b5 0072          .db ">number",0
0009b6 0938          .dw VE_HEAD
                     .set VE_HEAD = VE_TO_NUMBER
                 XT_TO_NUMBER:
0009b7 1c00          .dw DO_COLON
                 
                 .endif
                 
0009b8 1cab
0009b9 1c30      TONUM1: .DW XT_DUP,XT_DOCONDBRANCH
0009ba 09d0              DEST(TONUM3)
0009bb 1cc9
0009bc 1c92
0009bd 07aa              .DW XT_OVER,XT_CFETCH,XT_DIGITQ
0009be 1d14
0009bf 1c30              .DW XT_ZEROEQUAL,XT_DOCONDBRANCH
0009c0 09c3              DEST(TONUM2)
0009c1 1cd3
0009c2 1c1a              .DW XT_DROP,XT_EXIT
0009c3 1cf9
0009c4 0d46
0009c5 059b
0009c6 1c73
0009c7 00dc      TONUM2: .DW XT_TO_R,XT_2SWAP,XT_BASE,XT_FETCH,XT_UDSTAR
0009c8 1cf0
0009c9 00d4
0009ca 0d46              .DW XT_R_FROM,XT_MPLUS,XT_2SWAP
0009cb 1c37
0009cc 0001
0009cd 09f5
0009ce 1c29              .DW XT_DOLITERAL,1,XT_SLASHSTRING,XT_DOBRANCH
0009cf 09b8              DEST(TONUM1)
0009d0 1c1a      TONUM3: .DW XT_EXIT
                 
                 ;C >NUMBER  ud adr u -- ud' adr' u'
                 ;C                      convert string to number
                 ;   BEGIN
                 ;   DUP WHILE
                 ;       OVER C@ DIGIT?
                 ;       0= IF DROP EXIT THEN
                 ;       >R 2SWAP BASE @ UD*
                 ;       R> M+ 2SWAP
                 ;       1 /STRING
                 ;   REPEAT ;
                 .include "words/parse.asm"
                 
                 ; String
                 ; in input buffer parse ccc delimited string by the delimiter char.
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_PARSE:
0009d1 ff05          .dw $ff05
0009d2 6170
0009d3 7372
0009d4 0065          .db "parse",0
0009d5 09b1          .dw VE_HEAD
                     .set VE_HEAD = VE_PARSE
                 XT_PARSE:
0009d6 1c00          .dw DO_COLON
                 PFA_PARSE:
                 .endif
0009d7 1cf9          .dw XT_TO_R     ; ( -- )
0009d8 09eb          .dw XT_SOURCE   ; ( -- addr len)
0009d9 05c9          .dw XT_TO_IN     ; ( -- addr len >in)
0009da 1c73          .dw XT_FETCH
0009db 09f5          .dw XT_SLASHSTRING ; ( -- addr' len' )
                 
0009dc 1cf0          .dw XT_R_FROM      ; ( -- addr' len' c)
0009dd 08c1          .dw XT_CSCAN       ; ( -- addr' len'')
0009de 1cab          .dw XT_DUP         ; ( -- addr' len'' len'')
0009df 1e29          .dw XT_1PLUS
0009e0 05c9          .dw XT_TO_IN        ; ( -- addr' len'' len'' >in)
0009e1 1e53          .dw XT_PLUSSTORE   ; ( -- addr' len')
0009e2 1c37          .dw XT_DOLITERAL
0009e3 0001          .dw 1
0009e4 09f5          .dw XT_SLASHSTRING
0009e5 1c1a          .dw XT_EXIT
                 .include "words/source.asm"
                 
                 ; System
                 ; address and current length of the input buffer
                 VE_SOURCE:
0009e6 ff06          .dw $FF06
0009e7 6f73
0009e8 7275
0009e9 6563          .db "source"
0009ea 09d1          .dw VE_HEAD
                     .set VE_HEAD = VE_SOURCE
                 XT_SOURCE:
0009eb 0c53          .dw PFA_DODEFER1
                 PFA_SOURCE:
0009ec 0016          .dw USER_SOURCE
0009ed 0c1c          .dw XT_UDEFERFETCH
0009ee 0c28          .dw XT_UDEFERSTORE
                 
                 
                 .include "words/slash-string.asm"
                 
                 ; String
                 ; adjust string from addr1 to addr1+n, reduce length from u1 to u2 by n
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SLASHSTRING:
0009ef ff07          .dw $ff07
0009f0 732f
0009f1 7274
0009f2 6e69
0009f3 0067          .db "/string",0
0009f4 09e6          .dw VE_HEAD
                     .set VE_HEAD = VE_SLASHSTRING
                 XT_SLASHSTRING:
0009f5 1c00          .dw DO_COLON
                 PFA_SLASHSTRING:
                 .endif
0009f6 1cdb          .dw XT_ROT
0009f7 1cc9          .dw XT_OVER
0009f8 1d97          .dw XT_PLUS
0009f9 1cdb          .dw XT_ROT
0009fa 1cdb          .dw XT_ROT
0009fb 1d8d          .dw XT_MINUS
0009fc 1c1a          .dw XT_EXIT
                 
                 .include "words/parse-name.asm"
                 
                 ; String
                 ; In the SOURCE buffer parse whitespace delimited string. Returns string address within SOURCE.
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 VE_PARSENAME:
0009fd ff0a          .dw $FF0A 
0009fe 6170
0009ff 7372
000a00 2d65
000a01 616e
000a02 656d          .db "parse-name"
000a03 09ef          .dw VE_HEAD
                     .set VE_HEAD = VE_PARSENAME
                 XT_PARSENAME:
000a04 1c00          .dw DO_COLON 
                 PFA_PARSENAME:
                 .endif
000a05 0642          .dw XT_BL
000a06 0a08          .dw XT_SKIPSCANCHAR
000a07 1c1a          .dw XT_EXIT 
                 
                 ; ( c -- addr2 len2 ) 
                 ; String
                 ; skips char and scan what's left in source for char
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 ;VE_SKIPSCANCHAR:
                 ;    .dw $FF0A 
                 ;    .db "skipscanchar"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_SKIPSCANCHAR
                 XT_SKIPSCANCHAR:
000a08 1c00          .dw DO_COLON
                 PFA_SKIPSCANCHAR:
                 .endif
000a09 1cf9          .dw XT_TO_R
000a0a 09eb          .dw XT_SOURCE 
000a0b 05c9          .dw XT_TO_IN 
000a0c 1c73          .dw XT_FETCH 
000a0d 09f5          .dw XT_SLASHSTRING 
                 
000a0e 1d02          .dw XT_R_FETCH
000a0f 08a9          .dw XT_CSKIP
000a10 1cf0          .dw XT_R_FROM
000a11 08c1          .dw XT_CSCAN
                 
                     ; adjust >IN
000a12 05b0          .dw XT_2DUP
000a13 1d97          .dw XT_PLUS
000a14 09eb          .dw XT_SOURCE 
000a15 1cd3          .dw XT_DROP
000a16 1d8d          .dw XT_MINUS
000a17 05c9          .dw XT_TO_IN
000a18 1c7b          .dw XT_STORE
000a19 1c1a          .dw XT_EXIT
                 .include "words/find-name.asm"
                 
                 ; Tools
                 ; search wordlists for an entry with the name from c-addr/len
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_FINDNAME:
000a1a ff09          .dw $ff09
000a1b 6966
000a1c 646e
000a1d 6e2d
000a1e 6d61
000a1f 0065          .db "find-name",0
000a20 09fd          .dw VE_HEAD
                     .set VE_HEAD = VE_FINDNAME
                 XT_FINDNAME:
000a21 1c00          .dw DO_COLON
                 PFA_FINDNAME:
                 .endif
000a22 1c37          .dw XT_DOLITERAL
000a23 0a2d          .dw XT_FINDNAMEA
000a24 1c37          .dw XT_DOLITERAL
000a25 0042          .dw CFG_ORDERLISTLEN
000a26 04bb          .dw XT_MAPSTACK
000a27 1d14          .dw XT_ZEROEQUAL
000a28 1c30          .dw XT_DOCONDBRANCH
000a29 0a2c          DEST(PFA_FINDNAME1)
000a2a 05b9            .dw XT_2DROP
000a2b 1d4e            .dw XT_ZERO
                 PFA_FINDNAME1:
000a2c 1c1a          .dw XT_EXIT
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 XT_FINDNAMEA:
000a2d 1c00          .dw DO_COLON
                 PFA_FINDNAMEA:
                 .endif
000a2e 1cf9          .dw XT_TO_R
000a2f 05b0          .dw XT_2DUP
000a30 1cf0          .dw XT_R_FROM
000a31 0c65          .dw XT_SEARCH_WORDLIST
000a32 1cab          .dw XT_DUP
000a33 1c30          .dw XT_DOCONDBRANCH
000a34 0a3a          DEST(PFA_FINDNAMEA1)
000a35 1cf9            .dw XT_TO_R
000a36 1cea            .dw XT_NIP
000a37 1cea            .dw XT_NIP
000a38 1cf0            .dw XT_R_FROM
000a39 1d45            .dw XT_TRUE
                 PFA_FINDNAMEA1:
000a3a 1c1a          .dw XT_EXIT
                 
                 .include "words/quit.asm"
                 
                 ; System
                 ; main loop of amforth. accept - interpret in an endless loop
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_QUIT:
000a3b ff04          .dw $ff04
000a3c 7571
000a3d 7469          .db "quit"
000a3e 0a1a          .dw VE_HEAD
                     .set VE_HEAD = VE_QUIT
                 XT_QUIT:
000a3f 1c00          .dw DO_COLON
                 PFA_QUIT:
                 .endif
                 PFA_QUIT1:
000a40 0368
000a41 036f
000a42 1c7b          .dw XT_LP0,XT_LP,XT_STORE
000a43 0ac1          .dw XT_SP0
000a44 1e84          .dw XT_SP_STORE
000a45 0ace          .dw XT_RP0
000a46 1e6e          .dw XT_RP_STORE
000a47 040a          .dw XT_LBRACKET
                 
                 PFA_QUIT2:
000a48 0595          .dw XT_STATE
000a49 1c73          .dw XT_FETCH
000a4a 1d14          .dw XT_ZEROEQUAL
000a4b 1c30          .dw XT_DOCONDBRANCH
000a4c 0a4e          DEST(PFA_QUIT4)
000a4d 0a6b          .dw XT_PROMPTREADY
                 PFA_QUIT4:
000a4e 092b          .dw XT_REFILL
000a4f 1c30          .dw XT_DOCONDBRANCH
000a50 0a48          DEST(PFA_QUIT2)
000a51 1c37          .dw XT_DOLITERAL
000a52 0b11          .dw XT_INTERPRET
000a53 087a          .dw XT_CATCH
000a54 1cb3          .dw XT_QDUP
000a55 1c30          .dw XT_DOCONDBRANCH
000a56 0a60          DEST(PFA_QUIT3)
000a57 1cab      	.dw XT_DUP
000a58 1c37      	.dw XT_DOLITERAL
000a59 fffe      	.dw -2
000a5a 1d68      	.dw XT_LESS
000a5b 1c30      	.dw XT_DOCONDBRANCH
000a5c 0a5e      	DEST(PFA_QUIT5)
000a5d 0a72      	.dw XT_PROMPTERROR
                 PFA_QUIT5:
000a5e 1c29      	.dw XT_DOBRANCH
000a5f 0a40      	DEST(PFA_QUIT1)
                 PFA_QUIT3:
000a60 0a64          .dw XT_PROMPTOK
000a61 1c29          .dw XT_DOBRANCH
000a62 0a48          DEST(PFA_QUIT2)
000a63 1c1a          .dw XT_EXIT ; never reached
                 
                 .include "words/prompt-ok.asm"
                 
                 ; System
                 ; send the READY prompt to the command line
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 ;VE_PROMPTOK:
                 ;    .dw $ff02
                 ;    .db "ok"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_PROMPTOK
                 XT_PROMPTOK:
000a64 1c00          .dw DO_COLON
                 PFA_PROMPTOK:
000a65 07c4          .dw XT_DOSLITERAL
000a66 0003          .dw 3
000a67 6f20
000a68 006b          .db " ok",0
                 .endif
000a69 07f7          .dw XT_ITYPE
000a6a 1c1a          .dw XT_EXIT
                 .include "words/prompt-ready.asm"
                 
                 ; System
                 ; process the error prompt
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 ;VE_PROMPTRDY:
                 ;    .dw $ff04
                 ;    .db "p_er"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_PROMPTRDY
                 XT_PROMPTREADY:
000a6b 1c00          .dw DO_COLON
                 PFA_PROMPTREADY:
000a6c 07c4          .dw XT_DOSLITERAL
000a6d 0002          .dw 2
000a6e 203e          .db "> "
                 .endif
000a6f 082c          .dw XT_CR
000a70 07f7          .dw XT_ITYPE
000a71 1c1a          .dw XT_EXIT
                 .include "words/prompt-error.asm"
                 
                 ; System
                 ; process the error prompt
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 ;VE_PROMPTERROR:
                 ;    .dw $ff04
                 ;    .db "p_er"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_PROMPTERROR
                 XT_PROMPTERROR:
000a72 1c00          .dw DO_COLON
                 PFA_PROMPTERROR:
000a73 07c4      	.dw XT_DOSLITERAL
000a74 0004          .dw 4
000a75 3f20
000a76 203f          .db " ?? "
                 .endif
000a77 07f7          .dw XT_ITYPE
000a78 059b          .dw XT_BASE
000a79 1c73          .dw XT_FETCH
000a7a 1cf9          .dw XT_TO_R
000a7b 062f          .dw XT_DECIMAL
000a7c 0779          .dw XT_DOT
000a7d 05c9          .dw XT_TO_IN
000a7e 1c73          .dw XT_FETCH
000a7f 0779          .dw XT_DOT
000a80 1cf0          .dw XT_R_FROM
000a81 059b          .dw XT_BASE
000a82 1c7b          .dw XT_STORE
000a83 1c1a          .dw XT_EXIT
                 .include "words/pause.asm"
                 
                 ; Multitasking
                 ; Fetch pause vector and execute it. may make a context/task switch
                 VE_PAUSE:
000a84 ff05          .dw $ff05
000a85 6170
000a86 7375
000a87 0065          .db "pause",0
000a88 0a3b          .dw VE_HEAD
                     .set VE_HEAD = VE_PAUSE
                 XT_PAUSE:
000a89 0c53          .dw PFA_DODEFER1
                 PFA_PAUSE:
000a8a 0125          .dw ram_pause
000a8b 0c08          .dw XT_RDEFERFETCH
000a8c 0c12          .dw XT_RDEFERSTORE
                 
                 .dseg
000125           ram_pause: .byte 2
                 .cseg
                 .include "words/cold.asm"
                 
                 ; System
                 ; start up amforth.
                 VE_COLD:
000a8d ff04          .dw $ff04
000a8e 6f63
000a8f 646c          .db "cold"
000a90 0a84          .dw VE_HEAD
                     .set VE_HEAD = VE_COLD
                 XT_COLD:
000a91 0a92          .dw PFA_COLD
                 PFA_COLD:
000a92 b6a4          in_ mcu_boot, MCUSR
000a93 2422          clr zerol
000a94 2433          clr zeroh
000a95 be24          out_ MCUSR, zerol
                     ; clear RAM
000a96 e0e0          ldi zl, low(ramstart)
000a97 e0f1          ldi zh, high(ramstart)
                 clearloop:
000a98 9221          st Z+, zerol
000a99 30e0          cpi zl, low(sram_size+ramstart)
000a9a f7e9          brne clearloop
000a9b 30f5          cpi zh, high(sram_size+ramstart)
000a9c f7d9          brne clearloop
                     ; init first user data area
                     ; allocate space for User Area
                 .dseg
000127           ram_user1: .byte SYSUSERSIZE + APPUSERSIZE
                 .cseg
000a9d e2e7          ldi zl, low(ram_user1)
000a9e e0f1          ldi zh, high(ram_user1)
000a9f 012f          movw upl, zl
                     ; init return stack pointer
000aa0 ef0f          ldi temp0,low(rstackstart)
000aa1 bf0d          out_ SPL,temp0
000aa2 8304          std Z+4, temp0
000aa3 e014          ldi temp1,high(rstackstart)
000aa4 bf1e          out_ SPH,temp1
000aa5 8315          std Z+5, temp1
                 
                     ; init parameter stack pointer
000aa6 eacf          ldi yl,low(stackstart)
000aa7 83c6          std Z+6, yl
000aa8 e0d4          ldi yh,high(stackstart)
000aa9 83d7          std Z+7, yh
                 
                     ; load Forth IP with starting word
000aaa eba3          ldi XL, low(PFA_WARM)
000aab e0ba          ldi XH, high(PFA_WARM)
                     ; its a far jump...
000aac 940c 1c04     jmp_ DO_NEXT
                 .include "words/warm.asm"
                 
                 ; System
                 ; initialize amforth further. executes turnkey operation and go to quit
                 VE_WARM:
000aae ff04          .dw $ff04
000aaf 6177
000ab0 6d72          .db "warm"
000ab1 0a8d          .dw VE_HEAD
                     .set VE_HEAD = VE_WARM
                 XT_WARM:
000ab2 1c00          .dw DO_COLON
                 PFA_WARM:
000ab3 0d8c          .dw XT_INITUSER
000ab4 1c37          .dw XT_DOLITERAL
000ab5 0bbe          .dw XT_NOOP
000ab6 1c37          .dw XT_DOLITERAL
000ab7 0a89          .dw XT_PAUSE
000ab8 0c33          .dw XT_DEFERSTORE
000ab9 040a          .dw XT_LBRACKET
000aba 064a          .dw XT_TURNKEY
000abb 0a3f          .dw XT_QUIT
000abc 1c1a          .dw XT_EXIT
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/sp0.asm"
                 
                 ; Stack
                 ; start address of the data stack
                 VE_SP0:
000abd ff03          .dw $ff03
000abe 7073
000abf 0030          .db "sp0",0
000ac0 0aae          .dw VE_HEAD
                     .set VE_HEAD = VE_SP0
                 XT_SP0:
000ac1 1c69          .dw PFA_DOVALUE1
                 PFA_SP0:
000ac2 0006          .dw USER_SP0
000ac3 0c1c          .dw XT_UDEFERFETCH
000ac4 0c28          .dw XT_UDEFERSTORE
                 
                 ; ( -- addr) 
                 ; Stack
                 ; address of user variable to store top-of-stack for inactive tasks
                 VE_SP:
000ac5 ff02          .dw $ff02
000ac6 7073          .db "sp"
000ac7 0abd          .dw VE_HEAD
                     .set VE_HEAD = VE_SP
                 XT_SP:
000ac8 1c52          .dw PFA_DOUSER
                 PFA_SP:
000ac9 0008          .dw USER_SP
                 .include "words/rp0.asm"
                 
                 ; Stack
                 ; start address of return stack
                 VE_RP0:
000aca ff03          .dw $ff03
000acb 7072
000acc 0030          .db "rp0",0
000acd 0ac5          .dw VE_HEAD
                     .set VE_HEAD = VE_RP0
                 XT_RP0:
000ace 1c00          .dw DO_COLON
                 PFA_RP0:
000acf 0ad2          .dw XT_DORP0
000ad0 1c73          .dw XT_FETCH
000ad1 1c1a          .dw XT_EXIT
                 
                 ; ( -- addr) 
                 ; Stack
                 ; user variable of the address of the initial return stack
                 ;VE_DORP0:
                 ;    .dw $ff05
                 ;    .db "(rp0)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DORP0
                 XT_DORP0:
000ad2 1c52          .dw PFA_DOUSER
                 PFA_DORP0:
000ad3 0004          .dw USER_RP
                 .include "words/depth.asm"
                 
                 ; Stack
                 ; number of single-cell values contained in the data stack before n was placed on the stack.
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DEPTH:
000ad4 ff05          .dw $ff05
000ad5 6564
000ad6 7470
000ad7 0068          .db "depth",0
000ad8 0aca          .dw VE_HEAD
                     .set VE_HEAD = VE_DEPTH
                 XT_DEPTH:
000ad9 1c00          .dw DO_COLON
                 PFA_DEPTH:
                 .endif
000ada 0ac1          .dw XT_SP0
000adb 1e7b          .dw XT_SP_FETCH
000adc 1d8d          .dw XT_MINUS
000add 1dfe          .dw XT_2SLASH
000ade 1e2f          .dw XT_1MINUS
000adf 1c1a          .dw XT_EXIT
                 .include "words/do-recognizer.asm"
                 
                 ; System
                 ; walk the recognizer stack
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DORECOGNIZER:
000ae0 ff0d          .dw $ff0d
000ae1 6f64
000ae2 722d
000ae3 6365
000ae4 676f
000ae5 696e
000ae6 657a
000ae7 0072          .db "do-recognizer",0
000ae8 0ad4          .dw VE_HEAD
                     .set VE_HEAD = VE_DORECOGNIZER
                 XT_DORECOGNIZER:
000ae9 1c00          .dw DO_COLON
                 PFA_DORECOGNIZER:
                 .endif
000aea 1c37          .dw XT_DOLITERAL
000aeb 0af5          .dw XT_DORECOGNIZER_A
000aec 1c37          .dw XT_DOLITERAL
000aed 0054          .dw CFG_RECOGNIZERLISTLEN
000aee 04bb          .dw XT_MAPSTACK
000aef 1d14          .dw XT_ZEROEQUAL
000af0 1c30          .dw XT_DOCONDBRANCH
000af1 0af4          DEST(PFA_DORECOGNIZER1)
000af2 05b9            .dw XT_2DROP
000af3 0b89            .dw XT_R_FAIL
                 PFA_DORECOGNIZER1:
000af4 1c1a          .dw XT_EXIT
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 ; ( addr len XT -- addr len [ r:table -1 | 0 ] )
                 XT_DORECOGNIZER_A:
000af5 1c00         .dw DO_COLON
                 PFA_DORECOGNIZER_A:
                 .endif
000af6 1cdb         .dw XT_ROT  ; -- len xt addr
000af7 1cdb         .dw XT_ROT  ; -- xt addr len
000af8 05b0         .dw XT_2DUP 
000af9 1f0c         .dw XT_2TO_R
000afa 1cdb         .dw XT_ROT  ; -- addr len xt
000afb 1c24         .dw XT_EXECUTE ; -- i*x r:foo | r:fail
000afc 1f1b         .dw XT_2R_FROM
000afd 1cdb         .dw XT_ROT
000afe 1cab         .dw XT_DUP
000aff 0b89         .dw XT_R_FAIL
000b00 1fd3         .dw XT_EQUAL
000b01 1c30         .dw XT_DOCONDBRANCH
000b02 0b06         DEST(PFA_DORECOGNIZER_A1)
000b03 1cd3           .dw XT_DROP
000b04 1d4e           .dw XT_ZERO
000b05 1c1a           .dw XT_EXIT
                 PFA_DORECOGNIZER_A1:
000b06 1cea         .dw XT_NIP 
000b07 1cea         .dw XT_NIP
000b08 1d45         .dw XT_TRUE
000b09 1c1a         .dw XT_EXIT
                 
                 ; : do-recognizer ( addr len -- i*x r:table|r:fail )
                 ;    \ ( addr len -- addr len 0 | i*x r:table -1 )
                 ;    [: rot rot 2dup 2>r rot execute 2r> rot 
                 ;          dup r:fail = ( -- addr len r:table f )
                 ;          if drop 0 else nip nip -1 then
                 ;    ;] 
                 ;    EE_RECOGNIZERLISTLEN map-stack ( -- i*x addr len r:table f )
                 ;    0= if \ a recognizer did the job, remove addr/len
                 ;     2drop r:fail 
                 ;    then
                 ;
                 .include "words/interpret.asm"
                 
                 ; System
                 ; Interpret SOURCE word by word.
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_INTERPRET:
000b0a ff09          .dw $ff09
000b0b 6e69
000b0c 6574
000b0d 7072
000b0e 6572
000b0f 0074          .db "interpret",0
000b10 0ae0          .dw VE_HEAD
                     .set VE_HEAD = VE_INTERPRET
                 XT_INTERPRET:
000b11 1c00          .dw DO_COLON
                 .endif
                 PFA_INTERPRET:
000b12 0a04          .dw XT_PARSENAME ; ( -- addr len )
000b13 1cab          .dw XT_DUP   ; ( -- addr len flag)
000b14 1c30          .dw XT_DOCONDBRANCH
000b15 0b21          DEST(PFA_INTERPRET2)
000b16 0ae9            .dw XT_DORECOGNIZER
000b17 0595            .dw XT_STATE
000b18 1c73            .dw XT_FETCH
000b19 1c30            .dw XT_DOCONDBRANCH
000b1a 0b1c          DEST(PFA_INTERPRET1)
000b1b 0beb            .dw XT_ICELLPLUS   ; we need the compile action
                 PFA_INTERPRET1:
000b1c 1fba            .dw XT_FETCHI
000b1d 1c24            .dw XT_EXECUTE
000b1e 0b96            .dw XT_QSTACK
000b1f 1c29          .dw XT_DOBRANCH
000b20 0b12          DEST(PFA_INTERPRET)
                 PFA_INTERPRET2:
000b21 05b9          .dw XT_2DROP
000b22 1c1a          .dw XT_EXIT
                 .include "words/r-intnumber.asm"
                 
                 ; Interpreter
                 ; Method table for single cell integers
                 
                 
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_R_NUM:
000b23 ff05          .dw $ff05
000b24 3a72
000b25 756e
000b26 006d          .db "r:num",0
000b27 0b0a          .dw VE_HEAD
                     .set VE_HEAD = VE_R_NUM
                 XT_R_NUM:
000b28 1c4c          .dw PFA_DOCONSTANT
                 PFA_R_NUM:
                 .endif
000b29 0bbe          .dw XT_NOOP    ; interpret
000b2a 0288          .dw XT_LITERAL ; compile
000b2b 0b35          .dw XT_FAILNUM ; postpone
                 
                 ; ( -- addr )
                 ; Interpreter
                 ; Method table for double cell integers
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_R_DNUM:
000b2c ff06          .dw $ff06
000b2d 3a72
000b2e 6e64
000b2f 6d75          .db "r:dnum"
000b30 0b23          .dw VE_HEAD
                     .set VE_HEAD = VE_R_DNUM
                 XT_R_DNUM:
000b31 1c4c          .dw PFA_DOCONSTANT
                 PFA_R_DNUM:
                 .endif
000b32 0bbe          .dw XT_NOOP     ; interpret
000b33 1fc7          .dw XT_2LITERAL ; compile
000b34 0b3b          .dw XT_FAILDNUM ; postpone
                 
                 ; ( -- addr )
                 ; Interpreter
                 ; Method to print a number and throw exception "invalid postpone"
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 ;VE_FAILNUM:
                 ;    .dw $ff06
                 ;    .db "fail:i"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_FAILNUM
                 XT_FAILNUM:
000b35 1c00          .dw DO_COLON
                 PFA_FAILNUM:
                 .endif
000b36 0779          .dw XT_DOT
000b37 1c37          .dw XT_DOLITERAL
000b38 ffd0          .dw -48
000b39 0890          .dw XT_THROW
000b3a 1c1a          .dw XT_EXIT
                 
                 ; ( -- addr )
                 ; Interpreter
                 ; Method to print a double cell number and throw exception "invalid postpone"
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 VE_FAILDNUM:
                 ;    .dw $ff06
                 ;    .db "fail:d"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_FAILDNUM
                 XT_FAILDNUM:
000b3b 1c00          .dw DO_COLON
                 PFA_FAILDNUM:
                 .endif
000b3c 0771          .dw XT_DDOT
000b3d 1c37          .dw XT_DOLITERAL
000b3e ffd0          .dw -48
000b3f 0890          .dw XT_THROW
000b40 1c1a          .dw XT_EXIT
                 
                 ; ( addr len -- f )
                 ; Interpreter
                 ; recognizer for integer numbers
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 VE_REC_NUM:
000b41 ff07          .dw $ff07
000b42 6572
000b43 3a63
000b44 756e
000b45 006d          .db "rec:num",0
000b46 0b2c          .dw VE_HEAD
                     .set VE_HEAD = VE_REC_NUM
                 XT_REC_NUM:
000b47 1c00          .dw DO_COLON
                 PFA_REC_NUM:
                 .endif
                     ; try converting to a number
000b48 093d          .dw XT_NUMBER
000b49 1c30          .dw XT_DOCONDBRANCH
000b4a 0b54          DEST(PFA_REC_NONUMBER)
000b4b 1c37          .dw XT_DOLITERAL
000b4c 0001          .dw 1
000b4d 1fd3          .dw XT_EQUAL
000b4e 1c30          .dw XT_DOCONDBRANCH
000b4f 0b52          DEST(PFA_REC_INTNUM2)
000b50 0b28            .dw XT_R_NUM
000b51 1c1a            .dw XT_EXIT
                 PFA_REC_INTNUM2:
000b52 0b31            .dw XT_R_DNUM
000b53 1c1a            .dw XT_EXIT
                 PFA_REC_NONUMBER:
000b54 0b89          .dw XT_R_FAIL
000b55 1c1a          .dw XT_EXIT
                 .include "words/r-word.asm"
                 
                 ; Interpreter
                 ; search for a word
                 .if cpu_msp430==1
                 .endif
                 .if cpu_avr8==1
                 VE_REC_WORD:
000b56 ff08          .dw $ff08
000b57 6572
000b58 3a63
000b59 6f77
000b5a 6472          .db "rec:word"
000b5b 0b41          .dw VE_HEAD
                     .set VE_HEAD = VE_REC_WORD
                 XT_REC_WORD:
000b5c 1c00          .dw DO_COLON
                 PFA_REC_WORD:
                 .endif
000b5d 0a21          .DW XT_FINDNAME
000b5e 1cab          .dw XT_DUP
000b5f 1d14          .dw XT_ZEROEQUAL
000b60 1c30          .dw XT_DOCONDBRANCH
000b61 0b65          DEST(PFA_REC_WORD_FOUND)
000b62 1cd3              .dw XT_DROP
000b63 0b89      	.dw XT_R_FAIL
000b64 1c1a      	.dw XT_EXIT
                 PFA_REC_WORD_FOUND:
000b65 0b6c          .dw XT_R_WORD
                 
000b66 1c1a          .dw XT_EXIT
                 
                 ; ( -- addr )
                 ; Interpreter
                 ; actions to handle execution tokens and their flags
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_R_WORD:
000b67 ff06          .dw $ff06
000b68 3a72
000b69 6f77
000b6a 6472          .db "r:word"
000b6b 0b56          .dw VE_HEAD
                     .set VE_HEAD = VE_R_WORD
                 XT_R_WORD:
000b6c 1c4c          .dw PFA_DOCONSTANT
                 PFA_R_WORD:
                 .endif
000b6d 0b70          .dw XT_R_WORD_INTERPRET
000b6e 0b74          .dw XT_R_WORD_COMPILE
000b6f 0b7c          .dw XT_R_WORD_POSTPONE
                 
                 ; ( XT flags -- )
                 ; Interpreter
                 ; interpret method for WORD recognizer
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 XT_R_WORD_INTERPRET:
000b70 1c00          .dw DO_COLON
                 PFA_R_WORD_INTERPRET:
                 .endif
000b71 1cd3          .dw XT_DROP ; the flags are in the way
000b72 1c24          .dw XT_EXECUTE
000b73 1c1a          .dw XT_EXIT
                 
                 ; ( XT flags -- )
                 ; Interpreter
                 ; Compile method for WORD recognizer
                 .if cpu_msp430==1
                 .endif
                 .if cpu_avr8==1
                 XT_R_WORD_COMPILE:
000b74 1c00          .dw DO_COLON
                 PFA_R_WORD_COMPILE:
                 .endif
000b75 1d1b          .dw XT_ZEROLESS
000b76 1c30          .dw XT_DOCONDBRANCH
000b77 0b7a          DEST(PFA_R_WORD_COMPILE1)
000b78 0272      	.dw XT_COMMA
000b79 1c1a              .dw XT_EXIT
                 PFA_R_WORD_COMPILE1:
000b7a 1c24              .dw XT_EXECUTE
000b7b 1c1a          .dw XT_EXIT
                 
                 ; ( XT flags -- )
                 ; Interpreter
                 ; Postpone method for WORD recognizer
                 .if cpu_msp430==1
                 .endif
                 .if cpu_avr8==1
                 XT_R_WORD_POSTPONE:
000b7c 1c00          .dw DO_COLON
                 PFA_R_WORD_POSTPONE:
                 .endif
000b7d 1d1b          .dw XT_ZEROLESS
000b7e 1c30          .dw XT_DOCONDBRANCH
000b7f 0b82          DEST(PFA_R_WORD_POSTPONE1)
000b80 0267            .dw XT_COMPILE
000b81 0267            .dw XT_COMPILE
                 PFA_R_WORD_POSTPONE1:
000b82 0272          .dw XT_COMMA
000b83 1c1a          .dw XT_EXIT
                 .include "words/r-fail.asm"
                 
                 ; Interpreter
                 ; there is no parser for this recognizer, this is the default and failsafe part
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_R_FAIL:
000b84 ff06          .dw $ff06
000b85 3a72
000b86 6166
000b87 6c69          .db "r:fail"
000b88 0b67          .dw VE_HEAD
                     .set VE_HEAD = VE_R_FAIL
                 XT_R_FAIL:
000b89 1c4c          .dw PFA_DOCONSTANT
                 PFA_R_FAIL:
                 .endif
000b8a 0b8d          .dw XT_FAIL  ; interpret
000b8b 0b8d          .dw XT_FAIL  ; compile
000b8c 0b8d          .dw XT_FAIL  ; postpone
                 
                 ; ( addr len -- )
                 ; Interpreter
                 ; default failure action: throw exception -13.
                 .if cpu_msp430==1
                 .endif
                 .if cpu_avr8==1
                 ;VE_FAIL:
                 ;    .dw $ff04
                 ;    .db "fail"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_FAIL
                 XT_FAIL:
000b8d 1c00          .dw DO_COLON
                 PFA_FAIL:
                 .endif
000b8e 1c37          .dw XT_DOLITERAL
000b8f fff3          .dw -13
000b90 0890          .dw XT_THROW
                 
                 .include "words/q-stack.asm"
                 
                 ; Tools
                 ; check data stack depth and exit to quit if underrun
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_QSTACK:
000b91 ff06          .dw $ff06
000b92 733f
000b93 6174
000b94 6b63          .db "?stack"
000b95 0b84          .dw VE_HEAD
                     .set VE_HEAD = VE_QSTACK
                 XT_QSTACK:
000b96 1c00          .dw DO_COLON
                 PFA_QSTACK:
                 .endif
000b97 0ad9          .dw XT_DEPTH
000b98 1d1b          .dw XT_ZEROLESS
000b99 1c30          .dw XT_DOCONDBRANCH
000b9a 0b9e          DEST(PFA_QSTACK1)
000b9b 1c37            .dw XT_DOLITERAL
000b9c fffc            .dw -4
000b9d 0890            .dw XT_THROW
                 PFA_QSTACK1:
000b9e 1c1a          .dw XT_EXIT
                 .include "words/ver.asm"
                 
                 ; Tools
                 ; print the version string
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DOT_VER:
000b9f ff03          .dw $ff03
000ba0 6576
../../common\words/ver.asm(12): warning: .cseg .db misalignment - padding zero byte
000ba1 0072          .db "ver"
000ba2 0b91          .dw VE_HEAD
                     .set VE_HEAD = VE_DOT_VER
                 XT_DOT_VER:
000ba3 1c00          .dw DO_COLON
                 PFA_DOT_VER:
                 .endif
000ba4 0557          .dw XT_ENV_FORTHNAME
000ba5 07f7          .dw XT_ITYPE
000ba6 0839          .dw XT_SPACE
000ba7 059b          .dw XT_BASE
000ba8 1c73          .dw XT_FETCH
                 
000ba9 0565          .dw XT_ENV_FORTHVERSION
000baa 062f          .dw XT_DECIMAL
000bab 0da3          .dw XT_S2D
000bac 0715          .dw XT_L_SHARP
000bad 071d          .dw XT_SHARP
000bae 1c37          .dw XT_DOLITERAL
000baf 002e          .dw '.'
000bb0 0706          .dw XT_HOLD
000bb1 0733          .dw XT_SHARP_S
000bb2 073e          .dw XT_SHARP_G
000bb3 0852          .dw XT_TYPE
000bb4 059b          .dw XT_BASE
000bb5 1c7b          .dw XT_STORE
000bb6 0839          .dw XT_SPACE
000bb7 056d          .dw XT_ENV_CPU
000bb8 07f7          .dw XT_ITYPE
                 
000bb9 1c1a          .dw XT_EXIT
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/noop.asm"
                 
                 ; Tools
                 ; do nothing
                 VE_NOOP:
000bba ff04          .dw $ff04
000bbb 6f6e
000bbc 706f          .db "noop"
000bbd 0b9f          .dw VE_HEAD
                     .set VE_HEAD = VE_NOOP
                 XT_NOOP:
000bbe 0bbf          .dw PFA_NOOP
                 PFA_NOOP:
000bbf 940c 1c04     jmp_ DO_NEXT
                 .include "words/unused.asm"
                 
                 ; Tools
                 ; Amount of available RAM (incl. PAD)
                 VE_UNUSED:
000bc1 ff06          .dw $ff06
000bc2 6e75
000bc3 7375
000bc4 6465          .db "unused"
000bc5 0bba          .dw VE_HEAD
                     .set VE_HEAD = VE_UNUSED
                 XT_UNUSED:
000bc6 1c00          .dw DO_COLON
                 PFA_UNUSED:
000bc7 1e7b          .dw XT_SP_FETCH
000bc8 0610          .dw XT_HERE
000bc9 1d8d          .dw XT_MINUS
000bca 1c1a          .dw XT_EXIT
                 
                 .include "words/to.asm"
                 
                 ; Tools
                 ; store the TOS to the named value (eeprom cell)
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_TO:
000bcb 0002          .dw $0002
000bcc 6f74          .db "to"
000bcd 0bc1          .dw VE_HEAD
                     .set VE_HEAD = VE_TO
                 XT_TO:
000bce 1c00          .dw DO_COLON
                 PFA_TO:
                 .endif
000bcf 0861          .dw XT_TICK
000bd0 0dac          .dw XT_TO_BODY
000bd1 0595          .dw XT_STATE
000bd2 1c73          .dw XT_FETCH
000bd3 1c30          .dw XT_DOCONDBRANCH
000bd4 0bdf          DEST(PFA_TO1)
000bd5 0267          .dw XT_COMPILE
000bd6 0bd9          .dw XT_DOTO
000bd7 0272          .dw XT_COMMA
000bd8 1c1a          .dw XT_EXIT
                 
                 ; ( n -- ) (R: IP -- IP+1)
                 ; Tools
                 ; runtime portion of to
                 ;VE_DOTO:
                 ;    .dw $ff04
                 ;    .db "(to)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOTO
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 XT_DOTO:
000bd9 1c00          .dw DO_COLON
                 PFA_DOTO:
                 .endif
000bda 1cf0          .dw XT_R_FROM
000bdb 1cab          .dw XT_DUP
000bdc 0beb          .dw XT_ICELLPLUS
000bdd 1cf9          .dw XT_TO_R
000bde 1fba          .dw XT_FETCHI
                 PFA_TO1:
000bdf 1cab          .dw XT_DUP
000be0 0beb          .dw XT_ICELLPLUS
000be1 0beb          .dw XT_ICELLPLUS
000be2 1fba          .dw XT_FETCHI
000be3 1c24          .dw XT_EXECUTE
000be4 1c1a          .dw XT_EXIT
                 .include "words/i-cellplus.asm"
                 
                 ; Compiler
                 ; skip to the next cell in flash
                 VE_ICELLPLUS:
000be5 ff07          .dw $FF07
000be6 2d69
000be7 6563
000be8 6c6c
000be9 002b          .db "i-cell+",0
000bea 0bcb          .dw VE_HEAD
                     .set VE_HEAD = VE_ICELLPLUS
                 XT_ICELLPLUS:
000beb 1c00          .dw DO_COLON
                 PFA_ICELLPLUS:
000bec 1e29          .dw XT_1PLUS
000bed 1c1a          .dw XT_EXIT
                 
                 .include "words/edefer-fetch.asm"
                 
                 ; System
                 ; does the real defer@ for eeprom defers
                 VE_EDEFERFETCH:
000bee ff07          .dw $ff07
000bef 6445
000bf0 6665
000bf1 7265
000bf2 0040          .db "Edefer@",0
000bf3 0be5          .dw VE_HEAD
                     .set VE_HEAD = VE_EDEFERFETCH
                 XT_EDEFERFETCH:
000bf4 1c00          .dw DO_COLON
                 PFA_EDEFERFETCH:
000bf5 1fba          .dw XT_FETCHI
000bf6 1f4d          .dw XT_FETCHE
000bf7 1c1a          .dw XT_EXIT
                 .include "words/edefer-store.asm"
                 
                 ; System
                 ; does the real defer! for eeprom defers
                 VE_EDEFERSTORE:
000bf8 ff07          .dw $ff07
000bf9 6445
000bfa 6665
000bfb 7265
000bfc 0021          .db "Edefer!",0
000bfd 0bee          .dw VE_HEAD
                     .set VE_HEAD = VE_EDEFERSTORE
                 XT_EDEFERSTORE:
000bfe 1c00          .dw DO_COLON
                 PFA_EDEFERSTORE:
000bff 1fba          .dw XT_FETCHI
000c00 1f29          .dw XT_STOREE
000c01 1c1a          .dw XT_EXIT
                 .include "words/rdefer-fetch.asm"
                 
                 ; System
                 ; The defer@ for ram defers
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_RDEFERFETCH:
000c02 ff07          .dw $ff07
000c03 6452
000c04 6665
000c05 7265
000c06 0040          .db "Rdefer@",0
000c07 0bf8          .dw VE_HEAD
                     .set VE_HEAD = VE_RDEFERFETCH
                 XT_RDEFERFETCH:
000c08 1c00          .dw DO_COLON
                 PFA_RDEFERFETCH:
                 .endif
000c09 1fba          .dw XT_FETCHI
000c0a 1c73          .dw XT_FETCH
000c0b 1c1a          .dw XT_EXIT
                 .include "words/rdefer-store.asm"
                 
                 ; System
                 ; The defer! for ram defers
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_RDEFERSTORE:
000c0c ff07          .dw $ff07
000c0d 6452
000c0e 6665
000c0f 7265
000c10 0021          .db "Rdefer!",0
000c11 0c02          .dw VE_HEAD
                     .set VE_HEAD = VE_RDEFERSTORE
                 XT_RDEFERSTORE:
000c12 1c00          .dw DO_COLON
                 PFA_RDEFERSTORE:
                 .endif
000c13 1fba          .dw XT_FETCHI
000c14 1c7b          .dw XT_STORE
000c15 1c1a          .dw XT_EXIT
                 
                 .include "words/udefer-fetch.asm"
                 
                 ; System
                 ; does the real defer@ for user based defers
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_UDEFERFETCH:
000c16 ff07          .dw $ff07
000c17 6455
000c18 6665
000c19 7265
000c1a 0040          .db "Udefer@",0
000c1b 0c0c          .dw VE_HEAD
                     .set VE_HEAD = VE_UDEFERFETCH
                 XT_UDEFERFETCH:
000c1c 1c00          .dw DO_COLON
                 PFA_UDEFERFETCH:
                 .endif
000c1d 1fba          .dw XT_FETCHI
000c1e 1ef0          .dw XT_UP_FETCH
000c1f 1d97          .dw XT_PLUS
000c20 1c73          .dw XT_FETCH
000c21 1c1a          .dw XT_EXIT
                 .include "words/udefer-store.asm"
                 
                 ; System
                 ; does the real defer! for user based defers
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_UDEFERSTORE:
000c22 ff07          .dw $ff07
000c23 6455
000c24 6665
000c25 7265
000c26 0021          .db "Udefer!",0
000c27 0c16          .dw VE_HEAD
                     .set VE_HEAD = VE_UDEFERSTORE
                 XT_UDEFERSTORE:
000c28 1c00          .dw DO_COLON
                 PFA_UDEFERSTORE:
                 .endif
                 
000c29 1fba          .dw XT_FETCHI
000c2a 1ef0          .dw XT_UP_FETCH
000c2b 1d97          .dw XT_PLUS
000c2c 1c7b          .dw XT_STORE
000c2d 1c1a          .dw XT_EXIT
                 
                 .include "words/defer-store.asm"
                 
                 ; System
                 ; stores xt1 as the xt to be executed when xt2 is called
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DEFERSTORE:
000c2e ff06          .dw $ff06
000c2f 6564
000c30 6566
000c31 2172          .db "defer!"
000c32 0c22          .dw VE_HEAD
                     .set VE_HEAD = VE_DEFERSTORE
                 XT_DEFERSTORE:
000c33 1c00          .dw DO_COLON
                 PFA_DEFERSTORE:
                 .endif
000c34 0dac          .dw XT_TO_BODY
000c35 1cab          .dw XT_DUP
000c36 0beb          .dw XT_ICELLPLUS
000c37 0beb          .dw XT_ICELLPLUS
000c38 1fba          .dw XT_FETCHI
000c39 1c24          .dw XT_EXECUTE
000c3a 1c1a          .dw XT_EXIT
                 
                 .include "words/defer-fetch.asm"
                 
                 ; System
                 ; returns the XT associated with the given XT
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DEFERFETCH:
000c3b ff06          .dw $ff06
000c3c 6564
000c3d 6566
000c3e 4072          .db "defer@"
000c3f 0c2e          .dw VE_HEAD
                     .set VE_HEAD = VE_DEFERFETCH
                 XT_DEFERFETCH:
000c40 1c00          .dw DO_COLON
                 PFA_DEFERFETCH:
                 .endif
000c41 0dac          .dw XT_TO_BODY 
000c42 1cab          .dw XT_DUP
000c43 0beb          .dw XT_ICELLPLUS
000c44 1fba          .dw XT_FETCHI
000c45 1c24          .dw XT_EXECUTE
000c46 1c1a          .dw XT_EXIT
                 .include "words/do-defer.asm"
                 
                 ; System
                 ; runtime of defer
                 VE_DODEFER:
000c47 ff07          .dw $ff07
000c48 6428
000c49 6665
000c4a 7265
000c4b 0029          .db "(defer)", 0
000c4c 0c3b          .dw VE_HEAD
                     .set VE_HEAD = VE_DODEFER
                 XT_DODEFER:
000c4d 1c00          .dw DO_COLON
                 PFA_DODEFER:
000c4e 0241          .dw XT_DOCREATE
000c4f 03a5          .dw XT_REVEAL
000c50 0267          .dw XT_COMPILE
000c51 0c53          .dw PFA_DODEFER1
000c52 1c1a          .dw XT_EXIT
                 PFA_DODEFER1:
000c53 940e 03c9     call_ DO_DODOES
000c55 1cab          .dw XT_DUP
000c56 0beb          .dw XT_ICELLPLUS
000c57 1fba          .dw XT_FETCHI
000c58 1c24          .dw XT_EXECUTE 
000c59 1c24          .dw XT_EXECUTE
000c5a 1c1a          .dw XT_EXIT
                 
                 ; : (defer) <builds does> dup i-cell+ @i execute execute ;
                 
                 
                 .include "words/search-wordlist.asm"
                 
                 ; Search Order
                 ; searches the word list wid for the word at c-addr/len
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SEARCH_WORDLIST:
000c5b ff0f          .dw $ff0f
000c5c 6573
000c5d 7261
000c5e 6863
000c5f 772d
000c60 726f
000c61 6c64
000c62 7369
000c63 0074          .db "search-wordlist",0
000c64 0c47          .dw VE_HEAD
                     .set VE_HEAD = VE_SEARCH_WORDLIST
                 XT_SEARCH_WORDLIST:
000c65 1c00          .dw DO_COLON
                 PFA_SEARCH_WORDLIST:
                 .endif
000c66 1cf9          .dw XT_TO_R
000c67 1d4e          .dw XT_ZERO
000c68 1c37          .dw XT_DOLITERAL
000c69 0c7a          .dw XT_ISWORD
000c6a 1cf0          .dw XT_R_FROM
000c6b 0c97          .dw XT_TRAVERSEWORDLIST
000c6c 1cab          .dw XT_DUP
000c6d 1d14          .dw XT_ZEROEQUAL
000c6e 1c30          .dw XT_DOCONDBRANCH
000c6f 0c74          DEST(PFA_SEARCH_WORDLIST1)
000c70 05b9             .dw XT_2DROP
000c71 1cd3             .dw XT_DROP
000c72 1d4e             .dw XT_ZERO
000c73 1c1a             .dw XT_EXIT
                 PFA_SEARCH_WORDLIST1:
                       ; ... get the XT ...
000c74 1cab            .dw XT_DUP
000c75 0cbe            .dw XT_NFA2CFA
                       ; .. and get the header flag
000c76 1cbe            .dw XT_SWAP
000c77 0112            .dw XT_NAME2FLAGS
000c78 00ff            .dw XT_IMMEDIATEQ
000c79 1c1a          .dw XT_EXIT
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 XT_ISWORD:
000c7a 1c00          .dw DO_COLON
                 PFA_ISWORD:
                 .endif
                     ; ( c-addr len 0 nt -- c-addr len 0 true| nt false )
000c7b 1cf9          .dw XT_TO_R
000c7c 1cd3          .dw XT_DROP
000c7d 05b0          .dw XT_2DUP
000c7e 1d02          .dw XT_R_FETCH  ; -- addr len addr len nt
000c7f 0cb2          .dw XT_NAME2STRING
000c80 0cc8          .dw XT_ICOMPARE      ; (-- addr len f )
000c81 1c30          .dw XT_DOCONDBRANCH
000c82 0c88          DEST(PFA_ISWORD3)
                       ; not now
000c83 1cf0            .dw XT_R_FROM
000c84 1cd3            .dw XT_DROP
000c85 1d4e            .dw XT_ZERO
000c86 1d45            .dw XT_TRUE         ; maybe next word
000c87 1c1a            .dw XT_EXIT
                 PFA_ISWORD3:
                       ; we found the word, now clean up iteration data ...
000c88 05b9            .dw XT_2DROP
000c89 1cf0            .dw XT_R_FROM
000c8a 1d4e            .dw XT_ZERO       ; finish traverse-wordlist
000c8b 1c1a            .dw XT_EXIT
                 .include "words/traverse-wordlist.asm"
                 
                 ; Tools Ext (2012)
                 ; call the xt for every member of the wordlist wid until xt returns false
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_TRAVERSEWORDLIST:
000c8c ff11          .dw $ff11
000c8d 7274
000c8e 7661
000c8f 7265
000c90 6573
000c91 772d
000c92 726f
000c93 6c64
000c94 7369
000c95 0074          .db "traverse-wordlist",0
000c96 0c5b          .dw VE_HEAD
                     .set VE_HEAD = VE_TRAVERSEWORDLIST
                 XT_TRAVERSEWORDLIST:
000c97 1c00          .dw DO_COLON
                 PFA_TRAVERSEWORDLIST:
                 
                 .endif
000c98 1f4d          .dw XT_FETCHE
                 PFA_TRAVERSEWORDLIST1:
000c99 1cab          .dw XT_DUP           ; ( -- xt nt nt )
000c9a 1c30          .dw XT_DOCONDBRANCH  ; ( -- nt ) is nfa = counted string
000c9b 0ca8          DEST(PFA_TRAVERSEWORDLIST2)
000c9c 05b0          .dw XT_2DUP
000c9d 1f0c          .dw XT_2TO_R
000c9e 1cbe          .dw XT_SWAP
000c9f 1c24          .dw XT_EXECUTE
000ca0 1f1b          .dw XT_2R_FROM
000ca1 1cdb          .dw XT_ROT
000ca2 1c30          .dw XT_DOCONDBRANCH
000ca3 0ca8          DEST(PFA_TRAVERSEWORDLIST2)
000ca4 0522          .dw XT_NFA2LFA
000ca5 1fba          .dw XT_FETCHI
000ca6 1c29          .dw XT_DOBRANCH      ; ( -- addr )
000ca7 0c99          DEST(PFA_TRAVERSEWORDLIST1)       ; ( -- addr )
                 PFA_TRAVERSEWORDLIST2:
000ca8 05b9          .dw XT_2DROP
000ca9 1c1a          .dw XT_EXIT
                 
                 ; : traverse-wordlist ( i*x xt wid -- i*x' ) 
                 ;        begin @ dup 
                 ;        while 
                 ;          2dup 2>r 
                 ;          cell + swap execute ( i*x nt -- i*x' f ) 
                 ;          2r> rot 
                 ;        while repeat then 2drop ; 
                 .include "words/name2string.asm"
                 
                 ; Tools Ext (2012)
                 ; get a (flash) string from a name token nt
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_NAME2STRING:
000caa ff0b          .dw $ff0b
000cab 616e
000cac 656d
000cad 733e
000cae 7274
000caf 6e69
000cb0 0067          .db "name>string",0
000cb1 0c8c          .dw VE_HEAD
                     .set VE_HEAD = VE_NAME2STRING
                 XT_NAME2STRING:
000cb2 1c00          .dw DO_COLON
                 PFA_NAME2STRING:
                 
                 .endif
000cb3 0823          .dw XT_ICOUNT   ; ( -- addr n )
000cb4 1c37          .dw XT_DOLITERAL
000cb5 00ff          .dw 255
000cb6 1e0d          .dw XT_AND      ; mask immediate bit
000cb7 1c1a          .dw XT_EXIT
                 .include "words/nfa2cfa.asm"
                 
                 ; Tools
                 ; get the XT from a name token
                 VE_NFA2CFA:
000cb8 ff07          .dw $ff07
000cb9 666e
000cba 3e61
000cbb 6663
../../avr8\words/nfa2cfa.asm(6): warning: .cseg .db misalignment - padding zero byte
000cbc 0061          .db "nfa>cfa"
000cbd 0caa          .dw VE_HEAD
                     .set VE_HEAD = VE_NFA2CFA
                 XT_NFA2CFA:
000cbe 1c00          .dw DO_COLON
                 PFA_NFA2CFA:
000cbf 0522          .dw XT_NFA2LFA ; skip to link field
000cc0 1e29          .dw XT_1PLUS   ; next is the execution token
000cc1 1c1a          .dw XT_EXIT
                 .include "words/icompare.asm"
                 
                 ; Tools
                 ; compares string in RAM with string in flash. f is zero if equal like COMPARE
                 VE_ICOMPARE:
000cc2 ff08          .dw $ff08
000cc3 6369
000cc4 6d6f
000cc5 6170
000cc6 6572          .db "icompare"
000cc7 0cb8          .dw VE_HEAD
                     .set VE_HEAD = VE_ICOMPARE
                 XT_ICOMPARE:
000cc8 1c00          .dw DO_COLON
                 PFA_ICOMPARE:
000cc9 1cf9          .dw XT_TO_R    ; ( -- r-addr r-len f-addr)
000cca 1cc9          .dw XT_OVER    ; ( -- r-addr r-len f-addr r-len)
000ccb 1cf0          .dw XT_R_FROM  ; ( -- r-addr r-len f-addr r-len f-len )
000ccc 1d0d          .dw XT_NOTEQUAL ; ( -- r-addr r-len f-addr flag )
000ccd 1c30          .dw XT_DOCONDBRANCH
000cce 0cd3          .dw PFA_ICOMPARE_SAMELEN
000ccf 05b9            .dw XT_2DROP
000cd0 1cd3            .dw XT_DROP
000cd1 1d45            .dw XT_TRUE
000cd2 1c1a            .dw XT_EXIT
                 PFA_ICOMPARE_SAMELEN:
000cd3 1cbe          .dw XT_SWAP ; ( -- r-addr f-addr len )
000cd4 1d4e          .dw XT_ZERO
000cd5 0331          .dw XT_QDOCHECK
000cd6 1c30          .dw XT_DOCONDBRANCH
000cd7 0cf6          .dw PFA_ICOMPARE_DONE
000cd8 1e89          .dw XT_DODO
                 PFA_ICOMPARE_LOOP:
                     ; ( r-addr f-addr --)
000cd9 1cc9          .dw XT_OVER
000cda 1c73          .dw XT_FETCH
                 .if WANT_IGNORECASE == 1
                 .endif
000cdb 1cc9          .dw XT_OVER
000cdc 1fba          .dw XT_FETCHI ; ( -- r-addr f-addr r-cc f- cc)
                 .if WANT_IGNORECASE == 1
                 .endif
                     ; flash strings are zero-padded at the last cell
                     ; that means: if the flash cell is less $0100, than mask the
                     ; high byte in the ram cell
000cdd 1cab          .dw XT_DUP
                     ;.dw XT_BYTESWAP
000cde 1c37          .dw XT_DOLITERAL
000cdf 0100          .dw $100
000ce0 1d56          .dw XT_ULESS
000ce1 1c30          .dw XT_DOCONDBRANCH
000ce2 0ce7          .dw PFA_ICOMPARE_LASTCELL
000ce3 1cbe          .dw XT_SWAP
000ce4 1c37          .dw XT_DOLITERAL
000ce5 00ff          .dw $00FF
000ce6 1e0d          .dw XT_AND  ; the final swap can be omitted
                 PFA_ICOMPARE_LASTCELL:
000ce7 1d0d          .dw XT_NOTEQUAL
000ce8 1c30          .dw XT_DOCONDBRANCH
000ce9 0cee          .dw PFA_ICOMPARE_NEXTLOOP
000cea 05b9          .dw XT_2DROP
000ceb 1d45          .dw XT_TRUE
000cec 1ec2          .dw XT_UNLOOP
000ced 1c1a          .dw XT_EXIT
                 PFA_ICOMPARE_NEXTLOOP:
000cee 1e29          .dw XT_1PLUS
000cef 1cbe          .dw XT_SWAP
000cf0 05a8          .dw XT_CELLPLUS
000cf1 1cbe          .dw XT_SWAP
000cf2 1c37          .dw XT_DOLITERAL
000cf3 0002          .dw 2
000cf4 1ea8          .dw XT_DOPLUSLOOP
000cf5 0cd9          .dw PFA_ICOMPARE_LOOP
                 PFA_ICOMPARE_DONE:
000cf6 05b9          .dw XT_2DROP
000cf7 1d4e          .dw XT_ZERO
000cf8 1c1a          .dw XT_EXIT
                 
                 .if WANT_IGNORECASE == 1
                 .endif
                 
                 .include "words/star.asm"
                 
                 ; Arithmetics
                 ; multiply routine
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_STAR:
000cf9 ff01          .dw $ff01
000cfa 002a          .db "*",0
000cfb 0cc2          .dw VE_HEAD
                     .set VE_HEAD = VE_STAR
                 XT_STAR:
000cfc 1c00          .dw DO_COLON
                 PFA_STAR:
                 .endif
                 
000cfd 1da0          .dw XT_MSTAR
000cfe 1cd3          .dw XT_DROP
000cff 1c1a          .dw XT_EXIT
                 .include "words/j.asm"
                 
                 ; Compiler
                 ; loop counter of outer loop
                 VE_J:
000d00 ff01          .dw $FF01
000d01 006a          .db "j",0
000d02 0cf9          .dw VE_HEAD
                     .set VE_HEAD = VE_J
                 XT_J:
000d03 1c00          .dw DO_COLON
                 PFA_J:
000d04 1e64          .dw XT_RP_FETCH
000d05 1c37          .dw XT_DOLITERAL
000d06 0007          .dw 7
000d07 1d97          .dw XT_PLUS
000d08 1c73          .dw XT_FETCH
000d09 1e64          .dw XT_RP_FETCH
000d0a 1c37          .dw XT_DOLITERAL
000d0b 0009          .dw 9
000d0c 1d97          .dw XT_PLUS
000d0d 1c73          .dw XT_FETCH
000d0e 1d97          .dw XT_PLUS
000d0f 1c1a          .dw XT_EXIT
                 
                 .include "words/dabs.asm"
                 
                 ; Arithmetics
                 ; double cell absolute value
                 VE_DABS:
000d10 ff04          .dw $ff04
000d11 6164
000d12 7362          .db "dabs"
000d13 0d00          .dw VE_HEAD
                     .set VE_HEAD = VE_DABS
                 XT_DABS:
000d14 1c00          .dw DO_COLON
                 PFA_DABS:
000d15 1cab          .dw XT_DUP
000d16 1d1b          .dw XT_ZEROLESS
000d17 1c30          .dw XT_DOCONDBRANCH
000d18 0d1a          .dw PFA_DABS1
000d19 0d21          .dw XT_DNEGATE
                 PFA_DABS1:
000d1a 1c1a          .dw XT_EXIT
                 ; : dabs      ( ud1 -- +d2 ) dup 0< if dnegate then ;
                 .include "words/dnegate.asm"
                 
                 ; Arithmetics
                 ; double cell negation
                 VE_DNEGATE:
000d1b ff07          .dw $ff07
000d1c 6e64
000d1d 6765
000d1e 7461
000d1f 0065          .db "dnegate",0
000d20 0d10          .dw VE_HEAD
                     .set VE_HEAD = VE_DNEGATE
                 XT_DNEGATE:
000d21 1c00          .dw DO_COLON
                 PFA_DNEGATE:
000d22 0183          .dw XT_DINVERT
000d23 1c37          .dw XT_DOLITERAL
000d24 0001          .dw 1
000d25 1d4e          .dw XT_ZERO
000d26 015b          .dw XT_DPLUS
000d27 1c1a          .dw XT_EXIT
                 ; : dnegate   ( ud1 -- ud2 ) dinvert 1. d+ ;
                 .include "words/cmove.asm"
                 
                 ; Memory
                 ; copy data in RAM, from lower to higher addresses
                 VE_CMOVE:
000d28 ff05          .dw $ff05
000d29 6d63
000d2a 766f
000d2b 0065          .db "cmove",0
000d2c 0d1b          .dw VE_HEAD
                     .set VE_HEAD  = VE_CMOVE
                 XT_CMOVE:
000d2d 0d2e          .dw PFA_CMOVE
                 PFA_CMOVE:
000d2e 93bf          push xh
000d2f 93af          push xl
000d30 91e9          ld zl, Y+
000d31 91f9          ld zh, Y+ ; addr-to
000d32 91a9          ld xl, Y+
000d33 91b9          ld xh, Y+ ; addr-from
000d34 2f09          mov temp0, tosh
000d35 2b08          or temp0, tosl
000d36 f021          brbs 1, PFA_CMOVE1
                 PFA_CMOVE2:
000d37 911d          ld temp1, X+
000d38 9311          st Z+, temp1
000d39 9701          sbiw tosl, 1
000d3a f7e1          brbc 1, PFA_CMOVE2
                 PFA_CMOVE1:
000d3b 91af          pop xl
000d3c 91bf          pop xh
000d3d 9189
000d3e 9199          loadtos
000d3f 940c 1c04     jmp_ DO_NEXT
                 .include "words/2swap.asm"
                 
                 ; Stack
                 ; Exchange the two top cell pairs
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_2SWAP:
000d41 ff05          .dw $ff05
000d42 7332
000d43 6177
000d44 0070          .db "2swap",0
000d45 0d28          .dw VE_HEAD
                     .set VE_HEAD = VE_2SWAP
                 XT_2SWAP:
000d46 1c00          .dw DO_COLON
                 PFA_2SWAP:
                 
                 .endif
000d47 1cdb          .dw XT_ROT
000d48 1cf9          .dw XT_TO_R
000d49 1cdb          .dw XT_ROT
000d4a 1cf0          .dw XT_R_FROM
000d4b 1c1a          .dw XT_EXIT
                 
                 .include "words/tib.asm"
                 
                 ; System Variable
                 ; terminal input buffer address
                 VE_TIB:
000d4c ff03          .dw $ff03
000d4d 6974
000d4e 0062          .db "tib",0
000d4f 0d41          .dw VE_HEAD
                     .set VE_HEAD = VE_TIB
                 XT_TIB:
000d50 1c42          .dw PFA_DOVARIABLE
                 PFA_TIB:
000d51 014d          .dw ram_tib
                     
                 .dseg
00014d           ram_tib: .byte TIBSIZE
                 .cseg
                 ; ( -- f ) 
                 ; System
                 ; refills the input buffer
                 VE_REFILLTIB:
000d52 ff0a          .dw $ff0a
000d53 6572
000d54 6966
000d55 6c6c
000d56 742d
000d57 6269          .db "refill-tib"
000d58 0d4c          .dw VE_HEAD
                     .set VE_HEAD = VE_REFILLTIB
                 XT_REFILLTIB:
000d59 1c00          .dw DO_COLON
                 PFA_REFILLTIB:
000d5a 0d50          .dw XT_TIB
000d5b 1c37          .dw XT_DOLITERAL
000d5c 005a          .dw TIBSIZE
000d5d 08e1          .dw XT_ACCEPT
000d5e 05cf          .dw XT_NUMBERTIB
000d5f 1c7b          .dw XT_STORE
000d60 1d4e          .dw XT_ZERO
000d61 05c9          .dw XT_TO_IN
000d62 1c7b          .dw XT_STORE
000d63 1d45          .dw XT_TRUE ; -1
000d64 1c1a          .dw XT_EXIT
                 
                 ; ( -- addr n ) 
                 ; System
                 ; address and current length of the input buffer
                 VE_SOURCETIB:
000d65 ff0a          .dw $FF0A
000d66 6f73
000d67 7275
000d68 6563
000d69 742d
000d6a 6269          .db "source-tib"
000d6b 0d52          .dw VE_HEAD
                     .set VE_HEAD = VE_SOURCETIB
                 XT_SOURCETIB:
000d6c 1c00          .dw DO_COLON
                 PFA_SOURCETIB:
000d6d 0d50          .dw XT_TIB
000d6e 05cf          .dw XT_NUMBERTIB
000d6f 1c73          .dw XT_FETCH
000d70 1c1a          .dw XT_EXIT
                 
                 .include "words/init-user.asm"
                 
                 ; Tools
                 ; copy len cells from eeprom to ram
                 VE_EE2RAM:
000d71 ff06        .dw $ff06
000d72 6565
000d73 723e
000d74 6d61        .db "ee>ram"
000d75 0d65        .dw VE_HEAD
                   .set VE_HEAD = VE_EE2RAM
                 XT_EE2RAM:
000d76 1c00        .dw DO_COLON
                 PFA_EE2RAM:          ; ( -- )
000d77 1d4e          .dw XT_ZERO
000d78 1e89          .dw XT_DODO
                 PFA_EE2RAM_1:
                     ; ( -- e-addr r-addr )
000d79 1cc9          .dw XT_OVER
000d7a 1f4d          .dw XT_FETCHE
000d7b 1cc9          .dw XT_OVER
000d7c 1c7b          .dw XT_STORE
000d7d 05a8          .dw XT_CELLPLUS
000d7e 1cbe          .dw XT_SWAP
000d7f 05a8          .dw XT_CELLPLUS
000d80 1cbe          .dw XT_SWAP
000d81 1eb7          .dw XT_DOLOOP
000d82 0d79          .dw PFA_EE2RAM_1
                 PFA_EE2RAM_2:
000d83 05b9          .dw XT_2DROP
000d84 1c1a          .dw XT_EXIT
                 
                 ; ( -- )
                 ; Tools
                 ; setup the default user area from eeprom
                 VE_INITUSER:
000d85 ff09        .dw $ff09
000d86 6e69
000d87 7469
000d88 752d
000d89 6573
000d8a 0072        .db "init-user",0
000d8b 0d71        .dw VE_HEAD
                   .set VE_HEAD = VE_INITUSER
                 XT_INITUSER:
000d8c 1c00        .dw DO_COLON
                 PFA_INITUSER:          ; ( -- )
000d8d 1c37          .dw XT_DOLITERAL
000d8e 0064          .dw EE_INITUSER
000d8f 1ef0          .dw XT_UP_FETCH
000d90 1c37          .dw XT_DOLITERAL
000d91 001c          .dw SYSUSERSIZE
000d92 1dfe          .dw XT_2SLASH
000d93 0d76          .dw XT_EE2RAM
000d94 1c1a          .dw XT_EXIT
                 .include "words/bounds.asm"
                 
                 ; Tools
                 ; convert a string to an address range
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_BOUNDS:
000d95 ff06          .dw $ff06
000d96 6f62
000d97 6e75
000d98 7364          .db "bounds"
000d99 0d85          .dw VE_HEAD
                     .set VE_HEAD = VE_BOUNDS
                 XT_BOUNDS:
000d9a 1c00          .dw DO_COLON
                 PFA_BOUNDS:
                 .endif
000d9b 1cc9          .dw XT_OVER
000d9c 1d97          .dw XT_PLUS
000d9d 1cbe          .dw XT_SWAP
000d9e 1c1a          .dw XT_EXIT
                 .include "words/s-to-d.asm"
                 
                 ; Conversion
                 ; extend (signed) single cell value to double cell
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_S2D:
000d9f ff03          .dw $ff03
000da0 3e73
000da1 0064          .db "s>d",0
000da2 0d95          .dw VE_HEAD
                     .set VE_HEAD = VE_S2D
                 XT_S2D:
000da3 1c00          .dw DO_COLON
                 PFA_S2D:
                 .endif
000da4 1cab          .dw XT_DUP
000da5 1d1b          .dw XT_ZEROLESS
000da6 1c1a          .dw XT_EXIT
                 .include "words/to-body.asm"
                 
                 ; Core
                 ; get body from XT
                 VE_TO_BODY:
000da7 ff05          .dw $ff05
000da8 623e
000da9 646f
000daa 0079          .db ">body",0
000dab 0d9f          .dw VE_HEAD
                     .set VE_HEAD = VE_TO_BODY
                 XT_TO_BODY:
000dac 1e2a          .dw PFA_1PLUS
                 .else
                 .endif
                 .include "dict_appl.inc"
                 
                 ; they may be moved to the core dictionary if needed
                 
                 
                 .include "words/applturnkey.asm"
                 
                 ; R( -- )
                 ; application specific turnkey action
                 VE_APPLTURNKEY:
000dad ff0b          .dw $ff0b
000dae 7061
000daf 6c70
000db0 7574
000db1 6e72
000db2 656b
000db3 0079          .db "applturnkey",0
000db4 0da7          .dw VE_HEAD
                     .set VE_HEAD = VE_APPLTURNKEY
                 XT_APPLTURNKEY:
000db5 1c00          .dw DO_COLON
                 PFA_APPLTURNKEY:
000db6 00ae          .dw XT_USART
000db7 01ca          .dw XT_INTON
000db8 0ba3          .dw XT_DOT_VER
000db9 1c1a          .dw XT_EXIT
                 
                 
                 .set DPSTART = pc
                 .if(pc>AMFORTH_RO_SEG)
                 .endif
                 
                 .org AMFORTH_RO_SEG
                 .include "amforth-interpreter.asm"
                 
                 
                 DO_COLON:
001c00 93bf          push XH
001c01 93af          push XL          ; PUSH IP
001c02 01db          movw XL, wl
001c03 9611          adiw xl, 1
                 DO_NEXT:
001c04 f06e          brts DO_INTERRUPT
001c05 01fd          movw zl, XL        ; READ IP
001c06 0fee
001c07 1fff
001c08 9165
001c09 9175          readflashcell wl, wh
001c0a 9611          adiw XL, 1        ; INC IP
                 
                 DO_EXECUTE:
001c0b 01fb          movw zl, wl
001c0c 0fee
001c0d 1fff
001c0e 9105
001c0f 9115          readflashcell temp0,temp1
001c10 01f8          movw zl, temp0
001c11 9409          ijmp
                 
                 DO_INTERRUPT:
                     ; here we deal with interrupts the forth way
001c12 94e8          clt
001c13 ef68          ldi wl, LOW(XT_ISREXEC)
001c14 e071          ldi wh, HIGH(XT_ISREXEC)
001c15 cff5          rjmp DO_EXECUTE
                 .include "dict/nrww.inc"
                 
                 ; section together with the forth inner interpreter
                 
                 .include "words/exit.asm"
                 
                 ; Compiler
                 ; end of current colon word
                 VE_EXIT:
001c16 ff04          .dw $ff04
001c17 7865
001c18 7469          .db "exit"
001c19 0dad          .dw VE_HEAD
                     .set VE_HEAD = VE_EXIT
                 XT_EXIT:
001c1a 1c1b          .dw PFA_EXIT
                 PFA_EXIT:
001c1b 91af          pop XL
001c1c 91bf          pop XH
001c1d cfe6          jmp_ DO_NEXT
                 .include "words/execute.asm"
                 
                 ; System
                 ; execute XT
                 VE_EXECUTE:
001c1e ff07          .dw $ff07
001c1f 7865
001c20 6365
001c21 7475
001c22 0065          .db "execute",0
001c23 1c16          .dw VE_HEAD
                     .set VE_HEAD = VE_EXECUTE
                 XT_EXECUTE:
001c24 1c25          .dw PFA_EXECUTE
                 PFA_EXECUTE:
001c25 01bc          movw wl, tosl
001c26 9189
001c27 9199          loadtos
001c28 cfe2          jmp_ DO_EXECUTE
                 .include "words/dobranch.asm"
                 
                 ; System
                 ; runtime of branch
                 ;VE_DOBRANCH:
                 ;    .dw $ff08
                 ;    .db "(branch)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOBRANCH
                 XT_DOBRANCH:
001c29 1c2a          .dw PFA_DOBRANCH
                 PFA_DOBRANCH:
001c2a 01fd          movw zl, XL
001c2b 0fee
001c2c 1fff
001c2d 91a5
001c2e 91b5          readflashcell XL,XH
001c2f cfd4          jmp_ DO_NEXT
                 .include "words/docondbranch.asm"
                 
                 ; System
                 ; runtime of ?branch
                 ;VE_DOCONDBRANCH:
                 ;    .dw $ff09
                 ;    .db "(?branch)"
                 ;    .dw  VE_HEAD
                 ;    .set VE_HEAD = VE_DOCONDBRANCH
                 XT_DOCONDBRANCH:
001c30 1c31          .dw PFA_DOCONDBRANCH
                 PFA_DOCONDBRANCH:
001c31 2b98          or tosh, tosl
001c32 9189
001c33 9199          loadtos
001c34 f3a9          brbs 1, PFA_DOBRANCH ; 1 is z flag; if tos is zero (false), do the branch
001c35 9611          adiw XL, 1
001c36 cfcd          jmp_ DO_NEXT
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/doliteral.asm"
                 
                 ; System
                 ; runtime of literal
                 ;VE_DOLITERAL:
                 ;    .dw $ff09
                 ;    .db "(literal)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOLITERAL
                 XT_DOLITERAL:
001c37 1c38          .dw PFA_DOLITERAL
                 PFA_DOLITERAL:
001c38 939a
001c39 938a          savetos
001c3a 01fd          movw zl, xl
001c3b 0fee
001c3c 1fff
001c3d 9185
001c3e 9195          readflashcell tosl,tosh
001c3f 9611          adiw xl, 1
001c40 cfc3          jmp_ DO_NEXT
                 
                 .include "words/dovariable.asm"
                 
                 ; System
                 ; puts content of parameter field (1 cell) to TOS
                 ;VE_DOVARIABLE:
                 ;    .dw $ff0a
                 ;    .db "(variable)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOVARIABLE
                 XT_DOVARIABLE:
001c41 1c42          .dw PFA_DOVARIABLE
                 PFA_DOVARIABLE:
001c42 939a
001c43 938a          savetos
001c44 01fb          movw zl, wl
001c45 9631          adiw zl,1
001c46 0fee
001c47 1fff
001c48 9185
001c49 9195          readflashcell tosl,tosh
001c4a cfb9          jmp_ DO_NEXT
                 .include "words/doconstant.asm"
                 
                 ; System
                 ; place data field address on TOS
                 ;VE_DOCONSTANT:
                 ;    .dw $ff0a
                 ;    .db "(constant)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOCONSTANT
                 XT_DOCONSTANT:
001c4b 1c4c          .dw PFA_DOCONSTANT
                 PFA_DOCONSTANT:
001c4c 939a
001c4d 938a          savetos
001c4e 01cb          movw tosl, wl
001c4f 9601          adiw tosl, 1
001c50 cfb3          jmp_ DO_NEXT
                 .include "words/douser.asm"
                 
                 ; System
                 ; runtime part of user
                 ;VE_DOUSER:
                 ;    .dw $ff06
                 ;    .db "(user)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOUSER
                 XT_DOUSER:
001c51 1c52          .dw PFA_DOUSER
                 PFA_DOUSER:
001c52 939a
001c53 938a          savetos
001c54 01fb          movw zl, wl
001c55 9631          adiw zl, 1
001c56 0fee
001c57 1fff
001c58 9185
001c59 9195          readflashcell tosl,tosh
001c5a 0d84          add tosl, upl
001c5b 1d95          adc tosh, uph
001c5c cfa7          jmp_ DO_NEXT
                 .include "words/do-value.asm"
                 
                 ; System
                 ; runtime of value
                 VE_DOVALUE:
001c5d ff07          .dw $ff07
001c5e 7628
001c5f 6c61
001c60 6575
001c61 0029          .db "(value)", 0
001c62 1c1e          .dw VE_HEAD
                     .set VE_HEAD = VE_DOVALUE
                 XT_DOVALUE:
001c63 1c00          .dw DO_COLON
                 PFA_DOVALUE:
001c64 0241          .dw XT_DOCREATE
001c65 03a5          .dw XT_REVEAL
001c66 0267          .dw XT_COMPILE
001c67 1c69          .dw PFA_DOVALUE1
001c68 1c1a          .dw XT_EXIT
                 PFA_DOVALUE1:
001c69 940e 03c9     call_ DO_DODOES
001c6b 1cab          .dw XT_DUP
001c6c 0beb          .dw XT_ICELLPLUS
001c6d 1fba          .dw XT_FETCHI
001c6e 1c24          .dw XT_EXECUTE
001c6f 1c1a          .dw XT_EXIT
                 
                 ; : (value) <builds does> dup icell+ @i execute ;
                 .include "words/fetch.asm"
                 
                 ; Memory
                 ; read 1 cell from RAM address
                 VE_FETCH:
001c70 ff01          .dw $ff01
001c71 0040          .db "@",0
001c72 1c5d          .dw VE_HEAD
                     .set VE_HEAD = VE_FETCH
                 XT_FETCH:
001c73 1c74          .dw PFA_FETCH
                 PFA_FETCH:
                 .if WANT_UNIFIED == 1
                 .endif
                 PFA_FETCHRAM:
001c74 01fc          movw zl, tosl
                     ; low byte is read before the high byte
001c75 9181          ld tosl, z+
001c76 9191          ld tosh, z+
001c77 cf8c          jmp_ DO_NEXT
                 .if WANT_UNIFIED == 1
                 .endif
                 .include "words/store.asm"
                 
                 ; Memory
                 ; write n to RAM memory at addr, low byte first
                 VE_STORE:
001c78 ff01          .dw $ff01
001c79 0021          .db "!",0
001c7a 1c70          .dw VE_HEAD
                     .set VE_HEAD = VE_STORE
                 XT_STORE:
001c7b 1c7c          .dw PFA_STORE
                 PFA_STORE:
                 .if WANT_UNIFIED == 1
                 .endif
                 PFA_STORERAM:
001c7c 01fc          movw zl, tosl
001c7d 9189
001c7e 9199          loadtos
                     ; the high byte is written before the low byte
001c7f 8391          std Z+1, tosh
001c80 8380          std Z+0, tosl
001c81 9189
001c82 9199          loadtos
001c83 cf80          jmp_ DO_NEXT
                 .if WANT_UNIFIED == 1
                 .endif
                 .include "words/cstore.asm"
                 
                 ; Memory
                 ; store a single byte to RAM address
                 VE_CSTORE:
001c84 ff02          .dw $ff02
001c85 2163          .db "c!"
001c86 1c78          .dw VE_HEAD
                     .set VE_HEAD = VE_CSTORE
                 XT_CSTORE:
001c87 1c88          .dw PFA_CSTORE
                 PFA_CSTORE:
001c88 01fc          movw zl, tosl
001c89 9189
001c8a 9199          loadtos
001c8b 8380          st Z, tosl
001c8c 9189
001c8d 9199          loadtos
001c8e cf75          jmp_ DO_NEXT
                 .include "words/cfetch.asm"
                 
                 ; Memory
                 ; fetch a single byte from memory mapped locations
                 VE_CFETCH:
001c8f ff02          .dw $ff02
001c90 4063          .db "c@"
001c91 1c84          .dw VE_HEAD
                     .set VE_HEAD  = VE_CFETCH
                 XT_CFETCH:
001c92 1c93          .dw PFA_CFETCH
                 PFA_CFETCH:
001c93 01fc          movw zl, tosl
001c94 2799          clr tosh
001c95 8180          ld tosl, Z
001c96 cf6d          jmp_ DO_NEXT
                 .include "words/fetch-u.asm"
                 
                 ; Memory
                 ; read 1 cell from USER area
                 VE_FETCHU:
001c97 ff02          .dw $ff02
001c98 7540          .db "@u"
001c99 1c8f          .dw VE_HEAD
                     .set VE_HEAD = VE_FETCHU
                 XT_FETCHU:
001c9a 1c00          .dw DO_COLON
                 PFA_FETCHU:
001c9b 1ef0          .dw XT_UP_FETCH
001c9c 1d97          .dw XT_PLUS
001c9d 1c73          .dw XT_FETCH
001c9e 1c1a          .dw XT_EXIT
                 .include "words/store-u.asm"
                 
                 ; Memory
                 ; write n to USER area at offset
                 VE_STOREU:
001c9f ff02          .dw $ff02
001ca0 7521          .db "!u"
001ca1 1c97          .dw VE_HEAD
                     .set VE_HEAD = VE_STOREU
                 XT_STOREU:
001ca2 1c00          .dw DO_COLON
                 PFA_STOREU:
001ca3 1ef0          .dw XT_UP_FETCH
001ca4 1d97          .dw XT_PLUS
001ca5 1c7b          .dw XT_STORE
001ca6 1c1a          .dw XT_EXIT
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/dup.asm"
                 
                 ; Stack
                 ; duplicate TOS
                 VE_DUP:
001ca7 ff03          .dw $ff03
001ca8 7564
001ca9 0070          .db "dup",0
001caa 1c9f          .dw VE_HEAD
                     .set VE_HEAD = VE_DUP
                 XT_DUP:
001cab 1cac          .dw PFA_DUP
                 PFA_DUP:
001cac 939a
001cad 938a          savetos
001cae cf55          jmp_ DO_NEXT
                 .include "words/qdup.asm"
                 
                 ; Stack
                 ; duplicate TOS if non-zero
                 VE_QDUP:
001caf ff04          .dw $ff04
001cb0 643f
001cb1 7075          .db "?dup"
001cb2 1ca7          .dw VE_HEAD
                     .set VE_HEAD = VE_QDUP
                 XT_QDUP:
001cb3 1cb4          .dw PFA_QDUP
                 PFA_QDUP:
001cb4 2f08          mov temp0, tosl
001cb5 2b09          or temp0, tosh
001cb6 f011          breq PFA_QDUP1
001cb7 939a
001cb8 938a          savetos
                 PFA_QDUP1:
001cb9 cf4a          jmp_ DO_NEXT
                 .include "words/swap.asm"
                 
                 ; Stack
                 ; swaps the two top level stack cells
                 VE_SWAP:
001cba ff04          .dw $ff04
001cbb 7773
001cbc 7061          .db "swap"
001cbd 1caf          .dw VE_HEAD
                     .set VE_HEAD = VE_SWAP
                 XT_SWAP:
001cbe 1cbf          .dw PFA_SWAP
                 PFA_SWAP:
001cbf 018c          movw temp0, tosl
001cc0 9189
001cc1 9199          loadtos
001cc2 931a          st -Y, temp1
001cc3 930a          st -Y, temp0
001cc4 cf3f          jmp_ DO_NEXT
                 .include "words/over.asm"
                 
                 ; Stack
                 ; Place a copy of x1 on top of the stack
                 VE_OVER:
001cc5 ff04          .dw $ff04
001cc6 766f
001cc7 7265          .db "over"
001cc8 1cba          .dw VE_HEAD
                     .set VE_HEAD = VE_OVER
                 XT_OVER:
001cc9 1cca          .dw PFA_OVER
                 PFA_OVER:
001cca 939a
001ccb 938a          savetos
001ccc 818a          ldd tosl, Y+2
001ccd 819b          ldd tosh, Y+3
                 
001cce cf35          jmp_ DO_NEXT
                 .include "words/drop.asm"
                 
                 ; Stack
                 ; drop TOS
                 VE_DROP:
001ccf ff04          .dw $ff04
001cd0 7264
001cd1 706f          .db "drop"
001cd2 1cc5          .dw VE_HEAD
                     .set VE_HEAD = VE_DROP
                 XT_DROP:
001cd3 1cd4          .dw PFA_DROP
                 PFA_DROP:
001cd4 9189
001cd5 9199          loadtos
001cd6 cf2d          jmp_ DO_NEXT
                 .include "words/rot.asm"
                 
                 ; Stack
                 ; rotate the three top level cells
                 VE_ROT:
001cd7 ff03          .dw $ff03
001cd8 6f72
001cd9 0074          .db "rot",0
001cda 1ccf          .dw VE_HEAD
                     .set VE_HEAD = VE_ROT
                 XT_ROT:
001cdb 1cdc          .dw PFA_ROT
                 PFA_ROT:
001cdc 018c          movw temp0, tosl
001cdd 9129          ld temp2, Y+
001cde 9139          ld temp3, Y+ 
001cdf 9189
001ce0 9199          loadtos
                         
001ce1 933a          st -Y, temp3
001ce2 932a          st -Y, temp2
001ce3 931a          st -Y, temp1
001ce4 930a          st -Y, temp0
                 
001ce5 cf1e          jmp_ DO_NEXT
                 .include "words/nip.asm"
                 
                 ; Stack
                 ; Remove Second of Stack
                 VE_NIP:
001ce6 ff03          .dw $ff03
001ce7 696e
001ce8 0070          .db "nip",0
001ce9 1cd7          .dw VE_HEAD
                     .set VE_HEAD = VE_NIP
                 XT_NIP:
001cea 1ceb          .dw PFA_NIP
                 PFA_NIP:
001ceb 9622          adiw yl, 2
001cec cf17          jmp_ DO_NEXT
                 ;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/r_from.asm"
                 
                 ; Stack
                 ; move TOR to TOS
                 VE_R_FROM:
001ced ff02          .dw $ff02
001cee 3e72          .db "r>"
001cef 1ce6          .dw VE_HEAD
                     .set VE_HEAD = VE_R_FROM
                 XT_R_FROM:
001cf0 1cf1          .dw PFA_R_FROM
                 PFA_R_FROM:
001cf1 939a
001cf2 938a          savetos
001cf3 918f          pop tosl
001cf4 919f          pop tosh
001cf5 cf0e          jmp_ DO_NEXT
                 .include "words/to_r.asm"
                 
                 ; Stack
                 ; move TOS to TOR
                 VE_TO_R:
001cf6 ff02          .dw $ff02
001cf7 723e          .db ">r"
001cf8 1ced          .dw VE_HEAD
                     .set VE_HEAD = VE_TO_R
                 XT_TO_R:
001cf9 1cfa          .dw PFA_TO_R
                 PFA_TO_R:
001cfa 939f          push tosh
001cfb 938f          push tosl
001cfc 9189
001cfd 9199          loadtos
001cfe cf05          jmp_ DO_NEXT
                 .include "words/r_fetch.asm"
                 
                 ; Stack
                 ; fetch content of TOR
                 VE_R_FETCH:
001cff ff02          .dw $ff02
001d00 4072          .db "r@"
001d01 1cf6          .dw VE_HEAD
                     .set VE_HEAD = VE_R_FETCH
                 XT_R_FETCH:
001d02 1d03          .dw PFA_R_FETCH
                 PFA_R_FETCH:
001d03 939a
001d04 938a          savetos
001d05 918f          pop tosl
001d06 919f          pop tosh
001d07 939f          push tosh
001d08 938f          push tosl
001d09 cefa          jmp_ DO_NEXT
                 
                 
                 .include "words/not-equal.asm"
                 
                 ; Compare
                 ; true if n1 is not equal to n2
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_NOTEQUAL:
001d0a ff02          .dw $ff02
001d0b 3e3c          .db "<>"
001d0c 1cff          .dw VE_HEAD
                     .set VE_HEAD = VE_NOTEQUAL
                 XT_NOTEQUAL:
001d0d 1c00          .dw DO_COLON
                 PFA_NOTEQUAL:
                 .endif
                 
001d0e 1fd3
001d0f 1d14
001d10 1c1a          .DW XT_EQUAL,XT_ZEROEQUAL,XT_EXIT
                 .include "words/equalzero.asm"
                 
                 ; Compare
                 ; compare with 0 (zero)
                 VE_ZEROEQUAL:
001d11 ff02          .dw $ff02
001d12 3d30          .db "0="
001d13 1d0a          .dw VE_HEAD
                     .set VE_HEAD = VE_ZEROEQUAL
                 XT_ZEROEQUAL:
001d14 1d15          .dw PFA_ZEROEQUAL
                 PFA_ZEROEQUAL:
001d15 2b98          or tosh, tosl
001d16 f5d1          brne PFA_ZERO1
001d17 c030          rjmp PFA_TRUE1
                 .include "words/lesszero.asm"
                 
                 ; Compare
                 ; compare with zero
                 VE_ZEROLESS:
001d18 ff02          .dw $ff02
001d19 3c30          .db "0<"
001d1a 1d11          .dw VE_HEAD
                     .set VE_HEAD = VE_ZEROLESS
                 XT_ZEROLESS:
001d1b 1d1c          .dw PFA_ZEROLESS
                 PFA_ZEROLESS:
001d1c fd97          sbrc tosh,7
001d1d c02a          rjmp PFA_TRUE1
001d1e c032          rjmp PFA_ZERO1
                 .include "words/greaterzero.asm"
                 
                 ; Compare
                 ; true if n1 is greater than 0
                 VE_GREATERZERO:
001d1f ff02          .dw $ff02
001d20 3e30          .db "0>"
001d21 1d18          .dw VE_HEAD
                     .set VE_HEAD = VE_GREATERZERO
                 XT_GREATERZERO:
001d22 1d23          .dw PFA_GREATERZERO
                 PFA_GREATERZERO:
001d23 1582          cp tosl, zerol
001d24 0593          cpc tosh, zeroh
001d25 f15c          brlt PFA_ZERO1
001d26 f151          brbs 1, PFA_ZERO1
001d27 c020          rjmp PFA_TRUE1
                 .include "words/d-greaterzero.asm"
                 
                 ; Compare
                 ; compares if a double double cell number is greater 0
                 VE_DGREATERZERO:
001d28 ff03          .dw $ff03
001d29 3064
001d2a 003e          .db "d0>",0
001d2b 1d1f          .dw VE_HEAD
                     .set VE_HEAD = VE_DGREATERZERO
                 XT_DGREATERZERO:
001d2c 1d2d          .dw PFA_DGREATERZERO
                 PFA_DGREATERZERO:
001d2d 1582          cp tosl, zerol
001d2e 0593          cpc tosh, zeroh
001d2f 9189
001d30 9199          loadtos
001d31 0582          cpc tosl, zerol
001d32 0593          cpc tosh, zeroh
001d33 f0ec          brlt PFA_ZERO1
001d34 f0e1          brbs 1, PFA_ZERO1
001d35 c012          rjmp PFA_TRUE1
                 .include "words/d-lesszero.asm"
                 
                 ; Compare
                 ; compares if a double double cell number is less than 0
                 VE_DXT_ZEROLESS:
001d36 ff03          .dw $ff03
001d37 3064
001d38 003c          .db "d0<",0
001d39 1d28          .dw VE_HEAD
                     .set VE_HEAD = VE_DXT_ZEROLESS
                 XT_DXT_ZEROLESS:
001d3a 1d3b          .dw PFA_DXT_ZEROLESS
                 PFA_DXT_ZEROLESS:
001d3b 9622          adiw Y,2
001d3c fd97          sbrc tosh,7
001d3d 940c 1d48     jmp PFA_TRUE1
001d3f 940c 1d51     jmp PFA_ZERO1
                 
                 .include "words/true.asm"
                 
                 ; Arithmetics
                 ; leaves the value -1 (true) on TOS
                 VE_TRUE:
001d41 ff04          .dw $ff04
001d42 7274
001d43 6575          .db "true"
001d44 1d36          .dw VE_HEAD
                     .set VE_HEAD = VE_TRUE
                 XT_TRUE:
001d45 1d46          .dw PFA_TRUE
                 PFA_TRUE:
001d46 939a
001d47 938a          savetos
                 PFA_TRUE1:
001d48 ef8f          ser tosl
001d49 ef9f          ser tosh
001d4a ceb9          jmp_ DO_NEXT
                 .include "words/zero.asm"
                 
                 ; Arithmetics
                 ; place a value 0 on TOS
                 VE_ZERO:
001d4b ff01          .dw $ff01
001d4c 0030          .db "0",0
001d4d 1d41          .dw VE_HEAD
                     .set VE_HEAD = VE_ZERO
                 XT_ZERO:
001d4e 1d4f          .dw PFA_ZERO
                 PFA_ZERO:
001d4f 939a
001d50 938a          savetos
                 PFA_ZERO1:
001d51 01c1          movw tosl, zerol
001d52 ceb1          jmp_ DO_NEXT
                 .include "words/uless.asm"
                 
                 ; Compare
                 ; true if u1 < u2 (unsigned)
                 VE_ULESS:
001d53 ff02          .dw $ff02
001d54 3c75          .db "u<"
001d55 1d4b          .dw VE_HEAD
                     .set VE_HEAD = VE_ULESS
                 XT_ULESS:
001d56 1d57          .dw PFA_ULESS
                 PFA_ULESS:
001d57 9129          ld temp2, Y+
001d58 9139          ld temp3, Y+
001d59 1782          cp tosl, temp2
001d5a 0793          cpc tosh, temp3
001d5b f3a8          brlo PFA_ZERO1
001d5c f3a1          brbs 1, PFA_ZERO1
001d5d cfea          jmp_ PFA_TRUE1
                 .include "words/u-greater.asm"
                 
                 ; Compare
                 ; true if u1 > u2 (unsigned)
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_UGREATER:
001d5e ff02          .dw $ff02
001d5f 3e75          .db "u>"
001d60 1d53          .dw VE_HEAD
                     .set VE_HEAD = VE_UGREATER
                 XT_UGREATER:
001d61 1c00          .dw DO_COLON
                 PFA_UGREATER:
                 .endif
001d62 1cbe          .DW XT_SWAP
001d63 1d56          .dw XT_ULESS
001d64 1c1a          .dw XT_EXIT
                 .include "words/less.asm"
                 
                 ; Compare
                 ; true if n1 is less than n2
                     VE_LESS:
001d65 ff01          .dw $ff01
001d66 003c          .db "<",0
001d67 1d5e          .dw VE_HEAD
                     .set VE_HEAD = VE_LESS
                 XT_LESS:
001d68 1d69          .dw PFA_LESS
                 PFA_LESS:
001d69 9129          ld temp2, Y+
001d6a 9139          ld temp3, Y+
001d6b 1728          cp temp2, tosl
001d6c 0739          cpc temp3, tosh
                 PFA_LESSDONE:
001d6d f71c          brge PFA_ZERO1
001d6e cfd9          rjmp PFA_TRUE1
                 .include "words/greater.asm"
                 
                 ; Compare
                 ; flag is true if n1 is greater than n2
                 VE_GREATER:
001d6f ff01          .dw $ff01
001d70 003e          .db ">",0
001d71 1d65          .dw VE_HEAD
                     .set VE_HEAD = VE_GREATER
                 XT_GREATER:
001d72 1d73          .dw PFA_GREATER
                 PFA_GREATER:
001d73 9129          ld temp2, Y+
001d74 9139          ld temp3, Y+
001d75 1728          cp temp2, tosl
001d76 0739          cpc temp3, tosh
                 PFA_GREATERDONE:
001d77 f2cc          brlt PFA_ZERO1
001d78 f2c1          brbs 1, PFA_ZERO1
001d79 cfce          rjmp PFA_TRUE1
                 
                 .include "words/log2.asm"
                 
                 ; Arithmetics
                 ; logarithm to base 2 or highest set bitnumber
                 VE_LOG2:
001d7a ff04          .dw $ff04
001d7b 6f6c
001d7c 3267          .db "log2"
001d7d 1d6f          .dw VE_HEAD
                     .set VE_HEAD = VE_LOG2
                 XT_LOG2:
001d7e 1d7f          .dw PFA_LOG2
                 PFA_LOG2:
001d7f 01fc          movw zl, tosl
001d80 2799          clr tosh
001d81 e180          ldi tosl, 16
                 PFA_LOG2_1:
001d82 958a          dec tosl
001d83 f022          brmi PFA_LOG2_2 ; wrong data
001d84 0fee          lsl  zl
001d85 1fff          rol  zh
001d86 f7d8          brcc PFA_LOG2_1
001d87 ce7c          jmp_ DO_NEXT
                 
                 PFA_LOG2_2:
001d88 959a          dec tosh
001d89 ce7a          jmp_ DO_NEXT
                 .include "words/minus.asm"
                 
                 ; Arithmetics
                 ; subtract n2 from n1
                 VE_MINUS:
001d8a ff01          .dw $ff01
001d8b 002d          .db "-",0
001d8c 1d7a          .dw VE_HEAD
                     .set VE_HEAD = VE_MINUS
                 XT_MINUS:
001d8d 1d8e          .dw PFA_MINUS
                 PFA_MINUS:
001d8e 9109          ld temp0, Y+
001d8f 9119          ld temp1, Y+
001d90 1b08          sub temp0, tosl
001d91 0b19          sbc temp1, tosh
001d92 01c8          movw tosl, temp0
001d93 ce70          jmp_ DO_NEXT
                 .include "words/plus.asm"
                 
                 ; Arithmetics
                 ; add n1 and n2
                 VE_PLUS:
001d94 ff01          .dw $ff01
001d95 002b          .db "+",0
001d96 1d8a          .dw VE_HEAD
                     .set VE_HEAD = VE_PLUS
                 XT_PLUS:
001d97 1d98          .dw PFA_PLUS
                 PFA_PLUS:
001d98 9109          ld temp0, Y+
001d99 9119          ld temp1, Y+
001d9a 0f80          add tosl, temp0
001d9b 1f91          adc tosh, temp1
001d9c ce67          jmp_ DO_NEXT
                 .include "words/mstar.asm"
                 
                 ; Arithmetics
                 ; multiply 2 cells to a double cell
                 VE_MSTAR:
001d9d ff02          .dw $ff02
001d9e 2a6d          .db "m*"
001d9f 1d94          .dw VE_HEAD
                     .set VE_HEAD = VE_MSTAR
                 XT_MSTAR:
001da0 1da1          .dw PFA_MSTAR
                 PFA_MSTAR:
001da1 018c          movw temp0, tosl
001da2 9189
001da3 9199          loadtos
001da4 019c          movw temp2, tosl
                     ; high cell ah*bh
001da5 0231          muls temp3, temp1
001da6 0170          movw temp4, r0
                     ; low cell  al*bl
001da7 9f20          mul  temp2, temp0
001da8 01c0          movw tosl, r0
                     ; signed ah*bl
001da9 0330          mulsu temp3, temp0
001daa 08f3          sbc   temp5, zeroh
001dab 0d90          add   tosh,  r0
001dac 1ce1          adc   temp4, r1
001dad 1cf3          adc   temp5, zeroh
                     
                     ; signed al*bh
001dae 0312          mulsu temp1, temp2
001daf 08f3          sbc   temp5, zeroh
001db0 0d90          add   tosh,  r0
001db1 1ce1          adc   temp4, r1
001db2 1cf3          adc   temp5, zeroh
                 
001db3 939a
001db4 938a          savetos
001db5 01c7          movw tosl, temp4
001db6 ce4d          jmp_ DO_NEXT
                 .include "words/umslashmod.asm"
                 
                 ; Arithmetics
                 ; unsigned division ud / u2 with remainder
                 VE_UMSLASHMOD:
001db7 ff06          .dw $ff06
001db8 6d75
001db9 6d2f
001dba 646f          .db "um/mod"
001dbb 1d9d          .dw VE_HEAD
                     .set VE_HEAD = VE_UMSLASHMOD
                 XT_UMSLASHMOD:
001dbc 1dbd          .dw PFA_UMSLASHMOD
                 PFA_UMSLASHMOD:
001dbd 017c          movw temp4, tosl
                 
001dbe 9129          ld temp2, Y+
001dbf 9139          ld temp3, Y+
                   
001dc0 9109          ld temp0, Y+
001dc1 9119          ld temp1, Y+
                 
                 ;; unsigned 32/16 -> 16r16 divide
                 
                 PFA_UMSLASHMODmod:
                 
                   ; set loop counter
001dc2 e140          ldi temp6,$10
                 
                 PFA_UMSLASHMODmod_loop:
                     ; shift left, saving high bit
001dc3 2755          clr temp7
001dc4 0f00          lsl temp0
001dc5 1f11          rol temp1
001dc6 1f22          rol temp2
001dc7 1f33          rol temp3
001dc8 1f55          rol temp7
                 
                   ; try subtracting divisor
001dc9 152e          cp temp2, temp4
001dca 053f          cpc temp3, temp5
001dcb 0552          cpc temp7,zerol
                 
001dcc f018          brcs PFA_UMSLASHMODmod_loop_control
                 
                 PFA_UMSLASHMODmod_subtract:
                     ; dividend is large enough
                     ; do the subtraction for real
                     ; and set lowest bit
001dcd 9503          inc temp0
001dce 192e          sub temp2, temp4
001dcf 093f          sbc temp3, temp5
                 
                 PFA_UMSLASHMODmod_loop_control:
001dd0 954a          dec  temp6
001dd1 f789          brne PFA_UMSLASHMODmod_loop
                 
                 PFA_UMSLASHMODmod_done:
                     ; put remainder on stack
001dd2 933a          st -Y,temp3
001dd3 932a          st -Y,temp2
                 
                     ; put quotient on stack
001dd4 01c8          movw tosl, temp0
001dd5 ce2e          jmp_ DO_NEXT
                 .include "words/umstar.asm"
                 
                 ; Arithmetics
                 ; multiply 2 unsigned cells to a double cell
                 VE_UMSTAR:
001dd6 ff03          .dw $ff03
001dd7 6d75
001dd8 002a          .db "um*",0
001dd9 1db7          .dw VE_HEAD
                     .set VE_HEAD = VE_UMSTAR
                 XT_UMSTAR:
001dda 1ddb          .dw PFA_UMSTAR
                 PFA_UMSTAR:
001ddb 018c          movw temp0, tosl
001ddc 9189
001ddd 9199          loadtos
                     ; result: (temp3*temp1)* 65536 + (temp3*temp0 + temp1*temp2) * 256 + (temp0 * temp2)
                     ; low bytes
001dde 9f80          mul tosl,temp0
001ddf 01f0          movw zl, r0
001de0 2722          clr temp2
001de1 2733          clr temp3
                     ; middle bytes
001de2 9f90          mul tosh, temp0
001de3 0df0          add zh, r0
001de4 1d21          adc temp2, r1
001de5 1d33          adc temp3, zeroh
                         
001de6 9f81          mul tosl, temp1
001de7 0df0          add zh, r0
001de8 1d21          adc temp2, r1
001de9 1d33          adc temp3, zeroh
                     
001dea 9f91          mul tosh, temp1
001deb 0d20          add temp2, r0
001dec 1d31          adc temp3, r1
001ded 01cf          movw tosl, zl
001dee 939a
001def 938a          savetos
001df0 01c9          movw tosl, temp2
001df1 ce12          jmp_ DO_NEXT
                 
                 .include "words/invert.asm"
                 
                 ; Arithmetics
                 ; 1-complement of TOS
                 VE_INVERT:
001df2 ff06          .dw $ff06
001df3 6e69
001df4 6576
001df5 7472          .db "invert"
001df6 1dd6          .dw VE_HEAD
                     .set VE_HEAD = VE_INVERT
                 XT_INVERT:
001df7 1df8          .dw PFA_INVERT
                 PFA_INVERT:
001df8 9580          com tosl
001df9 9590          com tosh
001dfa ce09          jmp_ DO_NEXT
                 .include "words/2slash.asm"
                 
                 ; Arithmetics
                 ; arithmetic shift right
                 VE_2SLASH:
001dfb ff02          .dw $ff02
001dfc 2f32          .db "2/"
001dfd 1df2          .dw VE_HEAD
                     .set VE_HEAD = VE_2SLASH
                 XT_2SLASH:
001dfe 1dff          .dw PFA_2SLASH
                 PFA_2SLASH:
001dff 9595          asr tosh
001e00 9587          ror tosl
001e01 ce02          jmp_ DO_NEXT
                 .include "words/2star.asm"
                 
                 ; Arithmetics
                 ; arithmetic shift left, filling with zero
                 VE_2STAR:
001e02 ff02          .dw $ff02
001e03 2a32          .db "2*"
001e04 1dfb          .dw VE_HEAD
                     .set VE_HEAD = VE_2STAR
                 XT_2STAR:
001e05 1e06          .dw PFA_2STAR
                 PFA_2STAR:
001e06 0f88          lsl tosl
001e07 1f99          rol tosh
001e08 cdfb          jmp_ DO_NEXT
                 .include "words/and.asm"
                 
                 ; Logic
                 ; bitwise and
                 VE_AND:
001e09 ff03          .dw $ff03
001e0a 6e61
001e0b 0064          .db "and",0
001e0c 1e02          .dw VE_HEAD
                     .set VE_HEAD = VE_AND
                 XT_AND:
001e0d 1e0e          .dw PFA_AND
                 PFA_AND:
001e0e 9109          ld temp0, Y+
001e0f 9119          ld temp1, Y+
001e10 2380          and tosl, temp0
001e11 2391          and tosh, temp1
001e12 cdf1          jmp_ DO_NEXT
                 .include "words/or.asm"
                 
                 ; Logic
                 ; logical or
                 VE_OR:
001e13 ff02          .dw $ff02
001e14 726f          .db "or"
001e15 1e09          .dw VE_HEAD
                     .set VE_HEAD = VE_OR
                 XT_OR:
001e16 1e17          .dw PFA_OR
                 PFA_OR:
001e17 9109          ld temp0, Y+
001e18 9119          ld temp1, Y+
001e19 2b80          or tosl, temp0
001e1a 2b91          or tosh, temp1
001e1b cde8          jmp_ DO_NEXT
                 
                 .include "words/xor.asm"
                 
                 ; Logic
                 ; exclusive or
                 VE_XOR:
001e1c ff03          .dw $ff03
001e1d 6f78
001e1e 0072          .db "xor",0
001e1f 1e13          .dw VE_HEAD
                     .set VE_HEAD = VE_XOR
                 XT_XOR:
001e20 1e21          .dw PFA_XOR
                 PFA_XOR:
001e21 9109          ld temp0, Y+
001e22 9119          ld temp1, Y+
001e23 2780          eor tosl, temp0
001e24 2791          eor tosh, temp1
001e25 cdde          jmp_ DO_NEXT
                 
                 .include "words/1plus.asm"
                 
                 ; Arithmetics
                 ; optimized increment
                 VE_1PLUS:
001e26 ff02          .dw $ff02
001e27 2b31          .db "1+"
001e28 1e1c          .dw VE_HEAD
                     .set VE_HEAD = VE_1PLUS
                 XT_1PLUS:
001e29 1e2a          .dw PFA_1PLUS
                 PFA_1PLUS:
001e2a 9601          adiw tosl,1
001e2b cdd8          jmp_ DO_NEXT
                 .include "words/1minus.asm"
                 
                 ; Arithmetics
                 ; optimized decrement
                 VE_1MINUS:
001e2c ff02          .dw $ff02 
001e2d 2d31          .db "1-"
001e2e 1e26          .dw VE_HEAD
                     .set VE_HEAD = VE_1MINUS
                 XT_1MINUS:
001e2f 1e30          .dw PFA_1MINUS
                 PFA_1MINUS:
001e30 9701          sbiw tosl, 1
001e31 cdd2          jmp_ DO_NEXT
                 .include "words/lshift.asm"
                 
                 ; Arithmetics
                 ; logically shift n1 left n2 times
                 VE_LSHIFT:
001e32 ff06          .dw $ff06
001e33 736c
001e34 6968
001e35 7466          .db "lshift"
001e36 1e2c          .dw VE_HEAD
                     .set VE_HEAD = VE_LSHIFT
                 XT_LSHIFT:
001e37 1e38          .dw PFA_LSHIFT
                 PFA_LSHIFT:
001e38 01fc          movw zl, tosl
001e39 9189
001e3a 9199          loadtos
                 PFA_LSHIFT1:
001e3b 9731          sbiw zl, 1
001e3c f01a          brmi PFA_LSHIFT2
001e3d 0f88          lsl tosl
001e3e 1f99          rol tosh
001e3f cffb          rjmp PFA_LSHIFT1
                 PFA_LSHIFT2:
001e40 cdc3          jmp_ DO_NEXT
                 
                 .include "words/rshift.asm"
                 
                 ; Arithmetics
                 ; shift n1 n2-times logically right
                 VE_RSHIFT:
001e41 ff06          .dw $ff06
001e42 7372
001e43 6968
001e44 7466          .db "rshift"
001e45 1e32          .dw VE_HEAD
                     .set VE_HEAD = VE_RSHIFT
                 XT_RSHIFT:
001e46 1e47          .dw PFA_RSHIFT
                 PFA_RSHIFT:
001e47 01fc          movw zl, tosl
001e48 9189
001e49 9199          loadtos
                 PFA_RSHIFT1:
001e4a 9731          sbiw zl, 1
001e4b f01a          brmi PFA_RSHIFT2
001e4c 9596          lsr tosh
001e4d 9587          ror tosl
001e4e cffb          rjmp PFA_RSHIFT1
                 PFA_RSHIFT2:
001e4f cdb4          jmp_ DO_NEXT
                 
                 .include "words/plusstore.asm"
                 
                 ; Arithmetics
                 ; add n to content of RAM address a-addr
                 VE_PLUSSTORE:
001e50 ff02          .dw $ff02
001e51 212b          .db "+!"
001e52 1e41          .dw VE_HEAD
                     .set VE_HEAD = VE_PLUSSTORE
                 XT_PLUSSTORE:
001e53 1e54          .dw PFA_PLUSSTORE
                 PFA_PLUSSTORE:
001e54 01fc          movw zl, tosl
001e55 9189
001e56 9199          loadtos
001e57 8120          ldd temp2, Z+0
001e58 8131          ldd temp3, Z+1
001e59 0f82          add tosl, temp2
001e5a 1f93          adc tosh, temp3
001e5b 8380          std Z+0, tosl
001e5c 8391          std Z+1, tosh
001e5d 9189
001e5e 9199          loadtos
001e5f cda4          jmp_ DO_NEXT
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/rpfetch.asm"
                 
                 ; Stack
                 ; current return stack pointer address
                 VE_RP_FETCH:
001e60 ff03          .dw $ff03
001e61 7072
001e62 0040          .db "rp@",0
001e63 1e50          .dw VE_HEAD
                     .set VE_HEAD = VE_RP_FETCH
                 XT_RP_FETCH:
001e64 1e65          .dw PFA_RP_FETCH
                 PFA_RP_FETCH:
001e65 939a
001e66 938a          savetos
001e67 b78d          in tosl, SPL
001e68 b79e          in tosh, SPH
001e69 cd9a          jmp_ DO_NEXT
                 .include "words/rpstore.asm"
                 
                 ; Stack
                 ; set return stack pointer
                 VE_RP_STORE:
001e6a ff03          .dw $ff03
001e6b 7072
001e6c 0021          .db "rp!",0
001e6d 1e60          .dw VE_HEAD
                     .set VE_HEAD = VE_RP_STORE
                 XT_RP_STORE:
001e6e 1e6f          .dw PFA_RP_STORE
                 PFA_RP_STORE:
001e6f b72f          in temp2, SREG
001e70 94f8          cli
001e71 bf8d          out SPL, tosl
001e72 bf9e          out SPH, tosh
001e73 bf2f          out SREG, temp2
001e74 9189
001e75 9199          loadtos
001e76 cd8d          jmp_ DO_NEXT
                 .include "words/spfetch.asm"
                 
                 ; Stack
                 ; current data stack pointer
                 VE_SP_FETCH:
001e77 ff03          .dw $ff03
001e78 7073
001e79 0040          .db "sp@",0
001e7a 1e6a          .dw VE_HEAD
                     .set VE_HEAD = VE_SP_FETCH
                 XT_SP_FETCH:
001e7b 1e7c          .dw PFA_SP_FETCH
                 PFA_SP_FETCH:
001e7c 939a
001e7d 938a          savetos
001e7e 01ce          movw tosl, yl
001e7f cd84          jmp_ DO_NEXT
                 .include "words/spstore.asm"
                 
                 ; Stack
                 ; set data stack pointer to addr
                 VE_SP_STORE:
001e80 ff03          .dw $ff03
001e81 7073
001e82 0021          .db "sp!",0
001e83 1e77          .dw VE_HEAD
                     .set VE_HEAD = VE_SP_STORE
                 XT_SP_STORE:
001e84 1e85          .dw PFA_SP_STORE
                 PFA_SP_STORE:
001e85 01ec          movw yl, tosl
001e86 9189
001e87 9199          loadtos
001e88 cd7b          jmp_ DO_NEXT
                 
                 .include "words/dodo.asm"
                 
                 ; System
                 ; runtime of do
                 ;VE_DODO:
                 ;    .dw $ff04
                 ;    .db "(do)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DODO
                 XT_DODO:
001e89 1e8a          .dw PFA_DODO
                 PFA_DODO:
001e8a 9129          ld temp2, Y+
001e8b 9139          ld temp3, Y+  ; limit
                 PFA_DODO1:
001e8c e8e0          ldi zl, $80
001e8d 0f3e          add temp3, zl
001e8e 1b82          sub  tosl, temp2
001e8f 0b93          sbc  tosh, temp3
                 
001e90 933f          push temp3
001e91 932f          push temp2    ; limit  ( --> limit + $8000)
001e92 939f          push tosh
001e93 938f          push tosl     ; start -> index ( --> index - (limit - $8000)
001e94 9189
001e95 9199          loadtos
001e96 cd6d          jmp_ DO_NEXT
                 .include "words/i.asm"
                 
                 ; Compiler
                 ; current loop counter
                 VE_I:
001e97 ff01          .dw $FF01
001e98 0069          .db "i",0
001e99 1e80          .dw VE_HEAD
                     .set VE_HEAD = VE_I
                 XT_I:
001e9a 1e9b          .dw PFA_I
                 PFA_I:
001e9b 939a
001e9c 938a          savetos
001e9d 918f          pop tosl
001e9e 919f          pop tosh  ; index
001e9f 91ef          pop zl
001ea0 91ff          pop zh    ; limit
001ea1 93ff          push zh
001ea2 93ef          push zl
001ea3 939f          push tosh
001ea4 938f          push tosl
001ea5 0f8e          add tosl, zl
001ea6 1f9f          adc tosh, zh
001ea7 cd5c          jmp_ DO_NEXT
                 .include "words/doplusloop.asm"
                 
                 ; System
                 ; runtime of +loop
                 ;VE_DOPLUSLOOP:
                 ;    .dw $ff07
                 ;    .db "(+loop)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOPLUSLOOP
                 XT_DOPLUSLOOP:
001ea8 1ea9          .dw PFA_DOPLUSLOOP
                 PFA_DOPLUSLOOP:
001ea9 91ef          pop zl
001eaa 91ff          pop zh
001eab 0fe8          add zl, tosl
001eac 1ff9          adc zh, tosh
001ead 9189
001eae 9199          loadtos
001eaf f01b          brvs PFA_DOPLUSLOOP_LEAVE
                     ; next cycle
                 PFA_DOPLUSLOOP_NEXT:
                     ; next iteration
001eb0 93ff          push zh
001eb1 93ef          push zl
001eb2 cd77          rjmp PFA_DOBRANCH ; read next cell from dictionary and jump to its destination
                 PFA_DOPLUSLOOP_LEAVE:
001eb3 910f          pop  temp0
001eb4 911f          pop  temp1  ; remove limit
001eb5 9611          adiw xl, 1  ; skip branch-back address
001eb6 cd4d          jmp_ DO_NEXT
                 .include "words/doloop.asm"
                 
                 ; System
                 ; runtime of loop
                 ;VE_DOLOOP:
                 ;    .dw $ff06
                 ;    .db "(loop)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOLOOP
                 XT_DOLOOP:
001eb7 1eb8          .dw PFA_DOLOOP
                 PFA_DOLOOP:
001eb8 91ef          pop zl
001eb9 91ff          pop zh
001eba 9631          adiw zl,1
001ebb f3bb          brvs PFA_DOPLUSLOOP_LEAVE
001ebc cff3          jmp_ PFA_DOPLUSLOOP_NEXT
                 .include "words/unloop.asm"
                 
                 ; Compiler
                 ; remove loop-sys, exit the loop and continue execution after it
                 VE_UNLOOP:
001ebd ff06          .dw $ff06
001ebe 6e75
001ebf 6f6c
001ec0 706f          .db "unloop"
001ec1 1e97          .dw VE_HEAD
                     .set VE_HEAD = VE_UNLOOP
                 XT_UNLOOP:
001ec2 1ec3          .dw PFA_UNLOOP
                 PFA_UNLOOP:
001ec3 911f          pop temp1
001ec4 910f          pop temp0
001ec5 911f          pop temp1
001ec6 910f          pop temp0
001ec7 cd3c          jmp_ DO_NEXT
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 
                 .include "words/cmove_g.asm"
                 
                 ; Memory
                 ; copy data in RAM from higher to lower addresses.
                 VE_CMOVE_G:
001ec8 ff06          .dw $ff06
001ec9 6d63
001eca 766f
001ecb 3e65          .db "cmove>"
001ecc 1ebd          .dw VE_HEAD
                     .set VE_HEAD  = VE_CMOVE_G
                 XT_CMOVE_G:
001ecd 1ece          .dw PFA_CMOVE_G
                 PFA_CMOVE_G:
001ece 93bf          push xh
001ecf 93af          push xl
001ed0 91e9          ld zl, Y+
001ed1 91f9          ld zh, Y+ ; addr-to
001ed2 91a9          ld xl, Y+
001ed3 91b9          ld xh, Y+ ; addr-from
001ed4 2f09          mov temp0, tosh
001ed5 2b08          or temp0, tosl
001ed6 f041          brbs 1, PFA_CMOVE_G1
001ed7 0fe8          add zl, tosl
001ed8 1ff9          adc zh, tosh
001ed9 0fa8          add xl, tosl
001eda 1fb9          adc xh, tosh
                 PFA_CMOVE_G2:
001edb 911e          ld temp1, -X
001edc 9312          st -Z, temp1
001edd 9701          sbiw tosl, 1
001ede f7e1          brbc 1, PFA_CMOVE_G2
                 PFA_CMOVE_G1:
001edf 91af          pop xl
001ee0 91bf          pop xh
001ee1 9189
001ee2 9199          loadtos
001ee3 cd20          jmp_ DO_NEXT
                 .include "words/byteswap.asm"
                 
                 ; Arithmetics
                 ; exchange the bytes of the TOS
                 VE_BYTESWAP:
001ee4 ff02          .dw $ff02
001ee5 3c3e          .db "><"
001ee6 1ec8          .dw VE_HEAD
                     .set VE_HEAD = VE_BYTESWAP
                 XT_BYTESWAP:
001ee7 1ee8          .dw PFA_BYTESWAP
                 PFA_BYTESWAP:
001ee8 2f09          mov temp0, tosh
001ee9 2f98          mov tosh, tosl
001eea 2f80          mov tosl, temp0
001eeb cd18          jmp_ DO_NEXT
                 .include "words/up.asm"
                 
                 ; System Variable
                 ; get user area pointer
                 VE_UP_FETCH:
001eec ff03          .dw $ff03
001eed 7075
001eee 0040          .db "up@",0
001eef 1ee4          .dw VE_HEAD
                     .set VE_HEAD = VE_UP_FETCH
                 XT_UP_FETCH:
001ef0 1ef1          .dw PFA_UP_FETCH
                 PFA_UP_FETCH:
001ef1 939a
001ef2 938a          savetos
001ef3 01c2          movw tosl, upl
001ef4 cd0f          jmp_ DO_NEXT
                 
                 ; ( addr -- ) 
                 ; System Variable
                 ; set user area pointer
                 VE_UP_STORE:
001ef5 ff03          .dw $ff03
001ef6 7075
001ef7 0021          .db "up!",0
001ef8 1eec          .dw VE_HEAD
                     .set VE_HEAD = VE_UP_STORE
                 XT_UP_STORE:
001ef9 1efa          .dw PFA_UP_STORE
                 PFA_UP_STORE:
001efa 012c          movw upl, tosl
001efb 9189
001efc 9199          loadtos
001efd cd06          jmp_ DO_NEXT
                 .include "words/1ms.asm"
                 
                 ; Time
                 ; busy waits (almost) exactly 1 millisecond
                 VE_1MS:
001efe ff03          .dw $ff03
001eff 6d31
001f00 0073          .db "1ms",0
001f01 1ef5          .dw VE_HEAD
                     .set VE_HEAD = VE_1MS
                 XT_1MS:
001f02 1f03          .dw PFA_1MS
                 PFA_1MS:
001f03 ede0
001f04 e0f7
001f05 9731
001f06 f7f1          delay 1000
001f07 ccfc          jmp_ DO_NEXT
                 .include "words/2to_r.asm"
                 
                 ; Stack
                 ; move DTOS to TOR
                 VE_2TO_R:
001f08 ff03          .dw $ff03
001f09 3e32
001f0a 0072          .db "2>r",0
001f0b 1efe          .dw VE_HEAD
                     .set VE_HEAD = VE_2TO_R
                 XT_2TO_R:
001f0c 1f0d          .dw PFA_2TO_R
                 PFA_2TO_R:
001f0d 01fc          movw zl, tosl
001f0e 9189
001f0f 9199          loadtos
001f10 939f          push tosh
001f11 938f          push tosl
001f12 93ff          push zh
001f13 93ef          push zl
001f14 9189
001f15 9199          loadtos
001f16 cced          jmp_ DO_NEXT
                 .include "words/2r_from.asm"
                 
                 ; Stack
                 ; move DTOR to TOS
                 VE_2R_FROM:
001f17 ff03          .dw $ff03
001f18 7232
001f19 003e          .db "2r>",0
001f1a 1f08          .dw VE_HEAD
                     .set VE_HEAD = VE_2R_FROM
                 XT_2R_FROM:
001f1b 1f1c          .dw PFA_2R_FROM
                 PFA_2R_FROM:
001f1c 939a
001f1d 938a          savetos
001f1e 91ef          pop zl
001f1f 91ff          pop zh
001f20 918f          pop tosl
001f21 919f          pop tosh
001f22 939a
001f23 938a          savetos
001f24 01cf          movw tosl, zl
001f25 ccde          jmp_ DO_NEXT
                 
                 .include "words/store-e.asm"
                 
                 ; Memory
                 ; write n (2bytes) to eeprom address
                 VE_STOREE:
001f26 ff02          .dw $ff02
001f27 6521          .db "!e"
001f28 1f17          .dw VE_HEAD
                     .set VE_HEAD = VE_STOREE
                 XT_STOREE:
001f29 1f2a          .dw PFA_STOREE
                 PFA_STOREE:
                 .if WANT_UNIFIED == 1
                 .endif
                 PFA_STOREE0:
001f2a 01fc          movw zl, tosl
001f2b 9189
001f2c 9199          loadtos
001f2d b72f          in_ temp2, SREG
001f2e 94f8          cli
001f2f d028          rcall PFA_FETCHE2
001f30 b500          in_  temp0, EEDR
001f31 1708          cp temp0,tosl
001f32 f009          breq PFA_STOREE3
001f33 d00b          rcall PFA_STOREE1
                 PFA_STOREE3:
001f34 9631          adiw zl,1
001f35 d022          rcall PFA_FETCHE2
001f36 b500          in_  temp0, EEDR
001f37 1709          cp temp0,tosh
001f38 f011          breq PFA_STOREE4
001f39 2f89          mov tosl, tosh
001f3a d004          rcall PFA_STOREE1
                 PFA_STOREE4:
001f3b bf2f          out_ SREG, temp2
001f3c 9189
001f3d 9199          loadtos
001f3e ccc5          jmp_ DO_NEXT
                     
                 PFA_STOREE1:
001f3f 99f9          sbic EECR, EEPE
001f40 cffe          rjmp PFA_STOREE1
                 
                 PFA_STOREE2: ; estore_wait_low_spm:
001f41 b707          in_ temp0, SPMCSR
001f42 fd00          sbrc temp0,SPMEN
001f43 cffd          rjmp PFA_STOREE2
                 
001f44 bdf2          out_ EEARH,zh
001f45 bde1          out_ EEARL,zl
001f46 bd80          out_ EEDR, tosl
001f47 9afa          sbi EECR,EEMPE
001f48 9af9          sbi EECR,EEPE
                 
001f49 9508          ret
                 .if WANT_UNIFIED == 1
                 .endif
                 .include "words/fetch-e.asm"
                 
                 ; Memory
                 ; read 1 cell from eeprom
                 VE_FETCHE:
001f4a ff02          .dw $ff02
001f4b 6540          .db "@e"
001f4c 1f26          .dw VE_HEAD
                     .set VE_HEAD = VE_FETCHE
                 XT_FETCHE:
001f4d 1f4e          .dw PFA_FETCHE
                 PFA_FETCHE:
                 .if WANT_UNIFIED == 1
                 .endif
                 PFA_FETCHE1:
001f4e b72f          in_ temp2, SREG
001f4f 94f8          cli
001f50 01fc          movw zl, tosl
001f51 d006          rcall PFA_FETCHE2
001f52 b580          in_ tosl, EEDR
                 
001f53 9631          adiw zl,1
                 
001f54 d003          rcall PFA_FETCHE2
001f55 b590          in_  tosh, EEDR
001f56 bf2f          out_ SREG, temp2
001f57 ccac          jmp_ DO_NEXT
                 
                 PFA_FETCHE2:
001f58 99f9          sbic EECR, EEPE
001f59 cffe          rjmp PFA_FETCHE2
                 
001f5a bdf2          out_ EEARH,zh
001f5b bde1          out_ EEARL,zl
                 
001f5c 9af8          sbi EECR,EERE
001f5d 9508          ret
                 
                 .if WANT_UNIFIED == 1
                 .endif
                 .include "words/store-i.asm"
                 
                 ; System Value
                 ; Deferred action to write a single 16bit cell to flash
                 VE_STOREI:
001f5e ff02          .dw $ff02
001f5f 6921          .db "!i"
001f60 1f4a          .dw VE_HEAD
                     .set VE_HEAD = VE_STOREI
                 XT_STOREI:
001f61 0c53          .dw PFA_DODEFER1
                 PFA_STOREI:
001f62 0038          .dw EE_STOREI
001f63 0bf4          .dw XT_EDEFERFETCH
001f64 0bfe          .dw XT_EDEFERSTORE
                 .if FLASHEND > $10000
                 .else
                   .include "words/store-i_nrww.asm"
                 
                 ; Memory
                 ; writes n to flash memory using assembly code (code to be placed in boot loader section)
                 VE_DO_STOREI_NRWW:
001f65 ff09          .dw $ff09
001f66 2128
001f67 2d69
001f68 726e
001f69 7777
001f6a 0029          .db "(!i-nrww)",0
001f6b 1f5e          .dw VE_HEAD
                     .set VE_HEAD = VE_DO_STOREI_NRWW
                 XT_DO_STOREI:
001f6c 1f6d          .dw PFA_DO_STOREI_NRWW
                 PFA_DO_STOREI_NRWW:
                   ; store status register
001f6d b71f        in temp1,SREG
001f6e 931f        push temp1
001f6f 94f8        cli
                 
001f70 019c        movw temp2, tosl ; save the (word) address
001f71 9189
001f72 9199        loadtos          ; get the new value for the flash cell
001f73 93af        push xl
001f74 93bf        push xh
001f75 93cf        push yl
001f76 93df        push yh
001f77 d009        rcall DO_STOREI_atmega
001f78 91df        pop yh
001f79 91cf        pop yl
001f7a 91bf        pop xh
001f7b 91af        pop xl
                   ; finally clear the stack
001f7c 9189
001f7d 9199        loadtos
001f7e 911f        pop temp1
                   ; restore status register (and interrupt enable flag)
001f7f bf1f        out SREG,temp1
                 
001f80 cc83        jmp_ DO_NEXT
                 
                 ; 
                 DO_STOREI_atmega:
                   ; write data to temp page buffer
                   ; use the values in tosl/tosh at the
                   ; appropiate place
001f81 d011        rcall pageload
                 
                   ; erase page if needed
                   ; it is needed if a bit goes from 0 to 1
001f82 94e0        com temp4
001f83 94f0        com temp5
001f84 218e        and tosl, temp4
001f85 219f        and tosh, temp5
001f86 2b98        or tosh, tosl
001f87 f021        breq DO_STOREI_writepage 
001f88 94b3          inc erase_counter
001f89 01f9          movw zl, temp2
001f8a e002          ldi temp0,(1<<PGERS)
001f8b d020          rcall dospm
                 
                 DO_STOREI_writepage:
                   ; write page
001f8c 01f9        movw zl, temp2
001f8d e004        ldi temp0,(1<<PGWRT)
001f8e d01d        rcall dospm
                 
                   ; reenable RWW section
001f8f 01f9        movw zl, temp2
001f90 e100        ldi temp0,(1<<RWWSRE)
001f91 d01a        rcall dospm
001f92 9508        ret
                 
                 ; load the desired page
                 .equ pagemask = ~ ( PAGESIZE - 1 )
                 pageload:
001f93 01f9        movw zl, temp2
                   ; get the beginning of page
001f94 7ce0        andi zl,low(pagemask)
001f95 7fff        andi zh,high(pagemask)
001f96 01ef        movw y, z
                   ; loop counter (in words)
001f97 e4a0        ldi xl,low(pagesize)
001f98 e0b0        ldi xh,high(pagesize)
                 pageload_loop:
                   ; we need the current flash value anyways
001f99 01fe        movw z, y
001f9a 0fee
001f9b 1fff
001f9c 9145
001f9d 9155        readflashcell temp6, temp7 ; destroys Z
                   ; now check: if Z points to the same cell as temp2/3, we want the new data
001f9e 01fe        movw z, y
001f9f 17e2        cp zl, temp2
001fa0 07f3        cpc zh, temp3
001fa1 f011        breq pageload_newdata
001fa2 010a          movw r0, temp6
001fa3 c002          rjmp pageload_cont
                 pageload_newdata:
001fa4 017a          movw temp4, temp6
001fa5 010c          movw r0, tosl
                 pageload_cont:
001fa6 2700        clr temp0
001fa7 d004        rcall dospm
001fa8 9621        adiw y, 1
001fa9 9711        sbiw x, 1
001faa f771        brne pageload_loop
                 
                 pageload_done:
001fab 9508        ret
                 
                 
                 ;; dospm
                 ;;
                 ;; execute spm instruction
                 ;;   temp0 holds the value for SPMCR
                 
                 dospm:
                 dospm_wait_ee:
001fac 99f9        sbic EECR, EEPE
001fad cffe        rjmp dospm_wait_ee
                 dospm_wait_spm:
001fae b717        in_  temp1, SPMCSR
001faf fd10        sbrc temp1, SPMEN
001fb0 cffd        rjmp dospm_wait_spm
                 
                   ; turn the word addres into a byte address
001fb1 0fee
001fb2 1fff        writeflashcell
                   ; execute spm
001fb3 6001        ori temp0, (1<<SPMEN)
001fb4 bf07        out_ SPMCSR,temp0
001fb5 95e8        spm
001fb6 9508        ret
                 .endif
                 .include "words/fetch-i.asm"
                 
                 ; Memory
                 ; read 1 cell from flash
                 VE_FETCHI:
001fb7 ff02          .dw $ff02
001fb8 6940          .db "@i"
001fb9 1f65          .dw VE_HEAD
                     .set VE_HEAD = VE_FETCHI
                 XT_FETCHI:
001fba 1fbb          .dw PFA_FETCHI
                 PFA_FETCHI:
001fbb 01fc          movw zl, tosl
001fbc 0fee
001fbd 1fff
001fbe 9185
001fbf 9195          readflashcell tosl,tosh
001fc0 cc43          jmp_ DO_NEXT
                 
                 .if AMFORTH_NRWW_SIZE>8000
                 .elif AMFORTH_NRWW_SIZE>4000
                 .elif AMFORTH_NRWW_SIZE>2000
                 .include "dict/core_2k.inc"
                 
                 .else
                 .endif
                 ; now colon words
                 ;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/2literal.asm"
                 
                 ; Compiler
                 ; compile a cell pair literal in colon definitions
                 VE_2LITERAL:
001fc1 0008          .dw $0008
001fc2 6c32
001fc3 7469
001fc4 7265
001fc5 6c61          .db "2literal"
001fc6 1fb7          .dw VE_HEAD
                     .set VE_HEAD = VE_2LITERAL
                 XT_2LITERAL:
001fc7 1c00          .dw DO_COLON
                 PFA_2LITERAL:
001fc8 1cbe          .dw XT_SWAP
001fc9 0267          .dw XT_COMPILE
001fca 1c37          .dw XT_DOLITERAL
001fcb 0272          .dw XT_COMMA
001fcc 0267          .dw XT_COMPILE
001fcd 1c37          .dw XT_DOLITERAL
001fce 0272          .dw XT_COMMA
                     
001fcf 1c1a          .dw XT_EXIT
                 .include "words/equal.asm"
                 
                 ; Compare
                 ; compares two values for equality
                 VE_EQUAL:
001fd0 ff01          .dw $ff01
001fd1 003d          .db "=",0
001fd2 1fc1          .dw VE_HEAD
                     .set VE_HEAD = VE_EQUAL
                 XT_EQUAL:
001fd3 1c00          .dw DO_COLON
                 PFA_EQUAL:
001fd4 1d8d          .dw XT_MINUS
001fd5 1d14          .dw XT_ZEROEQUAL
001fd6 1c1a          .dw XT_EXIT
                 .include "words/num-constants.asm"
                 
                 .endif
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_ONE:
001fd7 ff01          .dw $ff01
001fd8 0031          .db "1",0
001fd9 1fd0          .dw VE_HEAD
                     .set VE_HEAD = VE_ONE
                 XT_ONE:
001fda 1c42          .dw PFA_DOVARIABLE
                 PFA_ONE:
                 .endif
001fdb 0001              .DW 1
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_TWO:
001fdc ff01          .dw $ff01
001fdd 0032          .db "2",0
001fde 1fd7          .dw VE_HEAD
                     .set VE_HEAD = VE_TWO
                 XT_TWO:
001fdf 1c42          .dw PFA_DOVARIABLE
                 PFA_TWO:
                 .endif
001fe0 0002              .DW 2
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_MINUSONE:
001fe1 ff02          .dw $ff02
001fe2 312d          .db "-1"
001fe3 1fdc          .dw VE_HEAD
                     .set VE_HEAD = VE_MINUSONE
                 XT_MINUSONE:
001fe4 1c42          .dw PFA_DOVARIABLE
                 PFA_MINUSONE:
                 .endif
001fe5 ffff              .DW -1
                 .include "dict_appl_core.inc"
                 
                 ; do not delete it!
                 
                 .set flashlast = pc
                 .if (pc>FLASHEND)
                 .endif
                 
                 .dseg
                 ; define a label for the 1st free ram address
                 HERESTART:
                 .eseg
                 .include "amforth-eeprom.inc"
00002e ff ff     
                 EE_DP:
000030 ba 0d         .dw DPSTART      ; Dictionary Pointer
                 EE_HERE:
000032 a7 01         .dw HERESTART    ; Memory Allocation
                 EE_EHERE:
000034 82 00         .dw EHERESTART     ; EEProm Memory Allocation
                 EE_TURNKEY:
000036 b5 0d         .dw XT_APPLTURNKEY  ; TURNKEY
                 EE_STOREI:
000038 6c 1f         .dw XT_DO_STOREI  ; Store a cell into flash
                 
                 EE_ENVIRONMENT:
00003a 7c 05         .dw VE_ENVHEAD   ; environmental queries
                 EE_WL_FORTH:
00003c 40 00         .dw EE_FORTHWORDLIST; forth-wordlist
                 EE_CURRENT:
00003e 40 00         .dw EE_FORTHWORDLIST
                 EE_FORTHWORDLIST:
000040 e1 1f         .dw VE_HEAD      ; pre-defined (compiled in) wordlist
                 CFG_ORDERLISTLEN:
000042 01 00         .dw 1
                 CFG_ORDERLIST: ; list of wordlist id, exactly numwordlist entries
000044 40 00         .dw EE_FORTHWORDLIST      ; get/set-order
000046               .byte  (NUMWORDLISTS-1)*CELLSIZE ; one slot is already used
                 CFG_RECOGNIZERLISTLEN:
000054 02 00         .dw 2
                 CFG_RECOGNIZERLIST:
000056 5c 0b         .dw XT_REC_WORD
000058 47 0b         .dw XT_REC_NUM
00005a               .byte  (NUMRECOGNIZERS-2)*CELLSIZE ; two slots are already used
                 
                 EE_WLSCOPE:
00005e e3 04         .dw XT_GET_CURRENT  ; default wordlist scope
                 
                 ; LEAVE stack is between data stack and return stack.
                 EE_LP0:
000060 b0 04         .dw stackstart+1
                 
                 ; MARKER saves everything up to here. Nothing beyond gets saved
                 EE_MARKER:
000062 62 00         .dw EE_MARKER
                 
                 ; default user area
                 EE_INITUSER:
000064 00 00         .dw 0  ; USER_STATE
000066 00 00         .dw 0  ; USER_FOLLOWER
000068 ff 04         .dw rstackstart  ; USER_RP
00006a af 04         .dw stackstart   ; USER_SP0
00006c af 04         .dw stackstart   ; USER_SP
                     
00006e 00 00         .dw 0  ; USER_HANDLER
000070 0a 00         .dw 10 ; USER_BASE
                     
000072 8a 00         .dw XT_TX  ; USER_EMIT
000074 98 00         .dw XT_TXQ ; USER_EMITQ
000076 60 00         .dw XT_RX  ; USER_KEY
000078 7a 00         .dw XT_RXQ ; USER_KEYQ
00007a 6c 0d         .dw XT_SOURCETIB ; USER_SKEY
00007c 00 00         .dw 0            ; USER_G_IN
00007e 59 0d         .dw XT_REFILLTIB ; USER_REFILL  
                 
                 ; calculate baud rate error
                 .equ UBRR_VAL   = ((F_CPU+BAUD*8)/(BAUD*16)-1)  ; smart round
                 .equ BAUD_REAL  = (F_CPU/(16*(UBRR_VAL+1)))     ; effective baud rate
                 .equ BAUD_ERROR = ((BAUD_REAL*1000)/BAUD-1000)  ; error in pro mille
                 
                 .if ((BAUD_ERROR>BAUD_MAXERROR) || (BAUD_ERROR<-BAUD_MAXERROR))       
                 .endif
                 EE_UBRRVAL:
000080 0c 00         .dw UBRR_VAL     ; BAUDRATE
                 ; 1st free address in EEPROM.
                 EHERESTART:
                 .cseg


RESOURCE USE INFORMATION
------------------------

Notice:
The register and instruction counts are symbol table hit counts,
and hence implicitly used resources are not counted, eg, the
'lpm' instruction without operands implicitly uses r0 and z,
none of which are counted.

x,y,z are separate entities in the symbol table and are
counted separately from r26..r31 here.

.dseg memory usage only counts static data declared with .byte

"ATmega169" register use summary:
r0 :  20 r1 :   5 r2 :   8 r3 :  11 r4 :   4 r5 :   1 r6 :   0 r7 :   0 
r8 :   0 r9 :   0 r10:   1 r11:   1 r12:   0 r13:   0 r14:  22 r15:  20 
r16:  72 r17:  52 r18:  52 r19:  37 r20:  13 r21:  11 r22:  11 r23:   3 
r24: 176 r25: 126 r26:  39 r27:  21 r28:   7 r29:   4 r30:  71 r31:  36 
x  :   4 y  : 191 z  :  39 
Registers used: 29 out of 35 (82.9%)

"ATmega169" instruction use summary:
.lds  :   0 .sts  :   0 adc   :  21 add   :  16 adiw  :  18 and   :   4 
andi  :   3 asr   :   2 bclr  :   0 bld   :   0 brbc  :   2 brbs  :   7 
brcc  :   2 brcs  :   1 break :   0 breq  :   6 brge  :   1 brhc  :   0 
brhs  :   0 brid  :   0 brie  :   0 brlo  :   1 brlt  :   3 brmi  :   3 
brne  :  10 brpl  :   1 brsh  :   0 brtc  :   0 brts  :   1 brvc  :   0 
brvs  :   2 bset  :   0 bst   :   0 call  :   2 cbi   :   0 cbr   :   0 
clc   :   1 clh   :   0 cli   :   5 cln   :   0 clr   :  10 cls   :   0 
clt   :   1 clv   :   0 clz   :   0 com   :  16 cp    :  10 cpc   :  10 
cpi   :   2 cpse  :   0 dec   :   8 eor   :   3 fmul  :   0 fmuls :   0 
fmulsu:   0 icall :   0 ijmp  :   1 in    :  15 inc   :   3 jmp   :  20 
ld    : 129 ldd   :   4 ldi   :  25 lds   :   2 lpm   :  16 lsl   :  14 
lsr   :   1 mov   :   9 movw  :  63 mul   :   5 muls  :   1 mulsu :   2 
neg   :   0 nop   :   0 or    :   9 ori   :   1 out   :  17 pop   :  44 
push  :  38 rcall :  35 ret   :   6 reti  :   2 rjmp  :  90 rol   :  23 
ror   :   5 sbc   :   9 sbci  :   3 sbi   :   3 sbic  :   3 sbis  :   0 
sbiw  :   7 sbr   :   0 sbrc  :   4 sbrs  :   3 sec   :   1 seh   :   0 
sei   :   1 sen   :   0 ser   :   3 ses   :   0 set   :   2 sev   :   0 
sez   :   0 sleep :   0 spm   :   2 st    :  67 std   :   8 sts   :   3 
sub   :   6 subi  :   3 swap  :   0 tst   :   1 wdr   :   0 
Instructions used: 75 out of 113 (66.4%)

"ATmega169" memory use summary [bytes]:
Segment   Begin    End      Code   Data   Used    Size   Use%
---------------------------------------------------------------
[.cseg] 0x000000 0x003fcc   1814   9166  10980   16384  67.0%
[.dseg] 0x000100 0x0001a7      0    167    167    1024  16.3%
[.eseg] 0x000000 0x000082      0    130    130     512  25.4%

Assembly complete, 0 errors, 5 warnings
