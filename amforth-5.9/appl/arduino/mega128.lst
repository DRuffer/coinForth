
AVRASM ver. 2.1.52  mega128.asm Fri Jul 10 18:43:14 2015

mega128.asm(5): Including file '../../avr8\preamble.inc'
../../avr8\preamble.inc(2): Including file '../../avr8\macros.asm'
../../avr8\macros.asm(6): Including file '../../avr8\user.inc'
../../avr8\preamble.inc(6): Including file '../../avr8/devices/atmega1280\device.asm'
../../avr8/devices/atmega1280\device.asm(5): Including file '../../avr8/Atmel/Appnotes2\m1280def.inc'
mega128.asm(10): Including file '../../avr8\drivers/usart_0.asm'
../../avr8\drivers/usart_0.asm(32): Including file '../../avr8\drivers/usart_common.asm'
../../avr8\drivers/usart_common.asm(5): Including file '../../avr8\drivers/usart-isr-rx.asm'
../../avr8\drivers/usart_common.asm(17): Including file '../../avr8\words/usart-tx-poll.asm'
../../avr8\drivers/usart_common.asm(22): Including file '../../avr8\words/ubrr.asm'
../../avr8\drivers/usart_common.asm(23): Including file '../../avr8\words/usart.asm'
mega128.asm(15): Including file '../../avr8\drivers/1wire.asm'
mega128.asm(18): Including file '../../avr8\amforth.asm'
../../avr8\amforth.asm(12): Including file '../../avr8\drivers/generic-isr.asm'
../../avr8\amforth.asm(14): Including file '../../avr8\dict/rww.inc'
../../avr8\dict/rww.inc(1): Including file '../../avr8\words/mplus.asm'
../../avr8\dict/rww.inc(2): Including file '../../common\words/ud-star.asm'
../../avr8\dict/rww.inc(3): Including file '../../common\words/umax.asm'
../../avr8\dict/rww.inc(4): Including file '../../common\words/umin.asm'
../../avr8\dict/rww.inc(5): Including file '../../avr8\words/immediate-q.asm'
../../avr8\dict/rww.inc(6): Including file '../../avr8\words/name2flags.asm'
../../avr8\dict/rww.inc(7): Including file '../../common\words/name2interpret.asm'
../../avr8\dict/rww.inc(8): Including file '../../common\words/name2compile.asm'
../../avr8\dict/rww.inc(11): Including file '../../avr8\dict/appl_8k.inc'
../../avr8\dict/appl_8k.inc(1): Including file '../../avr8\dict/compiler1.inc'
../../avr8\dict/compiler1.inc(2): Including file '../../avr8\words/docreate.asm'
../../avr8\dict/compiler1.inc(3): Including file '../../common\words/backslash.asm'
../../avr8\dict/compiler1.inc(4): Including file '../../common\words/l-paren.asm'
../../avr8\dict/compiler1.inc(6): Including file '../../common\words/compile.asm'
../../avr8\dict/compiler1.inc(7): Including file '../../avr8\words/comma.asm'
../../avr8\dict/compiler1.inc(8): Including file '../../common\words/brackettick.asm'
../../avr8\dict/compiler1.inc(11): Including file '../../common\words/literal.asm'
../../avr8\dict/compiler1.inc(12): Including file '../../common\words/sliteral.asm'
../../avr8\dict/compiler1.inc(13): Including file '../../avr8\words/g-mark.asm'
../../avr8\dict/compiler1.inc(14): Including file '../../avr8\words/g-resolve.asm'
../../avr8\dict/compiler1.inc(15): Including file '../../avr8\words/l_mark.asm'
../../avr8\dict/compiler1.inc(16): Including file '../../avr8\words/l_resolve.asm'
../../avr8\dict/compiler1.inc(18): Including file '../../common\words/ahead.asm'
../../avr8\dict/compiler1.inc(19): Including file '../../common\words/if.asm'
../../avr8\dict/compiler1.inc(20): Including file '../../common\words/else.asm'
../../avr8\dict/compiler1.inc(21): Including file '../../common\words/then.asm'
../../avr8\dict/compiler1.inc(22): Including file '../../common\words/begin.asm'
../../avr8\dict/compiler1.inc(23): Including file '../../common\words/while.asm'
../../avr8\dict/compiler1.inc(24): Including file '../../common\words/repeat.asm'
../../avr8\dict/compiler1.inc(25): Including file '../../common\words/until.asm'
../../avr8\dict/compiler1.inc(26): Including file '../../common\words/again.asm'
../../avr8\dict/compiler1.inc(27): Including file '../../common\words/do.asm'
../../avr8\dict/compiler1.inc(28): Including file '../../common\words/loop.asm'
../../avr8\dict/compiler1.inc(29): Including file '../../common\words/plusloop.asm'
../../avr8\dict/compiler1.inc(30): Including file '../../common\words/leave.asm'
../../avr8\dict/compiler1.inc(31): Including file '../../common\words/qdo.asm'
../../avr8\dict/compiler1.inc(32): Including file '../../common\words/endloop.asm'
../../avr8\dict/compiler1.inc(34): Including file '../../common\words/l-from.asm'
../../avr8\dict/compiler1.inc(35): Including file '../../common\words/to-l.asm'
../../avr8\dict/compiler1.inc(36): Including file '../../avr8\words/lp0.asm'
../../avr8\dict/compiler1.inc(37): Including file '../../avr8\words/lp.asm'
../../avr8\dict/compiler1.inc(39): Including file '../../avr8\words/create.asm'
../../avr8\dict/compiler1.inc(40): Including file '../../avr8\words/header.asm'
../../avr8\dict/compiler1.inc(41): Including file '../../avr8\words/wlscope.asm'
../../avr8\dict/compiler1.inc(42): Including file '../../avr8\words/reveal.asm'
../../avr8\dict/compiler1.inc(43): Including file '../../avr8\words/latest.asm'
../../avr8\dict/compiler1.inc(44): Including file '../../avr8\words/does.asm'
../../avr8\dict/compiler1.inc(45): Including file '../../common\words/colon.asm'
../../avr8\dict/compiler1.inc(46): Including file '../../avr8\words/colon-noname.asm'
../../avr8\dict/compiler1.inc(47): Including file '../../common\words/semicolon.asm'
../../avr8\dict/compiler1.inc(48): Including file '../../common\words/right-bracket.asm'
../../avr8\dict/compiler1.inc(49): Including file '../../common\words/left-bracket.asm'
../../avr8\dict/compiler1.inc(50): Including file '../../common\words/variable.asm'
../../avr8\dict/compiler1.inc(51): Including file '../../common\words/constant.asm'
../../avr8\dict/compiler1.inc(52): Including file '../../avr8\words/user.asm'
../../avr8\dict/compiler1.inc(54): Including file '../../avr8\words/recurse.asm'
../../avr8\dict/compiler1.inc(55): Including file '../../avr8\words/immediate.asm'
../../avr8\dict/compiler1.inc(57): Including file '../../common\words/bracketchar.asm'
../../avr8\dict/compiler1.inc(58): Including file '../../common\words/abort-string.asm'
../../avr8\dict/compiler1.inc(59): Including file '../../common\words/abort.asm'
../../avr8\dict/compiler1.inc(60): Including file '../../common\words/q-abort.asm'
../../avr8\dict/compiler1.inc(62): Including file '../../common\words/get-stack.asm'
../../avr8\dict/compiler1.inc(63): Including file '../../common\words/set-stack.asm'
../../avr8\dict/compiler1.inc(64): Including file '../../common\words/map-stack.asm'
../../avr8\dict/compiler1.inc(65): Including file '../../avr8\words/get-current.asm'
../../avr8\dict/compiler1.inc(66): Including file '../../common\words/get-order.asm'
../../avr8\dict/compiler1.inc(68): Including file '../../avr8\words/compare.asm'
../../avr8\dict/compiler1.inc(69): Including file '../../avr8\words/nfa2lfa.asm'
../../avr8\amforth.asm(15): Including file 'dict_appl.inc'
dict_appl.inc(4): Including file '../../avr8\dict/compiler2.inc'
../../avr8\dict/compiler2.inc(8): Including file '../../avr8\words/set-current.asm'
../../avr8\dict/compiler2.inc(9): Including file '../../avr8\words/wordlist.asm'
../../avr8\dict/compiler2.inc(11): Including file '../../avr8\words/only.asm'
../../avr8\dict/compiler2.inc(12): Including file '../../avr8\words/forth-wordlist.asm'
../../avr8\dict/compiler2.inc(13): Including file '../../common\words/set-order.asm'
../../avr8\dict/compiler2.inc(14): Including file '../../common\words/set-recognizer.asm'
../../avr8\dict/compiler2.inc(15): Including file '../../common\words/get-recognizer.asm'
../../avr8\dict/compiler2.inc(16): Including file '../../avr8\words/code.asm'
../../avr8\dict/compiler2.inc(17): Including file '../../avr8\words/end-code.asm'
../../avr8\dict/compiler2.inc(18): Including file '../../avr8\words/marker.asm'
../../avr8\dict/compiler2.inc(19): Including file '../../common\words/postpone.asm'
dict_appl.inc(6): Including file 'words/applturnkey.asm'
../../avr8\amforth.asm(23): Including file '../../avr8\amforth-interpreter.asm'
../../avr8\amforth.asm(24): Including file '../../avr8\dict/nrww.inc'
../../avr8\dict/nrww.inc(4): Including file '../../avr8\words/exit.asm'
../../avr8\dict/nrww.inc(5): Including file '../../avr8\words/execute.asm'
../../avr8\dict/nrww.inc(6): Including file '../../avr8\words/dobranch.asm'
../../avr8\dict/nrww.inc(7): Including file '../../avr8\words/docondbranch.asm'
../../avr8\dict/nrww.inc(10): Including file '../../avr8\words/doliteral.asm'
../../avr8\dict/nrww.inc(11): Including file '../../avr8\words/dovariable.asm'
../../avr8\dict/nrww.inc(12): Including file '../../avr8\words/doconstant.asm'
../../avr8\dict/nrww.inc(13): Including file '../../avr8\words/douser.asm'
../../avr8\dict/nrww.inc(14): Including file '../../avr8\words/do-value.asm'
../../avr8\dict/nrww.inc(15): Including file '../../avr8\words/fetch.asm'
../../avr8\dict/nrww.inc(16): Including file '../../avr8\words/store.asm'
../../avr8\dict/nrww.inc(17): Including file '../../avr8\words/cstore.asm'
../../avr8\dict/nrww.inc(18): Including file '../../avr8\words/cfetch.asm'
../../avr8\dict/nrww.inc(19): Including file '../../avr8\words/fetch-u.asm'
../../avr8\dict/nrww.inc(20): Including file '../../avr8\words/store-u.asm'
../../avr8\dict/nrww.inc(23): Including file '../../avr8\words/dup.asm'
../../avr8\dict/nrww.inc(24): Including file '../../avr8\words/qdup.asm'
../../avr8\dict/nrww.inc(25): Including file '../../avr8\words/swap.asm'
../../avr8\dict/nrww.inc(26): Including file '../../avr8\words/over.asm'
../../avr8\dict/nrww.inc(27): Including file '../../avr8\words/drop.asm'
../../avr8\dict/nrww.inc(28): Including file '../../avr8\words/rot.asm'
../../avr8\dict/nrww.inc(29): Including file '../../avr8\words/nip.asm'
../../avr8\dict/nrww.inc(31): Including file '../../avr8\words/r_from.asm'
../../avr8\dict/nrww.inc(32): Including file '../../avr8\words/to_r.asm'
../../avr8\dict/nrww.inc(33): Including file '../../avr8\words/r_fetch.asm'
../../avr8\dict/nrww.inc(36): Including file '../../common\words/not-equal.asm'
../../avr8\dict/nrww.inc(37): Including file '../../avr8\words/equalzero.asm'
../../avr8\dict/nrww.inc(38): Including file '../../avr8\words/lesszero.asm'
../../avr8\dict/nrww.inc(39): Including file '../../avr8\words/greaterzero.asm'
../../avr8\dict/nrww.inc(40): Including file '../../avr8\words/d-greaterzero.asm'
../../avr8\dict/nrww.inc(41): Including file '../../avr8\words/d-lesszero.asm'
../../avr8\dict/nrww.inc(43): Including file '../../avr8\words/true.asm'
../../avr8\dict/nrww.inc(44): Including file '../../avr8\words/zero.asm'
../../avr8\dict/nrww.inc(45): Including file '../../avr8\words/uless.asm'
../../avr8\dict/nrww.inc(46): Including file '../../common\words/u-greater.asm'
../../avr8\dict/nrww.inc(47): Including file '../../avr8\words/less.asm'
../../avr8\dict/nrww.inc(48): Including file '../../avr8\words/greater.asm'
../../avr8\dict/nrww.inc(50): Including file '../../avr8\words/log2.asm'
../../avr8\dict/nrww.inc(51): Including file '../../avr8\words/minus.asm'
../../avr8\dict/nrww.inc(52): Including file '../../avr8\words/plus.asm'
../../avr8\dict/nrww.inc(53): Including file '../../avr8\words/mstar.asm'
../../avr8\dict/nrww.inc(54): Including file '../../avr8\words/umslashmod.asm'
../../avr8\dict/nrww.inc(55): Including file '../../avr8\words/umstar.asm'
../../avr8\dict/nrww.inc(57): Including file '../../avr8\words/invert.asm'
../../avr8\dict/nrww.inc(58): Including file '../../avr8\words/2slash.asm'
../../avr8\dict/nrww.inc(59): Including file '../../avr8\words/2star.asm'
../../avr8\dict/nrww.inc(60): Including file '../../avr8\words/and.asm'
../../avr8\dict/nrww.inc(61): Including file '../../avr8\words/or.asm'
../../avr8\dict/nrww.inc(62): Including file '../../avr8\words/xor.asm'
../../avr8\dict/nrww.inc(64): Including file '../../avr8\words/1plus.asm'
../../avr8\dict/nrww.inc(65): Including file '../../avr8\words/1minus.asm'
../../avr8\dict/nrww.inc(66): Including file '../../avr8\words/lshift.asm'
../../avr8\dict/nrww.inc(67): Including file '../../avr8\words/rshift.asm'
../../avr8\dict/nrww.inc(68): Including file '../../avr8\words/plusstore.asm'
../../avr8\dict/nrww.inc(70): Including file '../../avr8\words/rpfetch.asm'
../../avr8\dict/nrww.inc(71): Including file '../../avr8\words/rpstore.asm'
../../avr8\dict/nrww.inc(72): Including file '../../avr8\words/spfetch.asm'
../../avr8\dict/nrww.inc(73): Including file '../../avr8\words/spstore.asm'
../../avr8\dict/nrww.inc(75): Including file '../../avr8\words/dodo.asm'
../../avr8\dict/nrww.inc(76): Including file '../../avr8\words/i.asm'
../../avr8\dict/nrww.inc(77): Including file '../../avr8\words/doplusloop.asm'
../../avr8\dict/nrww.inc(78): Including file '../../avr8\words/doloop.asm'
../../avr8\dict/nrww.inc(79): Including file '../../avr8\words/unloop.asm'
../../avr8\dict/nrww.inc(83): Including file '../../avr8\words/cmove_g.asm'
../../avr8\dict/nrww.inc(84): Including file '../../avr8\words/byteswap.asm'
../../avr8\dict/nrww.inc(85): Including file '../../avr8\words/up.asm'
../../avr8\dict/nrww.inc(86): Including file '../../avr8\words/1ms.asm'
../../avr8\dict/nrww.inc(87): Including file '../../avr8\words/2to_r.asm'
../../avr8\dict/nrww.inc(88): Including file '../../avr8\words/2r_from.asm'
../../avr8\dict/nrww.inc(90): Including file '../../avr8\words/store-e.asm'
../../avr8\dict/nrww.inc(91): Including file '../../avr8\words/fetch-e.asm'
../../avr8\dict/nrww.inc(92): Including file '../../avr8\words/store-i.asm'
../../avr8\dict/nrww.inc(96): Including file '../../avr8\words/store-i_nrww.asm'
../../avr8\dict/nrww.inc(98): Including file '../../avr8\words/fetch-i.asm'
../../avr8\dict/nrww.inc(101): Including file '../../avr8\dict/core_8k.inc'
../../avr8\dict/core_8k.inc(2): Including file '../../avr8\words/n_to_r.asm'
../../avr8\dict/core_8k.inc(3): Including file '../../avr8\words/n_r_from.asm'
../../avr8\dict/core_8k.inc(5): Including file '../../avr8\words/d-2star.asm'
../../avr8\dict/core_8k.inc(6): Including file '../../avr8\words/d-2slash.asm'
../../avr8\dict/core_8k.inc(7): Including file '../../avr8\words/d-plus.asm'
../../avr8\dict/core_8k.inc(8): Including file '../../avr8\words/d-minus.asm'
../../avr8\dict/core_8k.inc(9): Including file '../../avr8\words/d-invert.asm'
../../avr8\dict/core_8k.inc(10): Including file '../../avr8\words/d-equal.asm'
../../avr8\dict/core_8k.inc(11): Including file '../../common\words/u-dot.asm'
../../avr8\dict/core_8k.inc(12): Including file '../../common\words/u-dot-r.asm'
../../avr8\dict/core_8k.inc(14): Including file '../../common\words/show-wordlist.asm'
../../avr8\dict/core_8k.inc(15): Including file '../../avr8\words/words.asm'
../../avr8\dict/core_8k.inc(16): Including file '../../avr8\dict/interrupt.inc'
../../avr8\dict/interrupt.inc(2): Including file '../../avr8\words/int-on.asm'
../../avr8\dict/interrupt.inc(3): Including file '../../avr8\words/int-off.asm'
../../avr8\dict/interrupt.inc(4): Including file '../../avr8\words/int-store.asm'
../../avr8\dict/interrupt.inc(5): Including file '../../avr8\words/int-fetch.asm'
../../avr8\dict/interrupt.inc(6): Including file '../../avr8\words/int-trap.asm'
../../avr8\dict/interrupt.inc(8): Including file '../../avr8\words/isr-exec.asm'
../../avr8\dict/interrupt.inc(9): Including file '../../avr8\words/isr-end.asm'
../../avr8\dict/core_8k.inc(18): Including file '../../common\words/pick.asm'
../../avr8\dict/core_8k.inc(19): Including file '../../common\words/dot-quote.asm'
../../avr8\dict/core_8k.inc(20): Including file '../../common\words/squote.asm'
../../avr8\dict/core_8k.inc(22): Including file '../../avr8\words/fill.asm'
../../avr8\dict/core_8k.inc(24): Including file '../../avr8\words/environment.asm'
../../avr8\dict/core_8k.inc(25): Including file '../../avr8\words/env-wordlists.asm'
../../avr8\dict/core_8k.inc(26): Including file '../../avr8\words/env-slashpad.asm'
../../avr8\dict/core_8k.inc(27): Including file '../../avr8\words/env-slashhold.asm'
../../avr8\dict/core_8k.inc(28): Including file '../../common\words/env-forthname.asm'
../../avr8\dict/core_8k.inc(29): Including file '../../common\words/env-forthversion.asm'
../../avr8\dict/core_8k.inc(30): Including file '../../common\words/env-cpu.asm'
../../avr8\dict/core_8k.inc(31): Including file '../../avr8\words/env-mcuinfo.asm'
../../avr8\dict/core_8k.inc(32): Including file '../../avr8\words/env-usersize.asm'
../../avr8\dict/core_8k.inc(34): Including file '../../common\words/f_cpu.asm'
../../avr8\dict/core_8k.inc(35): Including file '../../avr8\words/state.asm'
../../avr8\dict/core_8k.inc(36): Including file '../../common\words/base.asm'
../../avr8\dict/core_8k.inc(38): Including file '../../avr8\words/cells.asm'
../../avr8\dict/core_8k.inc(39): Including file '../../avr8\words/cellplus.asm'
../../avr8\dict/core_8k.inc(41): Including file '../../common\words/2dup.asm'
../../avr8\dict/core_8k.inc(42): Including file '../../common\words/2drop.asm'
../../avr8\dict/core_8k.inc(44): Including file '../../common\words/tuck.asm'
../../avr8\dict/core_8k.inc(46): Including file '../../common\words/to-in.asm'
../../avr8\dict/core_8k.inc(47): Including file '../../avr8\words/sharptib.asm'
../../avr8\dict/core_8k.inc(48): Including file '../../avr8\words/pad.asm'
../../avr8\dict/core_8k.inc(49): Including file '../../avr8\words/emit.asm'
../../avr8\dict/core_8k.inc(50): Including file '../../avr8\words/emitq.asm'
../../avr8\dict/core_8k.inc(51): Including file '../../avr8\words/key.asm'
../../avr8\dict/core_8k.inc(52): Including file '../../avr8\words/keyq.asm'
../../avr8\dict/core_8k.inc(54): Including file '../../avr8\words/dp.asm'
../../avr8\dict/core_8k.inc(55): Including file '../../avr8\words/ehere.asm'
../../avr8\dict/core_8k.inc(56): Including file '../../avr8\words/here.asm'
../../avr8\dict/core_8k.inc(57): Including file '../../avr8\words/allot.asm'
../../avr8\dict/core_8k.inc(59): Including file '../../common\words/bin.asm'
../../avr8\dict/core_8k.inc(60): Including file '../../common\words/decimal.asm'
../../avr8\dict/core_8k.inc(61): Including file '../../common\words/hex.asm'
../../avr8\dict/core_8k.inc(62): Including file '../../common\words/bl.asm'
../../avr8\dict/core_8k.inc(64): Including file '../../avr8\words/turnkey.asm'
../../avr8\dict/core_8k.inc(66): Including file '../../avr8\words/slashmod.asm'
../../avr8\dict/core_8k.inc(67): Including file '../../avr8\words/uslashmod.asm'
../../avr8\dict/core_8k.inc(68): Including file '../../avr8\words/negate.asm'
../../avr8\dict/core_8k.inc(69): Including file '../../common\words/slash.asm'
../../avr8\dict/core_8k.inc(70): Including file '../../common\words/mod.asm'
../../avr8\dict/core_8k.inc(71): Including file '../../avr8\words/abs.asm'
../../avr8\dict/core_8k.inc(72): Including file '../../common\words/min.asm'
../../avr8\dict/core_8k.inc(73): Including file '../../common\words/max.asm'
../../avr8\dict/core_8k.inc(74): Including file '../../common\words/within.asm'
../../avr8\dict/core_8k.inc(76): Including file '../../common\words/to-upper.asm'
../../avr8\dict/core_8k.inc(77): Including file '../../common\words/to-lower.asm'
../../avr8\dict/core_8k.inc(79): Including file '../../avr8\words/hld.asm'
../../avr8\dict/core_8k.inc(80): Including file '../../common\words/hold.asm'
../../avr8\dict/core_8k.inc(81): Including file '../../common\words/less-sharp.asm'
../../avr8\dict/core_8k.inc(82): Including file '../../common\words/sharp.asm'
../../avr8\dict/core_8k.inc(83): Including file '../../common\words/sharp-s.asm'
../../avr8\dict/core_8k.inc(84): Including file '../../common\words/sharp-greater.asm'
../../avr8\dict/core_8k.inc(85): Including file '../../common\words/sign.asm'
../../avr8\dict/core_8k.inc(86): Including file '../../common\words/d-dot-r.asm'
../../avr8\dict/core_8k.inc(87): Including file '../../common\words/dot-r.asm'
../../avr8\dict/core_8k.inc(88): Including file '../../common\words/d-dot.asm'
../../avr8\dict/core_8k.inc(89): Including file '../../common\words/dot.asm'
../../avr8\dict/core_8k.inc(90): Including file '../../common\words/ud-dot.asm'
../../avr8\dict/core_8k.inc(91): Including file '../../common\words/ud-dot-r.asm'
../../avr8\dict/core_8k.inc(92): Including file '../../common\words/ud-slash-mod.asm'
../../avr8\dict/core_8k.inc(93): Including file '../../common\words/digit-q.asm'
../../avr8\dict/core_8k.inc(95): Including file '../../avr8\words/do-sliteral.asm'
../../avr8\dict/core_8k.inc(96): Including file '../../avr8\words/scomma.asm'
../../avr8\dict/core_8k.inc(97): Including file '../../avr8\words/itype.asm'
../../avr8\dict/core_8k.inc(98): Including file '../../avr8\words/icount.asm'
../../avr8\dict/core_8k.inc(99): Including file '../../common\words/cr.asm'
../../avr8\dict/core_8k.inc(100): Including file '../../common\words/space.asm'
../../avr8\dict/core_8k.inc(101): Including file '../../common\words/spaces.asm'
../../avr8\dict/core_8k.inc(102): Including file '../../common\words/type.asm'
../../avr8\dict/core_8k.inc(103): Including file '../../common\words/tick.asm'
../../avr8\dict/core_8k.inc(105): Including file '../../common\words/handler.asm'
../../avr8\dict/core_8k.inc(106): Including file '../../common\words/catch.asm'
../../avr8\dict/core_8k.inc(107): Including file '../../common\words/throw.asm'
../../avr8\dict/core_8k.inc(109): Including file '../../common\words/cskip.asm'
../../avr8\dict/core_8k.inc(110): Including file '../../common\words/cscan.asm'
../../avr8\dict/core_8k.inc(111): Including file '../../common\words/accept.asm'
../../avr8\dict/core_8k.inc(112): Including file '../../avr8\words/refill.asm'
../../avr8\dict/core_8k.inc(113): Including file '../../common\words/char.asm'
../../avr8\dict/core_8k.inc(114): Including file '../../common\words/number.asm'
../../avr8\dict/core_8k.inc(115): Including file '../../common\words/q-sign.asm'
../../avr8\dict/core_8k.inc(116): Including file '../../common\words/set-base.asm'
../../avr8\dict/core_8k.inc(117): Including file '../../common\words/to-number.asm'
../../avr8\dict/core_8k.inc(118): Including file '../../common\words/parse.asm'
../../avr8\dict/core_8k.inc(119): Including file '../../avr8\words/source.asm'
../../avr8\dict/core_8k.inc(120): Including file '../../common\words/slash-string.asm'
../../avr8\dict/core_8k.inc(121): Including file '../../common\words/parse-name.asm'
../../avr8\dict/core_8k.inc(122): Including file '../../common\words/find-name.asm'
../../avr8\dict/core_8k.inc(124): Including file '../../common\words/prompt-ok.asm'
../../avr8\dict/core_8k.inc(125): Including file '../../common\words/prompt-ready.asm'
../../avr8\dict/core_8k.inc(126): Including file '../../common\words/prompt-error.asm'
../../avr8\dict/core_8k.inc(128): Including file '../../common\words/quit.asm'
../../avr8\dict/core_8k.inc(129): Including file '../../avr8\words/pause.asm'
../../avr8\dict/core_8k.inc(130): Including file '../../avr8\words/cold.asm'
../../avr8\dict/core_8k.inc(131): Including file '../../avr8\words/warm.asm'
../../avr8\dict/core_8k.inc(133): Including file '../../avr8\words/sp0.asm'
../../avr8\dict/core_8k.inc(134): Including file '../../avr8\words/rp0.asm'
../../avr8\dict/core_8k.inc(135): Including file '../../common\words/depth.asm'
../../avr8\dict/core_8k.inc(136): Including file '../../common\words/interpret.asm'
../../avr8\dict/core_8k.inc(137): Including file '../../common\words/do-recognizer.asm'
../../avr8\dict/core_8k.inc(138): Including file '../../common\words/r-intnumber.asm'
../../avr8\dict/core_8k.inc(139): Including file '../../common\words/r-word.asm'
../../avr8\dict/core_8k.inc(140): Including file '../../common\words/r-fail.asm'
../../avr8\dict/core_8k.inc(142): Including file '../../common\words/q-stack.asm'
../../avr8\dict/core_8k.inc(143): Including file '../../common\words/ver.asm'
../../avr8\dict/core_8k.inc(145): Including file '../../avr8\words/noop.asm'
../../avr8\dict/core_8k.inc(146): Including file '../../avr8\words/unused.asm'
../../avr8\dict/core_8k.inc(148): Including file '../../common\words/to.asm'
../../avr8\dict/core_8k.inc(149): Including file '../../avr8\words/i-cellplus.asm'
../../avr8\dict/core_8k.inc(151): Including file '../../avr8\words/edefer-fetch.asm'
../../avr8\dict/core_8k.inc(152): Including file '../../avr8\words/edefer-store.asm'
../../avr8\dict/core_8k.inc(153): Including file '../../common\words/rdefer-fetch.asm'
../../avr8\dict/core_8k.inc(154): Including file '../../common\words/rdefer-store.asm'
../../avr8\dict/core_8k.inc(155): Including file '../../common\words/udefer-fetch.asm'
../../avr8\dict/core_8k.inc(156): Including file '../../common\words/udefer-store.asm'
../../avr8\dict/core_8k.inc(157): Including file '../../common\words/defer-store.asm'
../../avr8\dict/core_8k.inc(158): Including file '../../common\words/defer-fetch.asm'
../../avr8\dict/core_8k.inc(159): Including file '../../avr8\words/do-defer.asm'
../../avr8\dict/core_8k.inc(161): Including file '../../common\words/search-wordlist.asm'
../../avr8\dict/core_8k.inc(162): Including file '../../common\words/traverse-wordlist.asm'
../../avr8\dict/core_8k.inc(163): Including file '../../common\words/name2string.asm'
../../avr8\dict/core_8k.inc(164): Including file '../../avr8\words/nfa2cfa.asm'
../../avr8\dict/core_8k.inc(165): Including file '../../avr8\words/icompare.asm'
../../avr8\dict/core_8k.inc(167): Including file '../../common\words/star.asm'
../../avr8\dict/core_8k.inc(168): Including file '../../avr8\words/j.asm'
../../avr8\dict/core_8k.inc(170): Including file '../../avr8\words/dabs.asm'
../../avr8\dict/core_8k.inc(171): Including file '../../avr8\words/dnegate.asm'
../../avr8\dict/core_8k.inc(172): Including file '../../avr8\words/cmove.asm'
../../avr8\dict/core_8k.inc(173): Including file '../../common\words/2swap.asm'
../../avr8\dict/core_8k.inc(175): Including file '../../avr8\words/tib.asm'
../../avr8\dict/core_8k.inc(177): Including file '../../avr8\words/init-user.asm'
../../avr8\dict/core_8k.inc(178): Including file '../../avr8\dict/compiler2.inc'
../../avr8\dict/core_8k.inc(179): Including file '../../common\words/bounds.asm'
../../avr8\dict/core_8k.inc(180): Including file '../../common\words/s-to-d.asm'
../../avr8\dict/core_8k.inc(181): Including file '../../avr8\words/to-body.asm'
../../avr8\dict/nrww.inc(111): Including file '../../avr8\words/2literal.asm'
../../avr8\dict/nrww.inc(112): Including file '../../avr8\words/equal.asm'
../../avr8\dict/nrww.inc(113): Including file '../../common\words/num-constants.asm'
../../avr8\amforth.asm(25): Including file 'dict_appl_core.inc'
../../avr8\amforth.asm(36): Including file '../../avr8\amforth-eeprom.inc'
                 
                 
                 ; file see ../template/template.asm. You may want to
                 ; copy that file to this one and edit it afterwards.
                 
                 .include "preamble.inc"
                 
                 .include "macros.asm"
                 
                 .set DICT_COMPILER2 = 0 ;
                 .set cpu_msp430 = 0
                 .set cpu_avr8   = 1
                 
                 .include "user.inc"
                 
                 ; 
                 
                 ; used by the multitasker
                 .set USER_STATE    = 0
                 .set USER_FOLLOWER = 2
                 
                 ; stackpointer, used by mulitasker
                 .set USER_RP      = 4
                 .set USER_SP0     = 6
                 .set USER_SP      = 8
                 
                 ; excpection handling
                 .set USER_HANDLER = 10
                 
                 ; numeric IO
                 .set USER_BASE  = 12
                 
                 ; character IO 
                 .set USER_EMIT  = 14
                 .set USER_EMITQ = 16
                 .set USER_KEY   = 18
                 .set USER_KEYQ  = 20
                 
                 .set USER_SOURCE  = 22
                 .set USER_TO_IN   = 24
                 .set USER_REFILL  = 26
                 
                 .set SYSUSERSIZE = 28
                 ; 
                 
                   .def zerol = r2
                   .def zeroh = r3
                   .def upl = r4
                   .def uph = r5
                 
                   .def al  = r6
                   .def ah  = r7
                   .def bl  = r8
                   .def bh  = r9
                 
                 ; internal
                   .def mcu_boot      = r10
                   .def erase_counter = r11
                 
                   .def temp4 = r14
                   .def temp5 = r15
                 
                   .def temp0 = r16
                   .def temp1 = r17
                   .def temp2 = r18
                   .def temp3 = r19
                 
                   .def temp6 = r20
                   .def temp7 = r21
                 
                   .def tosl = r24
                   .def tosh = r25
                 
                   .def wl = r22
                   .def wh = r23
                 
                 .macro loadtos
                     ld tosl, Y+
                     ld tosh, Y+
                 .endmacro
                 
                 .macro savetos
                     st -Y, tosh
                     st -Y, tosl
                 .endmacro
                 
                 .macro in_
                 .if (@1 < $40)
                   in @0,@1
                 .else
                   lds @0,@1
                 .endif
                 .endmacro
                 
                 .macro out_
                 .if (@0 < $40)
                   out @0,@1
                 .else
                   sts @0,@1
                 .endif
                 .endmacro
                 
                 .macro sbi_
                 .if (@0 < $40)
                   sbi @0,@1
                 .else
                   in_ @2,@0
                   ori @2,exp2(@1)
                   out_ @0,@2
                 .endif
                 .endmacro
                 
                 .macro cbi_
                 .if (@0 < $40)
                   cbi @0,@1
                 .else
                   in_ @2,@0
                   andi @2,~(exp2(@1))
                   out_ @0,@2
                 .endif
                 .endmacro
                 
                 .macro jmp_
                 	; a more flexible macro
                     .ifdef @0
                     .if (@0-pc > 2040) || (pc-@0>2040)
                 	jmp @0
                 	.else
                 	rjmp @0
                 	.endif
                 	.else
                 	jmp @0
                 	.endif
                 .endmacro
                 .macro call_
                 	; a more flexible macro
                     .ifdef @0
                     .if (@0-pc > 2040) || (pc-@0>2040)
                 	call @0
                 	.else
                 	rcall @0
                 	.endif
                 	.else
                 	call @0
                 	.endif
                 .endmacro
                 
                 ;               F_CPU
                 ;    µsec   16000000   14745600    8000000  1000000
                 ;    1            16      14,74          8        1
                 ;    10          160     147,45         80       10
                 ;    100        1600    1474,56        800      100
                 ;    1000      16000   14745,6        8000     1000
                 ;
                 ; cycles = µsec * f_cpu / 1e6
                 ; n_loops=cycles/5
                 ;
                 ;     cycles already used will be subtracted from the delay
                 ;     the waittime resolution is 1 cycle (delay from exact to +1 cycle)
                 ;     the maximum delay at 20MHz (50ns/clock) is 38350ns
                 ;     waitcount register must specify an immediate register
                 ;
                 ; busy waits a specfied amount of microseconds
                 .macro   delay
                       .set cycles = ( ( @0 * F_CPU ) / 1000000 )
                       .if (cycles > ( 256 * 255 * 4 + 2))
                         .error "MACRO delay - too many cycles to burn"
                       .else
                         .if (cycles > 6)
                           .set  loop_cycles = (cycles / 4)      
                           ldi   zl,low(loop_cycles)
                           ldi   zh,high(loop_cycles)
                           sbiw  Z, 1
                           brne  pc-1
                           .set  cycles = (cycles - (loop_cycles * 4))
                         .endif
                         .if (cycles > 0)
                           .if   (cycles & 4)
                             rjmp  pc+1
                             rjmp  pc+1
                           .endif
                           .if   (cycles & 2)
                             rjmp  pc+1
                           .endif
                           .if   (cycles & 1)
                             nop
                           .endif
                         .endif
                       .endif
                 .endmacro
                 
                 ; portability macros, they come from the msp430 branches
                 
                 .macro DEST
                     .dw @0
                 .endm
                 
                 ; controller specific file selected via include
                 ; directory definition when calling the assembler (-I)
                 .include "device.asm"
                 
                 ; generated automatically, do not edit
                 
                 .list
                 
                 .equ ramstart =  512
                 .equ CELLSIZE = 2
                 .macro readflashcell
                 	clr temp7
                 	lsl zl
                 	rol zh
                 	rol temp7
                 	out_ RAMPZ, temp7
                 	elpm @0, Z+
                 	elpm @1, Z+
                 .endmacro
                 .macro writeflashcell
                 	clr temp7
                 	lsl zl
                 	rol zh
                 	rol temp7
                 	out_ RAMPZ, temp7
                 .endmacro
                 .set WANT_ANALOG_COMPARATOR = 0
                 .set WANT_USART0 = 0
                 .set WANT_TWI = 0
                 .set WANT_SPI = 0
                 .set WANT_PORTA = 0
                 .set WANT_PORTB = 0
                 .set WANT_PORTC = 0
                 .set WANT_PORTD = 0
                 .set WANT_PORTE = 0
                 .set WANT_PORTF = 0
                 .set WANT_PORTG = 0
                 .set WANT_PORTH = 0
                 .set WANT_PORTJ = 0
                 .set WANT_PORTK = 0
                 .set WANT_PORTL = 0
                 .set WANT_TIMER_COUNTER_0 = 0
                 .set WANT_TIMER_COUNTER_2 = 0
                 .set WANT_WATCHDOG = 0
                 .set WANT_USART1 = 0
                 .set WANT_EEPROM = 0
                 .set WANT_TIMER_COUNTER_5 = 0
                 .set WANT_TIMER_COUNTER_4 = 0
                 .set WANT_TIMER_COUNTER_3 = 0
                 .set WANT_TIMER_COUNTER_1 = 0
                 .set WANT_JTAG = 0
                 .set WANT_EXTERNAL_INTERRUPT = 0
                 .set WANT_CPU = 0
                 .set WANT_AD_CONVERTER = 0
                 .set WANT_BOOT_LOAD = 0
                 .set WANT_USART2 = 0
                 .set WANT_USART3 = 0
                 .equ intvecsize = 2 ; please verify; flash size: 131072 bytes
                 .equ pclen = 2 ; please verify
                 .overlap
                 .org 2
000002 d152      	 rcall isr ; External Interrupt Request 0
                 .org 4
000004 d150      	 rcall isr ; External Interrupt Request 1
                 .org 6
000006 d14e      	 rcall isr ; External Interrupt Request 2
                 .org 8
000008 d14c      	 rcall isr ; External Interrupt Request 3
                 .org 10
00000a d14a      	 rcall isr ; External Interrupt Request 4
                 .org 12
00000c d148      	 rcall isr ; External Interrupt Request 5
                 .org 14
00000e d146      	 rcall isr ; External Interrupt Request 6
                 .org 16
000010 d144      	 rcall isr ; External Interrupt Request 7
                 .org 18
000012 d142      	 rcall isr ; Pin Change Interrupt Request 0
                 .org 20
000014 d140      	 rcall isr ; Pin Change Interrupt Request 1
                 .org 22
000016 d13e      	 rcall isr ; Pin Change Interrupt Request 2
                 .org 24
000018 d13c      	 rcall isr ; Watchdog Time-out Interrupt
                 .org 26
00001a d13a      	 rcall isr ; Timer/Counter2 Compare Match A
                 .org 28
00001c d138      	 rcall isr ; Timer/Counter2 Compare Match B
                 .org 30
00001e d136      	 rcall isr ; Timer/Counter2 Overflow
                 .org 32
000020 d134      	 rcall isr ; Timer/Counter1 Capture Event
                 .org 34
000022 d132      	 rcall isr ; Timer/Counter1 Compare Match A
                 .org 36
000024 d130      	 rcall isr ; Timer/Counter1 Compare Match B
                 .org 38
000026 d12e      	 rcall isr ; Timer/Counter1 Compare Match C
                 .org 40
000028 d12c      	 rcall isr ; Timer/Counter1 Overflow
                 .org 42
00002a d12a      	 rcall isr ; Timer/Counter0 Compare Match A
                 .org 44
00002c d128      	 rcall isr ; Timer/Counter0 Compare Match B
                 .org 46
00002e d126      	 rcall isr ; Timer/Counter0 Overflow
                 .org 48
000030 d124      	 rcall isr ; SPI Serial Transfer Complete
                 .org 50
000032 d122      	 rcall isr ; USART0, Rx Complete
                 .org 52
000034 d120      	 rcall isr ; USART0 Data register Empty
                 .org 54
000036 d11e      	 rcall isr ; USART0, Tx Complete
                 .org 56
000038 d11c      	 rcall isr ; Analog Comparator
                 .org 58
00003a d11a      	 rcall isr ; ADC Conversion Complete
                 .org 60
00003c d118      	 rcall isr ; EEPROM Ready
                 .org 62
00003e d116      	 rcall isr ; Timer/Counter3 Capture Event
                 .org 64
000040 d114      	 rcall isr ; Timer/Counter3 Compare Match A
                 .org 66
000042 d112      	 rcall isr ; Timer/Counter3 Compare Match B
                 .org 68
000044 d110      	 rcall isr ; Timer/Counter3 Compare Match C
                 .org 70
000046 d10e      	 rcall isr ; Timer/Counter3 Overflow
                 .org 72
000048 d10c      	 rcall isr ; USART1, Rx Complete
                 .org 74
00004a d10a      	 rcall isr ; USART1 Data register Empty
                 .org 76
00004c d108      	 rcall isr ; USART1, Tx Complete
                 .org 78
00004e d106      	 rcall isr ; 2-wire Serial Interface
                 .org 80
000050 d104      	 rcall isr ; Store Program Memory Read
                 .org 82
000052 d102      	 rcall isr ; Timer/Counter4 Capture Event
                 .org 84
000054 d100      	 rcall isr ; Timer/Counter4 Compare Match A
                 .org 86
000056 d0fe      	 rcall isr ; Timer/Counter4 Compare Match B
                 .org 88
000058 d0fc      	 rcall isr ; Timer/Counter4 Compare Match C
                 .org 90
00005a d0fa      	 rcall isr ; Timer/Counter4 Overflow
                 .org 92
00005c d0f8      	 rcall isr ; Timer/Counter5 Capture Event
                 .org 94
00005e d0f6      	 rcall isr ; Timer/Counter5 Compare Match A
                 .org 96
000060 d0f4      	 rcall isr ; Timer/Counter5 Compare Match B
                 .org 98
000062 d0f2      	 rcall isr ; Timer/Counter5 Compare Match C
                 .org 100
000064 d0f0      	 rcall isr ; Timer/Counter5 Overflow
                 .org 102
000066 d0ee      	 rcall isr ; USART2, Rx Complete
                 .org 104
000068 d0ec      	 rcall isr ; USART2 Data register Empty
                 .org 106
00006a d0ea      	 rcall isr ; USART2, Tx Complete
                 .org 108
00006c d0e8      	 rcall isr ; USART3, Rx Complete
                 .org 110
00006e d0e6      	 rcall isr ; USART3 Data register Empty
                 .org 112
000070 d0e4      	 rcall isr ; USART3, Tx Complete
                 .equ INTVECTORS = 57
                 .nooverlap
                 
                 ; compatability layer (maybe empty)
                 
                 ; controller data area, environment query mcu-info
                 mcu_info:
                 mcu_ramsize:
000071 2000      	.dw 8192
                 mcu_eepromsize:
000072 1000      	.dw 4096
                 mcu_maxdp:
000073 ffff      	.dw 65535 
                 mcu_numints:
000074 0039      	.dw 57
                 mcu_name:
000075 000a      	.dw 10
000076 5441
000077 656d
000078 6167
000079 3231
00007a 3038      	.db "ATmega1280"
                 .set codestart=pc
                 
                 ; some defaults, change them in your application master file
                 ; see template.asm for an example
                 
                 .set AMFORTH_RO_SEG = NRWW_START_ADDR
                 
                 ; receiving is asynchron, so an interrupt queue is useful.
                 .set WANT_ISR_RX = 1
                 
                 ; case insensitve dictionary lookup.
                 .set WANT_IGNORECASE = 0
                 
                 ; map all memories to one address space. Details in the
                 ; technical guide
                 .set WANT_UNIFIED = 0
                 
                 ; terminal input buffer
                 .set TIBSIZE  = 90    ; ANS94 needs at least 80 characters per line
                 
                 ; USER variables *in addition* to system ones
                 .set APPUSERSIZE = 10  ; size of application specific user area in bytes
                 
                 ; addresses of various data segments
                 .set rstackstart = RAMEND      ; start address of return stack, grows downward
                 .set stackstart  = RAMEND - 80 ; start address of data stack, grows downward
                 ; change only if you know what to you do
                 .set NUMWORDLISTS = 8 ; number of word lists in the searh order, at least 8
                 .set NUMRECOGNIZERS = 4 ; total number of recognizers, two are always used.
                 
                 ; 10 per mille (1 per cent) is ok.
                 .set BAUD = 38400
                 .set BAUD_MAXERROR = 10
                 
                 ; Dictionary setup
                 .set VE_HEAD = $0000
                 .set VE_ENVHEAD = $0000
                 
                 
                 .set WANT_IGNORECASE = 1
                 
                 .equ F_CPU = 16000000
                 .include "drivers/usart_0.asm"
                 
                   .equ BAUDRATE_HIGH = UBRR0H
                   .equ USART_C = UCSR0C
                   .equ USART_B = UCSR0B
                   .equ USART_A = UCSR0A
                   .equ USART_DATA = UDR0
                   .ifndef URXCaddr
                   .equ URXCaddr = URXC0addr
                   .equ UDREaddr = UDRE0addr
                   .endif
                 
                 .equ bm_USART_RXRD = 1 << RXC0
                 .equ bm_USART_TXRD = 1 << UDRE0
                 .equ bm_ENABLE_TX  = 1 << TXEN0
                 .equ bm_ENABLE_RX  = 1 << RXEN0
                 .equ bm_ENABLE_INT_RX = 1<<RXCIE0
                 .equ bm_ENABLE_INT_TX = 1<<UDRIE0
                 
                 .equ bm_USARTC_en   = 0
                 .equ bm_ASYNC       = 0 << 6
                 .equ bm_SYNC        = 1 << 6
                 .equ bm_NO_PARITY   = 0 << 4
                 .equ bm_EVEN_PARITY = 2 << 4
                 .equ bm_ODD_PARITY  = 3 << 4
                 .equ bm_1STOPBIT    = 0 << 3
                 .equ bm_2STOPBIT    = 1 << 3
                 .equ bm_5BIT        = 0 << 1
                 .equ bm_6BIT        = 1 << 1
                 .equ bm_7BIT        = 2 << 1
                 .equ bm_8BIT        = 3 << 1
                 
                 .include "drivers/usart_common.asm"
                 
                 .set USART_C_VALUE = bm_ASYNC | bm_NO_PARITY | bm_1STOPBIT | bm_8BIT
                 .if WANT_ISR_RX == 1
                   .set USART_B_VALUE = bm_ENABLE_TX | bm_ENABLE_RX | bm_ENABLE_INT_RX
                   .include "drivers/usart-isr-rx.asm"
                 
                 
                 ; sizes have to be powers of 2!
                 .equ usart_rx_size = $10
                 .equ usart_rx_mask = usart_rx_size - 1
                 .dseg
000200           usart_rx_data: .byte usart_rx_size+2
000212           usart_rx_in: .byte 2
000214           usart_rx_out: .byte 2
                 
                 .cseg
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 ; forth code:
                 ; : rx-isr USART_DATA c@
                 ;    usart_rx_data usart_rx_in c@ dup >r
                 ;    + !
                 ;    r> 1+ usart_rx_mask and usart_rx_in c!
                 ; ;
                 ; setup with
                 ; ' rx-isr URXCaddr int!
                 usart_rx_isr:
00007b 93af        push xl
00007c b7af        in xl, SREG
00007d 93af        push xl
00007e 93bf        push xh
00007f 93ef        push zl
000080 93ff        push zh
                 
000081 91b0 00c6   lds xh, USART_DATA
                 usart_rx_store:
000083 91a0 0212   lds xl, usart_rx_in
000085 e0e0        ldi zl, low(usart_rx_data)
000086 e0f2        ldi zh, high(usart_rx_data)
000087 0fea        add zl, xl
000088 1df3        adc zh, zeroh
000089 83b0        st Z, xh
                 
00008a 95a3        inc xl
00008b 70af        andi xl,usart_rx_mask
                 
00008c 93a0 0212   sts usart_rx_in, xl
                 
                 usart_rx_isr_finish:
00008e 91ff        pop zh
00008f 91ef        pop zl
000090 91bf        pop xh
000091 91af        pop xl
000092 bfaf        out SREG, xl
000093 91af        pop xl
000094 9518        reti
                 
                 .set usartpc = pc
                 .org URXCaddr
000032 c048        jmp_ usart_rx_isr
                 .org usartpc
                 
                 
                 ; ( -- ) Hardware Access
                 ; R( --)
                 ; initialize usart
                 ;VE_USART_INIT_RX:
                 ;  .dw $ff06
                 ;  .db "+usart"
                 ;  .dw VE_HEAD
                 ;  .set VE_HEAD = VE_USART_INIT_RX
                 XT_USART_INIT_RX_ISR:
000095 f000        .dw DO_COLON
                 PFA_USART_INIT_RX_ISR:          ; ( -- )
000096 f160        .dw XT_ZERO
000097 f040        .dw XT_DOLITERAL
000098 0212        .dw usart_rx_in
000099 f099        .dw XT_CSTORE
00009a f160        .dw XT_ZERO
00009b f040        .dw XT_DOLITERAL
00009c 0214        .dw usart_rx_out
00009d f099        .dw XT_CSTORE
                 
00009e f020        .dw XT_EXIT
                 
                 ; ( -- c)
                 ; MCU
                 ; get 1 character from input queue, wait if needed using interrupt driver
                 VE_RX_ISR:
00009f ff06          .dw $ff06
0000a0 7872
0000a1 692d
0000a2 7273          .db "rx-isr"
0000a3 0000          .dw VE_HEAD
                     .set VE_HEAD = VE_RX_ISR
                 XT_RX_ISR:
0000a4 f000          .dw DO_COLON
                 PFA_RX_ISR:
0000a5 00be        .dw XT_RXQ_ISR
0000a6 f039        .dw XT_DOCONDBRANCH
0000a7 00a5        .dw PFA_RX_ISR
0000a8 f040        .dw XT_DOLITERAL
0000a9 0214        .dw usart_rx_out
0000aa f0a4        .dw XT_CFETCH
0000ab f0bd        .dw XT_DUP
0000ac f23b        .dw XT_1PLUS
0000ad f040        .dw XT_DOLITERAL
0000ae 000f        .dw usart_rx_mask
0000af f21f        .dw XT_AND
0000b0 f040        .dw XT_DOLITERAL
0000b1 0214        .dw usart_rx_out
0000b2 f099        .dw XT_CSTORE
0000b3 f040        .dw XT_DOLITERAL
0000b4 0200        .dw usart_rx_data
0000b5 f1a9        .dw XT_PLUS
0000b6 f0a4        .dw XT_CFETCH
0000b7 f020        .dw XT_EXIT
                 
                 ; ( -- f)  
                 ; MCU
                 ; check if unread characters are in the input queue using interrupt driver
                 VE_RXQ_ISR:
0000b8 ff07          .dw $ff07
0000b9 7872
0000ba 2d3f
0000bb 7369
0000bc 0072          .db "rx?-isr",0
0000bd 009f          .dw VE_HEAD
                     .set VE_HEAD = VE_RXQ_ISR
                 XT_RXQ_ISR:
0000be f000          .dw DO_COLON
                 PFA_RXQ_ISR:
0000bf fa56        .dw XT_PAUSE
0000c0 f040        .dw XT_DOLITERAL
0000c1 0214        .dw usart_rx_out
0000c2 f0a4        .dw XT_CFETCH
0000c3 f040        .dw XT_DOLITERAL
0000c4 0212        .dw usart_rx_in
0000c5 f0a4        .dw XT_CFETCH
0000c6 f11f        .dw XT_NOTEQUAL
0000c7 f020        .dw XT_EXIT
                   .set XT_RX  = XT_RX_ISR
                   .set XT_RXQ = XT_RXQ_ISR
                   .set XT_USART_INIT_RX = XT_USART_INIT_RX_ISR
                 .else
                 .endif
                 
                 .include "words/usart-tx-poll.asm"
                 
                 ; MCU
                 ; check availability and send one character to the terminal using register poll
                 VE_TX_POLL:
0000c8 ff07          .dw $ff07
0000c9 7874
0000ca 702d
0000cb 6c6f
0000cc 006c          .db "tx-poll",0
0000cd 00b8          .dw VE_HEAD
                     .set VE_HEAD = VE_TX_POLL
                 XT_TX_POLL:
0000ce f000          .dw DO_COLON
                 PFA_TX_POLL:
                   ; wait for data ready
0000cf 00dc        .dw XT_TXQ_POLL
0000d0 f039        .dw XT_DOCONDBRANCH
0000d1 00cf        .dw PFA_TX_POLL
                   ; send to usart
0000d2 f040        .dw XT_DOLITERAL
0000d3 00c6        .dw USART_DATA
0000d4 f099        .dw XT_CSTORE
0000d5 f020        .dw XT_EXIT
                 
                 ; ( -- f) MCU
                 ; MCU
                 ; check if a character can be send using register poll
                 VE_TXQ_POLL:
0000d6 ff08          .dw $ff08
0000d7 7874
0000d8 2d3f
0000d9 6f70
0000da 6c6c          .db "tx?-poll"
0000db 00c8          .dw VE_HEAD
                     .set VE_HEAD = VE_TXQ_POLL
                 XT_TXQ_POLL:
0000dc f000          .dw DO_COLON
                 PFA_TXQ_POLL:
0000dd fa56        .dw XT_PAUSE
0000de f040        .dw XT_DOLITERAL
0000df 00c0        .dw USART_A
0000e0 f0a4        .dw XT_CFETCH
0000e1 f040        .dw XT_DOLITERAL
0000e2 0020        .dw bm_USART_TXRD
0000e3 f21f        .dw XT_AND
0000e4 f020        .dw XT_EXIT
                 .set XT_TX  = XT_TX_POLL
                 .set XT_TXQ = XT_TXQ_POLL
                 .set XT_USART_INIT_TX = 0
                 
                 .include "words/ubrr.asm"
                 
                 ; MCU
                 ; returns usart UBRR settings
                 VE_UBRR:
0000e5 ff04        .dw $ff04
0000e6 6275
0000e7 7272        .db "ubrr"
0000e8 00d6        .dw VE_HEAD
                   .set VE_HEAD = VE_UBRR
                 XT_UBRR:
0000e9 f07b        .dw PFA_DOVALUE1
                 PFA_UBRR:          ; ( -- )
0000ea 00c4        .dw EE_UBRRVAL
0000eb fbc1        .dw XT_EDEFERFETCH
0000ec fbcb        .dw XT_EDEFERSTORE
                 .include "words/usart.asm"
                 
                 ; MCU
                 ; initialize usart
                 VE_USART:
0000ed ff06        .dw $ff06
0000ee 752b
0000ef 6173
0000f0 7472        .db "+usart"
0000f1 00e5        .dw VE_HEAD
                   .set VE_HEAD = VE_USART
                 XT_USART:
0000f2 f000        .dw DO_COLON
                 PFA_USART:          ; ( -- )
                 
0000f3 f040        .dw XT_DOLITERAL
0000f4 0098        .dw USART_B_VALUE
0000f5 f040        .dw XT_DOLITERAL
0000f6 00c1        .dw USART_B
0000f7 f099        .dw XT_CSTORE
                 
0000f8 f040        .dw XT_DOLITERAL
0000f9 0006        .dw USART_C_VALUE
0000fa f040        .dw XT_DOLITERAL
0000fb 00c2        .dw USART_C | bm_USARTC_en
0000fc f099        .dw XT_CSTORE
                 
0000fd 00e9        .dw XT_UBRR
0000fe f0bd        .dw XT_DUP
0000ff f2f9        .dw XT_BYTESWAP
000100 f040        .dw XT_DOLITERAL
000101 00c5        .dw BAUDRATE_HIGH
000102 f099        .dw XT_CSTORE
000103 f040        .dw XT_DOLITERAL
000104 00c4        .dw BAUDRATE_LOW
000105 f099        .dw XT_CSTORE
                 .if XT_USART_INIT_RX!=0
000106 0095        .dw XT_USART_INIT_RX
                 .endif
                 .if XT_USART_INIT_TX!=0
                 .endif
                 
000107 f020        .dw XT_EXIT
                 
                 ; settings for 1wire interface, if desired
                 .equ OW_PORT=PORTE
                 .EQU OW_BIT=4
                 .include "drivers/1wire.asm"
                 
                 ;   B. J. Rodriguez (MSP 430)
                 ;   Matthias Trute (AVR Atmega)
                 ; COPYRIGHT
                 ;   (c) 2012 Bradford J. Rodriguez for the 430 code and API
                 
                 ;  adapted 430 assembly code to AVR
                 ;  wishlist: 
                 ;     use a configurable pin at runtime, compatible with bitnames.frt
                 ;     no external pull up, no external power supply for devices
                 ;     ???
                 ;
                 ;.EQU OW_BIT=4
                 ;.equ OW_PORT=PORTE
                 .set OW_DDR=(OW_PORT-1)
                 .set OW_PIN=(OW_DDR-1)
                 
                 ;****f* 1W.RESET
                 ; NAME
                 ;   1W.RESET
                 ; SYNOPSIS
                 ;   1W.RESET ( -- f )  Initialize 1-wire devices; return true if present
                 ; DESCRIPTION
                 ;   This configures the port pin used by the 1-wire interface, and then
                 ;   sends an "initialize" sequence to the 1-wire devices.  If any device
                 ;   is present, it will be detected.
                 ;
                 ;   Timing, per DS18B20 data sheet:
                 ;   a) Output "0" (drive output low) for >480 usec.
                 ;   b) Output "1" (let output float).
                 ;   c) After 15 to 60 usec, device will drive pin low for 60 to 240 usec.
                 ;      So, wait 75 usec and sample input.
                 ;   d) Leave output high (floating) for at least 480 usec.
                 ;******
                 ; ( -- f )
                 ; Hardware
                 ; Initialize 1-wire devices; return true if present
                 VE_OW_RESET:
000108 ff08          .dw $ff08
000109 7731
00010a 722e
00010b 7365
00010c 7465          .db "1w.reset"
00010d 00ed          .dw VE_HEAD
                     .set VE_HEAD = VE_OW_RESET
                 XT_OW_RESET:
00010e 010f          .dw PFA_OW_RESET
                 PFA_OW_RESET:
00010f 939a
000110 938a          savetos
000111 2799          clr tosh
                     ; setup to output
000112 9a6c          sbi OW_DDR, OW_BIT
                     ; Pull output low
000113 9874          cbi OW_PORT, OW_BIT
                     ; Delay >480 usec        
000114 e8e0
000115 e0f7
000116 9731
000117 f7f1          DELAY   480
                     ; Critical timing period, disable interrupts.
000118 b71f          in temp1, SREG
000119 94f8          cli
                     ; Pull output high
00011a 9a74          sbi OW_PORT, OW_BIT
                     ; make pin input, sends "1"
00011b 986c          cbi OW_DDR, OW_BIT 
00011c e0e0
00011d e0f1
00011e 9731
00011f f7f1          DELAY   64 ; delayB
                     ; Sample input pin, set TOS if input is zero
000120 b18c          in tosl, OW_PIN
000121 ff84          sbrs tosl, OW_BIT
000122 ef9f          ser  tosh
                     ; End critical timing period, enable interrupts
000123 bf1f          out SREG, temp1
                     ; release bus
000124 986c          cbi OW_DDR, OW_BIT
000125 9874          cbi OW_PORT, OW_BIT
                 
                     ; Delay rest of 480 usec 
000126 e8e0
000127 e0f6
000128 9731
000129 f7f1          DELAY   416
                     ; we now have the result flag in TOS        
00012a 2f89          mov tosl, tosh
00012b 940c f004     jmp_ DO_NEXT
                     
                 ;****f* 1W.SLOT
                 ; NAME
                 ;   1W.SLOT
                 ; SYNOPSIS
                 ;   1W.SLOT ( c -- c' ) Write and read one bit to/from 1-wire.
                 ; DESCRIPTION
                 ;   The "touch byte" function is described in Dallas App Note 74.
                 ;   It outputs a byte to the 1-wire pin, LSB first, and reads back
                 ;   the state of the 1-wire pin after a suitable delay.
                 ;   To read a byte, output $FF and read the reply data.
                 ;   To write a byte, output that byte and discard the reply.
                 ;
                 ;   This function performs one bit of the "touch" operation --
                 ;   one read/write "slot" in Dallas jargon.  Perform this eight
                 ;   times in a row to get the "touch byte" function.
                 ;
                 ; PARAMETERS
                 ;   The input parameter is xxxxxxxxbbbbbbbo where
                 ;   'xxxxxxxx' are don't cares,
                 ;   'bbbbbbb' are bits to be shifted down, and
                 ;   'o' is the bit to be output in the slot.  This must be 1
                 ;   to create a read slot.
                 ;
                 ;   The returned value is xxxxxxxxibbbbbbb where
                 ;   'xxxxxxxx' are not known (the input shifted down 1 position),
                 ;   'i' is the bit read during the slot.  This has no meaning
                 ;   if it was a write slot.
                 ;   'bbbbbbb' are the 7 input bits, shifted down one position.
                 ;
                 ;   This peculiar parameter usage allows OWTOUCH to be written as
                 ;     OWSLOT OWSLOT OWSLOT OWSLOT OWSLOT OWSLOT OWSLOT OWSLOT 
                 ;
                 ; NOTES 
                 ;   Interrupts are disabled during each bit.
                 
                 ;   Timing, per DS18B20 data sheet:
                 ;   a) Output "0" for start period.  (> 1 us, < 15 us, typ. 6 us*)
                 ;   b) Output data bit (0 or 1), open drain 
                 ;   c) After MS from start of cycle, sample input (15 to 60 us, typ. 25 us*)
                 ;   d) After write-0 period from start of cycle, output "1" (>60 us)
                 ;   e) After recovery period, loop or return. (> 1 us)
                 ;   For writes, DS18B20 samples input 15 to 60 usec from start of cycle.
                 ;   * "Typical" values are per App Note 132 for a 300m cable length.
                 
                 ;   ---------        -------------------------------
                 ;            \      /                        /
                 ;             ------------------------------- 
                 ;            a      b          c             d     e
                 ;            |  6us |   19us   |    35us     | 2us |
                 ;******
                 ; ( c -- c' )
                 ; Hardware
                 ; Write and read one bit to/from 1-wire.
                 VE_OW_SLOT:
00012d ff07          .dw $ff07
00012e 7731
00012f 732e
000130 6f6c
000131 0074          .db "1w.slot",0
000132 0108          .dw VE_HEAD
                     .set VE_HEAD = VE_OW_SLOT
                 XT_OW_SLOT:
000133 0134          .dw PFA_OW_SLOT
                 PFA_OW_SLOT:
                     ; pull low
000134 9a6c          sbi OW_DDR, OW_BIT
000135 9874          cbi OW_PORT, OW_BIT
                     ; disable interrupts
000136 b71f          in temp1, SREG
000137 94f8          cli
000138 e1e8
000139 e0f0
00013a 9731
00013b f7f1          DELAY   6 ; DELAY A
                     ; check bit
00013c 9488          clc
00013d 9587          ror tosl
00013e f410          brcc PFA_OW_SLOT0 ; a 0 keeps the bus low
                       ; release bus, a 1 is written
00013f 986c            cbi OW_DDR, OW_BIT
000140 9a74            sbi OW_PORT, OW_BIT
                 PFA_OW_SLOT0:
                     ; sample the input (no action required if zero)
000141 e2e4
000142 e0f0
000143 9731
000144 f7f1          DELAY 9   ; wait DELAY E to sample
000145 b10c          in temp0, OW_PIN
000146 fd04          sbrc temp0, OW_BIT
000147 6880          ori tosl, $80
                 
000148 ecec
000149 e0f0
00014a 9731
00014b f7f1          DELAY   51 ; DELAY B
00014c 986c          cbi OW_DDR, OW_BIT
00014d 9a74          sbi OW_PORT, OW_BIT ; release bus
00014e e0e8
00014f e0f0
000150 9731
000151 f7f1          delay 2
                     ; re-enable interrupts
000152 bf1f          out SREG, temp1
000153 940c f004     jmp_ DO_NEXT
                 
                 ;  include the whole source tree.
                 .include "amforth.asm"
                 
                 ;;;;
                 ;;;; GPL V2 (only)
                 
                 .set AMFORTH_NRWW_SIZE=(FLASHEND-AMFORTH_RO_SEG)*2
                 
                 .set corepc = pc
                 .org $0000
000000 940c fa5f   jmp_ PFA_COLD
                 
                 .org corepc
                 .include "drivers/generic-isr.asm"
                 
                 .dseg
000216           intcur: .byte 1
                 .eseg
000000           intvec: .byte INTVECTORS * CELLSIZE
                 .cseg
                 
                 ; interrupt routine gets called (again) by rcall! This gives the
                 ; address of the int-vector on the stack.
                 isr:
000155 920a          st -Y, r0
000156 b60f          in r0, SREG
000157 920a          st -Y, r0
                 .if (pclen==3)
                 .endif
000158 900f          pop r0
000159 900f          pop r0          ; = intnum * intvectorsize + 1 (address following the rcall)
00015a 940a          dec r0
                 .if intvecsize == 1 ;
                 .endif
00015b 9200 0216     sts intcur, r0
00015d 9009          ld r0, Y+
00015e be0f          out SREG, r0
00015f 9009          ld r0, Y+
000160 9468          set ; set the interrupt flag for the inner interpreter
000161 9508          ret ; returns the interrupt, the rcall stack frame is removed!
                 
                 ; lower part of the dictionary
                 .include "dict/rww.inc"
                 
                 
                 ; Arithmetics
                 ; add a number to a double cell
                 VE_MPLUS:
000162 ff02          .dw $ff02
000163 2b6d          .db "m+"
000164 012d          .dw VE_HEAD
                     .set VE_HEAD = VE_MPLUS
                 XT_MPLUS:
000165 f000          .dw DO_COLON
                 PFA_MPLUS:
000166 fd81          .dw XT_S2D
000167 f41f          .dw XT_DPLUS
000168 f020          .dw XT_EXIT
                 .include "words/ud-star.asm"
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_UDSTAR:
000169 ff03          .dw $ff03
00016a 6475
../../common\words/ud-star.asm(9): warning: .cseg .db misalignment - padding zero byte
00016b 002a          .db "ud*"
00016c 0162          .dw VE_HEAD
                     .set VE_HEAD = VE_UDSTAR
                 XT_UDSTAR:
00016d f000          .dw DO_COLON
                 PFA_UDSTAR:
                 
                 .endif
                 ;Z UD*      ud1 d2 -- ud3      32*16->32 multiply
                 ;   XT_DUP >R UM* DROP  XT_SWAP R> UM* ROT + ;
                 
00016e f0bd
00016f f10b
000170 f1ec
000171 f0e5              .DW XT_DUP,XT_TO_R,XT_UMSTAR,XT_DROP
000172 f0d0
000173 f102
000174 f1ec
000175 f0ed
000176 f1a9
000177 f020              .DW XT_SWAP,XT_R_FROM,XT_UMSTAR,XT_ROT,XT_PLUS,XT_EXIT
                 .include "words/umax.asm"
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_UMAX:
000178 ff04          .dw $ff04
000179 6d75
00017a 7861          .db "umax"
00017b 0169          .dw VE_HEAD
                     .set VE_HEAD = VE_UMAX
                 XT_UMAX:
00017c f000          .dw DO_COLON
                 PFA_UMAX:
                 .endif
                 
00017d f57f
00017e f168              .DW XT_2DUP,XT_ULESS
00017f f039      	.dw XT_DOCONDBRANCH
000180 0182      	 DEST(UMAX1)
000181 f0d0              .DW XT_SWAP
000182 f0e5      UMAX1:  .DW XT_DROP
000183 f020      	.dw XT_EXIT
                 .include "words/umin.asm"
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_UMIN:
000184 ff04          .dw $ff04
000185 6d75
000186 6e69          .db "umin"
000187 0178          .dw VE_HEAD
                     .set VE_HEAD = VE_UMIN
                 XT_UMIN:
000188 f000          .dw DO_COLON
                 PFA_UMIN:
                 .endif
000189 f57f
00018a f173              .DW XT_2DUP,XT_UGREATER
00018b f039      	.dw XT_DOCONDBRANCH
00018c 018e      	DEST(UMIN1)
00018d f0d0              .DW XT_SWAP
00018e f0e5      UMIN1:  .DW XT_DROP
00018f f020      	.dw XT_EXIT
                 .include "words/immediate-q.asm"
                 
                 ; Tools
                 ; get count information out of a counted string in flash
                 ;VE_IMMEDIATEQ:
                 ;    .dw $ff06
                 ;    .db "immediate?"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_IMMEDIATEQ
                 XT_IMMEDIATEQ:
000190 f000          .dw DO_COLON
                 PFA_IMMEDIATEQ:
000191 f040          .dw XT_DOLITERAL
000192 8000          .dw $8000
000193 f21f          .dw XT_AND
000194 f126          .dw XT_ZEROEQUAL
000195 f039          .dw XT_DOCONDBRANCH
000196 019a          DEST(IMMEDIATEQ1)
000197 f040           .dw XT_DOLITERAL
000198 0001           .dw 1
000199 f020           .dw XT_EXIT
                 IMMEDIATEQ1:
                     ; not immediate
00019a f157          .dw XT_TRUE
00019b f020          .dw XT_EXIT
                 .include "words/name2flags.asm"
                 
                 ; Tools
                 ; get the flags from a name token
                 VE_NAME2FLAGS:
00019c ff0a          .dw $ff0a
00019d 616e
00019e 656d
00019f 663e
0001a0 616c
0001a1 7367          .db "name>flags"
0001a2 0184          .dw VE_HEAD
                     .set VE_HEAD = VE_NAME2FLAGS
                 XT_NAME2FLAGS:
0001a3 f000          .dw DO_COLON
                 PFA_NAME2FLAGS:
0001a4 f3d2          .dw XT_FETCHI ; skip to link field
0001a5 f040          .dw XT_DOLITERAL
0001a6 ff00          .dw $ff00
0001a7 f21f          .dw XT_AND
0001a8 f020          .dw XT_EXIT
                 .include "words/name2interpret.asm"
                 
                 ; Tools (ext)
                 ; get the execution token from the name token
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_NAME2INTERPRET:
0001a9 ff0e          .dw $ff0e
0001aa 616e
0001ab 656d
0001ac 693e
0001ad 746e
0001ae 7265
0001af 7270
0001b0 7465          .db "name>interpret"
0001b1 019c          .dw VE_HEAD
                     .set VE_HEAD = VE_NAME2INTERPRET
                 XT_NAME2INTERPRET:
0001b2 f000          .dw DO_COLON
                 PFA_NAME2INTERPRET:
                 .endif
0001b3 fc8b          .dw XT_NFA2CFA
0001b4 f020          .dw XT_EXIT
                 .include "words/name2compile.asm"
                 
                 ; Tools (ext)
                 ; get the execution token from the name token in compile state
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_NAME2COMPILE:
0001b5 ff0c          .dw $ff0c
0001b6 616e
0001b7 656d
0001b8 633e
0001b9 6d6f
0001ba 6970
0001bb 656c          .db "name>compile"
0001bc 01a9          .dw VE_HEAD
                     .set VE_HEAD = VE_NAME2COMPILE
                 XT_NAME2COMPILE:
0001bd f000          .dw DO_COLON
                 PFA_NAME2COMPILE:
                 .endif
0001be f0bd          .dw XT_DUP
0001bf fc8b          .dw XT_NFA2CFA
0001c0 f0d0          .dw XT_SWAP
0001c1 01a3          .dw XT_NAME2FLAGS
0001c2 0190          .dw XT_IMMEDIATEQ
0001c3 f039          .dw XT_DOCONDBRANCH
0001c4 01c8          DEST(NAME2COMPILE1)
0001c5 f040      	.dw XT_DOLITERAL
0001c6 0202      	.dw XT_COMMA
0001c7 f020      	.dw XT_EXIT
                 NAME2COMPILE1:
0001c8 f040      	.dw XT_DOLITERAL
0001c9 f02a      	.dw XT_EXECUTE
0001ca f020          .dw XT_EXIT
                 
                 .if AMFORTH_NRWW_SIZE > 8000
                 .include "dict/appl_8k.inc"
                 
                 
                 .include "words/docreate.asm"
                 
                 ; Compiler
                 ; parse the input and create an empty vocabulary entry without XT and data field (PF)
                 VE_DOCREATE:
0001cb ff08          .dw $ff08
0001cc 6328
0001cd 6572
0001ce 7461
0001cf 2965          .db "(create)"
0001d0 01b5          .dw VE_HEAD
                     .set VE_HEAD = VE_DOCREATE
                 XT_DOCREATE:
0001d1 f000          .dw DO_COLON
                 PFA_DOCREATE:
0001d2 f9d1          .dw XT_PARSENAME
0001d3 032c          .dw XT_WLSCOPE
0001d4 f0bd          .dw XT_DUP
0001d5 f10b          .dw XT_TO_R
0001d6 0311          .dw XT_HEADER
0001d7 f102          .dw XT_R_FROM
                 .dseg
000217           COLON_SMUDGE: .byte 4
                 .cseg
0001d8 f040          .dw XT_DOLITERAL
0001d9 0219          .dw COLON_SMUDGE+2
0001da f08d          .dw XT_STORE		; save wid
0001db f040          .dw XT_DOLITERAL
0001dc 0217          .dw COLON_SMUDGE+0
0001dd f08d          .dw XT_STORE		; save NFA
                 
0001de f020          .dw XT_EXIT
                 .include "words/backslash.asm"
                 
                 ; Compiler
                 ; everything up to the end of the current line is a comment
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_BACKSLASH:
0001df 0001          .dw $0001
0001e0 005c          .db $5c,0
0001e1 01cb          .dw VE_HEAD
                     .set VE_HEAD = VE_BACKSLASH
                 XT_BACKSLASH:
0001e2 f000          .dw DO_COLON
                 PFA_BACKSLASH:
                 .endif
0001e3 f9b8          .dw XT_SOURCE
0001e4 f0fc          .dw XT_NIP
0001e5 f598          .dw XT_TO_IN
0001e6 f08d          .dw XT_STORE
0001e7 f020          .dw XT_EXIT
                 .include "words/l-paren.asm"
                 
                 ; Compiler
                 ; skip everything up to the closing bracket on the same line
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_LPAREN:
0001e8 0001          .dw $0001
0001e9 0028          .db "(" ,0
0001ea 01df          .dw VE_HEAD
                     .set VE_HEAD = VE_LPAREN
                 XT_LPAREN:
0001eb f000          .dw DO_COLON
                 PFA_LPAREN:
                 .endif
0001ec f040          .dw XT_DOLITERAL
0001ed 0029          .dw ')'
0001ee f9a3          .dw XT_PARSE
0001ef f588          .dw XT_2DROP
0001f0 f020          .dw XT_EXIT
                 
                 .include "words/compile.asm"
                 
                 ; Dictionary
                 ; read the following cell from the dictionary and append it to the current dictionary position.
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_COMPILE:
0001f1 ff07          .dw $ff07
0001f2 6f63
0001f3 706d
0001f4 6c69
0001f5 0065          .db "compile",0
0001f6 01e8          .dw  VE_HEAD
                     .set VE_HEAD = VE_COMPILE
                 XT_COMPILE:
0001f7 f000          .dw DO_COLON
                 PFA_COMPILE:
                 .endif
0001f8 f102          .dw XT_R_FROM
0001f9 f0bd          .dw XT_DUP
0001fa fbb8          .dw XT_ICELLPLUS
0001fb f10b          .dw XT_TO_R
0001fc f3d2          .dw XT_FETCHI
0001fd 0202          .dw XT_COMMA
0001fe f020          .dw XT_EXIT
                 .include "words/comma.asm"
                 
                 ; Dictionary
                 ; compile 16 bit into flash at DP
                 VE_COMMA:
0001ff ff01          .dw $ff01
000200 002c          .db ',',0 ; ,
000201 01f1          .dw VE_HEAD
                     .set VE_HEAD = VE_COMMA
                 XT_COMMA:
000202 f000          .dw DO_COLON
                 PFA_COMMA:
000203 f5ce          .dw XT_DP
000204 f373          .dw XT_STOREI
000205 f5ce          .dw XT_DP
000206 f23b          .dw XT_1PLUS
000207 fba6          .dw XT_DOTO
000208 f5cf          .dw PFA_DP
000209 f020          .dw XT_EXIT
                 .include "words/brackettick.asm"
                 
                 ; Compiler
                 ; what ' does in the interpreter mode, do in colon definitions
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_BRACKETTICK:
00020a 0003          .dw $0003
00020b 275b
00020c 005d          .db "[']",0
00020d 01ff          .dw VE_HEAD
                     .set VE_HEAD = VE_BRACKETTICK
                 XT_BRACKETTICK:
00020e f000          .dw DO_COLON
                 PFA_BRACKETTICK:
                 .endif
00020f f82e          .dw XT_TICK
000210 0218          .dw XT_LITERAL
000211 f020          .dw XT_EXIT
                 
                 
                 .include "words/literal.asm"
                 
                 ; Compiler
                 ; compile a literal in colon defintions
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_LITERAL:
000212 0007          .dw $0007
000213 696c
000214 6574
000215 6172
000216 006c          .db "literal",0
000217 020a          .dw VE_HEAD
                     .set VE_HEAD = VE_LITERAL
                 XT_LITERAL:
000218 f000          .dw DO_COLON
                 PFA_LITERAL:
                 .endif
000219 01f7              .DW XT_COMPILE
00021a f040              .DW XT_DOLITERAL
00021b 0202              .DW XT_COMMA
00021c f020              .DW XT_EXIT
                 .include "words/sliteral.asm"
                 
                 ; String
                 ; compiles a string to flash, at runtime leaves ( -- flash-addr count) on stack
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SLITERAL:
00021d 0008        .dw $0008
00021e 6c73
00021f 7469
000220 7265
000221 6c61        .db "sliteral"
000222 0212        .dw VE_HEAD
                   .set VE_HEAD = VE_SLITERAL
                 XT_SLITERAL:
000223 f000          .dw DO_COLON
                 PFA_SLITERAL:
                 .endif
000224 01f7          .dw XT_COMPILE
000225 f791          .dw XT_DOSLITERAL    ; ( -- addr n)
000226 f79f          .dw XT_SCOMMA
000227 f020          .dw XT_EXIT
                 .include "words/g-mark.asm"
                 
                 ; Compiler
                 ; places current dictionary position for backward resolves
                 ;VE_GMARK:
                 ;    .dw $ff05
                 ;    .db ">mark"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_GMARK
                 XT_GMARK:
000228 f000          .dw DO_COLON
                 PFA_GMARK:
000229 f5ce          .dw XT_DP
00022a 01f7          .dw XT_COMPILE
00022b ffff          .dw -1           ; ffff does not erase flash
00022c f020          .dw XT_EXIT
                 .include "words/g-resolve.asm"
                 
                 ; Compiler
                 ; resolve backward jumps
                 ;VE_GRESOLVE:
                 ;    .dw $ff08
                 ;    .db ">resolve"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_GRESOLVE
                 XT_GRESOLVE:
00022d f000          .dw DO_COLON
                 PFA_GRESOLVE:
00022e fb63          .dw XT_QSTACK
00022f f5ce          .dw XT_DP
000230 f0d0          .dw XT_SWAP
000231 f373          .dw XT_STOREI
000232 f020          .dw XT_EXIT
                 .include "words/l_mark.asm"
                 
                 ; Compiler
                 ; place destination for backward branch
                 ;VE_LMARK:
                 ;    .dw $ff05
                 ;    .db "<mark"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_LMARK
                 XT_LMARK:
000233 f000          .dw DO_COLON
                 PFA_LMARK:
000234 f5ce          .dw XT_DP
000235 f020          .dw XT_EXIT
                 .include "words/l_resolve.asm"
                 
                 ; Compiler
                 ; resolve backward branch
                 ;VE_LRESOLVE:
                 ;    .dw $ff08
                 ;    .db "<resolve"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_LRESOLVE
                 XT_LRESOLVE:
000236 f000          .dw DO_COLON
                 PFA_LRESOLVE:
000237 fb63          .dw XT_QSTACK
000238 0202          .dw XT_COMMA
000239 f020          .dw XT_EXIT
                 
                 .include "words/ahead.asm"
                 
                 ; Compiler
                 ; do a unconditional branch
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_AHEAD:
00023a 0005          .dw $0005
00023b 6861
00023c 6165
00023d 0064          .db "ahead",0
00023e 021d          .dw VE_HEAD
                     .set VE_HEAD = VE_AHEAD
                 XT_AHEAD:
00023f f000          .dw DO_COLON
                 PFA_AHEAD:
                 .endif
000240 01f7          .dw XT_COMPILE
000241 f02f          .dw XT_DOBRANCH
000242 0228          .dw XT_GMARK
000243 f020          .dw XT_EXIT
                 .include "words/if.asm"
                 
                 ; Compiler
                 ; start conditional branch
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_IF:
000244 0002          .dw $0002
000245 6669          .db "if"
000246 023a          .dw VE_HEAD
                     .set VE_HEAD = VE_IF
                 XT_IF:
000247 f000          .dw DO_COLON
                 PFA_IF:
                 .endif
000248 01f7          .dw XT_COMPILE
000249 f039          .dw XT_DOCONDBRANCH
00024a 0228          .dw XT_GMARK
00024b f020          .dw XT_EXIT
                 .include "words/else.asm"
                 
                 ; Compiler
                 ; resolve the forward reference and place a new unresolved forward reference
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_ELSE:
00024c 0004          .dw $0004
00024d 6c65
00024e 6573          .db "else"
00024f 0244          .dw VE_HEAD
                     .set VE_HEAD = VE_ELSE
                 XT_ELSE:
000250 f000          .dw DO_COLON
                 PFA_ELSE:
                 .endif
000251 01f7          .dw XT_COMPILE
000252 f02f          .dw XT_DOBRANCH
000253 0228          .dw XT_GMARK
000254 f0d0          .dw XT_SWAP
000255 022d          .dw XT_GRESOLVE
000256 f020          .dw XT_EXIT
                 .include "words/then.asm"
                 
                 ; Compiler
                 ; finish if
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_THEN:
000257 0004          .dw $0004
000258 6874
000259 6e65          .db "then"
00025a 024c          .dw VE_HEAD
                     .set VE_HEAD = VE_THEN
                 XT_THEN:
00025b f000          .dw DO_COLON
                 PFA_THEN:
                 .endif
00025c 022d          .dw XT_GRESOLVE
00025d f020          .dw XT_EXIT
                 .include "words/begin.asm"
                 
                 ; Compiler
                 ; put the next location for a transfer of control onto the control flow stack
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_BEGIN:
00025e 0005          .dw $0005
00025f 6562
000260 6967
000261 006e          .db "begin",0
000262 0257          .dw VE_HEAD
                     .set VE_HEAD = VE_BEGIN
                 XT_BEGIN:
000263 f000          .dw DO_COLON
                 PFA_BEGIN:
                 .endif
000264 0233          .dw XT_LMARK
000265 f020          .dw XT_EXIT
                 .include "words/while.asm"
                 
                 ; Compiler
                 ; at runtime skip until repeat if non-true
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_WHILE:
000266 0005          .dw $0005
000267 6877
000268 6c69
000269 0065          .db "while",0
00026a 025e          .dw VE_HEAD
                     .set VE_HEAD = VE_WHILE
                 XT_WHILE:
00026b f000          .dw DO_COLON
                 PFA_WHILE:
                 .endif
00026c 0247          .dw XT_IF
00026d f0d0          .dw XT_SWAP
00026e f020          .dw XT_EXIT
                 .include "words/repeat.asm"
                 
                 ; Compiler
                 ; continue execution at dest, resolve orig
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_REPEAT:
00026f 0006          .dw $0006
000270 6572
000271 6570
000272 7461          .db "repeat"
000273 0266          .dw VE_HEAD
                     .set VE_HEAD = VE_REPEAT
                 XT_REPEAT:
000274 f000          .dw DO_COLON
                 PFA_REPEAT:
                 .endif
000275 0288          .dw XT_AGAIN
000276 025b          .dw XT_THEN
000277 f020          .dw XT_EXIT
                 .include "words/until.asm"
                 
                 ; Compiler
                 ; finish begin with conditional branch, leaves the loop if true flag at runtime
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_UNTIL:
000278 0005          .dw $0005
000279 6e75
00027a 6974
00027b 006c          .db "until",0
00027c 026f          .dw VE_HEAD
                     .set VE_HEAD = VE_UNTIL
                 XT_UNTIL:
00027d f000          .dw DO_COLON
                 PFA_UNTIL:
                 .endif
00027e f040          .dw XT_DOLITERAL
00027f f039          .dw XT_DOCONDBRANCH
000280 0202          .dw XT_COMMA
                 
000281 0236          .dw XT_LRESOLVE
000282 f020          .dw XT_EXIT
                 .include "words/again.asm"
                 
                 ; Compiler
                 ; compile a jump back to dest
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_AGAIN:
000283 0005          .dw $0005
000284 6761
000285 6961
000286 006e          .db "again",0
000287 0278          .dw VE_HEAD
                     .set VE_HEAD = VE_AGAIN
                 XT_AGAIN:
000288 f000          .dw DO_COLON
                 PFA_AGAIN:
                 .endif
000289 01f7          .dw XT_COMPILE
00028a f02f          .dw XT_DOBRANCH
00028b 0236          .dw XT_LRESOLVE
00028c f020          .dw XT_EXIT
                 .include "words/do.asm"
                 
                 ; Compiler
                 ; start do .. [+]loop
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DO:
00028d 0002          .dw $0002
00028e 6f64          .db "do"
00028f 0283          .dw VE_HEAD
                     .set VE_HEAD = VE_DO
                 XT_DO:
000290 f000          .dw DO_COLON
                 PFA_DO:
                 
                 .endif
000291 01f7          .dw XT_COMPILE
000292 f29b          .dw XT_DODO
000293 0233          .dw XT_LMARK
000294 f160          .dw XT_ZERO
000295 02eb          .dw XT_TO_L
000296 f020          .dw XT_EXIT
                 .include "words/loop.asm"
                 
                 ; Compiler
                 ; compile (loop) and resolve the backward branch
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_LOOP:
000297 0004          .dw $0004
000298 6f6c
000299 706f          .db "loop"
00029a 028d          .dw VE_HEAD
                     .set VE_HEAD = VE_LOOP
                 XT_LOOP:
00029b f000          .dw DO_COLON
                 PFA_LOOP:
                 .endif
00029c 01f7          .dw XT_COMPILE
00029d f2c9          .dw XT_DOLOOP
00029e 02d2          .dw XT_ENDLOOP
00029f f020          .dw XT_EXIT
                 .include "words/plusloop.asm"
                 
                 ; Compiler
                 ; compile (+loop) and resolve branches
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_PLUSLOOP:
0002a0 0005          .dw $0005
0002a1 6c2b
0002a2 6f6f
0002a3 0070          .db "+loop",0
0002a4 0297          .dw VE_HEAD
                     .set VE_HEAD = VE_PLUSLOOP
                 XT_PLUSLOOP:
0002a5 f000          .dw DO_COLON
                 PFA_PLUSLOOP:
                 .endif
0002a6 01f7          .dw XT_COMPILE
0002a7 f2ba          .dw XT_DOPLUSLOOP
0002a8 02d2          .dw XT_ENDLOOP
0002a9 f020          .dw XT_EXIT
                 .include "words/leave.asm"
                 
                 ; Compiler
                 ; immediatly leave the current DO..LOOP
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_LEAVE:
0002aa 0005         .dw $0005
0002ab 656c
0002ac 7661
0002ad 0065         .db "leave",0
0002ae 02a0         .dw VE_HEAD
                    .set VE_HEAD = VE_LEAVE
                 XT_LEAVE:
0002af f000          .dw DO_COLON
                 PFA_LEAVE:
                 .endif
0002b0 01f7
0002b1 f2d4          .DW XT_COMPILE,XT_UNLOOP
0002b2 023f
0002b3 02eb
0002b4 f020          .DW XT_AHEAD,XT_TO_L,XT_EXIT
                 .include "words/qdo.asm"
                 
                 ; Compiler
                 ; start a ?do .. [+]loop control structure
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 VE_QDO:
0002b5 0003          .dw $0003
0002b6 643f
0002b7 006f          .db "?do",0
0002b8 02aa          .dw VE_HEAD
                     .set VE_HEAD = VE_QDO
                 XT_QDO:
0002b9 f000          .dw DO_COLON
                 PFA_QDO:
                 .endif
0002ba 01f7          .dw XT_COMPILE
0002bb 02c1          .dw XT_QDOCHECK
0002bc 0247          .dw XT_IF
0002bd 0290          .dw XT_DO
0002be f0d0          .dw XT_SWAP    ; DO sets a 0 marker on the leave stack
0002bf 02eb          .dw XT_TO_L    ; then follows at the end.
0002c0 f020          .dw XT_EXIT
                 
                 ; there is no special runtime for ?do, the do runtime
                 ; gets wrapped with the sequence
                 ; ... ?do-check if do ..... loop then
                 ; with
                 ; : ?do-check ( n1 n2 -- n1 n2 true | false )
                 ;   2dup = dup >r if 2drop then r> invert ;
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 XT_QDOCHECK:
0002c1 f000          .dw DO_COLON
                 PFA_QDOCHECK:
                 .endif
0002c2 f57f          .dw XT_2DUP
0002c3 fd9d          .dw XT_EQUAL
0002c4 f0bd          .dw XT_DUP
0002c5 f10b          .dw XT_TO_R
0002c6 f039          .dw XT_DOCONDBRANCH
0002c7 02c9          DEST(PFA_QDOCHECK1)
0002c8 f588          .dw XT_2DROP
                 PFA_QDOCHECK1:
0002c9 f102          .dw XT_R_FROM
0002ca f209          .dw XT_INVERT
0002cb f020          .dw XT_EXIT
                 .include "words/endloop.asm"
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_ENDLOOP:
0002cc ff07          .dw $ff07
0002cd 6e65
0002ce 6c64
0002cf 6f6f
0002d0 0070          .db "endloop",0
0002d1 02b5          .dw VE_HEAD
                     .set VE_HEAD = VE_ENDLOOP
                 XT_ENDLOOP:
0002d2 f000          .dw DO_COLON
                 PFA_ENDLOOP:
                 .endif
                 ;Z ENDLOOP   adrs xt --   L: 0 a1 a2 .. aN --
                 ;   <resolve                backward loop
                 ;   BEGIN L> ?DUP WHILE POSTPONE THEN REPEAT ;
                 ;                                 resolve LEAVEs
                 ; This is a common factor of LOOP and +LOOP.
                 
0002d3 0236              .DW XT_LRESOLVE
0002d4 02df
0002d5 f0c5
0002d6 f039      LOOP1:  .DW XT_L_FROM,XT_QDUP,XT_DOCONDBRANCH
0002d7 02db               DEST(LOOP2)
0002d8 025b              .DW XT_THEN
0002d9 f02f      	.dw XT_DOBRANCH
0002da 02d4               DEST(LOOP1)
0002db f020      LOOP2:  .DW XT_EXIT
                 ; leave address stack
                 .include "words/l-from.asm"
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_L_FROM:
0002dc ff02          .dw $ff02
0002dd 3e6c          .db "l>"
0002de 02cc          .dw VE_HEAD
                     .set VE_HEAD = VE_L_FROM
                 XT_L_FROM:
0002df f000          .dw DO_COLON
                 PFA_L_FROM:
                 
                 .endif
                 ;Z L>   -- x   L: x --      move from leave stack
                 ;   LP @ @  -2 LP +! ;
                 
0002e0 02ff          .dw XT_LP
0002e1 f085          .dw XT_FETCH
0002e2 f085          .dw XT_FETCH
0002e3 f040          .dw XT_DOLITERAL
0002e4 fffe          .dw -2
0002e5 02ff          .dw XT_LP
0002e6 f265          .dw XT_PLUSSTORE
0002e7 f020          .dw XT_EXIT
                 .include "words/to-l.asm"
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_TO_L:
0002e8 ff02          .dw $ff02
0002e9 6c3e          .db ">l"
0002ea 02dc          .dw VE_HEAD
                     .set VE_HEAD = VE_TO_L
                 XT_TO_L:
0002eb f000          .dw DO_COLON
                 PFA_TO_L:
                 .endif
                 ;Z >L   x --   L: -- x        move to leave stack
                 ;   CELL LP +!  LP @ ! ;      (L stack grows up)
                 
0002ec f040              .dw XT_DOLITERAL
0002ed 0002      	.dw 2
0002ee 02ff      	.dw XT_LP
0002ef f265      	.dw XT_PLUSSTORE
0002f0 02ff      	.dw XT_LP
0002f1 f085      	.dw XT_FETCH
0002f2 f08d      	.dw XT_STORE
0002f3 f020      	.dw XT_EXIT
                 .include "words/lp0.asm"
                 
                 ; Stack
                 ; start address of leave stack
                 VE_LP0:
0002f4 ff03          .dw $ff03
0002f5 706c
0002f6 0030          .db "lp0",0
0002f7 02e8          .dw VE_HEAD
                     .set VE_HEAD = VE_LP0
                 XT_LP0:
0002f8 f07b          .dw PFA_DOVALUE1
                 PFA_LP0:
0002f9 00a4          .dw EE_LP0
0002fa fbc1          .dw XT_EDEFERFETCH
0002fb fbcb          .dw XT_EDEFERSTORE
                 .include "words/lp.asm"
                 
                 ; System Variable
                 ; leave stack pointer
                 VE_LP:
0002fc ff02          .dw $ff02
0002fd 706c          .db "lp"
0002fe 02f4          .dw VE_HEAD
                     .set VE_HEAD = VE_LP
                 XT_LP:
0002ff f04e          .dw PFA_DOVARIABLE
                 PFA_LP:
000300 021b          .dw ram_lp
                 
                 .dseg
00021b           ram_lp: .byte 2
                 .cseg
                 
                 
                 .include "words/create.asm"
                 
                 ; Dictionary
                 ; create a dictionary header. XT is (constant), with the address of the data field of name
                 VE_CREATE:
000301 ff06          .dw $ff06
000302 7263
000303 6165
000304 6574          .db "create"
000305 02fc          .dw VE_HEAD
                     .set VE_HEAD = VE_CREATE
                 XT_CREATE:
000306 f000          .dw DO_COLON
                 PFA_CREATE:
000307 01d1          .dw XT_DOCREATE
000308 0335          .dw XT_REVEAL
000309 01f7          .dw XT_COMPILE
00030a f05b          .dw PFA_DOCONSTANT
00030b f020          .dw XT_EXIT
                 .include "words/header.asm"
                 
                 ; Compiler
                 ; creates the vocabulary header without XT and data field (PF) in the wordlist wid
                 VE_HEADER:
00030c ff06          .dw $ff06
00030d 6568
00030e 6461
00030f 7265          .db "header"
000310 0301          .dw VE_HEAD
                     .set VE_HEAD = VE_HEADER
                 XT_HEADER:
000311 f000          .dw DO_COLON
                 PFA_HEADER:
000312 f5ce          .dw XT_DP           ; the new Name Field
000313 f10b          .dw XT_TO_R
000314 f10b          .dw XT_TO_R		; ( R: NFA WID )
000315 f0bd          .dw XT_DUP    
000316 f134          .dw XT_GREATERZERO 
000317 f039          .dw XT_DOCONDBRANCH
000318 0323          .dw PFA_HEADER1
000319 f0bd          .dw XT_DUP
00031a f040          .dw XT_DOLITERAL
00031b ff00          .dw $ff00           ; all flags are off (e.g. immediate)
00031c f228          .dw XT_OR
00031d f7a3          .dw XT_DOSCOMMA
                     ; make the link to the previous entry in this wordlist
00031e f102          .dw XT_R_FROM
00031f f35f          .dw XT_FETCHE
000320 0202          .dw XT_COMMA
000321 f102          .dw XT_R_FROM
000322 f020          .dw XT_EXIT
                 
                 PFA_HEADER1:
                     ; -16: attempt to use zero length string as a name
000323 f040          .dw XT_DOLITERAL
000324 fff0          .dw -16
000325 f85d          .dw XT_THROW
                 
                 .include "words/wlscope.asm"
                 
                 ; Compiler
                 ; dynamically place a word in a wordlist. The word name may be changed.
                 VE_WLSCOPE:
000326 ff07          .dw $ff07
000327 6c77
000328 6373
000329 706f
00032a 0065          .db "wlscope",0
00032b 030c          .dw VE_HEAD
                     .set VE_HEAD = VE_WLSCOPE
                 XT_WLSCOPE:
00032c fc20          .dw PFA_DODEFER1
                 PFA_WLSCOPE:
00032d 00a2          .dw EE_WLSCOPE
00032e fbc1          .dw XT_EDEFERFETCH
00032f fbcb          .dw XT_EDEFERSTORE
                 
                 ; wlscope, "wordlist scope" ( addr len -- addr' len' wid ), is a deferred word
                 ; which enables the AmForth application to choose the wordlist ( wid ) for the
                 ; new voc entry based on the input ( addr len ) string. The name of the new voc
                 ; entry ( addr' len' ) may be different from the input string. Note that all
                 ; created voc entry types pass through the wlscope mechanism. The default
                 ; wlscope action passes the input string to the output without modification and
                 ; uses get-current to select the wid.
                 .include "words/reveal.asm"
                 
                 ; Dictionary
                 ; makes an entry in a wordlist visible, if not already done.
                 VE_REVEAL:
000330 ff06          .dw $ff06
000331 6572
000332 6576
000333 6c61          .db "reveal"
000334 0326          .dw VE_HEAD
                     .set VE_HEAD = VE_REVEAL
                 XT_REVEAL:
000335 f000          .dw DO_COLON
                 PFA_REVEAL:
000336 f040          .dw XT_DOLITERAL
000337 0217          .dw COLON_SMUDGE+0
000338 f085          .dw XT_FETCH
000339 f0c5          .dw XT_QDUP
00033a f039          .dw XT_DOCONDBRANCH
00033b 0344          .dw PFA_REVEAL1
                 ;
00033c f040          .dw XT_DOLITERAL
00033d 0219          .dw COLON_SMUDGE+2
00033e f085          .dw XT_FETCH		; ( NFA WID )
00033f f33b          .dw XT_STOREE
                     ; prevent duplicate actions and cooperate with :noname
000340 f160          .dw XT_ZERO
000341 f040          .dw XT_DOLITERAL
000342 0217          .dw COLON_SMUDGE+0
000343 f08d          .dw XT_STORE
                 PFA_REVEAL1:
000344 f020          .dw XT_EXIT
                 .include "words/latest.asm"
                 
                 ; System Variable
                 ; system LATEST
                 VE_LATEST:
000345 ff06          .dw $ff06
000346 616c
000347 6574
000348 7473          .db "latest"
000349 0330          .dw VE_HEAD
                     .set VE_HEAD = VE_LATEST
                 XT_LATEST:
00034a f04e          .dw PFA_DOVARIABLE
                 PFA_LATEST:
00034b 021d          .dw ram_LATEST
                 
                 .dseg
00021d           ram_LATEST: .byte 2
                 .cseg
                 .include "words/does.asm"
                 
                 ; Compiler
                 ; organize the XT replacement to call other colon code
                 VE_DOES:
00034c 0005          .dw $0005
00034d 6f64
00034e 7365
00034f 003e          .db "does>",0
000350 0345          .dw VE_HEAD
                     .set VE_HEAD = VE_DOES
                 XT_DOES:
000351 f000          .dw DO_COLON
                 PFA_DOES:
000352 01f7          .dw XT_COMPILE
000353 0364          .dw XT_DODOES
000354 01f7          .dw XT_COMPILE  ; create a code snippet to be used in an embedded XT
000355 940e          .dw $940e       ; the address of this compiled
000356 01f7          .dw XT_COMPILE  ; code will replace the XT of the 
000357 0359          .dw DO_DODOES   ; word that CREATE created
000358 f020          .dw XT_EXIT     ; 
                 
                 DO_DODOES: ; ( -- PFA )
000359 939a
00035a 938a          savetos
00035b 01cb          movw tosl, wl
00035c 9601          adiw tosl, 1
                     ; the following takes the address from a real uC-call
                 .if (pclen==3)
                 .endif
00035d 917f          pop wh
00035e 916f          pop wl
                 
00035f 93bf          push XH
000360 93af          push XL
000361 01db          movw XL, wl
000362 940c f004     jmp_ DO_NEXT
                 
                 ; ( -- )
                 ; System
                 ; replace the XT written by CREATE to call the code that follows does>
                 ;VE_DODOES:
                 ;   .dw $ff07
                 ;   .db "(does>)"
                 ;   .set VE_HEAD = VE_DODOES
                 XT_DODOES:
000364 f000          .dw DO_COLON
                 PFA_DODOES:
000365 f102          .dw XT_R_FROM
000366 f040          .dw XT_DOLITERAL
000367 0219          .dw COLON_SMUDGE+2
000368 f085          .dw XT_FETCH
000369 f35f          .dw XT_FETCHE
00036a 04b2          .dw XT_NFA2LFA
00036b f23b          .dw XT_1PLUS   ; lfa>xt
                 
00036c f373          .dw XT_STOREI
00036d f020          .dw XT_EXIT
                 .include "words/colon.asm"
                 
                 ; Compiler
                 ; create a named entry in the dictionary, XT is DO_COLON
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_COLON:
00036e ff01          .dw $ff01
00036f 003a          .db ":",0
000370 034c          .dw VE_HEAD
                     .set VE_HEAD = VE_COLON
                 XT_COLON:
000371 f000          .dw DO_COLON
                 PFA_COLON:
                 .endif
000372 01d1          .dw XT_DOCREATE
000373 037c          .dw XT_COLONNONAME
000374 f0e5          .dw XT_DROP
000375 f020          .dw XT_EXIT
                 .include "words/colon-noname.asm"
                 
                 ; Compiler
                 ; create an unnamed entry in the dictionary, XT is DO_COLON
                 VE_COLONNONAME:
000376 ff07          .dw $ff07
000377 6e3a
000378 6e6f
000379 6d61
00037a 0065          .db ":noname",0
00037b 036e          .dw VE_HEAD
                     .set VE_HEAD = VE_COLONNONAME
                 XT_COLONNONAME:
00037c f000          .dw DO_COLON
                 PFA_COLONNONAME:
00037d f5ce          .dw XT_DP
00037e f0bd          .dw XT_DUP
00037f 034a          .dw XT_LATEST
000380 f08d          .dw XT_STORE
                 
000381 01f7          .dw XT_COMPILE
000382 f000          .dw DO_COLON
                 
000383 0391          .dw XT_RBRACKET
000384 f020          .dw XT_EXIT
                 .include "words/semicolon.asm"
                 
                 ; Compiler
                 ; finish colon defintion, compiles (exit) and returns to interpret state 
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 
                 VE_SEMICOLON:
000385 0001          .dw $0001
000386 003b          .db $3b,0
000387 0376          .dw VE_HEAD
                     .set VE_HEAD = VE_SEMICOLON
                 XT_SEMICOLON:
000388 f000          .dw DO_COLON
                 PFA_SEMICOLON:
                 .endif
000389 01f7          .dw XT_COMPILE
00038a f020          .dw XT_EXIT
00038b 039a          .dw XT_LBRACKET
00038c 0335          .dw XT_REVEAL
00038d f020          .dw XT_EXIT
                 .include "words/right-bracket.asm"
                 
                 ; Compiler
                 ; enter compiler mode
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_RBRACKET:
00038e ff01          .dw $ff01
00038f 005d          .db "]",0
000390 0385          .dw VE_HEAD
                     .set VE_HEAD = VE_RBRACKET
                 XT_RBRACKET:
000391 f000          .dw DO_COLON
                 PFA_RBRACKET:
                 .endif
000392 f040          .dw XT_DOLITERAL
000393 0001          .dw 1
000394 f565          .dw XT_STATE
000395 f08d          .dw XT_STORE
000396 f020          .dw XT_EXIT
                 .include "words/left-bracket.asm"
                 
                 ; Compiler
                 ; enter interpreter mode
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_LBRACKET:
000397 0001          .dw $0001
000398 005b          .db "[",0
000399 038e          .dw VE_HEAD
                     .set VE_HEAD = VE_LBRACKET
                 XT_LBRACKET:
00039a f000          .dw DO_COLON
                 PFA_LBRACKET:
                 .endif
00039b f160          .dw XT_ZERO
00039c f565          .dw XT_STATE
00039d f08d          .dw XT_STORE
00039e f020          .dw XT_EXIT
                 .include "words/variable.asm"
                 
                 ; Compiler
                 ; create a dictionary entry for a variable and allocate 1 cell RAM
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 VE_VARIABLE:
00039f ff08          .dw $ff08
0003a0 6176
0003a1 6972
0003a2 6261
0003a3 656c          .db "variable"
0003a4 0397          .dw VE_HEAD
                     .set VE_HEAD = VE_VARIABLE
                 XT_VARIABLE:
0003a5 f000          .dw DO_COLON
                 PFA_VARIABLE:
                 .endif
0003a6 f5df          .dw XT_HERE
0003a7 03b2          .dw XT_CONSTANT
0003a8 f040          .dw XT_DOLITERAL
0003a9 0002          .dw 2
0003aa f5e8          .dw XT_ALLOT
0003ab f020          .dw XT_EXIT
                 .include "words/constant.asm"
                 
                 ; Compiler
                 ; create a constant in the dictionary
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 VE_CONSTANT:
0003ac ff08          .dw $ff08
0003ad 6f63
0003ae 736e
0003af 6174
0003b0 746e          .db "constant"
0003b1 039f          .dw VE_HEAD
                     .set VE_HEAD = VE_CONSTANT
                 XT_CONSTANT:
0003b2 f000          .dw DO_COLON
                 PFA_CONSTANT:
                 .endif
0003b3 01d1          .dw XT_DOCREATE
0003b4 0335          .dw XT_REVEAL
0003b5 01f7          .dw XT_COMPILE
0003b6 f04e          .dw PFA_DOVARIABLE
0003b7 0202          .dw XT_COMMA
0003b8 f020          .dw XT_EXIT
                 .include "words/user.asm"
                 
                 ; Compiler
                 ; create a dictionary entry for a user variable at offset n
                 VE_USER:
0003b9 ff04          .dw $ff04
0003ba 7375
0003bb 7265          .db "user"
0003bc 03ac          .dw VE_HEAD
                     .set VE_HEAD = VE_USER
                 XT_USER:
0003bd f000          .dw DO_COLON
                 PFA_USER:
0003be 01d1          .dw XT_DOCREATE
0003bf 0335          .dw XT_REVEAL
                 
0003c0 01f7          .dw XT_COMPILE
0003c1 f061          .dw PFA_DOUSER
0003c2 0202          .dw XT_COMMA
0003c3 f020          .dw XT_EXIT
                 
                 .include "words/recurse.asm"
                 
                 ; Compiler
                 ; compile the XT of the word currently being defined into the dictionary
                 VE_RECURSE:
0003c4 0007          .dw $0007
0003c5 6572
0003c6 7563
0003c7 7372
0003c8 0065          .db "recurse",0
0003c9 03b9          .dw VE_HEAD
                     .set VE_HEAD = VE_RECURSE
                 XT_RECURSE:
0003ca f000          .dw DO_COLON
                 PFA_RECURSE:
0003cb 034a          .dw XT_LATEST
0003cc f085          .dw XT_FETCH
0003cd 0202          .dw XT_COMMA
0003ce f020          .dw XT_EXIT
                 .include "words/immediate.asm"
                 
                 ; Compiler
                 ; set immediate flag for the most recent word definition
                 VE_IMMEDIATE:
0003cf ff09          .dw $ff09
0003d0 6d69
0003d1 656d
0003d2 6964
0003d3 7461
0003d4 0065          .db "immediate",0
0003d5 03c4          .dw VE_HEAD
                     .set VE_HEAD = VE_IMMEDIATE
                 XT_IMMEDIATE:
0003d6 f000          .dw DO_COLON
                 PFA_IMMEDIATE:
0003d7 0473          .dw XT_GET_CURRENT
0003d8 f35f          .dw XT_FETCHE
0003d9 f0bd          .dw XT_DUP
0003da f3d2          .dw XT_FETCHI
0003db f040          .dw XT_DOLITERAL
0003dc 7fff          .dw $7fff
0003dd f21f          .dw XT_AND
0003de f0d0          .dw XT_SWAP
0003df f373          .dw XT_STOREI
0003e0 f020          .dw XT_EXIT
                 
                 .include "words/bracketchar.asm"
                 
                 ; Tools
                 ; skip leading space delimites, place the first character of the word on the stack
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_BRACKETCHAR:
0003e1 0006          .dw $0006
0003e2 635b
0003e3 6168
0003e4 5d72          .db "[char]"
0003e5 03cf          .dw VE_HEAD
                     .set VE_HEAD = VE_BRACKETCHAR
                 XT_BRACKETCHAR:
0003e6 f000          .dw DO_COLON
                 PFA_BRACKETCHAR:
                 .endif
0003e7 01f7          .dw XT_COMPILE
0003e8 f040          .dw XT_DOLITERAL
0003e9 f900          .dw XT_CHAR
0003ea 0202          .dw XT_COMMA
0003eb f020          .dw XT_EXIT
                 .include "words/abort-string.asm"
                 
                 ;C         i*x x1 --       R: j*x --      x1<>0
                 ;   POSTPONE IS" POSTPONE ?ABORT ; IMMEDIATE
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_ABORTQUOTE:
0003ec 0006          .dw $0006
0003ed 6261
0003ee 726f
0003ef 2274          .db "abort",'"'
0003f0 03e1          .dw VE_HEAD
                     .set VE_HEAD = VE_ABORTQUOTE
                 XT_ABORTQUOTE:
0003f1 f000          .dw DO_COLON
                 PFA_ABORTQUOTE:
                 .endif
0003f2 f4db          .dw XT_SQUOTE
0003f3 01f7          .dw XT_COMPILE
0003f4 0404          .dw XT_QABORT
0003f5 f020          .DW XT_EXIT
                 .include "words/abort.asm"
                 
                 ; Exceptions
                 ; send an exception -1
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_ABORT:
0003f6 ff05          .dw $ff05
0003f7 6261
0003f8 726f
0003f9 0074          .db "abort",0
0003fa 03ec          .dw VE_HEAD
                     .set VE_HEAD = VE_ABORT
                 XT_ABORT:
0003fb f000          .dw DO_COLON
                 PFA_ABORT:
                 .endif
0003fc f040          .dw XT_DOLITERAL
0003fd ffff          .dw -1
0003fe f85d          .dw XT_THROW
                 .include "words/q-abort.asm"
                 
                 ;   ROT IF ITYPE ABORT THEN 2DROP ;
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_QABORT:
0003ff ff06          .dw $ff06
000400 613f
000401 6f62
000402 7472          .db "?abort"
000403 03f6          .dw VE_HEAD
                     .set VE_HEAD = VE_QABORT
                 XT_QABORT:
000404 f000          .dw DO_COLON
                 PFA_QABORT:
                 
                 .endif
000405 f0ed
000406 f039              .DW XT_ROT,XT_DOCONDBRANCH
000407 040a              DEST(QABO1)
000408 f7c4
000409 03fb              .DW XT_ITYPE,XT_ABORT
00040a f588
00040b f020      QABO1:  .DW XT_2DROP,XT_EXIT
                 
                 .include "words/get-stack.asm"
                 
                 ; Tools
                 ; Get a stack from EEPROM
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_GET_STACK:
00040c ff09          .dw $ff09
00040d 6567
00040e 2d74
00040f 7473
000410 6361
000411 006b          .db "get-stack",0
000412 03ff          .dw VE_HEAD
                     .set VE_HEAD = VE_GET_STACK
                 XT_GET_STACK:
000413 f000          .dw DO_COLON
                 PFA_N_FETCH_E:
                 .endif
000414 f0bd          .dw XT_DUP
000415 f578          .dw XT_CELLPLUS
000416 f0d0          .dw XT_SWAP
000417 f35f          .dw XT_FETCHE
000418 f0bd          .dw XT_DUP
000419 f10b          .dw XT_TO_R
00041a f160          .dw XT_ZERO
00041b f0d0          .dw XT_SWAP    ; go from bigger to smaller addresses
00041c 02c1          .dw XT_QDOCHECK
00041d f039          .dw XT_DOCONDBRANCH
00041e 042a          DEST(PFA_N_FETCH_E2)
00041f f29b          .dw XT_DODO
                 PFA_N_FETCH_E1:
                     ; ( ee-addr )
000420 f2ac          .dw XT_I
000421 f241          .dw XT_1MINUS
000422 f572          .dw XT_CELLS ; ( -- ee-addr i*2 )
000423 f0db          .dw XT_OVER  ; ( -- ee-addr i*2 ee-addr )
000424 f1a9          .dw XT_PLUS  ; ( -- ee-addr ee-addr+i
000425 f35f          .dw XT_FETCHE ;( -- ee-addr item_i )
000426 f0d0          .dw XT_SWAP   ;( -- item_i ee-addr )
000427 f157          .dw XT_TRUE  ; shortcut for -1
000428 f2ba          .dw XT_DOPLUSLOOP
000429 0420          DEST(PFA_N_FETCH_E1)
                 PFA_N_FETCH_E2:
00042a f588          .dw XT_2DROP
00042b f102          .dw XT_R_FROM
00042c f020          .dw XT_EXIT
                 
                 .include "words/set-stack.asm"
                 
                 ; Tools
                 ; Write a stack to EEPROM
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SET_STACK:
00042d ff09          .dw $ff09
00042e 6573
00042f 2d74
000430 7473
000431 6361
000432 006b          .db "set-stack",0
000433 040c          .dw VE_HEAD
                     .set VE_HEAD = VE_SET_STACK
                 XT_SET_STACK:
000434 f000          .dw DO_COLON
                 PFA_SET_STACK:
                 .endif
000435 f57f          .dw XT_2DUP
000436 f33b          .dw XT_STOREE ; ( -- i_n .. i_0 n e-addr )
000437 f0d0          .dw XT_SWAP    
000438 f160          .dw XT_ZERO
000439 02c1          .dw XT_QDOCHECK
00043a f039          .dw XT_DOCONDBRANCH
00043b 0442          DEST(PFA_SET_STACK2)
00043c f29b          .dw XT_DODO
                 PFA_SET_STACK1:
00043d f578          .dw XT_CELLPLUS ; ( -- i_x e-addr )
00043e f590          .dw XT_TUCK      ; ( -- e-addr i_x e-addr
00043f f33b          .dw XT_STOREE
000440 f2c9          .dw XT_DOLOOP
000441 043d          DEST(PFA_SET_STACK1)
                 PFA_SET_STACK2:
000442 f0e5          .dw XT_DROP
000443 f020          .dw XT_EXIT
                 
                 .include "words/map-stack.asm"
                 
                 ; Tools
                 ; Iterate over a stack
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_MAPSTACK:
000444 ff09          .dw $ff09
000445 616d
000446 2d70
000447 7473
000448 6361
000449 006b          .db "map-stack",0
00044a 042d          .dw VE_HEAD
                     .set VE_HEAD = VE_MAPSTACK
                 XT_MAPSTACK:
00044b f000          .dw DO_COLON
                 PFA_MAPSTACK:
                 .endif
00044c f0bd          .dw XT_DUP
00044d f578          .dw XT_CELLPLUS
00044e f0d0          .dw XT_SWAP
00044f f35f          .dw XT_FETCHE
000450 f572          .dw XT_CELLS
000451 fd78          .dw XT_BOUNDS
000452 02c1          .dw XT_QDOCHECK
000453 f039          .dw XT_DOCONDBRANCH
000454 0468          DEST(PFA_MAPSTACK3)
000455 f29b          .dw XT_DODO
                 PFA_MAPSTACK1:
000456 f2ac            .dw XT_I
000457 f35f            .dw XT_FETCHE   ; -- i*x XT id
000458 f0d0            .dw XT_SWAP
000459 f10b            .dw XT_TO_R
00045a f114            .dw XT_R_FETCH
00045b f02a            .dw XT_EXECUTE  ; i*x id -- j*y true | i*x false
00045c f0c5            .dw XT_QDUP
00045d f039            .dw XT_DOCONDBRANCH
00045e 0463            DEST(PFA_MAPSTACK2)
00045f f102               .dw XT_R_FROM
000460 f0e5               .dw XT_DROP
000461 f2d4               .dw XT_UNLOOP
000462 f020               .dw XT_EXIT
                 PFA_MAPSTACK2:
000463 f102            .dw XT_R_FROM
000464 f040            .dw XT_DOLITERAL
000465 0002            .dw 2
000466 f2ba            .dw XT_DOPLUSLOOP
000467 0456            DEST(PFA_MAPSTACK1)
                 PFA_MAPSTACK3:
000468 f0e5          .dw XT_DROP
000469 f160          .dw XT_ZERO
00046a f020          .dw XT_EXIT
                 
                 ;
                 ; : map-stack ( i*x XT e-addr -- j*y )
                 ;     dup cell+ swap @e cells bounds ?do 
                 ;       ( -- i*x XT )
                 ;       i @e swap >r r@ execute
                 ;       ?dup if r> drop unloop exit then
                 ;       r>
                 ;     2 +loop drop 0
                 ;
                 .include "words/get-current.asm"
                 
                 ; Search Order
                 ; get the wid of the current compilation word list
                 VE_GET_CURRENT:
00046b ff0b          .dw $ff0b
00046c 6567
00046d 2d74
00046e 7563
00046f 7272
000470 6e65
000471 0074          .db "get-current",0
000472 0444          .dw VE_HEAD
                     .set VE_HEAD = VE_GET_CURRENT
                 XT_GET_CURRENT:
000473 f000          .dw DO_COLON
                 PFA_GET_CURRENT:
000474 f040          .dw XT_DOLITERAL
000475 0082          .dw EE_CURRENT
000476 f35f          .dw XT_FETCHE
000477 f020          .dw XT_EXIT
                 .include "words/get-order.asm"
                 
                 ; Search Order
                 ; Get the current search order word list
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_GET_ORDER:
000478 ff09          .dw $ff09
000479 6567
00047a 2d74
00047b 726f
00047c 6564
00047d 0072          .db "get-order",0
00047e 046b          .dw VE_HEAD
                     .set VE_HEAD = VE_GET_ORDER
                 XT_GET_ORDER:
00047f f000          .dw DO_COLON
                 PFA_GET_ORDER:
                 .endif
000480 f040          .dw XT_DOLITERAL
000481 0086          .dw CFG_ORDERLISTLEN
000482 0413          .dw XT_GET_STACK
000483 f020          .dw XT_EXIT
                 
                 .include "words/compare.asm"
                 
                 ; String
                 ; compares two strings in RAM
                 VE_COMPARE:
000484 ff07          .dw $ff07
000485 6f63
000486 706d
000487 7261
000488 0065          .db "compare",0
000489 0478          .dw VE_HEAD
                     .set VE_HEAD = VE_COMPARE
                 XT_COMPARE:
00048a 048b          .dw PFA_COMPARE
                 PFA_COMPARE:
00048b 93bf          push xh
00048c 93af          push xl
00048d 018c          movw temp0, tosl
00048e 9189
00048f 9199          loadtos
000490 01dc          movw xl, tosl
000491 9189
000492 9199          loadtos
000493 019c          movw temp2, tosl
000494 9189
000495 9199          loadtos
000496 01fc          movw zl, tosl
                 PFA_COMPARE_LOOP:
000497 90ed          ld temp4, X+
000498 90f1          ld temp5, Z+
000499 14ef          cp temp4, temp5
00049a f451          brne PFA_COMPARE_NOTEQUAL
00049b 950a          dec temp0
00049c f019          breq PFA_COMPARE_ENDREACHED2
00049d 952a          dec temp2
00049e f7c1          brne PFA_COMPARE_LOOP
00049f c001          rjmp PFA_COMPARE_ENDREACHED
                 PFA_COMPARE_ENDREACHED2:
0004a0 952a          dec temp2
                 PFA_COMPARE_ENDREACHED:
0004a1 2b02          or temp0, temp2
0004a2 f411          brne PFA_COMPARE_CHECKLASTCHAR
0004a3 2788          clr tosl
0004a4 c002          rjmp PFA_COMPARE_DONE
                 PFA_COMPARE_CHECKLASTCHAR:
                 PFA_COMPARE_NOTEQUAL:
0004a5 ef8f          ser tosl
0004a6 c000          rjmp PFA_COMPARE_DONE
                 
                 PFA_COMPARE_DONE:
0004a7 2f98          mov tosh, tosl
0004a8 91af          pop xl
0004a9 91bf          pop xh
0004aa 940c f004     jmp_ DO_NEXT
                 .include "words/nfa2lfa.asm"
                 
                 ; System
                 ; get the link field address from the name field address
                 VE_NFA2LFA:
0004ac ff07         .dw $ff07
0004ad 666e
0004ae 3e61
0004af 666c
0004b0 0061         .db "nfa>lfa",0
0004b1 0484         .dw VE_HEAD
                    .set VE_HEAD = VE_NFA2LFA
                 XT_NFA2LFA:
0004b2 f000          .dw DO_COLON
                 PFA_NFA2LFA:
0004b3 fc7f          .dw XT_NAME2STRING
0004b4 f23b          .dw XT_1PLUS
0004b5 f210          .dw XT_2SLASH
0004b6 f1a9          .dw XT_PLUS
0004b7 f020          .dw XT_EXIT
                 .elif AMFORTH_NRWW_SIZE > 4000
                 .elif AMFORTH_NRWW_SIZE > 2000
                 .else
                 .endif
                 .include "dict_appl.inc"
                 
                 ; they may be moved to the core dictionary if needed
                 
                 .include "dict/compiler2.inc" ; additional words for the compiler
                 
                 ; included almost independently from each other
                 ; on a include-per-use basis
                 ;
                 .if DICT_COMPILER2 == 0
                 .set DICT_COMPILER2 = 1
                 
                 .include "words/set-current.asm"
                 
                 ; Search Order
                 ; set current word list to the given word list wid
                 VE_SET_CURRENT:
0004b8 ff0b          .dw $ff0b
0004b9 6573
0004ba 2d74
0004bb 7563
0004bc 7272
0004bd 6e65
0004be 0074          .db "set-current",0
0004bf 04ac          .dw VE_HEAD
                     .set VE_HEAD = VE_SET_CURRENT
                 XT_SET_CURRENT:
0004c0 f000          .dw DO_COLON
                 PFA_SET_CURRENT:
0004c1 f040          .dw XT_DOLITERAL
0004c2 0082          .dw EE_CURRENT
0004c3 f33b          .dw XT_STOREE
0004c4 f020          .dw XT_EXIT
                 .include "words/wordlist.asm"
                 
                 ; Search Order
                 ; create a new, empty wordlist
                 VE_WORDLIST:
0004c5 ff08          .dw $ff08
0004c6 6f77
0004c7 6472
0004c8 696c
0004c9 7473          .db "wordlist"
0004ca 04b8          .dw VE_HEAD
                     .set VE_HEAD = VE_WORDLIST
                 XT_WORDLIST:
0004cb f000          .dw DO_COLON
                 PFA_WORDLIST:
0004cc f5d7          .dw XT_EHERE
0004cd f160          .dw XT_ZERO
0004ce f0db          .dw XT_OVER
0004cf f33b          .dw XT_STOREE
0004d0 f0bd          .dw XT_DUP
0004d1 f578          .dw XT_CELLPLUS
0004d2 fba6          .dw XT_DOTO
0004d3 f5d8          .dw PFA_EHERE
0004d4 f020          .dw XT_EXIT
                 
                 .include "words/only.asm"
                 
                 ; Search Order
                 ; replace the order list with the system default list
                 VE_ONLY:
0004d5 ff04          .dw $ff04
0004d6 6e6f
0004d7 796c          .db "only"
0004d8 04c5          .dw VE_HEAD
                     .set VE_HEAD = VE_ONLY
                 XT_ONLY:
0004d9 f000          .dw DO_COLON
                 PFA_ONLY:
0004da f040          .dw XT_DOLITERAL
0004db 0084          .dw EE_FORTHWORDLIST
0004dc f040          .dw XT_DOLITERAL
0004dd 0001          .dw 1
0004de 04f4          .dw XT_SET_ORDER
0004df f020          .dw XT_EXIT
                 .include "words/forth-wordlist.asm"
                 
                 ; Search Order
                 ; get the system default word list
                 VE_FORTH_WORDLIST:
0004e0 ff0e          .dw $ff0e
0004e1 6f66
0004e2 7472
0004e3 2d68
0004e4 6f77
0004e5 6472
0004e6 696c
0004e7 7473          .db "forth-wordlist"
0004e8 04d5          .dw VE_HEAD
                     .set VE_HEAD = VE_FORTH_WORDLIST
                 XT_FORTH_WORDLIST:
0004e9 f07b          .dw PFA_DOVALUE1
                 PFA_FORTH_WORDLIST:
0004ea 0080          .dw EE_WL_FORTH
0004eb fbc1          .dw XT_EDEFERFETCH
0004ec fbcb          .dw XT_EDEFERSTORE
                 .include "words/set-order.asm"
                 
                 ; Search Order
                 ; replace the search order list
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SET_ORDER:
0004ed ff09          .dw $ff09
0004ee 6573
0004ef 2d74
0004f0 726f
0004f1 6564
0004f2 0072          .db "set-order",0
0004f3 04e0          .dw VE_HEAD
                     .set VE_HEAD = VE_SET_ORDER
                 XT_SET_ORDER:
0004f4 f000          .dw DO_COLON
                 PFA_SET_ORDER:
                 .endif
0004f5 f040          .dw XT_DOLITERAL
0004f6 0086          .dw CFG_ORDERLISTLEN
0004f7 0434          .dw XT_SET_STACK
0004f8 f020          .dw XT_EXIT
                 
                 .include "words/set-recognizer.asm"
                 
                 ; Interpreter
                 ; replace the recognizer list
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SET_RECOGNIZERS:
0004f9 ff0f          .dw $ff0f
0004fa 6573
0004fb 2d74
0004fc 6572
0004fd 6f63
0004fe 6e67
0004ff 7a69
000500 7265
000501 0073          .db "set-recognizers",0
000502 04ed          .dw VE_HEAD
                     .set VE_HEAD = VE_SET_RECOGNIZERS
                 XT_SET_RECOGNIZERS:
000503 f000          .dw DO_COLON
                 PFA_SET_RECOGNIZERS:
                 .endif
000504 f040          .dw XT_DOLITERAL
000505 0098          .dw CFG_RECOGNIZERLISTLEN
000506 0434          .dw XT_SET_STACK
000507 f020          .dw XT_EXIT
                 
                 .include "words/get-recognizer.asm"
                 
                 ; Interpreter
                 ; Get the current recognizer list
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_GET_RECOGNIZERS:
000508 ff0f          .dw $ff0f
000509 6567
00050a 2d74
00050b 6572
00050c 6f63
00050d 6e67
00050e 7a69
00050f 7265
000510 0073          .db "get-recognizers",0
000511 04f9          .dw VE_HEAD
                     .set VE_HEAD = VE_GET_RECOGNIZERS
                 XT_GET_RECOGNIZERS:
000512 f000          .dw DO_COLON
                 PFA_GET_RECOGNIZERS:
                 .endif
000513 f040          .dw XT_DOLITERAL
000514 0098          .dw CFG_RECOGNIZERLISTLEN
000515 0413          .dw XT_GET_STACK
000516 f020          .dw XT_EXIT
                 .include "words/code.asm"
                 
                 ; Compiler
                 ; create named entry in the dictionary, XT is the data field
                 VE_CODE:
000517 ff04          .dw $ff04
000518 6f63
000519 6564          .db "code"
00051a 0508          .dw VE_HEAD
                     .set VE_HEAD = VE_CODE
                 XT_CODE:
00051b f000          .dw DO_COLON
                 PFA_CODE:
00051c 01d1          .dw XT_DOCREATE
00051d 0335          .dw XT_REVEAL
00051e f5ce          .dw XT_DP
00051f fbb8          .dw XT_ICELLPLUS
000520 0202          .dw XT_COMMA
000521 f020          .dw XT_EXIT
                 .include "words/end-code.asm"
                 
                 ; Compiler
                 ; finish a code definition
                 VE_ENDCODE:
000522 ff08          .dw $ff08
000523 6e65
000524 2d64
000525 6f63
000526 6564          .db "end-code"
000527 0517          .dw VE_HEAD
                     .set VE_HEAD = VE_ENDCODE
                 XT_ENDCODE:
000528 f000          .dw DO_COLON
                 PFA_ENDCODE:
000529 01f7          .dw XT_COMPILE
00052a 940c          .dw $940c
00052b 01f7          .dw XT_COMPILE
00052c f004          .dw DO_NEXT
00052d f020          .dw XT_EXIT
                 .include "words/marker.asm"
                 
                 ; System Value
                 ; The eeprom address until which MARKER saves and restores the eeprom data.
                 VE_MARKER:
00052e ff08          .dw $ff08
00052f 6d28
000530 7261
000531 656b
000532 2972          .db "(marker)"
000533 0522          .dw VE_HEAD
                     .set VE_HEAD = VE_MARKER
                 XT_MARKER:
000534 f07b          .dw PFA_DOVALUE1
                 PFA_MARKER:
000535 00a6          .dw EE_MARKER
000536 fbc1          .dw XT_EDEFERFETCH
000537 fbcb          .dw XT_EDEFERSTORE
                 .include "words/postpone.asm"
                 
                 ; Compiler
                 ; Append the compilation semantics of "name" to the dictionary
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_POSTPONE:
000538 0008          .dw $0008
000539 6f70
00053a 7473
00053b 6f70
00053c 656e          .db "postpone"
00053d 052e          .dw VE_HEAD
                     .set VE_HEAD = VE_POSTPONE
                 XT_POSTPONE:
00053e f000          .dw DO_COLON
                 PFA_POSTPONE:
                 .endif
00053f f9d1          .dw XT_PARSENAME
000540 facf          .dw XT_DORECOGNIZER
000541 fbb8          .dw XT_ICELLPLUS 
000542 fbb8          .dw XT_ICELLPLUS
000543 f3d2          .dw XT_FETCHI
000544 f02a          .dw XT_EXECUTE
000545 f020          .dw XT_EXIT
                 .endif
                 
                 .include "words/applturnkey.asm"
                 
                 ; R( -- )
                 ; application specific turnkey action
                 VE_APPLTURNKEY:
000546 ff0b          .dw $ff0b
000547 7061
000548 6c70
000549 7574
00054a 6e72
00054b 656b
00054c 0079          .db "applturnkey",0
00054d 0538          .dw VE_HEAD
                     .set VE_HEAD = VE_APPLTURNKEY
                 XT_APPLTURNKEY:
00054e f000          .dw DO_COLON
                 PFA_APPLTURNKEY:
00054f 00f2          .dw XT_USART
000550 f48b          .dw XT_INTON
000551 fb70          .dw XT_DOT_VER
000552 f806          .dw XT_SPACE
000553 f791          .dw XT_DOSLITERAL
000554 000a          .dw 10
000555 6f46
000556 7472
000557 6468
000558 6975
000559 6f6e          .db "Forthduino"
00055a f7c4          .dw XT_ITYPE
                 
00055b f020          .dw XT_EXIT
                 
                 
                 .set DPSTART = pc
                 .if(pc>AMFORTH_RO_SEG)
                 .endif
                 
                 .org AMFORTH_RO_SEG
                 .include "amforth-interpreter.asm"
                 
                 
                 DO_COLON:
00f000 93bf          push XH
00f001 93af          push XL          ; PUSH IP
00f002 01db          movw XL, wl
00f003 9611          adiw xl, 1
                 DO_NEXT:
00f004 f09e          brts DO_INTERRUPT
00f005 01fd          movw zl, XL        ; READ IP
00f006 2755
00f007 0fee
00f008 1fff
00f009 1f55
00f00a bf5b
00f00b 9167
00f00c 9177          readflashcell wl, wh
00f00d 9611          adiw XL, 1        ; INC IP
                 
                 DO_EXECUTE:
00f00e 01fb          movw zl, wl
00f00f 2755
00f010 0fee
00f011 1fff
00f012 1f55
00f013 bf5b
00f014 9107
00f015 9117          readflashcell temp0,temp1
00f016 01f8          movw zl, temp0
00f017 9409          ijmp
                 
                 DO_INTERRUPT:
                     ; here we deal with interrupts the forth way
00f018 94e8          clt
00f019 eb66          ldi wl, LOW(XT_ISREXEC)
00f01a ef74          ldi wh, HIGH(XT_ISREXEC)
00f01b cff2          rjmp DO_EXECUTE
                 .include "dict/nrww.inc"
                 
                 ; section together with the forth inner interpreter
                 
                 .include "words/exit.asm"
                 
                 ; Compiler
                 ; end of current colon word
                 VE_EXIT:
00f01c ff04          .dw $ff04
00f01d 7865
00f01e 7469          .db "exit"
00f01f 0546          .dw VE_HEAD
                     .set VE_HEAD = VE_EXIT
                 XT_EXIT:
00f020 f021          .dw PFA_EXIT
                 PFA_EXIT:
00f021 91af          pop XL
00f022 91bf          pop XH
00f023 cfe0          jmp_ DO_NEXT
                 .include "words/execute.asm"
                 
                 ; System
                 ; execute XT
                 VE_EXECUTE:
00f024 ff07          .dw $ff07
00f025 7865
00f026 6365
00f027 7475
00f028 0065          .db "execute",0
00f029 f01c          .dw VE_HEAD
                     .set VE_HEAD = VE_EXECUTE
                 XT_EXECUTE:
00f02a f02b          .dw PFA_EXECUTE
                 PFA_EXECUTE:
00f02b 01bc          movw wl, tosl
00f02c 9189
00f02d 9199          loadtos
00f02e cfdf          jmp_ DO_EXECUTE
                 .include "words/dobranch.asm"
                 
                 ; System
                 ; runtime of branch
                 ;VE_DOBRANCH:
                 ;    .dw $ff08
                 ;    .db "(branch)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOBRANCH
                 XT_DOBRANCH:
00f02f f030          .dw PFA_DOBRANCH
                 PFA_DOBRANCH:
00f030 01fd          movw zl, XL
00f031 2755
00f032 0fee
00f033 1fff
00f034 1f55
00f035 bf5b
00f036 91a7
00f037 91b7          readflashcell XL,XH
00f038 cfcb          jmp_ DO_NEXT
                 .include "words/docondbranch.asm"
                 
                 ; System
                 ; runtime of ?branch
                 ;VE_DOCONDBRANCH:
                 ;    .dw $ff09
                 ;    .db "(?branch)"
                 ;    .dw  VE_HEAD
                 ;    .set VE_HEAD = VE_DOCONDBRANCH
                 XT_DOCONDBRANCH:
00f039 f03a          .dw PFA_DOCONDBRANCH
                 PFA_DOCONDBRANCH:
00f03a 2b98          or tosh, tosl
00f03b 9189
00f03c 9199          loadtos
00f03d f391          brbs 1, PFA_DOBRANCH ; 1 is z flag; if tos is zero (false), do the branch
00f03e 9611          adiw XL, 1
00f03f cfc4          jmp_ DO_NEXT
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/doliteral.asm"
                 
                 ; System
                 ; runtime of literal
                 ;VE_DOLITERAL:
                 ;    .dw $ff09
                 ;    .db "(literal)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOLITERAL
                 XT_DOLITERAL:
00f040 f041          .dw PFA_DOLITERAL
                 PFA_DOLITERAL:
00f041 939a
00f042 938a          savetos
00f043 01fd          movw zl, xl
00f044 2755
00f045 0fee
00f046 1fff
00f047 1f55
00f048 bf5b
00f049 9187
00f04a 9197          readflashcell tosl,tosh
00f04b 9611          adiw xl, 1
00f04c cfb7          jmp_ DO_NEXT
                 
                 .include "words/dovariable.asm"
                 
                 ; System
                 ; puts content of parameter field (1 cell) to TOS
                 ;VE_DOVARIABLE:
                 ;    .dw $ff0a
                 ;    .db "(variable)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOVARIABLE
                 XT_DOVARIABLE:
00f04d f04e          .dw PFA_DOVARIABLE
                 PFA_DOVARIABLE:
00f04e 939a
00f04f 938a          savetos
00f050 01fb          movw zl, wl
00f051 9631          adiw zl,1
00f052 2755
00f053 0fee
00f054 1fff
00f055 1f55
00f056 bf5b
00f057 9187
00f058 9197          readflashcell tosl,tosh
00f059 cfaa          jmp_ DO_NEXT
                 .include "words/doconstant.asm"
                 
                 ; System
                 ; place data field address on TOS
                 ;VE_DOCONSTANT:
                 ;    .dw $ff0a
                 ;    .db "(constant)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOCONSTANT
                 XT_DOCONSTANT:
00f05a f05b          .dw PFA_DOCONSTANT
                 PFA_DOCONSTANT:
00f05b 939a
00f05c 938a          savetos
00f05d 01cb          movw tosl, wl
00f05e 9601          adiw tosl, 1
00f05f cfa4          jmp_ DO_NEXT
                 .include "words/douser.asm"
                 
                 ; System
                 ; runtime part of user
                 ;VE_DOUSER:
                 ;    .dw $ff06
                 ;    .db "(user)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOUSER
                 XT_DOUSER:
00f060 f061          .dw PFA_DOUSER
                 PFA_DOUSER:
00f061 939a
00f062 938a          savetos
00f063 01fb          movw zl, wl
00f064 9631          adiw zl, 1
00f065 2755
00f066 0fee
00f067 1fff
00f068 1f55
00f069 bf5b
00f06a 9187
00f06b 9197          readflashcell tosl,tosh
00f06c 0d84          add tosl, upl
00f06d 1d95          adc tosh, uph
00f06e cf95          jmp_ DO_NEXT
                 .include "words/do-value.asm"
                 
                 ; System
                 ; runtime of value
                 VE_DOVALUE:
00f06f ff07          .dw $ff07
00f070 7628
00f071 6c61
00f072 6575
00f073 0029          .db "(value)", 0
00f074 f024          .dw VE_HEAD
                     .set VE_HEAD = VE_DOVALUE
                 XT_DOVALUE:
00f075 f000          .dw DO_COLON
                 PFA_DOVALUE:
00f076 01d1          .dw XT_DOCREATE
00f077 0335          .dw XT_REVEAL
00f078 01f7          .dw XT_COMPILE
00f079 f07b          .dw PFA_DOVALUE1
00f07a f020          .dw XT_EXIT
                 PFA_DOVALUE1:
00f07b 940e 0359     call_ DO_DODOES
00f07d f0bd          .dw XT_DUP
00f07e fbb8          .dw XT_ICELLPLUS
00f07f f3d2          .dw XT_FETCHI
00f080 f02a          .dw XT_EXECUTE
00f081 f020          .dw XT_EXIT
                 
                 ; : (value) <builds does> dup icell+ @i execute ;
                 .include "words/fetch.asm"
                 
                 ; Memory
                 ; read 1 cell from RAM address
                 VE_FETCH:
00f082 ff01          .dw $ff01
00f083 0040          .db "@",0
00f084 f06f          .dw VE_HEAD
                     .set VE_HEAD = VE_FETCH
                 XT_FETCH:
00f085 f086          .dw PFA_FETCH
                 PFA_FETCH:
                 .if WANT_UNIFIED == 1
                 .endif
                 PFA_FETCHRAM:
00f086 01fc          movw zl, tosl
                     ; low byte is read before the high byte
00f087 9181          ld tosl, z+
00f088 9191          ld tosh, z+
00f089 cf7a          jmp_ DO_NEXT
                 .if WANT_UNIFIED == 1
                 .endif
                 .include "words/store.asm"
                 
                 ; Memory
                 ; write n to RAM memory at addr, low byte first
                 VE_STORE:
00f08a ff01          .dw $ff01
00f08b 0021          .db "!",0
00f08c f082          .dw VE_HEAD
                     .set VE_HEAD = VE_STORE
                 XT_STORE:
00f08d f08e          .dw PFA_STORE
                 PFA_STORE:
                 .if WANT_UNIFIED == 1
                 .endif
                 PFA_STORERAM:
00f08e 01fc          movw zl, tosl
00f08f 9189
00f090 9199          loadtos
                     ; the high byte is written before the low byte
00f091 8391          std Z+1, tosh
00f092 8380          std Z+0, tosl
00f093 9189
00f094 9199          loadtos
00f095 cf6e          jmp_ DO_NEXT
                 .if WANT_UNIFIED == 1
                 .endif
                 .include "words/cstore.asm"
                 
                 ; Memory
                 ; store a single byte to RAM address
                 VE_CSTORE:
00f096 ff02          .dw $ff02
00f097 2163          .db "c!"
00f098 f08a          .dw VE_HEAD
                     .set VE_HEAD = VE_CSTORE
                 XT_CSTORE:
00f099 f09a          .dw PFA_CSTORE
                 PFA_CSTORE:
00f09a 01fc          movw zl, tosl
00f09b 9189
00f09c 9199          loadtos
00f09d 8380          st Z, tosl
00f09e 9189
00f09f 9199          loadtos
00f0a0 cf63          jmp_ DO_NEXT
                 .include "words/cfetch.asm"
                 
                 ; Memory
                 ; fetch a single byte from memory mapped locations
                 VE_CFETCH:
00f0a1 ff02          .dw $ff02
00f0a2 4063          .db "c@"
00f0a3 f096          .dw VE_HEAD
                     .set VE_HEAD  = VE_CFETCH
                 XT_CFETCH:
00f0a4 f0a5          .dw PFA_CFETCH
                 PFA_CFETCH:
00f0a5 01fc          movw zl, tosl
00f0a6 2799          clr tosh
00f0a7 8180          ld tosl, Z
00f0a8 cf5b          jmp_ DO_NEXT
                 .include "words/fetch-u.asm"
                 
                 ; Memory
                 ; read 1 cell from USER area
                 VE_FETCHU:
00f0a9 ff02          .dw $ff02
00f0aa 7540          .db "@u"
00f0ab f0a1          .dw VE_HEAD
                     .set VE_HEAD = VE_FETCHU
                 XT_FETCHU:
00f0ac f000          .dw DO_COLON
                 PFA_FETCHU:
00f0ad f302          .dw XT_UP_FETCH
00f0ae f1a9          .dw XT_PLUS
00f0af f085          .dw XT_FETCH
00f0b0 f020          .dw XT_EXIT
                 .include "words/store-u.asm"
                 
                 ; Memory
                 ; write n to USER area at offset
                 VE_STOREU:
00f0b1 ff02          .dw $ff02
00f0b2 7521          .db "!u"
00f0b3 f0a9          .dw VE_HEAD
                     .set VE_HEAD = VE_STOREU
                 XT_STOREU:
00f0b4 f000          .dw DO_COLON
                 PFA_STOREU:
00f0b5 f302          .dw XT_UP_FETCH
00f0b6 f1a9          .dw XT_PLUS
00f0b7 f08d          .dw XT_STORE
00f0b8 f020          .dw XT_EXIT
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/dup.asm"
                 
                 ; Stack
                 ; duplicate TOS
                 VE_DUP:
00f0b9 ff03          .dw $ff03
00f0ba 7564
00f0bb 0070          .db "dup",0
00f0bc f0b1          .dw VE_HEAD
                     .set VE_HEAD = VE_DUP
                 XT_DUP:
00f0bd f0be          .dw PFA_DUP
                 PFA_DUP:
00f0be 939a
00f0bf 938a          savetos
00f0c0 cf43          jmp_ DO_NEXT
                 .include "words/qdup.asm"
                 
                 ; Stack
                 ; duplicate TOS if non-zero
                 VE_QDUP:
00f0c1 ff04          .dw $ff04
00f0c2 643f
00f0c3 7075          .db "?dup"
00f0c4 f0b9          .dw VE_HEAD
                     .set VE_HEAD = VE_QDUP
                 XT_QDUP:
00f0c5 f0c6          .dw PFA_QDUP
                 PFA_QDUP:
00f0c6 2f08          mov temp0, tosl
00f0c7 2b09          or temp0, tosh
00f0c8 f011          breq PFA_QDUP1
00f0c9 939a
00f0ca 938a          savetos
                 PFA_QDUP1:
00f0cb cf38          jmp_ DO_NEXT
                 .include "words/swap.asm"
                 
                 ; Stack
                 ; swaps the two top level stack cells
                 VE_SWAP:
00f0cc ff04          .dw $ff04
00f0cd 7773
00f0ce 7061          .db "swap"
00f0cf f0c1          .dw VE_HEAD
                     .set VE_HEAD = VE_SWAP
                 XT_SWAP:
00f0d0 f0d1          .dw PFA_SWAP
                 PFA_SWAP:
00f0d1 018c          movw temp0, tosl
00f0d2 9189
00f0d3 9199          loadtos
00f0d4 931a          st -Y, temp1
00f0d5 930a          st -Y, temp0
00f0d6 cf2d          jmp_ DO_NEXT
                 .include "words/over.asm"
                 
                 ; Stack
                 ; Place a copy of x1 on top of the stack
                 VE_OVER:
00f0d7 ff04          .dw $ff04
00f0d8 766f
00f0d9 7265          .db "over"
00f0da f0cc          .dw VE_HEAD
                     .set VE_HEAD = VE_OVER
                 XT_OVER:
00f0db f0dc          .dw PFA_OVER
                 PFA_OVER:
00f0dc 939a
00f0dd 938a          savetos
00f0de 818a          ldd tosl, Y+2
00f0df 819b          ldd tosh, Y+3
                 
00f0e0 cf23          jmp_ DO_NEXT
                 .include "words/drop.asm"
                 
                 ; Stack
                 ; drop TOS
                 VE_DROP:
00f0e1 ff04          .dw $ff04
00f0e2 7264
00f0e3 706f          .db "drop"
00f0e4 f0d7          .dw VE_HEAD
                     .set VE_HEAD = VE_DROP
                 XT_DROP:
00f0e5 f0e6          .dw PFA_DROP
                 PFA_DROP:
00f0e6 9189
00f0e7 9199          loadtos
00f0e8 cf1b          jmp_ DO_NEXT
                 .include "words/rot.asm"
                 
                 ; Stack
                 ; rotate the three top level cells
                 VE_ROT:
00f0e9 ff03          .dw $ff03
00f0ea 6f72
00f0eb 0074          .db "rot",0
00f0ec f0e1          .dw VE_HEAD
                     .set VE_HEAD = VE_ROT
                 XT_ROT:
00f0ed f0ee          .dw PFA_ROT
                 PFA_ROT:
00f0ee 018c          movw temp0, tosl
00f0ef 9129          ld temp2, Y+
00f0f0 9139          ld temp3, Y+ 
00f0f1 9189
00f0f2 9199          loadtos
                         
00f0f3 933a          st -Y, temp3
00f0f4 932a          st -Y, temp2
00f0f5 931a          st -Y, temp1
00f0f6 930a          st -Y, temp0
                 
00f0f7 cf0c          jmp_ DO_NEXT
                 .include "words/nip.asm"
                 
                 ; Stack
                 ; Remove Second of Stack
                 VE_NIP:
00f0f8 ff03          .dw $ff03
00f0f9 696e
00f0fa 0070          .db "nip",0
00f0fb f0e9          .dw VE_HEAD
                     .set VE_HEAD = VE_NIP
                 XT_NIP:
00f0fc f0fd          .dw PFA_NIP
                 PFA_NIP:
00f0fd 9622          adiw yl, 2
00f0fe cf05          jmp_ DO_NEXT
                 ;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/r_from.asm"
                 
                 ; Stack
                 ; move TOR to TOS
                 VE_R_FROM:
00f0ff ff02          .dw $ff02
00f100 3e72          .db "r>"
00f101 f0f8          .dw VE_HEAD
                     .set VE_HEAD = VE_R_FROM
                 XT_R_FROM:
00f102 f103          .dw PFA_R_FROM
                 PFA_R_FROM:
00f103 939a
00f104 938a          savetos
00f105 918f          pop tosl
00f106 919f          pop tosh
00f107 cefc          jmp_ DO_NEXT
                 .include "words/to_r.asm"
                 
                 ; Stack
                 ; move TOS to TOR
                 VE_TO_R:
00f108 ff02          .dw $ff02
00f109 723e          .db ">r"
00f10a f0ff          .dw VE_HEAD
                     .set VE_HEAD = VE_TO_R
                 XT_TO_R:
00f10b f10c          .dw PFA_TO_R
                 PFA_TO_R:
00f10c 939f          push tosh
00f10d 938f          push tosl
00f10e 9189
00f10f 9199          loadtos
00f110 cef3          jmp_ DO_NEXT
                 .include "words/r_fetch.asm"
                 
                 ; Stack
                 ; fetch content of TOR
                 VE_R_FETCH:
00f111 ff02          .dw $ff02
00f112 4072          .db "r@"
00f113 f108          .dw VE_HEAD
                     .set VE_HEAD = VE_R_FETCH
                 XT_R_FETCH:
00f114 f115          .dw PFA_R_FETCH
                 PFA_R_FETCH:
00f115 939a
00f116 938a          savetos
00f117 918f          pop tosl
00f118 919f          pop tosh
00f119 939f          push tosh
00f11a 938f          push tosl
00f11b cee8          jmp_ DO_NEXT
                 
                 
                 .include "words/not-equal.asm"
                 
                 ; Compare
                 ; true if n1 is not equal to n2
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_NOTEQUAL:
00f11c ff02          .dw $ff02
00f11d 3e3c          .db "<>"
00f11e f111          .dw VE_HEAD
                     .set VE_HEAD = VE_NOTEQUAL
                 XT_NOTEQUAL:
00f11f f000          .dw DO_COLON
                 PFA_NOTEQUAL:
                 .endif
                 
00f120 fd9d
00f121 f126
00f122 f020          .DW XT_EQUAL,XT_ZEROEQUAL,XT_EXIT
                 .include "words/equalzero.asm"
                 
                 ; Compare
                 ; compare with 0 (zero)
                 VE_ZEROEQUAL:
00f123 ff02          .dw $ff02
00f124 3d30          .db "0="
00f125 f11c          .dw VE_HEAD
                     .set VE_HEAD = VE_ZEROEQUAL
                 XT_ZEROEQUAL:
00f126 f127          .dw PFA_ZEROEQUAL
                 PFA_ZEROEQUAL:
00f127 2b98          or tosh, tosl
00f128 f5d1          brne PFA_ZERO1
00f129 c030          rjmp PFA_TRUE1
                 .include "words/lesszero.asm"
                 
                 ; Compare
                 ; compare with zero
                 VE_ZEROLESS:
00f12a ff02          .dw $ff02
00f12b 3c30          .db "0<"
00f12c f123          .dw VE_HEAD
                     .set VE_HEAD = VE_ZEROLESS
                 XT_ZEROLESS:
00f12d f12e          .dw PFA_ZEROLESS
                 PFA_ZEROLESS:
00f12e fd97          sbrc tosh,7
00f12f c02a          rjmp PFA_TRUE1
00f130 c032          rjmp PFA_ZERO1
                 .include "words/greaterzero.asm"
                 
                 ; Compare
                 ; true if n1 is greater than 0
                 VE_GREATERZERO:
00f131 ff02          .dw $ff02
00f132 3e30          .db "0>"
00f133 f12a          .dw VE_HEAD
                     .set VE_HEAD = VE_GREATERZERO
                 XT_GREATERZERO:
00f134 f135          .dw PFA_GREATERZERO
                 PFA_GREATERZERO:
00f135 1582          cp tosl, zerol
00f136 0593          cpc tosh, zeroh
00f137 f15c          brlt PFA_ZERO1
00f138 f151          brbs 1, PFA_ZERO1
00f139 c020          rjmp PFA_TRUE1
                 .include "words/d-greaterzero.asm"
                 
                 ; Compare
                 ; compares if a double double cell number is greater 0
                 VE_DGREATERZERO:
00f13a ff03          .dw $ff03
00f13b 3064
00f13c 003e          .db "d0>",0
00f13d f131          .dw VE_HEAD
                     .set VE_HEAD = VE_DGREATERZERO
                 XT_DGREATERZERO:
00f13e f13f          .dw PFA_DGREATERZERO
                 PFA_DGREATERZERO:
00f13f 1582          cp tosl, zerol
00f140 0593          cpc tosh, zeroh
00f141 9189
00f142 9199          loadtos
00f143 0582          cpc tosl, zerol
00f144 0593          cpc tosh, zeroh
00f145 f0ec          brlt PFA_ZERO1
00f146 f0e1          brbs 1, PFA_ZERO1
00f147 c012          rjmp PFA_TRUE1
                 .include "words/d-lesszero.asm"
                 
                 ; Compare
                 ; compares if a double double cell number is less than 0
                 VE_DXT_ZEROLESS:
00f148 ff03          .dw $ff03
00f149 3064
00f14a 003c          .db "d0<",0
00f14b f13a          .dw VE_HEAD
                     .set VE_HEAD = VE_DXT_ZEROLESS
                 XT_DXT_ZEROLESS:
00f14c f14d          .dw PFA_DXT_ZEROLESS
                 PFA_DXT_ZEROLESS:
00f14d 9622          adiw Y,2
00f14e fd97          sbrc tosh,7
00f14f 940c f15a     jmp PFA_TRUE1
00f151 940c f163     jmp PFA_ZERO1
                 
                 .include "words/true.asm"
                 
                 ; Arithmetics
                 ; leaves the value -1 (true) on TOS
                 VE_TRUE:
00f153 ff04          .dw $ff04
00f154 7274
00f155 6575          .db "true"
00f156 f148          .dw VE_HEAD
                     .set VE_HEAD = VE_TRUE
                 XT_TRUE:
00f157 f158          .dw PFA_TRUE
                 PFA_TRUE:
00f158 939a
00f159 938a          savetos
                 PFA_TRUE1:
00f15a ef8f          ser tosl
00f15b ef9f          ser tosh
00f15c cea7          jmp_ DO_NEXT
                 .include "words/zero.asm"
                 
                 ; Arithmetics
                 ; place a value 0 on TOS
                 VE_ZERO:
00f15d ff01          .dw $ff01
00f15e 0030          .db "0",0
00f15f f153          .dw VE_HEAD
                     .set VE_HEAD = VE_ZERO
                 XT_ZERO:
00f160 f161          .dw PFA_ZERO
                 PFA_ZERO:
00f161 939a
00f162 938a          savetos
                 PFA_ZERO1:
00f163 01c1          movw tosl, zerol
00f164 ce9f          jmp_ DO_NEXT
                 .include "words/uless.asm"
                 
                 ; Compare
                 ; true if u1 < u2 (unsigned)
                 VE_ULESS:
00f165 ff02          .dw $ff02
00f166 3c75          .db "u<"
00f167 f15d          .dw VE_HEAD
                     .set VE_HEAD = VE_ULESS
                 XT_ULESS:
00f168 f169          .dw PFA_ULESS
                 PFA_ULESS:
00f169 9129          ld temp2, Y+
00f16a 9139          ld temp3, Y+
00f16b 1782          cp tosl, temp2
00f16c 0793          cpc tosh, temp3
00f16d f3a8          brlo PFA_ZERO1
00f16e f3a1          brbs 1, PFA_ZERO1
00f16f cfea          jmp_ PFA_TRUE1
                 .include "words/u-greater.asm"
                 
                 ; Compare
                 ; true if u1 > u2 (unsigned)
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_UGREATER:
00f170 ff02          .dw $ff02
00f171 3e75          .db "u>"
00f172 f165          .dw VE_HEAD
                     .set VE_HEAD = VE_UGREATER
                 XT_UGREATER:
00f173 f000          .dw DO_COLON
                 PFA_UGREATER:
                 .endif
00f174 f0d0          .DW XT_SWAP
00f175 f168          .dw XT_ULESS
00f176 f020          .dw XT_EXIT
                 .include "words/less.asm"
                 
                 ; Compare
                 ; true if n1 is less than n2
                     VE_LESS:
00f177 ff01          .dw $ff01
00f178 003c          .db "<",0
00f179 f170          .dw VE_HEAD
                     .set VE_HEAD = VE_LESS
                 XT_LESS:
00f17a f17b          .dw PFA_LESS
                 PFA_LESS:
00f17b 9129          ld temp2, Y+
00f17c 9139          ld temp3, Y+
00f17d 1728          cp temp2, tosl
00f17e 0739          cpc temp3, tosh
                 PFA_LESSDONE:
00f17f f71c          brge PFA_ZERO1
00f180 cfd9          rjmp PFA_TRUE1
                 .include "words/greater.asm"
                 
                 ; Compare
                 ; flag is true if n1 is greater than n2
                 VE_GREATER:
00f181 ff01          .dw $ff01
00f182 003e          .db ">",0
00f183 f177          .dw VE_HEAD
                     .set VE_HEAD = VE_GREATER
                 XT_GREATER:
00f184 f185          .dw PFA_GREATER
                 PFA_GREATER:
00f185 9129          ld temp2, Y+
00f186 9139          ld temp3, Y+
00f187 1728          cp temp2, tosl
00f188 0739          cpc temp3, tosh
                 PFA_GREATERDONE:
00f189 f2cc          brlt PFA_ZERO1
00f18a f2c1          brbs 1, PFA_ZERO1
00f18b cfce          rjmp PFA_TRUE1
                 
                 .include "words/log2.asm"
                 
                 ; Arithmetics
                 ; logarithm to base 2 or highest set bitnumber
                 VE_LOG2:
00f18c ff04          .dw $ff04
00f18d 6f6c
00f18e 3267          .db "log2"
00f18f f181          .dw VE_HEAD
                     .set VE_HEAD = VE_LOG2
                 XT_LOG2:
00f190 f191          .dw PFA_LOG2
                 PFA_LOG2:
00f191 01fc          movw zl, tosl
00f192 2799          clr tosh
00f193 e180          ldi tosl, 16
                 PFA_LOG2_1:
00f194 958a          dec tosl
00f195 f022          brmi PFA_LOG2_2 ; wrong data
00f196 0fee          lsl  zl
00f197 1fff          rol  zh
00f198 f7d8          brcc PFA_LOG2_1
00f199 ce6a          jmp_ DO_NEXT
                 
                 PFA_LOG2_2:
00f19a 959a          dec tosh
00f19b ce68          jmp_ DO_NEXT
                 .include "words/minus.asm"
                 
                 ; Arithmetics
                 ; subtract n2 from n1
                 VE_MINUS:
00f19c ff01          .dw $ff01
00f19d 002d          .db "-",0
00f19e f18c          .dw VE_HEAD
                     .set VE_HEAD = VE_MINUS
                 XT_MINUS:
00f19f f1a0          .dw PFA_MINUS
                 PFA_MINUS:
00f1a0 9109          ld temp0, Y+
00f1a1 9119          ld temp1, Y+
00f1a2 1b08          sub temp0, tosl
00f1a3 0b19          sbc temp1, tosh
00f1a4 01c8          movw tosl, temp0
00f1a5 ce5e          jmp_ DO_NEXT
                 .include "words/plus.asm"
                 
                 ; Arithmetics
                 ; add n1 and n2
                 VE_PLUS:
00f1a6 ff01          .dw $ff01
00f1a7 002b          .db "+",0
00f1a8 f19c          .dw VE_HEAD
                     .set VE_HEAD = VE_PLUS
                 XT_PLUS:
00f1a9 f1aa          .dw PFA_PLUS
                 PFA_PLUS:
00f1aa 9109          ld temp0, Y+
00f1ab 9119          ld temp1, Y+
00f1ac 0f80          add tosl, temp0
00f1ad 1f91          adc tosh, temp1
00f1ae ce55          jmp_ DO_NEXT
                 .include "words/mstar.asm"
                 
                 ; Arithmetics
                 ; multiply 2 cells to a double cell
                 VE_MSTAR:
00f1af ff02          .dw $ff02
00f1b0 2a6d          .db "m*"
00f1b1 f1a6          .dw VE_HEAD
                     .set VE_HEAD = VE_MSTAR
                 XT_MSTAR:
00f1b2 f1b3          .dw PFA_MSTAR
                 PFA_MSTAR:
00f1b3 018c          movw temp0, tosl
00f1b4 9189
00f1b5 9199          loadtos
00f1b6 019c          movw temp2, tosl
                     ; high cell ah*bh
00f1b7 0231          muls temp3, temp1
00f1b8 0170          movw temp4, r0
                     ; low cell  al*bl
00f1b9 9f20          mul  temp2, temp0
00f1ba 01c0          movw tosl, r0
                     ; signed ah*bl
00f1bb 0330          mulsu temp3, temp0
00f1bc 08f3          sbc   temp5, zeroh
00f1bd 0d90          add   tosh,  r0
00f1be 1ce1          adc   temp4, r1
00f1bf 1cf3          adc   temp5, zeroh
                     
                     ; signed al*bh
00f1c0 0312          mulsu temp1, temp2
00f1c1 08f3          sbc   temp5, zeroh
00f1c2 0d90          add   tosh,  r0
00f1c3 1ce1          adc   temp4, r1
00f1c4 1cf3          adc   temp5, zeroh
                 
00f1c5 939a
00f1c6 938a          savetos
00f1c7 01c7          movw tosl, temp4
00f1c8 ce3b          jmp_ DO_NEXT
                 .include "words/umslashmod.asm"
                 
                 ; Arithmetics
                 ; unsigned division ud / u2 with remainder
                 VE_UMSLASHMOD:
00f1c9 ff06          .dw $ff06
00f1ca 6d75
00f1cb 6d2f
00f1cc 646f          .db "um/mod"
00f1cd f1af          .dw VE_HEAD
                     .set VE_HEAD = VE_UMSLASHMOD
                 XT_UMSLASHMOD:
00f1ce f1cf          .dw PFA_UMSLASHMOD
                 PFA_UMSLASHMOD:
00f1cf 017c          movw temp4, tosl
                 
00f1d0 9129          ld temp2, Y+
00f1d1 9139          ld temp3, Y+
                   
00f1d2 9109          ld temp0, Y+
00f1d3 9119          ld temp1, Y+
                 
                 ;; unsigned 32/16 -> 16r16 divide
                 
                 PFA_UMSLASHMODmod:
                 
                   ; set loop counter
00f1d4 e140          ldi temp6,$10
                 
                 PFA_UMSLASHMODmod_loop:
                     ; shift left, saving high bit
00f1d5 2755          clr temp7
00f1d6 0f00          lsl temp0
00f1d7 1f11          rol temp1
00f1d8 1f22          rol temp2
00f1d9 1f33          rol temp3
00f1da 1f55          rol temp7
                 
                   ; try subtracting divisor
00f1db 152e          cp temp2, temp4
00f1dc 053f          cpc temp3, temp5
00f1dd 0552          cpc temp7,zerol
                 
00f1de f018          brcs PFA_UMSLASHMODmod_loop_control
                 
                 PFA_UMSLASHMODmod_subtract:
                     ; dividend is large enough
                     ; do the subtraction for real
                     ; and set lowest bit
00f1df 9503          inc temp0
00f1e0 192e          sub temp2, temp4
00f1e1 093f          sbc temp3, temp5
                 
                 PFA_UMSLASHMODmod_loop_control:
00f1e2 954a          dec  temp6
00f1e3 f789          brne PFA_UMSLASHMODmod_loop
                 
                 PFA_UMSLASHMODmod_done:
                     ; put remainder on stack
00f1e4 933a          st -Y,temp3
00f1e5 932a          st -Y,temp2
                 
                     ; put quotient on stack
00f1e6 01c8          movw tosl, temp0
00f1e7 ce1c          jmp_ DO_NEXT
                 .include "words/umstar.asm"
                 
                 ; Arithmetics
                 ; multiply 2 unsigned cells to a double cell
                 VE_UMSTAR:
00f1e8 ff03          .dw $ff03
00f1e9 6d75
00f1ea 002a          .db "um*",0
00f1eb f1c9          .dw VE_HEAD
                     .set VE_HEAD = VE_UMSTAR
                 XT_UMSTAR:
00f1ec f1ed          .dw PFA_UMSTAR
                 PFA_UMSTAR:
00f1ed 018c          movw temp0, tosl
00f1ee 9189
00f1ef 9199          loadtos
                     ; result: (temp3*temp1)* 65536 + (temp3*temp0 + temp1*temp2) * 256 + (temp0 * temp2)
                     ; low bytes
00f1f0 9f80          mul tosl,temp0
00f1f1 01f0          movw zl, r0
00f1f2 2722          clr temp2
00f1f3 2733          clr temp3
                     ; middle bytes
00f1f4 9f90          mul tosh, temp0
00f1f5 0df0          add zh, r0
00f1f6 1d21          adc temp2, r1
00f1f7 1d33          adc temp3, zeroh
                         
00f1f8 9f81          mul tosl, temp1
00f1f9 0df0          add zh, r0
00f1fa 1d21          adc temp2, r1
00f1fb 1d33          adc temp3, zeroh
                     
00f1fc 9f91          mul tosh, temp1
00f1fd 0d20          add temp2, r0
00f1fe 1d31          adc temp3, r1
00f1ff 01cf          movw tosl, zl
00f200 939a
00f201 938a          savetos
00f202 01c9          movw tosl, temp2
00f203 ce00          jmp_ DO_NEXT
                 
                 .include "words/invert.asm"
                 
                 ; Arithmetics
                 ; 1-complement of TOS
                 VE_INVERT:
00f204 ff06          .dw $ff06
00f205 6e69
00f206 6576
00f207 7472          .db "invert"
00f208 f1e8          .dw VE_HEAD
                     .set VE_HEAD = VE_INVERT
                 XT_INVERT:
00f209 f20a          .dw PFA_INVERT
                 PFA_INVERT:
00f20a 9580          com tosl
00f20b 9590          com tosh
00f20c cdf7          jmp_ DO_NEXT
                 .include "words/2slash.asm"
                 
                 ; Arithmetics
                 ; arithmetic shift right
                 VE_2SLASH:
00f20d ff02          .dw $ff02
00f20e 2f32          .db "2/"
00f20f f204          .dw VE_HEAD
                     .set VE_HEAD = VE_2SLASH
                 XT_2SLASH:
00f210 f211          .dw PFA_2SLASH
                 PFA_2SLASH:
00f211 9595          asr tosh
00f212 9587          ror tosl
00f213 cdf0          jmp_ DO_NEXT
                 .include "words/2star.asm"
                 
                 ; Arithmetics
                 ; arithmetic shift left, filling with zero
                 VE_2STAR:
00f214 ff02          .dw $ff02
00f215 2a32          .db "2*"
00f216 f20d          .dw VE_HEAD
                     .set VE_HEAD = VE_2STAR
                 XT_2STAR:
00f217 f218          .dw PFA_2STAR
                 PFA_2STAR:
00f218 0f88          lsl tosl
00f219 1f99          rol tosh
00f21a cde9          jmp_ DO_NEXT
                 .include "words/and.asm"
                 
                 ; Logic
                 ; bitwise and
                 VE_AND:
00f21b ff03          .dw $ff03
00f21c 6e61
00f21d 0064          .db "and",0
00f21e f214          .dw VE_HEAD
                     .set VE_HEAD = VE_AND
                 XT_AND:
00f21f f220          .dw PFA_AND
                 PFA_AND:
00f220 9109          ld temp0, Y+
00f221 9119          ld temp1, Y+
00f222 2380          and tosl, temp0
00f223 2391          and tosh, temp1
00f224 cddf          jmp_ DO_NEXT
                 .include "words/or.asm"
                 
                 ; Logic
                 ; logical or
                 VE_OR:
00f225 ff02          .dw $ff02
00f226 726f          .db "or"
00f227 f21b          .dw VE_HEAD
                     .set VE_HEAD = VE_OR
                 XT_OR:
00f228 f229          .dw PFA_OR
                 PFA_OR:
00f229 9109          ld temp0, Y+
00f22a 9119          ld temp1, Y+
00f22b 2b80          or tosl, temp0
00f22c 2b91          or tosh, temp1
00f22d cdd6          jmp_ DO_NEXT
                 
                 .include "words/xor.asm"
                 
                 ; Logic
                 ; exclusive or
                 VE_XOR:
00f22e ff03          .dw $ff03
00f22f 6f78
00f230 0072          .db "xor",0
00f231 f225          .dw VE_HEAD
                     .set VE_HEAD = VE_XOR
                 XT_XOR:
00f232 f233          .dw PFA_XOR
                 PFA_XOR:
00f233 9109          ld temp0, Y+
00f234 9119          ld temp1, Y+
00f235 2780          eor tosl, temp0
00f236 2791          eor tosh, temp1
00f237 cdcc          jmp_ DO_NEXT
                 
                 .include "words/1plus.asm"
                 
                 ; Arithmetics
                 ; optimized increment
                 VE_1PLUS:
00f238 ff02          .dw $ff02
00f239 2b31          .db "1+"
00f23a f22e          .dw VE_HEAD
                     .set VE_HEAD = VE_1PLUS
                 XT_1PLUS:
00f23b f23c          .dw PFA_1PLUS
                 PFA_1PLUS:
00f23c 9601          adiw tosl,1
00f23d cdc6          jmp_ DO_NEXT
                 .include "words/1minus.asm"
                 
                 ; Arithmetics
                 ; optimized decrement
                 VE_1MINUS:
00f23e ff02          .dw $ff02 
00f23f 2d31          .db "1-"
00f240 f238          .dw VE_HEAD
                     .set VE_HEAD = VE_1MINUS
                 XT_1MINUS:
00f241 f242          .dw PFA_1MINUS
                 PFA_1MINUS:
00f242 9701          sbiw tosl, 1
00f243 cdc0          jmp_ DO_NEXT
                 .include "words/lshift.asm"
                 
                 ; Arithmetics
                 ; logically shift n1 left n2 times
                 VE_LSHIFT:
00f244 ff06          .dw $ff06
00f245 736c
00f246 6968
00f247 7466          .db "lshift"
00f248 f23e          .dw VE_HEAD
                     .set VE_HEAD = VE_LSHIFT
                 XT_LSHIFT:
00f249 f24a          .dw PFA_LSHIFT
                 PFA_LSHIFT:
00f24a 01fc          movw zl, tosl
00f24b 9189
00f24c 9199          loadtos
                 PFA_LSHIFT1:
00f24d 9731          sbiw zl, 1
00f24e f01a          brmi PFA_LSHIFT2
00f24f 0f88          lsl tosl
00f250 1f99          rol tosh
00f251 cffb          rjmp PFA_LSHIFT1
                 PFA_LSHIFT2:
00f252 cdb1          jmp_ DO_NEXT
                 
                 .include "words/rshift.asm"
                 
                 ; Arithmetics
                 ; shift n1 n2-times logically right
                 VE_RSHIFT:
00f253 ff06          .dw $ff06
00f254 7372
00f255 6968
00f256 7466          .db "rshift"
00f257 f244          .dw VE_HEAD
                     .set VE_HEAD = VE_RSHIFT
                 XT_RSHIFT:
00f258 f259          .dw PFA_RSHIFT
                 PFA_RSHIFT:
00f259 01fc          movw zl, tosl
00f25a 9189
00f25b 9199          loadtos
                 PFA_RSHIFT1:
00f25c 9731          sbiw zl, 1
00f25d f01a          brmi PFA_RSHIFT2
00f25e 9596          lsr tosh
00f25f 9587          ror tosl
00f260 cffb          rjmp PFA_RSHIFT1
                 PFA_RSHIFT2:
00f261 cda2          jmp_ DO_NEXT
                 
                 .include "words/plusstore.asm"
                 
                 ; Arithmetics
                 ; add n to content of RAM address a-addr
                 VE_PLUSSTORE:
00f262 ff02          .dw $ff02
00f263 212b          .db "+!"
00f264 f253          .dw VE_HEAD
                     .set VE_HEAD = VE_PLUSSTORE
                 XT_PLUSSTORE:
00f265 f266          .dw PFA_PLUSSTORE
                 PFA_PLUSSTORE:
00f266 01fc          movw zl, tosl
00f267 9189
00f268 9199          loadtos
00f269 8120          ldd temp2, Z+0
00f26a 8131          ldd temp3, Z+1
00f26b 0f82          add tosl, temp2
00f26c 1f93          adc tosh, temp3
00f26d 8380          std Z+0, tosl
00f26e 8391          std Z+1, tosh
00f26f 9189
00f270 9199          loadtos
00f271 cd92          jmp_ DO_NEXT
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/rpfetch.asm"
                 
                 ; Stack
                 ; current return stack pointer address
                 VE_RP_FETCH:
00f272 ff03          .dw $ff03
00f273 7072
00f274 0040          .db "rp@",0
00f275 f262          .dw VE_HEAD
                     .set VE_HEAD = VE_RP_FETCH
                 XT_RP_FETCH:
00f276 f277          .dw PFA_RP_FETCH
                 PFA_RP_FETCH:
00f277 939a
00f278 938a          savetos
00f279 b78d          in tosl, SPL
00f27a b79e          in tosh, SPH
00f27b cd88          jmp_ DO_NEXT
                 .include "words/rpstore.asm"
                 
                 ; Stack
                 ; set return stack pointer
                 VE_RP_STORE:
00f27c ff03          .dw $ff03
00f27d 7072
00f27e 0021          .db "rp!",0
00f27f f272          .dw VE_HEAD
                     .set VE_HEAD = VE_RP_STORE
                 XT_RP_STORE:
00f280 f281          .dw PFA_RP_STORE
                 PFA_RP_STORE:
00f281 b72f          in temp2, SREG
00f282 94f8          cli
00f283 bf8d          out SPL, tosl
00f284 bf9e          out SPH, tosh
00f285 bf2f          out SREG, temp2
00f286 9189
00f287 9199          loadtos
00f288 cd7b          jmp_ DO_NEXT
                 .include "words/spfetch.asm"
                 
                 ; Stack
                 ; current data stack pointer
                 VE_SP_FETCH:
00f289 ff03          .dw $ff03
00f28a 7073
00f28b 0040          .db "sp@",0
00f28c f27c          .dw VE_HEAD
                     .set VE_HEAD = VE_SP_FETCH
                 XT_SP_FETCH:
00f28d f28e          .dw PFA_SP_FETCH
                 PFA_SP_FETCH:
00f28e 939a
00f28f 938a          savetos
00f290 01ce          movw tosl, yl
00f291 cd72          jmp_ DO_NEXT
                 .include "words/spstore.asm"
                 
                 ; Stack
                 ; set data stack pointer to addr
                 VE_SP_STORE:
00f292 ff03          .dw $ff03
00f293 7073
00f294 0021          .db "sp!",0
00f295 f289          .dw VE_HEAD
                     .set VE_HEAD = VE_SP_STORE
                 XT_SP_STORE:
00f296 f297          .dw PFA_SP_STORE
                 PFA_SP_STORE:
00f297 01ec          movw yl, tosl
00f298 9189
00f299 9199          loadtos
00f29a cd69          jmp_ DO_NEXT
                 
                 .include "words/dodo.asm"
                 
                 ; System
                 ; runtime of do
                 ;VE_DODO:
                 ;    .dw $ff04
                 ;    .db "(do)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DODO
                 XT_DODO:
00f29b f29c          .dw PFA_DODO
                 PFA_DODO:
00f29c 9129          ld temp2, Y+
00f29d 9139          ld temp3, Y+  ; limit
                 PFA_DODO1:
00f29e e8e0          ldi zl, $80
00f29f 0f3e          add temp3, zl
00f2a0 1b82          sub  tosl, temp2
00f2a1 0b93          sbc  tosh, temp3
                 
00f2a2 933f          push temp3
00f2a3 932f          push temp2    ; limit  ( --> limit + $8000)
00f2a4 939f          push tosh
00f2a5 938f          push tosl     ; start -> index ( --> index - (limit - $8000)
00f2a6 9189
00f2a7 9199          loadtos
00f2a8 cd5b          jmp_ DO_NEXT
                 .include "words/i.asm"
                 
                 ; Compiler
                 ; current loop counter
                 VE_I:
00f2a9 ff01          .dw $FF01
00f2aa 0069          .db "i",0
00f2ab f292          .dw VE_HEAD
                     .set VE_HEAD = VE_I
                 XT_I:
00f2ac f2ad          .dw PFA_I
                 PFA_I:
00f2ad 939a
00f2ae 938a          savetos
00f2af 918f          pop tosl
00f2b0 919f          pop tosh  ; index
00f2b1 91ef          pop zl
00f2b2 91ff          pop zh    ; limit
00f2b3 93ff          push zh
00f2b4 93ef          push zl
00f2b5 939f          push tosh
00f2b6 938f          push tosl
00f2b7 0f8e          add tosl, zl
00f2b8 1f9f          adc tosh, zh
00f2b9 cd4a          jmp_ DO_NEXT
                 .include "words/doplusloop.asm"
                 
                 ; System
                 ; runtime of +loop
                 ;VE_DOPLUSLOOP:
                 ;    .dw $ff07
                 ;    .db "(+loop)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOPLUSLOOP
                 XT_DOPLUSLOOP:
00f2ba f2bb          .dw PFA_DOPLUSLOOP
                 PFA_DOPLUSLOOP:
00f2bb 91ef          pop zl
00f2bc 91ff          pop zh
00f2bd 0fe8          add zl, tosl
00f2be 1ff9          adc zh, tosh
00f2bf 9189
00f2c0 9199          loadtos
00f2c1 f01b          brvs PFA_DOPLUSLOOP_LEAVE
                     ; next cycle
                 PFA_DOPLUSLOOP_NEXT:
                     ; next iteration
00f2c2 93ff          push zh
00f2c3 93ef          push zl
00f2c4 cd6b          rjmp PFA_DOBRANCH ; read next cell from dictionary and jump to its destination
                 PFA_DOPLUSLOOP_LEAVE:
00f2c5 910f          pop  temp0
00f2c6 911f          pop  temp1  ; remove limit
00f2c7 9611          adiw xl, 1  ; skip branch-back address
00f2c8 cd3b          jmp_ DO_NEXT
                 .include "words/doloop.asm"
                 
                 ; System
                 ; runtime of loop
                 ;VE_DOLOOP:
                 ;    .dw $ff06
                 ;    .db "(loop)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOLOOP
                 XT_DOLOOP:
00f2c9 f2ca          .dw PFA_DOLOOP
                 PFA_DOLOOP:
00f2ca 91ef          pop zl
00f2cb 91ff          pop zh
00f2cc 9631          adiw zl,1
00f2cd f3bb          brvs PFA_DOPLUSLOOP_LEAVE
00f2ce cff3          jmp_ PFA_DOPLUSLOOP_NEXT
                 .include "words/unloop.asm"
                 
                 ; Compiler
                 ; remove loop-sys, exit the loop and continue execution after it
                 VE_UNLOOP:
00f2cf ff06          .dw $ff06
00f2d0 6e75
00f2d1 6f6c
00f2d2 706f          .db "unloop"
00f2d3 f2a9          .dw VE_HEAD
                     .set VE_HEAD = VE_UNLOOP
                 XT_UNLOOP:
00f2d4 f2d5          .dw PFA_UNLOOP
                 PFA_UNLOOP:
00f2d5 911f          pop temp1
00f2d6 910f          pop temp0
00f2d7 911f          pop temp1
00f2d8 910f          pop temp0
00f2d9 cd2a          jmp_ DO_NEXT
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 
                 .include "words/cmove_g.asm"
                 
                 ; Memory
                 ; copy data in RAM from higher to lower addresses.
                 VE_CMOVE_G:
00f2da ff06          .dw $ff06
00f2db 6d63
00f2dc 766f
00f2dd 3e65          .db "cmove>"
00f2de f2cf          .dw VE_HEAD
                     .set VE_HEAD  = VE_CMOVE_G
                 XT_CMOVE_G:
00f2df f2e0          .dw PFA_CMOVE_G
                 PFA_CMOVE_G:
00f2e0 93bf          push xh
00f2e1 93af          push xl
00f2e2 91e9          ld zl, Y+
00f2e3 91f9          ld zh, Y+ ; addr-to
00f2e4 91a9          ld xl, Y+
00f2e5 91b9          ld xh, Y+ ; addr-from
00f2e6 2f09          mov temp0, tosh
00f2e7 2b08          or temp0, tosl
00f2e8 f041          brbs 1, PFA_CMOVE_G1
00f2e9 0fe8          add zl, tosl
00f2ea 1ff9          adc zh, tosh
00f2eb 0fa8          add xl, tosl
00f2ec 1fb9          adc xh, tosh
                 PFA_CMOVE_G2:
00f2ed 911e          ld temp1, -X
00f2ee 9312          st -Z, temp1
00f2ef 9701          sbiw tosl, 1
00f2f0 f7e1          brbc 1, PFA_CMOVE_G2
                 PFA_CMOVE_G1:
00f2f1 91af          pop xl
00f2f2 91bf          pop xh
00f2f3 9189
00f2f4 9199          loadtos
00f2f5 cd0e          jmp_ DO_NEXT
                 .include "words/byteswap.asm"
                 
                 ; Arithmetics
                 ; exchange the bytes of the TOS
                 VE_BYTESWAP:
00f2f6 ff02          .dw $ff02
00f2f7 3c3e          .db "><"
00f2f8 f2da          .dw VE_HEAD
                     .set VE_HEAD = VE_BYTESWAP
                 XT_BYTESWAP:
00f2f9 f2fa          .dw PFA_BYTESWAP
                 PFA_BYTESWAP:
00f2fa 2f09          mov temp0, tosh
00f2fb 2f98          mov tosh, tosl
00f2fc 2f80          mov tosl, temp0
00f2fd cd06          jmp_ DO_NEXT
                 .include "words/up.asm"
                 
                 ; System Variable
                 ; get user area pointer
                 VE_UP_FETCH:
00f2fe ff03          .dw $ff03
00f2ff 7075
00f300 0040          .db "up@",0
00f301 f2f6          .dw VE_HEAD
                     .set VE_HEAD = VE_UP_FETCH
                 XT_UP_FETCH:
00f302 f303          .dw PFA_UP_FETCH
                 PFA_UP_FETCH:
00f303 939a
00f304 938a          savetos
00f305 01c2          movw tosl, upl
00f306 ccfd          jmp_ DO_NEXT
                 
                 ; ( addr -- ) 
                 ; System Variable
                 ; set user area pointer
                 VE_UP_STORE:
00f307 ff03          .dw $ff03
00f308 7075
00f309 0021          .db "up!",0
00f30a f2fe          .dw VE_HEAD
                     .set VE_HEAD = VE_UP_STORE
                 XT_UP_STORE:
00f30b f30c          .dw PFA_UP_STORE
                 PFA_UP_STORE:
00f30c 012c          movw upl, tosl
00f30d 9189
00f30e 9199          loadtos
00f30f ccf4          jmp_ DO_NEXT
                 .include "words/1ms.asm"
                 
                 ; Time
                 ; busy waits (almost) exactly 1 millisecond
                 VE_1MS:
00f310 ff03          .dw $ff03
00f311 6d31
00f312 0073          .db "1ms",0
00f313 f307          .dw VE_HEAD
                     .set VE_HEAD = VE_1MS
                 XT_1MS:
00f314 f315          .dw PFA_1MS
                 PFA_1MS:
00f315 eae0
00f316 e0ff
00f317 9731
00f318 f7f1          delay 1000
00f319 ccea          jmp_ DO_NEXT
                 .include "words/2to_r.asm"
                 
                 ; Stack
                 ; move DTOS to TOR
                 VE_2TO_R:
00f31a ff03          .dw $ff03
00f31b 3e32
00f31c 0072          .db "2>r",0
00f31d f310          .dw VE_HEAD
                     .set VE_HEAD = VE_2TO_R
                 XT_2TO_R:
00f31e f31f          .dw PFA_2TO_R
                 PFA_2TO_R:
00f31f 01fc          movw zl, tosl
00f320 9189
00f321 9199          loadtos
00f322 939f          push tosh
00f323 938f          push tosl
00f324 93ff          push zh
00f325 93ef          push zl
00f326 9189
00f327 9199          loadtos
00f328 ccdb          jmp_ DO_NEXT
                 .include "words/2r_from.asm"
                 
                 ; Stack
                 ; move DTOR to TOS
                 VE_2R_FROM:
00f329 ff03          .dw $ff03
00f32a 7232
00f32b 003e          .db "2r>",0
00f32c f31a          .dw VE_HEAD
                     .set VE_HEAD = VE_2R_FROM
                 XT_2R_FROM:
00f32d f32e          .dw PFA_2R_FROM
                 PFA_2R_FROM:
00f32e 939a
00f32f 938a          savetos
00f330 91ef          pop zl
00f331 91ff          pop zh
00f332 918f          pop tosl
00f333 919f          pop tosh
00f334 939a
00f335 938a          savetos
00f336 01cf          movw tosl, zl
00f337 cccc          jmp_ DO_NEXT
                 
                 .include "words/store-e.asm"
                 
                 ; Memory
                 ; write n (2bytes) to eeprom address
                 VE_STOREE:
00f338 ff02          .dw $ff02
00f339 6521          .db "!e"
00f33a f329          .dw VE_HEAD
                     .set VE_HEAD = VE_STOREE
                 XT_STOREE:
00f33b f33c          .dw PFA_STOREE
                 PFA_STOREE:
                 .if WANT_UNIFIED == 1
                 .endif
                 PFA_STOREE0:
00f33c 01fc          movw zl, tosl
00f33d 9189
00f33e 9199          loadtos
00f33f b72f          in_ temp2, SREG
00f340 94f8          cli
00f341 d028          rcall PFA_FETCHE2
00f342 b500          in_  temp0, EEDR
00f343 1708          cp temp0,tosl
00f344 f009          breq PFA_STOREE3
00f345 d00b          rcall PFA_STOREE1
                 PFA_STOREE3:
00f346 9631          adiw zl,1
00f347 d022          rcall PFA_FETCHE2
00f348 b500          in_  temp0, EEDR
00f349 1709          cp temp0,tosh
00f34a f011          breq PFA_STOREE4
00f34b 2f89          mov tosl, tosh
00f34c d004          rcall PFA_STOREE1
                 PFA_STOREE4:
00f34d bf2f          out_ SREG, temp2
00f34e 9189
00f34f 9199          loadtos
00f350 ccb3          jmp_ DO_NEXT
                     
                 PFA_STOREE1:
00f351 99f9          sbic EECR, EEPE
00f352 cffe          rjmp PFA_STOREE1
                 
                 PFA_STOREE2: ; estore_wait_low_spm:
00f353 b707          in_ temp0, SPMCSR
00f354 fd00          sbrc temp0,SPMEN
00f355 cffd          rjmp PFA_STOREE2
                 
00f356 bdf2          out_ EEARH,zh
00f357 bde1          out_ EEARL,zl
00f358 bd80          out_ EEDR, tosl
00f359 9afa          sbi EECR,EEMPE
00f35a 9af9          sbi EECR,EEPE
                 
00f35b 9508          ret
                 .if WANT_UNIFIED == 1
                 .endif
                 .include "words/fetch-e.asm"
                 
                 ; Memory
                 ; read 1 cell from eeprom
                 VE_FETCHE:
00f35c ff02          .dw $ff02
00f35d 6540          .db "@e"
00f35e f338          .dw VE_HEAD
                     .set VE_HEAD = VE_FETCHE
                 XT_FETCHE:
00f35f f360          .dw PFA_FETCHE
                 PFA_FETCHE:
                 .if WANT_UNIFIED == 1
                 .endif
                 PFA_FETCHE1:
00f360 b72f          in_ temp2, SREG
00f361 94f8          cli
00f362 01fc          movw zl, tosl
00f363 d006          rcall PFA_FETCHE2
00f364 b580          in_ tosl, EEDR
                 
00f365 9631          adiw zl,1
                 
00f366 d003          rcall PFA_FETCHE2
00f367 b590          in_  tosh, EEDR
00f368 bf2f          out_ SREG, temp2
00f369 cc9a          jmp_ DO_NEXT
                 
                 PFA_FETCHE2:
00f36a 99f9          sbic EECR, EEPE
00f36b cffe          rjmp PFA_FETCHE2
                 
00f36c bdf2          out_ EEARH,zh
00f36d bde1          out_ EEARL,zl
                 
00f36e 9af8          sbi EECR,EERE
00f36f 9508          ret
                 
                 .if WANT_UNIFIED == 1
                 .endif
                 .include "words/store-i.asm"
                 
                 ; System Value
                 ; Deferred action to write a single 16bit cell to flash
                 VE_STOREI:
00f370 ff02          .dw $ff02
00f371 6921          .db "!i"
00f372 f35c          .dw VE_HEAD
                     .set VE_HEAD = VE_STOREI
                 XT_STOREI:
00f373 fc20          .dw PFA_DODEFER1
                 PFA_STOREI:
00f374 007c          .dw EE_STOREI
00f375 fbc1          .dw XT_EDEFERFETCH
00f376 fbcb          .dw XT_EDEFERSTORE
                 .if FLASHEND > $10000
                 .else
                   .include "words/store-i_nrww.asm"
                 
                 ; Memory
                 ; writes n to flash memory using assembly code (code to be placed in boot loader section)
                 VE_DO_STOREI_NRWW:
00f377 ff09          .dw $ff09
00f378 2128
00f379 2d69
00f37a 726e
00f37b 7777
00f37c 0029          .db "(!i-nrww)",0
00f37d f370          .dw VE_HEAD
                     .set VE_HEAD = VE_DO_STOREI_NRWW
                 XT_DO_STOREI:
00f37e f37f          .dw PFA_DO_STOREI_NRWW
                 PFA_DO_STOREI_NRWW:
                   ; store status register
00f37f b71f        in temp1,SREG
00f380 931f        push temp1
00f381 94f8        cli
                 
00f382 019c        movw temp2, tosl ; save the (word) address
00f383 9189
00f384 9199        loadtos          ; get the new value for the flash cell
00f385 93af        push xl
00f386 93bf        push xh
00f387 93cf        push yl
00f388 93df        push yh
00f389 d009        rcall DO_STOREI_atmega
00f38a 91df        pop yh
00f38b 91cf        pop yl
00f38c 91bf        pop xh
00f38d 91af        pop xl
                   ; finally clear the stack
00f38e 9189
00f38f 9199        loadtos
00f390 911f        pop temp1
                   ; restore status register (and interrupt enable flag)
00f391 bf1f        out SREG,temp1
                 
00f392 cc71        jmp_ DO_NEXT
                 
                 ; 
                 DO_STOREI_atmega:
                   ; write data to temp page buffer
                   ; use the values in tosl/tosh at the
                   ; appropiate place
00f393 d011        rcall pageload
                 
                   ; erase page if needed
                   ; it is needed if a bit goes from 0 to 1
00f394 94e0        com temp4
00f395 94f0        com temp5
00f396 218e        and tosl, temp4
00f397 219f        and tosh, temp5
00f398 2b98        or tosh, tosl
00f399 f021        breq DO_STOREI_writepage 
00f39a 94b3          inc erase_counter
00f39b 01f9          movw zl, temp2
00f39c e002          ldi temp0,(1<<PGERS)
00f39d d023          rcall dospm
                 
                 DO_STOREI_writepage:
                   ; write page
00f39e 01f9        movw zl, temp2
00f39f e004        ldi temp0,(1<<PGWRT)
00f3a0 d020        rcall dospm
                 
                   ; reenable RWW section
00f3a1 01f9        movw zl, temp2
00f3a2 e100        ldi temp0,(1<<RWWSRE)
00f3a3 d01d        rcall dospm
00f3a4 9508        ret
                 
                 ; load the desired page
                 .equ pagemask = ~ ( PAGESIZE - 1 )
                 pageload:
00f3a5 01f9        movw zl, temp2
                   ; get the beginning of page
00f3a6 78e0        andi zl,low(pagemask)
00f3a7 7fff        andi zh,high(pagemask)
00f3a8 01ef        movw y, z
                   ; loop counter (in words)
00f3a9 e8a0        ldi xl,low(pagesize)
00f3aa e0b0        ldi xh,high(pagesize)
                 pageload_loop:
                   ; we need the current flash value anyways
00f3ab 01fe        movw z, y
00f3ac 2755
00f3ad 0fee
00f3ae 1fff
00f3af 1f55
00f3b0 bf5b
00f3b1 9147
00f3b2 9157        readflashcell temp6, temp7 ; destroys Z
                   ; now check: if Z points to the same cell as temp2/3, we want the new data
00f3b3 01fe        movw z, y
00f3b4 17e2        cp zl, temp2
00f3b5 07f3        cpc zh, temp3
00f3b6 f011        breq pageload_newdata
00f3b7 010a          movw r0, temp6
00f3b8 c002          rjmp pageload_cont
                 pageload_newdata:
00f3b9 017a          movw temp4, temp6
00f3ba 010c          movw r0, tosl
                 pageload_cont:
00f3bb 2700        clr temp0
00f3bc d004        rcall dospm
00f3bd 9621        adiw y, 1
00f3be 9711        sbiw x, 1
00f3bf f759        brne pageload_loop
                 
                 pageload_done:
00f3c0 9508        ret
                 
                 
                 ;; dospm
                 ;;
                 ;; execute spm instruction
                 ;;   temp0 holds the value for SPMCR
                 
                 dospm:
                 dospm_wait_ee:
00f3c1 99f9        sbic EECR, EEPE
00f3c2 cffe        rjmp dospm_wait_ee
                 dospm_wait_spm:
00f3c3 b717        in_  temp1, SPMCSR
00f3c4 fd10        sbrc temp1, SPMEN
00f3c5 cffd        rjmp dospm_wait_spm
                 
                   ; turn the word addres into a byte address
00f3c6 2755
00f3c7 0fee
00f3c8 1fff
00f3c9 1f55
00f3ca bf5b        writeflashcell
                   ; execute spm
00f3cb 6001        ori temp0, (1<<SPMEN)
00f3cc bf07        out_ SPMCSR,temp0
00f3cd 95e8        spm
00f3ce 9508        ret
                 .endif
                 .include "words/fetch-i.asm"
                 
                 ; Memory
                 ; read 1 cell from flash
                 VE_FETCHI:
00f3cf ff02          .dw $ff02
00f3d0 6940          .db "@i"
00f3d1 f377          .dw VE_HEAD
                     .set VE_HEAD = VE_FETCHI
                 XT_FETCHI:
00f3d2 f3d3          .dw PFA_FETCHI
                 PFA_FETCHI:
00f3d3 01fc          movw zl, tosl
00f3d4 2755
00f3d5 0fee
00f3d6 1fff
00f3d7 1f55
00f3d8 bf5b
00f3d9 9187
00f3da 9197          readflashcell tosl,tosh
00f3db cc28          jmp_ DO_NEXT
                 
                 .if AMFORTH_NRWW_SIZE>8000
                 .include "dict/core_8k.inc"
                 
                 .include "words/n_to_r.asm"
                 
                 ; Stack
                 ; move n items from data stack to return stack
                 VE_N_TO_R:
00f3dc ff03          .dw $ff03
00f3dd 3e6e
00f3de 0072          .db "n>r",0
00f3df f3cf          .dw VE_HEAD
                     .set VE_HEAD = VE_N_TO_R
                 XT_N_TO_R:
00f3e0 f3e1          .dw PFA_N_TO_R
                 PFA_N_TO_R:
00f3e1 01fc          movw zl, tosl
00f3e2 2f08          mov  temp0, tosl
                 PFA_N_TO_R1:
00f3e3 9189
00f3e4 9199          loadtos
00f3e5 939f          push tosh
00f3e6 938f          push tosl
00f3e7 950a          dec temp0
00f3e8 f7d1          brne PFA_N_TO_R1
00f3e9 93ef          push zl
00f3ea 93ff          push zh
00f3eb 9189
00f3ec 9199          loadtos
00f3ed cc16          jmp_ DO_NEXT
                 .include "words/n_r_from.asm"
                 
                 ; Stack
                 ; move n items from return stack to data stack
                 VE_N_R_FROM:
00f3ee ff03          .dw $ff03
00f3ef 726e
00f3f0 003e          .db "nr>",0
00f3f1 f3dc          .dw VE_HEAD
                     .set VE_HEAD = VE_N_R_FROM
                 XT_N_R_FROM:
00f3f2 f3f3          .dw PFA_N_R_FROM
                 PFA_N_R_FROM:
00f3f3 939a
00f3f4 938a          savetos
00f3f5 91ff          pop zh
00f3f6 91ef          pop zl
00f3f7 2f0e          mov  temp0, zl
                 PFA_N_R_FROM1:
00f3f8 918f          pop tosl
00f3f9 919f          pop tosh
00f3fa 939a
00f3fb 938a          savetos
00f3fc 950a          dec temp0
00f3fd f7d1          brne PFA_N_R_FROM1
00f3fe 01cf          movw tosl, zl
00f3ff cc04          jmp_ DO_NEXT
                 
                 .include "words/d-2star.asm"
                 
                 ; Arithmetics
                 ; shift a double cell left
                 VE_D2STAR:
00f400 ff03          .dw $ff03
00f401 3264
00f402 002a          .db "d2*",0
00f403 f3ee          .dw VE_HEAD
                     .set VE_HEAD = VE_D2STAR
                 XT_D2STAR:
00f404 f405          .dw PFA_D2STAR
                 PFA_D2STAR:
00f405 9109          ld temp0, Y+
00f406 9119          ld temp1, Y+
00f407 0f00          lsl temp0
00f408 1f11          rol temp1
00f409 1f88          rol tosl
00f40a 1f99          rol tosh
00f40b 931a          st -Y, temp1
00f40c 930a          st -Y, temp0
00f40d cbf6          jmp_ DO_NEXT
                 .include "words/d-2slash.asm"
                 
                 ; Arithmetics
                 ; shift a double cell value right
                 VE_D2SLASH:
00f40e ff03          .dw $ff03
00f40f 3264
00f410 002f          .db "d2/",0
00f411 f400          .dw VE_HEAD
                     .set VE_HEAD = VE_D2SLASH
                 XT_D2SLASH:
00f412 f413          .dw PFA_D2SLASH
                 PFA_D2SLASH:
00f413 9109          ld temp0, Y+
00f414 9119          ld temp1, Y+
00f415 9595          asr tosh
00f416 9587          ror tosl
00f417 9517          ror temp1
00f418 9507          ror temp0
00f419 931a          st -Y, temp1
00f41a 930a          st -Y, temp0
00f41b cbe8          jmp_ DO_NEXT
                 .include "words/d-plus.asm"
                 
                 ; Arithmetics
                 ; add 2 double cell values
                 VE_DPLUS:
00f41c ff02          .dw $ff02
00f41d 2b64          .db "d+"
00f41e f40e          .dw VE_HEAD
                     .set VE_HEAD = VE_DPLUS
                 XT_DPLUS:
00f41f f420          .dw PFA_DPLUS
                 PFA_DPLUS:
00f420 9129          ld temp2, Y+
00f421 9139          ld temp3, Y+
                 
00f422 90e9          ld temp4, Y+
00f423 90f9          ld temp5, Y+
00f424 9149          ld temp6, Y+
00f425 9159          ld temp7, Y+
                 
00f426 0f24          add temp2, temp6
00f427 1f35          adc temp3, temp7
00f428 1d8e          adc tosl, temp4
00f429 1d9f          adc tosh, temp5
                     
00f42a 933a          st -Y, temp3
00f42b 932a          st -Y, temp2
00f42c cbd7          jmp_ DO_NEXT
                 .include "words/d-minus.asm"
                 
                 ; Arithmetics
                 ; subtract d2 from d1 
                 VE_DMINUS:
00f42d ff02          .dw $ff02
00f42e 2d64          .db "d-"
00f42f f41c          .dw VE_HEAD
                     .set VE_HEAD = VE_DMINUS
                 XT_DMINUS:
00f430 f431          .dw PFA_DMINUS
                 PFA_DMINUS:
00f431 9129          ld temp2, Y+
00f432 9139          ld temp3, Y+
                 
00f433 90e9          ld temp4, Y+
00f434 90f9          ld temp5, Y+
00f435 9149          ld temp6, Y+
00f436 9159          ld temp7, Y+
                 
00f437 1b42          sub temp6, temp2
00f438 0b53          sbc temp7, temp3
00f439 0ae8          sbc temp4, tosl
00f43a 0af9          sbc temp5, tosh
                 
00f43b 935a          st -Y, temp7
00f43c 934a          st -Y, temp6
00f43d 01c7          movw tosl, temp4
00f43e cbc5          jmp_ DO_NEXT
                 .include "words/d-invert.asm"
                 
                 ; Arithmetics
                 ; invert all bits in the double cell value
                 VE_DINVERT:
00f43f ff07          .dw $ff07
00f440 6964
00f441 766e
00f442 7265
00f443 0074          .db "dinvert",0
00f444 f42d          .dw VE_HEAD
                     .set VE_HEAD = VE_DINVERT
                 XT_DINVERT:
00f445 f446          .dw PFA_DINVERT
                 PFA_DINVERT:
00f446 9109          ld temp0, Y+
00f447 9119          ld temp1, Y+
00f448 9580          com tosl
00f449 9590          com tosh
00f44a 9500          com temp0
00f44b 9510          com temp1
00f44c 931a          st -Y, temp1
00f44d 930a          st -Y, temp0
00f44e cbb5          jmp_ DO_NEXT
                 .include "words/d-equal.asm"
                 
                 ; Compare
                 ; compares two double cell values
                 VE_DEQUAL:
00f44f ff02          .dw $ff02
00f450 3d64          .db "d="
00f451 f43f          .dw VE_HEAD
                     .set VE_HEAD = VE_DEQUAL
                 XT_DEQUAL:
00f452 f000          .dw DO_COLON
                 PFA_DEQUAL:
00f453 f430          .dw XT_DMINUS
00f454 f228          .dw XT_OR
00f455 f126          .dw XT_ZEROEQUAL
00f456 f020          .dw XT_EXIT
                 .include "words/u-dot.asm"
                 
                 ; Numeric IO
                 ; unsigned PNO with single cell numbers
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_UDOT:
00f457 ff02          .dw $ff02
00f458 2e75          .db "u."
00f459 f44f          .dw VE_HEAD
                     .set VE_HEAD = VE_UDOT
                 XT_UDOT:
00f45a f000          .dw DO_COLON
                 PFA_UDOT:
                 .endif
00f45b f160          .dw XT_ZERO
00f45c f74e          .dw XT_UDDOT
00f45d f020          .dw XT_EXIT
                 ; : u.        ( us -- )    0 ud. ;
                 .include "words/u-dot-r.asm"
                 
                 ; Numeric IO
                 ; unsigned PNO with single cells numbers, right aligned in width w
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 
                 VE_UDOTR:
00f45e ff03          .dw $ff03
00f45f 2e75
00f460 0072          .db "u.r",0
00f461 f457          .dw VE_HEAD
                     .set VE_HEAD = VE_UDOTR
                 XT_UDOTR:
00f462 f000          .dw DO_COLON
                 PFA_UDOTR:
                 .endif
00f463 f160          .dw XT_ZERO
00f464 f0d0          .dw XT_SWAP
00f465 f757          .dw XT_UDDOTR
00f466 f020          .dw XT_EXIT
                 ; : u.r       ( s n -- )   0 swap ud.r ;
                 
                 .include "words/show-wordlist.asm"
                 
                 ; Tools
                 ; prints the name of the words in a wordlist
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SHOWWORDLIST:
00f467 ff0d          .dw $ff0d
00f468 6873
00f469 776f
00f46a 772d
00f46b 726f
00f46c 6c64
00f46d 7369
00f46e 0074          .db "show-wordlist",0
00f46f f45e          .dw VE_HEAD
                     .set VE_HEAD = VE_SHOWWORDLIST
                 XT_SHOWWORDLIST:
00f470 f000          .dw DO_COLON
                 PFA_SHOWWORDLIST:
                 .endif
00f471 f040          .dw XT_DOLITERAL
00f472 f476          .dw XT_SHOWWORD
00f473 f0d0          .dw XT_SWAP
00f474 fc64          .dw XT_TRAVERSEWORDLIST
00f475 f020          .dw XT_EXIT
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 XT_SHOWWORD:
00f476 f000          .dw DO_COLON
                 PFA_SHOWWORD:
                 .endif
00f477 fc7f          .dw XT_NAME2STRING
00f478 f7c4          .dw XT_ITYPE
00f479 f806          .dw XT_SPACE         ; ( -- addr n)
00f47a f157          .dw XT_TRUE
00f47b f020          .dw XT_EXIT
                 .include "words/words.asm"
                 
                 ; Tools
                 ; prints a list of all (visible) words in the dictionary
                 VE_WORDS:
00f47c ff05          .dw $ff05
00f47d 6f77
00f47e 6472
00f47f 0073          .db "words",0
00f480 f467          .dw VE_HEAD
                     .set VE_HEAD = VE_WORDS
                 XT_WORDS:
00f481 f000          .dw DO_COLON
                 PFA_WORDS:
00f482 f040          .dw XT_DOLITERAL
00f483 0088          .dw CFG_ORDERLIST
00f484 f35f          .dw XT_FETCHE
00f485 f470          .dw XT_SHOWWORDLIST
00f486 f020          .dw XT_EXIT
                 .include "dict/interrupt.inc"
                 
                 .include "words/int-on.asm"
                 
                 ; Interrupt
                 ; turns on all interrupts
                 VE_INTON:
00f487 ff04          .dw $ff04
00f488 692b
00f489 746e          .db "+int"
00f48a f47c          .dw VE_HEAD
                     .set VE_HEAD = VE_INTON
                 XT_INTON:
00f48b f48c          .dw PFA_INTON
                 PFA_INTON:
00f48c 9478          sei
00f48d cb76          jmp_ DO_NEXT
                 .include "words/int-off.asm"
                 
                 ; Interrupt
                 ; turns off all interrupts 
                 VE_INTOFF:
00f48e ff04          .dw $ff04
00f48f 692d
00f490 746e          .db "-int"
00f491 f487          .dw VE_HEAD
                     .set VE_HEAD = VE_INTOFF
                 XT_INTOFF:
00f492 f493          .dw PFA_INTOFF
                 PFA_INTOFF:
00f493 94f8          cli
00f494 cb6f          jmp_ DO_NEXT
                 .include "words/int-store.asm"
                 
                 ; Interrupt
                 ; stores XT as interrupt vector i
                 VE_INTSTORE:
00f495 ff04          .dw $ff04
00f496 6e69
00f497 2174          .db "int!"
00f498 f48e          .dw VE_HEAD
                     .set VE_HEAD = VE_INTSTORE
                 XT_INTSTORE:
00f499 f000          .dw DO_COLON
                 PFA_INTSTORE:
00f49a f040          .dw XT_DOLITERAL
00f49b 0000          .dw intvec
00f49c f1a9          .dw XT_PLUS
00f49d f33b          .dw XT_STOREE
00f49e f020          .dw XT_EXIT
                 .include "words/int-fetch.asm"
                 
                 ; Interrupt
                 ; fetches XT from interrupt vector i
                 VE_INTFETCH:
00f49f ff04          .dw $ff04
00f4a0 6e69
00f4a1 4074          .db "int@"
00f4a2 f495          .dw VE_HEAD
                     .set VE_HEAD = VE_INTFETCH
                 XT_INTFETCH:
00f4a3 f000          .dw DO_COLON
                 PFA_INTFETCH:
00f4a4 f040          .dw XT_DOLITERAL
00f4a5 0000          .dw intvec
00f4a6 f1a9          .dw XT_PLUS
00f4a7 f35f          .dw XT_FETCHE
00f4a8 f020          .dw XT_EXIT
                 .include "words/int-trap.asm"
                 
                 ; Interrupt
                 ; trigger an interrupt
                 VE_INTTRAP:
00f4a9 ff08          .dw $ff08
00f4aa 6e69
00f4ab 2d74
00f4ac 7274
00f4ad 7061          .db "int-trap"
00f4ae f49f          .dw VE_HEAD
                     .set VE_HEAD = VE_INTTRAP
                 XT_INTTRAP:
00f4af f4b0          .dw PFA_INTTRAP
                 PFA_INTTRAP:
00f4b0 9380 0216     sts intcur, tosl
00f4b2 9189
00f4b3 9199          loadtos
00f4b4 9468          set ; set the interrupt flag for the inner interpreter
00f4b5 cb4e          jmp_ DO_NEXT
                 
                 .include "words/isr-exec.asm"
                 
                 ; Interrupt
                 ; executes an interrupt service routine
                 ;VE_ISREXEC:
                 ;    .dw $ff08
                 ;    .db "isr-exec"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_ISREXEC
                 XT_ISREXEC:
00f4b6 f000          .dw DO_COLON
                 PFA_ISREXEC:
00f4b7 f040          .dw XT_DOLITERAL
00f4b8 0216          .dw intcur
00f4b9 f0a4          .dw XT_CFETCH
00f4ba f040          .dw XT_DOLITERAL
00f4bb 0000          .dw intvec
00f4bc f1a9          .dw XT_PLUS
00f4bd f35f          .dw XT_FETCHE
00f4be f02a          .dw XT_EXECUTE
00f4bf f4c1          .dw XT_ISREND
00f4c0 f020          .dw XT_EXIT
                 .include "words/isr-end.asm"
                 
                 ; Interrupt
                 ; re-enables interrupts in an ISR
                 ;VE_ISREND:
                 ;    .dw $ff07
                 ;    .db "isr-end",0
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_ISREND
                 XT_ISREND:
00f4c1 f4c2          .dw PFA_ISREND
                 PFA_ISREND:
00f4c2 d001          rcall PFA_ISREND1 ; clear the interrupt flag for the controller
00f4c3 cb40          jmp_ DO_NEXT
                 PFA_ISREND1:
00f4c4 9518          reti
                 
                 .include "words/pick.asm"
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_PICK:
00f4c5 ff04          .dw $ff04
00f4c6 6970
00f4c7 6b63          .db "pick"
00f4c8 f4a9          .dw VE_HEAD
                     .set VE_HEAD = VE_PICK
                 XT_PICK:
00f4c9 f000          .dw DO_COLON
                 PFA_PICK:
                 .endif
00f4ca f23b          .dw XT_1PLUS
00f4cb f572          .dw XT_CELLS
00f4cc f28d          .dw XT_SP_FETCH
00f4cd f1a9          .dw XT_PLUS
00f4ce f085          .dw XT_FETCH
00f4cf f020          .dw XT_EXIT
                 .include "words/dot-quote.asm"
                 
                 ; Compiler
                 ; compiles string into dictionary to be printed at runtime
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 
                 VE_DOTSTRING:
00f4d0 0002          .dw $0002
00f4d1 222e          .db ".",$22
00f4d2 f4c5          .dw VE_HEAD
                     .set VE_HEAD = VE_DOTSTRING
                 XT_DOTSTRING:
00f4d3 f000          .dw DO_COLON
                 PFA_DOTSTRING:
                 .endif
00f4d4 f4db          .dw XT_SQUOTE
00f4d5 01f7          .dw XT_COMPILE
00f4d6 f7c4          .dw XT_ITYPE
00f4d7 f020          .dw XT_EXIT
                 .include "words/squote.asm"
                 
                 ; Compiler
                 ; compiles a string to flash, at runtime leaves ( -- flash-addr count) on stack
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SQUOTE:
00f4d8 0002        .dw $0002
00f4d9 2273        .db "s",$22
00f4da f4d0        .dw VE_HEAD
                   .set VE_HEAD = VE_SQUOTE
                 XT_SQUOTE:
00f4db f000          .dw DO_COLON
                 PFA_SQUOTE:
                 .endif
00f4dc f040          .dw XT_DOLITERAL
00f4dd 0022          .dw 34   ; 0x22 
00f4de f9a3          .dw XT_PARSE       ; ( -- addr n)
00f4df f565          .dw XT_STATE
00f4e0 f085          .dw XT_FETCH
00f4e1 f039          .dw XT_DOCONDBRANCH
00f4e2 f4e4          DEST(PFA_SQUOTE1)
00f4e3 0223            .dw XT_SLITERAL
                 PFA_SQUOTE1:
00f4e4 f020          .dw XT_EXIT
                 
                 .include "words/fill.asm"
                 
                 ; Memory
                 ; fill u bytes memory beginning at a-addr with character c
                 VE_FILL:
00f4e5 ff04          .dw $ff04
00f4e6 6966
00f4e7 6c6c          .db "fill"
00f4e8 f4d8          .dw VE_HEAD
                     .set VE_HEAD = VE_FILL
                 XT_FILL:
00f4e9 f000          .dw DO_COLON
                 PFA_FILL:
00f4ea f0ed          .dw XT_ROT
00f4eb f0ed          .dw XT_ROT
00f4ec f0c5
00f4ed f039          .dw XT_QDUP,XT_DOCONDBRANCH
00f4ee f4f6          DEST(PFA_FILL2)
00f4ef fd78          .dw XT_BOUNDS
00f4f0 f29b          .dw XT_DODO
                 PFA_FILL1:
00f4f1 f0bd          .dw XT_DUP
00f4f2 f2ac          .dw XT_I
00f4f3 f099          .dw XT_CSTORE  ; ( -- c c-addr)
00f4f4 f2c9          .dw XT_DOLOOP
00f4f5 f4f1          .dw PFA_FILL1
                 PFA_FILL2:
00f4f6 f0e5          .dw XT_DROP
00f4f7 f020          .dw XT_EXIT
                 
                 .include "words/environment.asm"
                 
                 ; System Value
                 ; word list identifier of the environmental search list
                 VE_ENVIRONMENT:
00f4f8 ff0b          .dw $ff0b
00f4f9 6e65
00f4fa 6976
00f4fb 6f72
00f4fc 6d6e
00f4fd 6e65
00f4fe 0074          .db "environment",0
00f4ff f4e5          .dw VE_HEAD
                     .set VE_HEAD = VE_ENVIRONMENT
                 XT_ENVIRONMENT:
00f500 f04e          .dw PFA_DOVARIABLE
                 PFA_ENVIRONMENT:
00f501 007e          .dw EE_ENVIRONMENT
                 .include "words/env-wordlists.asm"
                 
                 ; Environment
                 ; maximum number of wordlists in the dictionary search order
                 VE_ENVWORDLISTS:
00f502 ff09          .dw $ff09
00f503 6f77
00f504 6472
00f505 696c
00f506 7473
00f507 0073          .db "wordlists",0
00f508 0000          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENVWORDLISTS
                 XT_ENVWORDLISTS:
00f509 f000          .dw DO_COLON
                 PFA_ENVWORDLISTS:
00f50a f040          .dw XT_DOLITERAL
00f50b 0008          .dw NUMWORDLISTS
00f50c f020          .dw XT_EXIT
                 .include "words/env-slashpad.asm"
                 
                 ; Environment
                 ; Size of the PAD buffer in bytes
                 VE_ENVSLASHPAD:
00f50d ff04          .dw $ff04
00f50e 702f
00f50f 6461          .db "/pad"
00f510 f502          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENVSLASHPAD
                 XT_ENVSLASHPAD:
00f511 f000          .dw DO_COLON
                 PFA_ENVSLASHPAD:
00f512 f28d          .dw XT_SP_FETCH
00f513 f5a4          .dw XT_PAD
00f514 f19f          .dw XT_MINUS
00f515 f020          .dw XT_EXIT
                 .include "words/env-slashhold.asm"
                 
                 ; Environment
                 ; size of the pictured numeric output buffer in bytes
                 VE_ENVSLASHHOLD:
00f516 ff05          .dw $ff05
00f517 682f
00f518 6c6f
00f519 0064          .db "/hold",0
00f51a f50d          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENVSLASHHOLD
                 XT_ENVSLASHHOLD:
00f51b f000          .dw DO_COLON
                 PFA_ENVSLASHHOLD:
00f51c f5a4          .dw XT_PAD
00f51d f5df          .dw XT_HERE
00f51e f19f          .dw XT_MINUS
00f51f f020          .dw XT_EXIT
                 .include "words/env-forthname.asm"
                 
                 ; Environment
                 ; flash address of the amforth name string
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_ENV_FORTHNAME:
00f520 ff0a          .dw $ff0a
00f521 6f66
00f522 7472
00f523 2d68
00f524 616e
00f525 656d          .db "forth-name"
00f526 f516          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENV_FORTHNAME
                 XT_ENV_FORTHNAME:
00f527 f000          .dw DO_COLON
                 PFA_EN_FORTHNAME:
00f528 f791          .dw XT_DOSLITERAL
00f529 0007          .dw 7
                 .endif
00f52a 6d61
00f52b 6f66
00f52c 7472
../../common\words/env-forthname.asm(22): warning: .cseg .db misalignment - padding zero byte
00f52d 0068          .db "amforth"
                 .if cpu_msp430==1
                 .endif
00f52e f020          .dw XT_EXIT
                 .include "words/env-forthversion.asm"
                 
                 ; Environment
                 ; version number of amforth
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_ENV_FORTHVERSION:
00f52f ff07          .dw $ff07
00f530 6576
00f531 7372
00f532 6f69
00f533 006e          .db "version",0
00f534 f520          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENV_FORTHVERSION
                 XT_ENV_FORTHVERSION:
00f535 f000          .dw DO_COLON
                 PFA_EN_FORTHVERSION:
                 .endif
00f536 f040          .dw XT_DOLITERAL
00f537 003b          .dw 59
00f538 f020          .dw XT_EXIT
                 .include "words/env-cpu.asm"
                 
                 ; Environment
                 ; flash address of the CPU identification string
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_ENV_CPU:
00f539 ff03          .dw $ff03
00f53a 7063
00f53b 0075          .db "cpu",0
00f53c f52f          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENV_CPU
                 XT_ENV_CPU:
00f53d f000          .dw DO_COLON
                 PFA_EN_CPU:
00f53e f040          .dw XT_DOLITERAL
00f53f 0075          .dw mcu_name
00f540 f7f0          .dw XT_ICOUNT
                 .endif
00f541 f020          .dw XT_EXIT
                 .include "words/env-mcuinfo.asm"
                 
                 ; Environment
                 ; flash address of some CPU specific parameters
                 VE_ENV_MCUINFO:
00f542 ff08          .dw $ff08
00f543 636d
00f544 2d75
00f545 6e69
00f546 6f66          .db "mcu-info"
00f547 f539          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENV_MCUINFO
                 XT_ENV_MCUINFO:
00f548 f000          .dw DO_COLON
                 PFA_EN_MCUINFO:
00f549 f040          .dw XT_DOLITERAL
00f54a 0071          .dw mcu_info
00f54b f020          .dw XT_EXIT
                 .include "words/env-usersize.asm"
                 
                 ; Environment
                 ; size of the USER area in bytes
                 VE_ENVUSERSIZE:
00f54c ff05          .dw $ff05
00f54d 752f
00f54e 6573
00f54f 0072          .db "/user",0
00f550 f542          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENVUSERSIZE
                 XT_ENVUSERSIZE:
00f551 f000          .dw DO_COLON
                 PFA_ENVUSERSIZE:
00f552 f040          .dw XT_DOLITERAL
00f553 0026          .dw SYSUSERSIZE + APPUSERSIZE
00f554 f020          .dw XT_EXIT
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/f_cpu.asm"
                 
                 ; System
                 ; put the cpu frequency in Hz on stack
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_F_CPU:
00f555 ff05          .dw $ff05
00f556 5f66
00f557 7063
00f558 0075          .db "f_cpu",0
00f559 f4f8          .dw VE_HEAD
                     .set VE_HEAD = VE_F_CPU
                 XT_F_CPU:
00f55a f000          .dw DO_COLON
                 PFA_F_CPU:
                 .endif
00f55b f040          .dw XT_DOLITERAL
00f55c 2400          .dw (F_CPU % 65536)
00f55d f040          .dw XT_DOLITERAL
00f55e 00f4          .dw (F_CPU / 65536)
00f55f f020          .dw XT_EXIT
                 .include "words/state.asm"
                 
                 ; System Variable
                 ; system state
                 VE_STATE:
00f560 ff05          .dw $ff05
00f561 7473
00f562 7461
00f563 0065          .db "state",0
00f564 f555          .dw VE_HEAD
                     .set VE_HEAD = VE_STATE
                 XT_STATE:
00f565 f04e          .dw PFA_DOVARIABLE
                 PFA_STATE:
00f566 021f          .dw ram_state
                 
                 .dseg
00021f           ram_state: .byte 2
                 .include "words/base.asm"
                 
                 ; Numeric IO
                 ; location of the cell containing the number conversion radix
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_BASE:
00f567 ff04          .dw $ff04
00f568 6162
00f569 6573          .db "base"
00f56a f560          .dw VE_HEAD
                     .set VE_HEAD = VE_BASE
                 XT_BASE:
00f56b f061          .dw PFA_DOUSER
                 PFA_BASE:
                 .endif
00f56c 000c          .dw USER_BASE
                 
                 .include "words/cells.asm"
                 
                 ; Arithmetics
                 ; n2 is the size in address units of n1 cells
                 VE_CELLS:
00f56d ff05          .dw $ff05
00f56e 6563
00f56f 6c6c
00f570 0073          .db "cells",0
00f571 f567          .dw VE_HEAD
                     .set VE_HEAD = VE_CELLS
                 XT_CELLS:
00f572 f218          .dw PFA_2STAR
                 .include "words/cellplus.asm"
                 
                 ; Arithmetics
                 ; add the size of an address-unit to a-addr1
                 VE_CELLPLUS:
00f573 ff05          .dw $ff05
00f574 6563
00f575 6c6c
00f576 002b          .db "cell+",0
00f577 f56d          .dw VE_HEAD
                     .set VE_HEAD = VE_CELLPLUS
                 XT_CELLPLUS:
00f578 f579          .dw PFA_CELLPLUS
                 PFA_CELLPLUS:
00f579 9602          adiw tosl, CELLSIZE
00f57a ca89          jmp_ DO_NEXT
                 
                 .include "words/2dup.asm"
                 
                 ; Stack
                 ; Duplicate the 2 top elements
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_2DUP:
00f57b ff04          .dw $ff04
00f57c 6432
00f57d 7075          .db "2dup"
00f57e f573          .dw VE_HEAD
                     .set VE_HEAD = VE_2DUP
                 XT_2DUP:
00f57f f000          .dw DO_COLON
                 PFA_2DUP:
                 .endif
                 
00f580 f0db          .dw XT_OVER
00f581 f0db          .dw XT_OVER
00f582 f020          .dw XT_EXIT
                 .include "words/2drop.asm"
                 
                 ; Stack
                 ; Remove the 2 top elements
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_2DROP:
00f583 ff05          .dw $ff05
00f584 6432
00f585 6f72
00f586 0070          .db "2drop",0
00f587 f57b          .dw VE_HEAD
                     .set VE_HEAD = VE_2DROP
                 XT_2DROP:
00f588 f000          .dw DO_COLON
                 PFA_2DROP:
                 .endif
00f589 f0e5          .dw XT_DROP
00f58a f0e5          .dw XT_DROP
00f58b f020          .dw XT_EXIT
                 
                 .include "words/tuck.asm"
                 
                 ; Stack
                 ; Copy the first (top) stack item below the second stack item. 
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_TUCK:
00f58c ff04          .dw $ff04
00f58d 7574
00f58e 6b63          .db "tuck"
00f58f f583          .dw VE_HEAD
                     .set VE_HEAD = VE_TUCK
                 XT_TUCK:
00f590 f000          .dw DO_COLON
                 PFA_TUCK:
                 .endif
00f591 f0d0          .dw XT_SWAP
00f592 f0db          .dw XT_OVER
00f593 f020          .dw XT_EXIT
                 
                 .include "words/to-in.asm"
                 
                 ; System Variable
                 ; pointer to current read position in input buffer
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_TO_IN:
00f594 ff03          .dw $ff03
00f595 693e
00f596 006e          .db ">in",0
00f597 f58c          .dw VE_HEAD
                     .set VE_HEAD = VE_TO_IN
                 XT_TO_IN:
00f598 f061          .dw PFA_DOUSER
                 PFA_TO_IN:
                 .endif
00f599 0018          .dw USER_TO_IN
                 .include "words/sharptib.asm"
                 
                 ; System Variable
                 ; variable holding the number of characters in TIB
                 VE_NUMBERTIB:
00f59a ff04          .dw $ff04
00f59b 7423
00f59c 6269          .db "#tib"
00f59d f594          .dw VE_HEAD
                     .set VE_HEAD  = VE_NUMBERTIB
                 XT_NUMBERTIB:
00f59e f04e          .dw PFA_DOVARIABLE
                 PFA_NUMBERTIB:
00f59f 0221          .dw ram_sharptib
                 
                 .dseg
000221           ram_sharptib: .byte 2
                 .cseg
                  
                 .include "words/pad.asm"
                 
                 ; System Variable
                 ; Address of the temporary scratch buffer.
                 VE_PAD:
00f5a0 ff03          .dw $ff03
00f5a1 6170
00f5a2 0064          .db "pad",0
00f5a3 f59a          .dw VE_HEAD
                     .set VE_HEAD = VE_PAD
                 XT_PAD:
00f5a4 f000          .dw DO_COLON
                 PFA_PAD:
00f5a5 f5df          .dw XT_HERE
00f5a6 f040          .dw XT_DOLITERAL
00f5a7 0064          .dw 100
00f5a8 f1a9          .dw XT_PLUS
00f5a9 f020          .dw XT_EXIT
                 .include "words/emit.asm"
                 
                 ; Character IO
                 ; fetch the emit vector and execute it. should emit a character from TOS
                 VE_EMIT:
00f5aa ff04          .dw $ff04
00f5ab 6d65
00f5ac 7469          .db "emit"
00f5ad f5a0          .dw VE_HEAD
                     .set VE_HEAD = VE_EMIT
                 XT_EMIT:
00f5ae fc20          .dw PFA_DODEFER1
                 PFA_EMIT:
00f5af 000e          .dw USER_EMIT
00f5b0 fbe9          .dw XT_UDEFERFETCH
00f5b1 fbf5          .dw XT_UDEFERSTORE
                 .include "words/emitq.asm"
                 
                 ; Character IO
                 ; fetch emit? vector and execute it. should return the ready-to-send condition
                 VE_EMITQ:
00f5b2 ff05          .dw $ff05
00f5b3 6d65
00f5b4 7469
00f5b5 003f          .db "emit?",0
00f5b6 f5aa          .dw VE_HEAD
                     .set VE_HEAD = VE_EMITQ
                 XT_EMITQ:
00f5b7 fc20          .dw PFA_DODEFER1
                 PFA_EMITQ:
00f5b8 0010          .dw USER_EMITQ
00f5b9 fbe9          .dw XT_UDEFERFETCH
00f5ba fbf5          .dw XT_UDEFERSTORE
                 .include "words/key.asm"
                 
                 ; Character IO
                 ; fetch key vector and execute it, should leave a single character on TOS
                 VE_KEY:
00f5bb ff03          .dw $ff03
00f5bc 656b
00f5bd 0079          .db "key",0
00f5be f5b2          .dw VE_HEAD
                     .set VE_HEAD = VE_KEY
                 XT_KEY:
00f5bf fc20          .dw PFA_DODEFER1
                 PFA_KEY:
00f5c0 0012          .dw USER_KEY
00f5c1 fbe9          .dw XT_UDEFERFETCH
00f5c2 fbf5          .dw XT_UDEFERSTORE
                 .include "words/keyq.asm"
                 
                 ; Character IO
                 ; fetch key? vector and execute it. should turn on key sender, if it is disabled/stopped
                 VE_KEYQ:
00f5c3 ff04          .dw $ff04
00f5c4 656b
00f5c5 3f79          .db "key?"
00f5c6 f5bb          .dw VE_HEAD
                     .set VE_HEAD = VE_KEYQ
                 XT_KEYQ:
00f5c7 fc20          .dw PFA_DODEFER1
                 PFA_KEYQ:
00f5c8 0014          .dw USER_KEYQ
00f5c9 fbe9          .dw XT_UDEFERFETCH
00f5ca fbf5          .dw XT_UDEFERSTORE
                 
                 .include "words/dp.asm"
                 
                 ; System Value
                 ; address of the next free dictionary cell
                 VE_DP:
00f5cb ff02          .dw $ff02
00f5cc 7064          .db "dp"
00f5cd f5c3          .dw VE_HEAD
                     .set VE_HEAD = VE_DP
                 XT_DP:
00f5ce f07b          .dw PFA_DOVALUE1
                 PFA_DP:
00f5cf 0074          .dw EE_DP
00f5d0 fbc1          .dw XT_EDEFERFETCH
00f5d1 fbcb          .dw XT_EDEFERSTORE
                 .include "words/ehere.asm"
                 
                 ; System Value
                 ; address of the next free address in eeprom
                 VE_EHERE:
00f5d2 ff05          .dw $ff05
00f5d3 6865
00f5d4 7265
00f5d5 0065          .db "ehere",0
00f5d6 f5cb          .dw VE_HEAD
                     .set VE_HEAD = VE_EHERE
                 XT_EHERE:
00f5d7 f07b          .dw PFA_DOVALUE1
                 PFA_EHERE:
00f5d8 0078          .dw EE_EHERE
00f5d9 fbc1          .dw XT_EDEFERFETCH
00f5da fbcb          .dw XT_EDEFERSTORE
                 .include "words/here.asm"
                 
                 ; System Value
                 ; address of the next free data space (RAM) cell
                 VE_HERE:
00f5db ff04          .dw $ff04
00f5dc 6568
00f5dd 6572          .db "here"
00f5de f5d2          .dw VE_HEAD
                     .set VE_HEAD = VE_HERE
                 XT_HERE:
00f5df f07b          .dw PFA_DOVALUE1
                 PFA_HERE:
00f5e0 0076          .dw EE_HERE
00f5e1 fbc1          .dw XT_EDEFERFETCH
00f5e2 fbcb          .dw XT_EDEFERSTORE
                 .include "words/allot.asm"
                 
                 ; System
                 ; allocate or release memory in RAM
                 VE_ALLOT:
00f5e3 ff05          .dw $ff05
00f5e4 6c61
00f5e5 6f6c
00f5e6 0074          .db "allot",0
00f5e7 f5db          .dw VE_HEAD
                     .set VE_HEAD = VE_ALLOT
                 XT_ALLOT:
00f5e8 f000          .dw DO_COLON
                 PFA_ALLOT:
00f5e9 f5df          .dw XT_HERE
00f5ea f1a9          .dw XT_PLUS
00f5eb fba6          .dw XT_DOTO
00f5ec f5e0          .dw PFA_HERE
00f5ed f020          .dw XT_EXIT
                 
                 .include "words/bin.asm"
                 
                 ; Numeric IO
                 ; set base for numeric conversion to 10
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_BIN:
00f5ee ff03          .dw $ff03
00f5ef 6962
00f5f0 006e          .db "bin",0
00f5f1 f5e3          .dw VE_HEAD
                     .set VE_HEAD = VE_BIN
                 XT_BIN:
00f5f2 f000          .dw DO_COLON
                 PFA_BIN:
                 .endif
00f5f3 f040          .dw XT_DOLITERAL
00f5f4 0002          .dw 2
00f5f5 f56b          .dw XT_BASE
00f5f6 f08d          .dw XT_STORE
00f5f7 f020          .dw XT_EXIT
                 .include "words/decimal.asm"
                 
                 ; Numeric IO
                 ; set base for numeric conversion to 10
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DECIMAL:
00f5f8 ff07          .dw $ff07
00f5f9 6564
00f5fa 6963
00f5fb 616d
00f5fc 006c          .db "decimal",0
00f5fd f5ee          .dw VE_HEAD
                     .set VE_HEAD = VE_DECIMAL
                 XT_DECIMAL:
00f5fe f000          .dw DO_COLON
                 PFA_DECIMAL:
                 .endif
00f5ff f040          .dw XT_DOLITERAL
00f600 000a          .dw 10
00f601 f56b          .dw XT_BASE
00f602 f08d          .dw XT_STORE
00f603 f020          .dw XT_EXIT
                 .include "words/hex.asm"
                 
                 ; Numeric IO
                 ; set base for numeric conversion to 10
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_HEX:
00f604 ff03          .dw $ff03
00f605 6568
00f606 0078          .db "hex",0
00f607 f5f8          .dw VE_HEAD
                     .set VE_HEAD = VE_HEX
                 XT_HEX:
00f608 f000          .dw DO_COLON
                 PFA_HEX:
                 .endif
00f609 f040          .dw XT_DOLITERAL
00f60a 0010          .dw 16
00f60b f56b          .dw XT_BASE
00f60c f08d          .dw XT_STORE
00f60d f020          .dw XT_EXIT
                 .include "words/bl.asm"
                 
                 ; Character IO
                 ; put ascii code of the blank to the stack
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_BL:
00f60e ff02          .dw $ff02
00f60f 6c62          .db "bl"
00f610 f604          .dw VE_HEAD
                     .set VE_HEAD = VE_BL
                 XT_BL:
00f611 f04e          .dw PFA_DOVARIABLE
                 PFA_BL:
                 .endif
00f612 0020          .dw 32
                 
                 .include "words/turnkey.asm"
                 
                 ; System Value
                 ; Deferred action during startup/reset
                 VE_TURNKEY:
00f613 ff07          .dw $ff07
00f614 7574
00f615 6e72
00f616 656b
00f617 0079          .db "turnkey",0
00f618 f60e          .dw VE_HEAD
                     .set VE_HEAD = VE_TURNKEY
                 XT_TURNKEY:
00f619 fc20          .dw PFA_DODEFER1
                 PFA_TURNKEY:
00f61a 007a          .dw EE_TURNKEY
00f61b fbc1          .dw XT_EDEFERFETCH
00f61c fbcb          .dw XT_EDEFERSTORE
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/slashmod.asm"
                 
                 ; Arithmetics
                 ; signed division n1/n2 with remainder and quotient
                 VE_SLASHMOD:
00f61d ff04          .dw $ff04
00f61e 6d2f
00f61f 646f          .db "/mod"
00f620 f613          .dw VE_HEAD
                     .set VE_HEAD = VE_SLASHMOD
                 XT_SLASHMOD:
00f621 f622          .dw PFA_SLASHMOD
                 PFA_SLASHMOD:
00f622 019c          movw temp2, tosl
                     
00f623 9109          ld temp0, Y+
00f624 9119          ld temp1, Y+
                 
00f625 2f41          mov	temp6,temp1	;move dividend High to sign register
00f626 2743          eor	temp6,temp3	;xor divisor High with sign register
00f627 ff17          sbrs	temp1,7	;if MSB in dividend set
00f628 c004          rjmp	PFA_SLASHMOD_1
00f629 9510          com	temp1		;    change sign of dividend
00f62a 9500          com	temp0		
00f62b 5f0f          subi	temp0,low(-1)
00f62c 4f1f          sbci	temp1,high(-1)
                 PFA_SLASHMOD_1:	
00f62d ff37          sbrs	temp3,7	;if MSB in divisor set
00f62e c004          rjmp	PFA_SLASHMOD_2
00f62f 9530          com	temp3		;    change sign of divisor
00f630 9520          com	temp2		
00f631 5f2f          subi	temp2,low(-1)
00f632 4f3f          sbci	temp3,high(-1)
00f633 24ee      PFA_SLASHMOD_2:	clr	temp4	;clear remainder Low byte
00f634 18ff          sub	temp5,temp5;clear remainder High byte and carry
00f635 e151          ldi	temp7,17	;init loop counter
                 
00f636 1f00      PFA_SLASHMOD_3:	rol	temp0		;shift left dividend
00f637 1f11          rol	temp1
00f638 955a          dec	temp7		;decrement counter
00f639 f439          brne	PFA_SLASHMOD_5		;if done
00f63a ff47          sbrs	temp6,7		;    if MSB in sign register set
00f63b c004          rjmp	PFA_SLASHMOD_4
00f63c 9510          com	temp1	;        change sign of result
00f63d 9500          com	temp0
00f63e 5f0f          subi	temp0,low(-1)
00f63f 4f1f          sbci	temp1,high(-1)
00f640 c00b      PFA_SLASHMOD_4:	rjmp PFA_SLASHMODmod_done			;    return
00f641 1cee      PFA_SLASHMOD_5:	rol	temp4	;shift dividend into remainder
00f642 1cff          rol	temp5
00f643 1ae2          sub	temp4,temp2	;remainder = remainder - divisor
00f644 0af3          sbc	temp5,temp3	;
00f645 f420          brcc	PFA_SLASHMOD_6		;if result negative
00f646 0ee2          add	temp4,temp2	;    restore remainder
00f647 1ef3          adc	temp5,temp3
00f648 9488          clc			;    clear carry to be shifted into result
00f649 cfec          rjmp	PFA_SLASHMOD_3		;else
00f64a 9408      PFA_SLASHMOD_6:	sec			;    set carry to be shifted into result
00f64b cfea          rjmp	PFA_SLASHMOD_3
                 
                 PFA_SLASHMODmod_done:
                     ; put remainder on stack
00f64c 92fa          st -Y,temp5
00f64d 92ea          st -Y,temp4
                 
                     ; put quotient on stack
00f64e 01c8          movw tosl, temp0
00f64f c9b4          jmp_ DO_NEXT
                 .include "words/uslashmod.asm"
                 
                 ; Arithmetics
                 ; unsigned division with remainder
                 VE_USLASHMOD:
00f650 ff05          .dw $ff05
00f651 2f75
00f652 6f6d
00f653 0064          .db "u/mod",0
00f654 f61d          .dw VE_HEAD
                     .set VE_HEAD = VE_USLASHMOD
                 XT_USLASHMOD:
00f655 f000          .dw DO_COLON
                 PFA_USLASHMOD:
00f656 f10b          .dw XT_TO_R
00f657 f160          .dw XT_ZERO
00f658 f102          .dw XT_R_FROM
00f659 f1ce          .dw XT_UMSLASHMOD
00f65a f020          .dw XT_EXIT
                 .include "words/negate.asm"
                 
                 ; Logic
                 ; 2-complement
                 VE_NEGATE:
00f65b ff06          .dw $ff06
00f65c 656e
00f65d 6167
00f65e 6574          .db "negate"
00f65f f650          .dw VE_HEAD
                     .set VE_HEAD = VE_NEGATE
                 XT_NEGATE:
00f660 f000          .dw DO_COLON
                 PFA_NEGATE:
00f661 f209          .dw XT_INVERT
00f662 f23b          .dw XT_1PLUS
00f663 f020          .dw XT_EXIT
                 .include "words/slash.asm"
                 
                 ; Arithmetics
                 ; divide n1 by n2. giving the quotient
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 
                 VE_SLASH:
00f664 ff01          .dw $ff01
00f665 002f          .db "/",0
00f666 f65b          .dw VE_HEAD
                     .set VE_HEAD = VE_SLASH
                 XT_SLASH:
00f667 f000          .dw DO_COLON
                 PFA_SLASH:
                 .endif
00f668 f621          .dw XT_SLASHMOD
00f669 f0fc          .dw XT_NIP
00f66a f020          .dw XT_EXIT
                 
                 .include "words/mod.asm"
                 
                 ; Arithmetics
                 ; divide n1 by n2 giving the remainder n3
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 
                 VE_MOD:
00f66b ff03          .dw $ff03
00f66c 6f6d
00f66d 0064          .db "mod",0
00f66e f664          .dw VE_HEAD
                     .set VE_HEAD = VE_MOD
                 XT_MOD:
00f66f f000          .dw DO_COLON
                 PFA_MOD:
                 .endif
00f670 f621          .dw XT_SLASHMOD
00f671 f0e5          .dw XT_DROP
00f672 f020          .dw XT_EXIT
                 .include "words/abs.asm"
                 
                 ; Arithmetics
                 ; get the absolute value
                 VE_ABS:
00f673 ff03          .dw $ff03
00f674 6261
00f675 0073          .db "abs",0
00f676 f66b          .dw VE_HEAD
                     .set VE_HEAD = VE_ABS
                 XT_ABS:
00f677 f678          .dw PFA_ABS
                 PFA_ABS:
00f678 2399          tst tosh
00f679 f41a          brpl PFA_ABS1
00f67a 9580          com tosl
00f67b 9590          com tosh
00f67c 9601          adiw tosl, 1
                 PFA_ABS1:
00f67d c986          jmp_ do_next
                 .include "words/min.asm"
                 
                 ; Compare
                 ; compare two values leave the smaller one
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 
                 VE_MIN:
00f67e ff03          .dw $ff03
00f67f 696d
00f680 006e          .db "min",0
00f681 f673          .dw VE_HEAD
                     .set VE_HEAD = VE_MIN
                 XT_MIN:
00f682 f000          .dw DO_COLON
                 PFA_MIN:
                 .endif
00f683 f57f          .dw XT_2DUP
00f684 f184          .dw XT_GREATER
00f685 f039          .dw XT_DOCONDBRANCH
00f686 f688          DEST(PFA_MIN1)
00f687 f0d0          .dw XT_SWAP
                 PFA_MIN1:
00f688 f0e5          .dw XT_DROP
00f689 f020          .dw XT_EXIT
                 .include "words/max.asm"
                 
                 ; Compare
                 ; compare two values, leave the bigger one
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_MAX:
00f68a ff03          .dw $ff03
00f68b 616d
00f68c 0078          .db "max",0
00f68d f67e          .dw VE_HEAD
                     .set VE_HEAD = VE_MAX
                 XT_MAX:
00f68e f000          .dw DO_COLON
                 PFA_MAX:
                 
                 .endif
00f68f f57f          .dw XT_2DUP
00f690 f17a          .dw XT_LESS
00f691 f039          .dw XT_DOCONDBRANCH
00f692 f694          DEST(PFA_MAX1)
00f693 f0d0          .dw XT_SWAP
                 PFA_MAX1:
00f694 f0e5          .dw XT_DROP
00f695 f020          .dw XT_EXIT
                 .include "words/within.asm"
                 
                 ; Compare
                 ; check if n is within min..max
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_WITHIN:
00f696 ff06          .dw $ff06
00f697 6977
00f698 6874
00f699 6e69          .db "within"
00f69a f68a          .dw VE_HEAD
                     .set VE_HEAD = VE_WITHIN
                 XT_WITHIN:
00f69b f000          .dw DO_COLON
                 PFA_WITHIN:
                 .endif
00f69c f0db          .dw XT_OVER
00f69d f19f          .dw XT_MINUS
00f69e f10b          .dw XT_TO_R
00f69f f19f          .dw XT_MINUS
00f6a0 f102          .dw XT_R_FROM
00f6a1 f168          .dw XT_ULESS
00f6a2 f020          .dw XT_EXIT
                 
                 .include "words/to-upper.asm"
                 
                 ; String
                 ; if c is a lowercase letter convert it to uppercase
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_TOUPPER:
00f6a3 ff07          .dw $ff07 
00f6a4 6f74
00f6a5 7075
00f6a6 6570
00f6a7 0072          .db "toupper",0
00f6a8 f696          .dw VE_HEAD
                     .set VE_HEAD = VE_TOUPPER
                 XT_TOUPPER:
00f6a9 f000          .dw DO_COLON 
                 PFA_TOUPPER:
                 .endif
00f6aa f0bd          .dw XT_DUP 
00f6ab f040          .dw XT_DOLITERAL 
00f6ac 0061          .dw 'a' 
00f6ad f040          .dw XT_DOLITERAL 
00f6ae 007b          .dw 'z'+1
00f6af f69b          .dw XT_WITHIN 
00f6b0 f039          .dw XT_DOCONDBRANCH
00f6b1 f6b5          DEST(PFA_TOUPPER0)
00f6b2 f040          .dw XT_DOLITERAL
00f6b3 00df          .dw 223 ; inverse of 0x20: 0xdf
00f6b4 f21f          .dw XT_AND 
                 PFA_TOUPPER0:
00f6b5 f020          .dw XT_EXIT 
                 .include "words/to-lower.asm"
                 
                 ; String
                 ; if C is an uppercase letter convert it to lowercase
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 
                 VE_TOLOWER:
00f6b6 ff07          .dw $ff07
00f6b7 6f74
00f6b8 6f6c
00f6b9 6577
00f6ba 0072          .db "tolower",0
00f6bb f6a3          .dw VE_HEAD
                     .set VE_HEAD = VE_TOLOWER
                 XT_TOLOWER:
00f6bc f000          .dw DO_COLON
                 PFA_TOLOWER:
                 .endif
00f6bd f0bd          .dw XT_DUP
00f6be f040          .dw XT_DOLITERAL
00f6bf 0041          .dw 'A'
00f6c0 f040          .dw XT_DOLITERAL
00f6c1 005b          .dw 'Z'+1
00f6c2 f69b          .dw XT_WITHIN
00f6c3 f039          .dw XT_DOCONDBRANCH
00f6c4 f6c8          DEST(PFA_TOLOWER0)
00f6c5 f040          .dw XT_DOLITERAL
00f6c6 0020          .dw 32
00f6c7 f228          .dw XT_OR 
                 PFA_TOLOWER0:
00f6c8 f020          .dw XT_EXIT 
                 ;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/hld.asm"
                 
                 ; Numeric IO
                 ; pointer to current write position in the Pictured Numeric Output buffer
                 VE_HLD:
00f6c9 ff03          .dw $ff03
00f6ca 6c68
00f6cb 0064          .db "hld",0
00f6cc f6b6          .dw VE_HEAD
                     .set VE_HEAD = VE_HLD
                 XT_HLD:
00f6cd f04e          .dw PFA_DOVARIABLE
                 PFA_HLD:
00f6ce 0223          .dw ram_hld
                 
                 .dseg
000223           ram_hld: .byte 2
                 .cseg
                 .include "words/hold.asm"
                 
                 ; Numeric IO
                 ; prepend character to pictured numeric output buffer
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_HOLD:
00f6cf ff04          .dw $ff04
00f6d0 6f68
00f6d1 646c          .db "hold"
00f6d2 f6c9          .dw VE_HEAD
                     .set VE_HEAD = VE_HOLD
                 XT_HOLD:
00f6d3 f000          .dw DO_COLON
                 PFA_HOLD:
                 .endif
00f6d4 f6cd          .dw XT_HLD
00f6d5 f0bd          .dw XT_DUP
00f6d6 f085          .dw XT_FETCH
00f6d7 f241          .dw XT_1MINUS
00f6d8 f0bd          .dw XT_DUP
00f6d9 f10b          .dw XT_TO_R
00f6da f0d0          .dw XT_SWAP
00f6db f08d          .dw XT_STORE
00f6dc f102          .dw XT_R_FROM
00f6dd f099          .dw XT_CSTORE
00f6de f020          .dw XT_EXIT
                 .include "words/less-sharp.asm" ; <#
                 
                 ; Numeric IO
                 ; initialize the pictured numeric output conversion process
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_L_SHARP:
00f6df ff02          .dw $ff02
00f6e0 233c          .db "<#"
00f6e1 f6cf          .dw VE_HEAD
                     .set VE_HEAD = VE_L_SHARP
                 XT_L_SHARP:
00f6e2 f000          .dw DO_COLON
                 PFA_L_SHARP:
                 .endif
00f6e3 f5a4          .dw XT_PAD
00f6e4 f6cd          .dw XT_HLD
00f6e5 f08d          .dw XT_STORE
00f6e6 f020          .dw XT_EXIT
                 .include "words/sharp.asm"
                 
                 ; Numeric IO
                 ; pictured numeric output: convert one digit
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 
                 VE_SHARP:
00f6e7 ff01          .dw $ff01
00f6e8 0023          .db "#",0
00f6e9 f6df          .dw VE_HEAD
                     .set VE_HEAD = VE_SHARP
                 XT_SHARP:
00f6ea f000          .dw DO_COLON
                 PFA_SHARP:
                 .endif
00f6eb f56b          .dw XT_BASE
00f6ec f085          .dw XT_FETCH
00f6ed f767          .dw XT_UDSLASHMOD
00f6ee f0ed          .dw XT_ROT
00f6ef f040          .dw XT_DOLITERAL
00f6f0 0009          .dw 9
00f6f1 f0db          .dw XT_OVER
00f6f2 f17a          .dw XT_LESS
00f6f3 f039          .dw XT_DOCONDBRANCH
00f6f4 f6f8          DEST(PFA_SHARP1)
00f6f5 f040          .dw XT_DOLITERAL
00f6f6 0007          .dw 7
00f6f7 f1a9          .dw XT_PLUS
                 PFA_SHARP1:
00f6f8 f040          .dw XT_DOLITERAL
00f6f9 0030          .dw 48 ; ASCII 0
00f6fa f1a9          .dw XT_PLUS
00f6fb f6d3          .dw XT_HOLD
00f6fc f020          .dw XT_EXIT
                 ; : #    ( ud1 -- ud2 ) 
                 ;        base @ ud/mod rot 9 over < if 7 + then 30 + hold ; 
                 .include "words/sharp-s.asm"
                 
                 ; Numeric IO
                 ; pictured numeric output: convert all digits until 0 (zero) is reached
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SHARP_S:
00f6fd ff02          .dw $ff02
00f6fe 7323          .db "#s"
00f6ff f6e7          .dw VE_HEAD
                     .set VE_HEAD = VE_SHARP_S
                 XT_SHARP_S:
00f700 f000          .dw DO_COLON
                 PFA_SHARP_S:
                 .endif
                 NUMS1:
00f701 f6ea          .dw XT_SHARP
00f702 f57f          .dw XT_2DUP
00f703 f228          .dw XT_OR
00f704 f126          .dw XT_ZEROEQUAL
00f705 f039          .dw XT_DOCONDBRANCH
00f706 f701          DEST(NUMS1) ; PFA_SHARP_S
00f707 f020          .dw XT_EXIT
                 .include "words/sharp-greater.asm" ; #>
                 
                 ; Numeric IO
                 ; Pictured Numeric Output: convert PNO buffer into an string
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SHARP_G:
00f708 ff02          .dw $ff02
00f709 3e23          .db "#>"
00f70a f6fd          .dw VE_HEAD
                     .set VE_HEAD = VE_SHARP_G
                 XT_SHARP_G:
00f70b f000          .dw DO_COLON
                 PFA_SHARP_G:
                 .endif
00f70c f588          .dw XT_2DROP
00f70d f6cd          .dw XT_HLD
00f70e f085          .dw XT_FETCH
00f70f f5a4          .dw XT_PAD
00f710 f0db          .dw XT_OVER
00f711 f19f          .dw XT_MINUS
00f712 f020          .dw XT_EXIT
                 .include "words/sign.asm"
                 
                 ; Numeric IO
                 ; place a - in HLD if n is negative
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SIGN:
00f713 ff04          .dw $ff04
00f714 6973
00f715 6e67          .db "sign"
00f716 f708          .dw VE_HEAD
                     .set VE_HEAD = VE_SIGN
                 XT_SIGN:
00f717 f000          .dw DO_COLON
                 PFA_SIGN:
                 .endif
00f718 f12d          .dw XT_ZEROLESS
00f719 f039          .dw XT_DOCONDBRANCH
00f71a f71e          DEST(PFA_SIGN1)
00f71b f040          .dw XT_DOLITERAL
00f71c 002d          .dw 45 ; ascii -
00f71d f6d3          .dw XT_HOLD
                 PFA_SIGN1:
00f71e f020          .dw XT_EXIT
                 .include "words/d-dot-r.asm"
                 
                 ; Numeric IO
                 ; singed PNO with double cell numbers, right aligned in width w
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DDOTR:
00f71f ff03          .dw $ff03
00f720 2e64
00f721 0072          .db "d.r",0
00f722 f713          .dw VE_HEAD
                     .set VE_HEAD = VE_DDOTR
                 XT_DDOTR:
00f723 f000          .dw DO_COLON
                 PFA_DDOTR:
                 
                 .endif
00f724 f10b          .dw XT_TO_R
00f725 f590          .dw XT_TUCK
00f726 fcf2          .dw XT_DABS
00f727 f6e2          .dw XT_L_SHARP
00f728 f700          .dw XT_SHARP_S
00f729 f0ed          .dw XT_ROT
00f72a f717          .dw XT_SIGN
00f72b f70b          .dw XT_SHARP_G
00f72c f102          .dw XT_R_FROM
00f72d f0db          .dw XT_OVER
00f72e f19f          .dw XT_MINUS
00f72f f80f          .dw XT_SPACES
00f730 f81f          .dw XT_TYPE
00f731 f020          .dw XT_EXIT
                 ; : d.r       ( d n -- )
                 ;             >r swap over dabs <# #s rot sign #> r> over - spaces type ;
                 .include "words/dot-r.asm"
                 
                 ; Numeric IO
                 ; singed PNO with single cell numbers, right aligned in width w
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DOTR:
00f732 ff02          .dw $ff02
00f733 722e          .db ".r"
00f734 f71f          .dw VE_HEAD
                     .set VE_HEAD = VE_DOTR
                 XT_DOTR:
00f735 f000          .dw DO_COLON
                 PFA_DOTR:
                 
                 .endif
00f736 f10b          .dw XT_TO_R
00f737 fd81          .dw XT_S2D
00f738 f102          .dw XT_R_FROM
00f739 f723          .dw XT_DDOTR
00f73a f020          .dw XT_EXIT
                 ; : .r        ( s n -- )  >r s>d r> d.r ;
                 .include "words/d-dot.asm"
                 
                 ; Numeric IO
                 ; singed PNO with double cell numbers
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DDOT:
00f73b ff02          .dw $ff02
00f73c 2e64          .db "d."
00f73d f732          .dw VE_HEAD
                     .set VE_HEAD = VE_DDOT
                 XT_DDOT:
00f73e f000          .dw DO_COLON
                 PFA_DDOT:
                 
                 .endif
00f73f f160          .dw XT_ZERO
00f740 f723          .dw XT_DDOTR
00f741 f806          .dw XT_SPACE
00f742 f020          .dw XT_EXIT
                 ; : d.        ( d -- )    0 d.r space ;
                 .include "words/dot.asm"
                 
                 ; Numeric IO
                 ; singed PNO with single cell numbers
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 
                 VE_DOT:
00f743 ff01          .dw $ff01
00f744 002e          .db ".",0
00f745 f73b          .dw VE_HEAD
                     .set VE_HEAD = VE_DOT
                 XT_DOT:
00f746 f000          .dw DO_COLON
                 PFA_DOT:
                 .endif
00f747 fd81          .dw XT_S2D
00f748 f73e          .dw XT_DDOT
00f749 f020          .dw XT_EXIT
                 ; : .         ( s -- )    s>d d. ; 
                 .include "words/ud-dot.asm"
                 
                 ; Numeric IO
                 ; unsigned PNO with double cell numbers
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_UDDOT:
00f74a ff03          .dw $ff03
00f74b 6475
00f74c 002e          .db "ud.",0
00f74d f743          .dw VE_HEAD
                     .set VE_HEAD = VE_UDDOT
                 XT_UDDOT:
00f74e f000          .dw DO_COLON
                 PFA_UDDOT:
                 .endif
00f74f f160          .dw XT_ZERO
00f750 f757          .dw XT_UDDOTR
00f751 f806          .dw XT_SPACE
00f752 f020          .dw XT_EXIT
                 .include "words/ud-dot-r.asm"
                 
                 ; Numeric IO
                 ; unsigned PNO with double cell numbers, right aligned in width w
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 
                 VE_UDDOTR:
00f753 ff04          .dw $ff04
00f754 6475
00f755 722e          .db "ud.r"
00f756 f74a          .dw VE_HEAD
                     .set VE_HEAD = VE_UDDOTR
                 XT_UDDOTR:
00f757 f000          .dw DO_COLON
                 PFA_UDDOTR:
                 .endif
00f758 f10b          .dw XT_TO_R
00f759 f6e2          .dw XT_L_SHARP
00f75a f700          .dw XT_SHARP_S
00f75b f70b          .dw XT_SHARP_G
00f75c f102          .dw XT_R_FROM
00f75d f0db          .dw XT_OVER
00f75e f19f          .dw XT_MINUS
00f75f f80f          .dw XT_SPACES
00f760 f81f          .dw XT_TYPE
00f761 f020          .dw XT_EXIT
                 .include "words/ud-slash-mod.asm"
                 
                 ; Arithmetics
                 ; unsigned double cell division with remainder
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_UDSLASHMOD:
00f762 ff06          .dw $ff06
00f763 6475
00f764 6d2f
00f765 646f          .db "ud/mod"
00f766 f753          .dw VE_HEAD
                     .set VE_HEAD = VE_UDSLASHMOD
                 XT_UDSLASHMOD:
00f767 f000          .dw DO_COLON
                 PFA_UDSLASHMOD:
                 .endif
00f768 f10b          .dw XT_TO_R
00f769 f160          .dw XT_ZERO
00f76a f114          .dw XT_R_FETCH
00f76b f1ce          .dw XT_UMSLASHMOD
00f76c f102          .dw XT_R_FROM
00f76d f0d0          .dw XT_SWAP
00f76e f10b          .dw XT_TO_R
00f76f f1ce          .dw XT_UMSLASHMOD
00f770 f102          .dw XT_R_FROM
00f771 f020          .dw XT_EXIT
                 .include "words/digit-q.asm"
                 
                 ; Numeric IO
                 ; tries to convert a character to a number, set flag accordingly
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DIGITQ:
00f772 ff06          .dw $ff06 
00f773 6964
00f774 6967
00f775 3f74          .db "digit?"
00f776 f762          .dw VE_HEAD
                     .set VE_HEAD = VE_DIGITQ
                 XT_DIGITQ:
00f777 f000          .dw DO_COLON 
                 PFA_DIGITQ:
                 .endif
00f778 f6a9          .dw XT_TOUPPER
00f779 f0bd
00f77a f040
00f77b 0039
00f77c f184
00f77d f040
00f77e 0100          .DW XT_DUP,XT_DOLITERAL,57,XT_GREATER,XT_DOLITERAL,256
00f77f f21f
00f780 f1a9
00f781 f0bd
00f782 f040
00f783 0140
00f784 f184          .DW XT_AND,XT_PLUS,XT_DUP,XT_DOLITERAL,320,XT_GREATER
00f785 f040
00f786 0107
00f787 f21f
00f788 f19f
00f789 f040
00f78a 0030          .DW XT_DOLITERAL,263,XT_AND,XT_MINUS,XT_DOLITERAL,48
00f78b f19f
00f78c f0bd
00f78d f56b
00f78e f085
00f78f f168          .DW XT_MINUS,XT_DUP,XT_BASE,XT_FETCH,XT_ULESS
00f790 f020          .DW XT_EXIT
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/do-sliteral.asm"
                 
                 ; String
                 ; runtime portion of sliteral
                 ;VE_DOSLITERAL:
                 ;  .dw $ff0a
                 ;  .db "(sliteral)"
                 ;  .dw VE_HEAD
                 ;  .set VE_HEAD = VE_DOSLITERAL
                 XT_DOSLITERAL:
00f791 f000        .dw DO_COLON
                 PFA_DOSLITERAL:
00f792 f114        .dw XT_R_FETCH   ; ( -- addr )
00f793 f7f0        .dw XT_ICOUNT
00f794 f102        .dw XT_R_FROM
00f795 f0db        .dw XT_OVER     ; ( -- addr' n addr n)
00f796 f23b        .dw XT_1PLUS
00f797 f210        .dw XT_2SLASH   ; ( -- addr' n addr k )
00f798 f1a9        .dw XT_PLUS     ; ( -- addr' n addr'' )
00f799 f23b        .dw XT_1PLUS
00f79a f10b        .dw XT_TO_R     ; ( -- )
00f79b f020        .dw XT_EXIT
                 .include "words/scomma.asm"
                 
                 ; Compiler
                 ; compiles a string from RAM to Flash
                 VE_SCOMMA:
00f79c ff02        .dw $ff02
00f79d 2c73        .db "s",$2c
00f79e f772        .dw VE_HEAD
                   .set VE_HEAD = VE_SCOMMA
                 XT_SCOMMA:
00f79f f000          .dw DO_COLON
                 PFA_SCOMMA:
00f7a0 f0bd          .dw XT_DUP
00f7a1 f7a3          .dw XT_DOSCOMMA
00f7a2 f020          .dw XT_EXIT
                 
                 ; ( addr len len' -- ) 
                 ; Compiler
                 ; compiles a string from RAM to Flash
                 ;VE_DOSCOMMA:
                 ;  .dw $ff04
                 ;  .db "(s",$2c,")"
                 ;  .dw VE_HEAD
                 ;  .set VE_HEAD = VE_DOSCOMMA
                 XT_DOSCOMMA:
00f7a3 f000          .dw DO_COLON
                 PFA_DOSCOMMA:
00f7a4 0202          .dw XT_COMMA
00f7a5 f0bd          .dw XT_DUP   ; ( --addr len len)
00f7a6 f210          .dw XT_2SLASH ; ( -- addr len len/2
00f7a7 f590          .dw XT_TUCK   ; ( -- addr len/2 len len/2
00f7a8 f217          .dw XT_2STAR  ; ( -- addr len/2 len len'
00f7a9 f19f          .dw XT_MINUS  ; ( -- addr len/2 rem
00f7aa f10b          .dw XT_TO_R
00f7ab f160          .dw XT_ZERO
00f7ac 02c1          .dw XT_QDOCHECK
00f7ad f039          .dw XT_DOCONDBRANCH
00f7ae f7b6          .dw PFA_SCOMMA2
00f7af f29b          .dw XT_DODO
                 PFA_SCOMMA1:
00f7b0 f0bd          .dw XT_DUP         ; ( -- addr addr )
00f7b1 f085          .dw XT_FETCH       ; ( -- addr c1c2 )
00f7b2 0202          .dw XT_COMMA       ; ( -- addr )
00f7b3 f578          .dw XT_CELLPLUS    ; ( -- addr+cell )
00f7b4 f2c9          .dw XT_DOLOOP
00f7b5 f7b0          .dw PFA_SCOMMA1
                 PFA_SCOMMA2:
00f7b6 f102          .dw XT_R_FROM
00f7b7 f134          .dw XT_GREATERZERO
00f7b8 f039          .dw XT_DOCONDBRANCH
00f7b9 f7bd          .dw PFA_SCOMMA3
00f7ba f0bd            .dw XT_DUP     ; well, tricky
00f7bb f0a4            .dw XT_CFETCH
00f7bc 0202            .dw XT_COMMA
                 PFA_SCOMMA3:
00f7bd f0e5          .dw XT_DROP        ; ( -- )
00f7be f020          .dw XT_EXIT
                 .include "words/itype.asm"
                 
                 ; Tools
                 ; reads string from flash and prints it
                 VE_ITYPE:
00f7bf ff05          .dw $ff05
00f7c0 7469
00f7c1 7079
00f7c2 0065          .db "itype",0
00f7c3 f79c          .dw VE_HEAD
                     .set VE_HEAD = VE_ITYPE
                 XT_ITYPE:
00f7c4 f000          .dw DO_COLON
                 PFA_ITYPE:
00f7c5 f0bd          .dw XT_DUP    ; ( --addr len len)
00f7c6 f210          .dw XT_2SLASH ; ( -- addr len len/2
00f7c7 f590          .dw XT_TUCK   ; ( -- addr len/2 len len/2
00f7c8 f217          .dw XT_2STAR  ; ( -- addr len/2 len len'
00f7c9 f19f          .dw XT_MINUS  ; ( -- addr len/2 rem
00f7ca f10b          .dw XT_TO_R
00f7cb f160          .dw XT_ZERO
00f7cc 02c1          .dw XT_QDOCHECK
00f7cd f039          .dw XT_DOCONDBRANCH
00f7ce f7d8          .dw PFA_ITYPE2
00f7cf f29b          .dw XT_DODO
                 PFA_ITYPE1:
00f7d0 f0bd          .dw XT_DUP         ; ( -- addr addr )
00f7d1 f3d2          .dw XT_FETCHI      ; ( -- addr c1c2 )
00f7d2 f0bd          .dw XT_DUP
00f7d3 f7e5          .dw XT_LOWEMIT
00f7d4 f7e1          .dw XT_HIEMIT
00f7d5 f23b          .dw XT_1PLUS    ; ( -- addr+cell )
00f7d6 f2c9          .dw XT_DOLOOP
00f7d7 f7d0          .dw PFA_ITYPE1
                 PFA_ITYPE2:
00f7d8 f102          .dw XT_R_FROM
00f7d9 f134          .dw XT_GREATERZERO
00f7da f039          .dw XT_DOCONDBRANCH
00f7db f7df          .dw PFA_ITYPE3
00f7dc f0bd            .dw XT_DUP     ; make sure the drop below has always something to do
00f7dd f3d2            .dw XT_FETCHI
00f7de f7e5            .dw XT_LOWEMIT
                 PFA_ITYPE3:
00f7df f0e5          .dw XT_DROP
00f7e0 f020          .dw XT_EXIT
                 
                 ; ( w -- )
                 ; R( -- )
                 ; content of cell fetched on stack.
                 ;VE_HIEMIT:
                 ;    .dw $ff06
                 ;    .db "hiemit"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_HIEMIT
                 XT_HIEMIT:
00f7e1 f000          .dw DO_COLON
                 PFA_HIEMIT:
00f7e2 f2f9          .dw XT_BYTESWAP
00f7e3 f7e5          .dw XT_LOWEMIT
00f7e4 f020          .dw XT_EXIT
                 
                 ; ( w -- )
                 ; R( -- )
                 ; content of cell fetched on stack.
                 ;VE_LOWEMIT:
                 ;    .dw $ff07
                 ;    .db "lowemit"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_LOWEMIT
                 XT_LOWEMIT:
00f7e5 f000          .dw DO_COLON
                 PFA_LOWEMIT:
00f7e6 f040          .dw XT_DOLITERAL
00f7e7 00ff          .dw $00ff
00f7e8 f21f          .dw XT_AND
00f7e9 f5ae          .dw XT_EMIT
00f7ea f020          .dw XT_EXIT
                 .include "words/icount.asm"
                 
                 ; Tools
                 ; get count information out of a counted string in flash
                 VE_ICOUNT:
00f7eb ff06          .dw $ff06
00f7ec 6369
00f7ed 756f
00f7ee 746e          .db "icount"
00f7ef f7bf          .dw VE_HEAD
                     .set VE_HEAD = VE_ICOUNT
                 XT_ICOUNT:
00f7f0 f000          .dw DO_COLON
                 PFA_ICOUNT:
00f7f1 f0bd          .dw XT_DUP
00f7f2 f23b          .dw XT_1PLUS
00f7f3 f0d0          .dw XT_SWAP
00f7f4 f3d2          .dw XT_FETCHI
00f7f5 f020          .dw XT_EXIT
                 .include "words/cr.asm"
                 
                 ; Character IO
                 ; cause subsequent output appear at the beginning of the next line
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_CR:
00f7f6 ff02          .dw 0xff02
00f7f7 7263          .db "cr"
00f7f8 f7eb          .dw VE_HEAD
                     .set VE_HEAD = VE_CR
                 XT_CR:
00f7f9 f000          .dw DO_COLON
                 PFA_CR:
                 .endif
                 
00f7fa f040          .dw XT_DOLITERAL
00f7fb 000d          .dw 13
00f7fc f5ae          .dw XT_EMIT
00f7fd f040          .dw XT_DOLITERAL
00f7fe 000a          .dw 10
00f7ff f5ae          .dw XT_EMIT
00f800 f020          .dw XT_EXIT
                 .include "words/space.asm"
                 
                 ; Character IO
                 ; emits a space (bl)
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SPACE:
00f801 ff05          .dw $ff05
00f802 7073
00f803 6361
00f804 0065          .db "space",0
00f805 f7f6          .dw VE_HEAD
                     .set VE_HEAD = VE_SPACE
                 XT_SPACE:
00f806 f000          .dw DO_COLON
                 PFA_SPACE:
                 .endif
00f807 f611          .dw XT_BL
00f808 f5ae          .dw XT_EMIT
00f809 f020          .dw XT_EXIT
                 .include "words/spaces.asm"
                 
                 ; Character IO
                 ; emits n space(s) (bl)
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SPACES:
00f80a ff06          .dw $ff06
00f80b 7073
00f80c 6361
00f80d 7365          .db "spaces"
00f80e f801          .dw VE_HEAD
                     .set VE_HEAD = VE_SPACES
                 XT_SPACES:
00f80f f000          .dw DO_COLON
                 PFA_SPACES:
                 
                 .endif
                 ;C SPACES   n --            output n spaces
                 ;   BEGIN DUP 0> WHILE SPACE 1- REPEAT DROP ;
00f810 f160
00f811 f68e      	.DW XT_ZERO, XT_MAX
00f812 f0bd
00f813 f039      SPCS1:  .DW XT_DUP,XT_DOCONDBRANCH
00f814 f819              DEST(SPCS2)
00f815 f806
00f816 f241
00f817 f02f              .DW XT_SPACE,XT_1MINUS,XT_DOBRANCH
00f818 f812              DEST(SPCS1)
00f819 f0e5
00f81a f020      SPCS2:  .DW XT_DROP,XT_EXIT
                 .include "words/type.asm"
                 
                 ; Character IO
                 ; print a RAM based string
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_TYPE:
00f81b ff04          .dw $ff04
00f81c 7974
00f81d 6570          .db "type"
00f81e f80a          .dw VE_HEAD
                     .set VE_HEAD = VE_TYPE
                 XT_TYPE:
00f81f f000          .dw DO_COLON
                 PFA_TYPE:
                 
                 .endif
00f820 fd78          .dw XT_BOUNDS
00f821 02c1          .dw XT_QDOCHECK
00f822 f039          .dw XT_DOCONDBRANCH
00f823 f82a          DEST(PFA_TYPE2)
00f824 f29b          .dw XT_DODO
                 PFA_TYPE1:
00f825 f2ac          .dw XT_I
00f826 f0a4          .dw XT_CFETCH
00f827 f5ae          .dw XT_EMIT
00f828 f2c9          .dw XT_DOLOOP
00f829 f825          DEST(PFA_TYPE1)
                 PFA_TYPE2:
00f82a f020          .dw XT_EXIT
                 .include "words/tick.asm"
                 
                 ; Dictionary
                 ; search dictionary for name, return XT or throw an exception -13
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_TICK:
00f82b ff01          .dw $ff01
00f82c 0027          .db "'",0
00f82d f81b          .dw VE_HEAD
                     .set VE_HEAD = VE_TICK
                 XT_TICK:
00f82e f000          .dw DO_COLON
                 PFA_TICK:
                 .endif
00f82f f9d1          .dw XT_PARSENAME
00f830 facf          .dw XT_DORECOGNIZER
00f831 fb39          .dw XT_R_WORD
00f832 fd9d          .dw XT_EQUAL
00f833 f039          .dw XT_DOCONDBRANCH
00f834 f837          DEST(PFA_TICK1)
00f835 f0e5          .dw XT_DROP
00f836 f020          .dw XT_EXIT
                 PFA_TICK1:
00f837 f040          .dw XT_DOLITERAL
00f838 fff3          .dw -13
00f839 f85d          .dw XT_THROW
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/handler.asm"
                 
                 ; Exceptions
                 ; USER variable used by catch/throw
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_HANDLER:
00f83a ff07          .dw $ff07
00f83b 6168
00f83c 646e
00f83d 656c
00f83e 0072          .db "handler",0
00f83f f82b          .dw VE_HEAD
                     .set VE_HEAD = VE_HANDLER
                 XT_HANDLER:
00f840 f061          .dw PFA_DOUSER
                 PFA_HANDLER:
                 .endif
00f841 000a          .dw USER_HANDLER
                 .include "words/catch.asm"
                 
                 ; Exceptions
                 ; execute XT and check for exceptions.
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_CATCH:
00f842 ff05          .dw $ff05
00f843 6163
00f844 6374
00f845 0068          .db "catch",0
00f846 f83a          .dw VE_HEAD
                     .set VE_HEAD = VE_CATCH
                 XT_CATCH:
00f847 f000          .dw DO_COLON
                 PFA_CATCH:
                 .endif
                 
                     ; sp@ >r
00f848 f28d          .dw XT_SP_FETCH
00f849 f10b          .dw XT_TO_R
                     ; handler @ >r
00f84a f840          .dw XT_HANDLER
00f84b f085          .dw XT_FETCH
00f84c f10b          .dw XT_TO_R
                     ; rp@ handler !
00f84d f276          .dw XT_RP_FETCH
00f84e f840          .dw XT_HANDLER
00f84f f08d          .dw XT_STORE
00f850 f02a          .dw XT_EXECUTE
                     ; r> handler !
00f851 f102          .dw XT_R_FROM
00f852 f840          .dw XT_HANDLER
00f853 f08d          .dw XT_STORE
00f854 f102          .dw XT_R_FROM
00f855 f0e5          .dw XT_DROP
00f856 f160          .dw XT_ZERO
00f857 f020          .dw XT_EXIT
                 .include "words/throw.asm"
                 
                 ; Exceptions
                 ; throw an exception
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_THROW:
00f858 ff05          .dw $ff05
00f859 6874
00f85a 6f72
00f85b 0077          .db "throw",0
00f85c f842          .dw VE_HEAD
                     .set VE_HEAD = VE_THROW
                 XT_THROW:
00f85d f000          .dw DO_COLON
                 PFA_THROW:
                 .endif
00f85e f0bd          .dw XT_DUP
00f85f f126          .dw XT_ZEROEQUAL
00f860 f039          .dw XT_DOCONDBRANCH
00f861 f864          DEST(PFA_THROW1)
00f862 f0e5      	.dw XT_DROP
00f863 f020      	.dw XT_EXIT
                 PFA_THROW1:
00f864 f840          .dw XT_HANDLER
00f865 f085          .dw XT_FETCH
00f866 f280          .dw XT_RP_STORE
00f867 f102          .dw XT_R_FROM
00f868 f840          .dw XT_HANDLER
00f869 f08d          .dw XT_STORE
00f86a f102          .dw XT_R_FROM
00f86b f0d0          .dw XT_SWAP
00f86c f10b          .dw XT_TO_R
00f86d f296          .dw XT_SP_STORE
00f86e f0e5          .dw XT_DROP
00f86f f102          .dw XT_R_FROM    
00f870 f020          .dw XT_EXIT
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/cskip.asm"
                 
                 ; String
                 ; skips leading occurancies in string at addr1/n1 leaving addr2/n2 pointing to the 1st non-c character
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_CSKIP:
00f871 ff05          .dw $ff05
00f872 7363
00f873 696b
00f874 0070          .db "cskip",0
00f875 f858          .dw VE_HEAD
                     .set VE_HEAD = VE_CSKIP
                 XT_CSKIP:
00f876 f000          .dw DO_COLON
                 PFA_CSKIP:
                 .endif
00f877 f10b          .dw XT_TO_R           ; ( -- addr1 n1 )
                 PFA_CSKIP1:
00f878 f0bd          .dw XT_DUP            ; ( -- addr' n' n' )
00f879 f039          .dw XT_DOCONDBRANCH   ; ( -- addr' n')
00f87a f886          DEST(PFA_CSKIP2)
00f87b f0db          .dw XT_OVER           ; ( -- addr' n' addr' )
00f87c f0a4          .dw XT_CFETCH         ; ( -- addr' n' c' )
00f87d f114          .dw XT_R_FETCH        ; ( -- addr' n' c' c )
00f87e fd9d          .dw XT_EQUAL          ; ( -- addr' n' f )
00f87f f039          .dw XT_DOCONDBRANCH   ; ( -- addr' n')
00f880 f886          DEST(PFA_CSKIP2)
00f881 f040          .dw XT_DOLITERAL
00f882 0001          .dw 1
00f883 f9c2          .dw XT_SLASHSTRING
00f884 f02f          .dw XT_DOBRANCH
00f885 f878          DEST(PFA_CSKIP1)
                 PFA_CSKIP2:
00f886 f102          .dw XT_R_FROM
00f887 f0e5          .dw XT_DROP           ; ( -- addr2 n2)
00f888 f020          .dw XT_EXIT
                 .include "words/cscan.asm"
                 
                 ; String
                 ; Scan string at addr1/n1 for the first occurance of c, leaving addr1/n2, char at n2 is first non-c character
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_CSCAN:
00f889 ff05          .dw $ff05
00f88a 7363
00f88b 6163
../../common\words/cscan.asm(12): warning: .cseg .db misalignment - padding zero byte
00f88c 006e          .db "cscan"
00f88d f871          .dw VE_HEAD
                     .set VE_HEAD = VE_CSCAN
                 XT_CSCAN:
00f88e f000          .dw DO_COLON
                 PFA_CSCAN:
                 .endif
00f88f f10b          .dw XT_TO_R
00f890 f0db          .dw XT_OVER
                 PFA_CSCAN1:
00f891 f0bd          .dw XT_DUP
00f892 f0a4          .dw XT_CFETCH
00f893 f114          .dw XT_R_FETCH
00f894 fd9d          .dw XT_EQUAL
00f895 f126          .dw XT_ZEROEQUAL
00f896 f039          .dw XT_DOCONDBRANCH
00f897 f8a3          DEST(PFA_CSCAN2)
00f898 f0d0            .dw XT_SWAP
00f899 f241            .dw XT_1MINUS
00f89a f0d0            .dw XT_SWAP
00f89b f0db            .dw XT_OVER
00f89c f12d            .dw XT_ZEROLESS ; not negative
00f89d f126            .dw XT_ZEROEQUAL
00f89e f039            .dw XT_DOCONDBRANCH
00f89f f8a3            DEST(PFA_CSCAN2)
00f8a0 f23b              .dw XT_1PLUS
00f8a1 f02f              .dw XT_DOBRANCH
00f8a2 f891              DEST(PFA_CSCAN1)
                 PFA_CSCAN2:
00f8a3 f0fc          .dw XT_NIP
00f8a4 f0db          .dw XT_OVER
00f8a5 f19f          .dw XT_MINUS
00f8a6 f102          .dw XT_R_FROM
00f8a7 f0e5          .dw XT_DROP
00f8a8 f020          .dw XT_EXIT
                 
                 ; : my-cscan ( addr len c -- addr len' )
                 ;    >r over ( -- addr len addr )
                 ;    begin
                 ;      dup c@ r@ <> while
                 ;       swap 1- swap over 0 >=  while
                 ;        1+ 
                 ;     repeat then
                 ;     nip over - r> drop 
                 ; ;
                 .include "words/accept.asm"
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_ACCEPT:
00f8a9 ff06          .dw $ff06
00f8aa 6361
00f8ab 6563
00f8ac 7470          .db "accept"
00f8ad f889          .dw VE_HEAD
                     .set VE_HEAD = VE_ACCEPT
                 XT_ACCEPT:
00f8ae f000          .dw DO_COLON
                 PFA_ACCEPT:
                 
                 .endif
00f8af f0db
00f8b0 f1a9
00f8b1 f241
00f8b2 f0db              .DW XT_OVER,XT_PLUS,XT_1MINUS,XT_OVER
00f8b3 f5bf
00f8b4 f0bd
00f8b5 f8e8
00f8b6 f126
00f8b7 f039      ACC1:   .DW XT_KEY,XT_DUP,XT_CRLFQ,XT_ZEROEQUAL,XT_DOCONDBRANCH
00f8b8 f8da              DEST(ACC5)
00f8b9 f0bd
00f8ba f040
00f8bb 0008
00f8bc fd9d
00f8bd f039              .DW XT_DUP,XT_DOLITERAL,8,XT_EQUAL,XT_DOCONDBRANCH
00f8be f8d1              DEST(ACC3)
00f8bf f0e5
00f8c0 f0ed
00f8c1 f57f
00f8c2 f184
00f8c3 f10b
00f8c4 f0ed
00f8c5 f0ed
00f8c6 f102
00f8c7 f039              .DW XT_DROP,XT_ROT,XT_2DUP,XT_GREATER,XT_TO_R,XT_ROT,XT_ROT,XT_R_FROM,XT_DOCONDBRANCH
00f8c8 f8cf      	DEST(ACC6)
00f8c9 f8e0
00f8ca f241
00f8cb f10b
00f8cc f0db
00f8cd f102
00f8ce 017c      	.DW XT_BS,XT_1MINUS,XT_TO_R,XT_OVER,XT_R_FROM,XT_UMAX
                 ACC6:
00f8cf f02f              .DW XT_DOBRANCH
00f8d0 f8d8              DEST(ACC4)
00f8d1 f0bd
00f8d2 f5ae
00f8d3 f0db
00f8d4 f099
00f8d5 f23b
00f8d6 f0db
00f8d7 0188      ACC3:   .DW XT_DUP,XT_EMIT,XT_OVER,XT_CSTORE,XT_1PLUS,XT_OVER,XT_UMIN
00f8d8 f02f      ACC4:   .DW XT_DOBRANCH
00f8d9 f8b3              DEST(ACC1)
00f8da f0e5
00f8db f0fc
00f8dc f0d0
00f8dd f19f
00f8de f7f9
00f8df f020      ACC5:   .DW XT_DROP,XT_NIP,XT_SWAP,XT_MINUS,XT_CR,XT_EXIT
                 
                 
                 ; ( --  ) 
                 ; System
                 ; send a backspace character to overwrite the current char
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 ;VE_BS:
                 ;    .dw $ff02
                 ;    .db "bs"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_BS
                 XT_BS:
00f8e0 f000          .dw DO_COLON
                 .endif
00f8e1 f040          .dw XT_DOLITERAL
00f8e2 0008          .dw 8
00f8e3 f0bd          .dw XT_DUP
00f8e4 f5ae          .dw XT_EMIT
00f8e5 f806          .dw XT_SPACE
00f8e6 f5ae          .dw XT_EMIT
00f8e7 f020          .dw XT_EXIT
                 
                 
                 ; ( c -- f ) 
                 ; System
                 ; is the character a line end character?
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 ;VE_CRLFQ:
                 ;    .dw $ff02
                 ;    .db "crlf?"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_CRLFQ
                 XT_CRLFQ:
00f8e8 f000          .dw DO_COLON
                 .endif
00f8e9 f0bd          .dw XT_DUP
00f8ea f040          .dw XT_DOLITERAL
00f8eb 000d          .dw 13
00f8ec fd9d          .dw XT_EQUAL
00f8ed f0d0          .dw XT_SWAP
00f8ee f040          .dw XT_DOLITERAL
00f8ef 000a          .dw 10
00f8f0 fd9d          .dw XT_EQUAL
00f8f1 f228          .dw XT_OR
00f8f2 f020          .dw XT_EXIT
                 .include "words/refill.asm"
                 
                 ; System
                 ; refills the input buffer
                 VE_REFILL:
00f8f3 ff06          .dw $ff06
00f8f4 6572
00f8f5 6966
00f8f6 6c6c          .db "refill"
00f8f7 f8a9          .dw VE_HEAD
                     .set VE_HEAD = VE_REFILL
                 XT_REFILL:
00f8f8 fc20          .dw PFA_DODEFER1
                 PFA_REFILL:
00f8f9 001a          .dw USER_REFILL
00f8fa fbe9          .dw XT_UDEFERFETCH
00f8fb fbf5          .dw XT_UDEFERSTORE
                 
                 .include "words/char.asm"
                 
                 ; Tools
                 ; copy the first character of the next word onto the stack
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_CHAR:
00f8fc ff04          .dw $ff04
00f8fd 6863
00f8fe 7261          .db "char"
00f8ff f8f3          .dw VE_HEAD
                     .set VE_HEAD = VE_CHAR
                 XT_CHAR:
00f900 f000          .dw DO_COLON
                 PFA_CHAR:
                 .endif
00f901 f9d1          .dw XT_PARSENAME
00f902 f0e5          .dw XT_DROP
00f903 f0a4          .dw XT_CFETCH
00f904 f020          .dw XT_EXIT
                 .include "words/number.asm"
                 
                 ; Numeric IO
                 ; convert a string at addr to a number
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_NUMBER:
00f905 ff06          .dw $ff06
00f906 756e
00f907 626d
00f908 7265          .db "number"
00f909 f8fc          .dw VE_HEAD
                     .set VE_HEAD = VE_NUMBER
                 XT_NUMBER:
00f90a f000          .dw DO_COLON
                 PFA_NUMBER:
                 .endif
00f90b f56b          .dw XT_BASE
00f90c f085          .dw XT_FETCH
00f90d f10b          .dw XT_TO_R
00f90e f951          .dw XT_QSIGN
00f90f f10b          .dw XT_TO_R
00f910 f965          .dw XT_SET_BASE
00f911 f951          .dw XT_QSIGN
00f912 f102          .dw XT_R_FROM
00f913 f228          .dw XT_OR
00f914 f10b          .dw XT_TO_R
                     ; check whether something is left
00f915 f0bd          .dw XT_DUP
00f916 f126          .dw XT_ZEROEQUAL
00f917 f039          .dw XT_DOCONDBRANCH
00f918 f921          DEST(PFA_NUMBER0)
                       ; nothing is left. It cannot be a number at all
00f919 f588            .dw XT_2DROP
00f91a f102            .dw XT_R_FROM
00f91b f0e5            .dw XT_DROP
00f91c f102            .dw XT_R_FROM
00f91d f56b            .dw XT_BASE
00f91e f08d            .dw XT_STORE
00f91f f160            .dw XT_ZERO
00f920 f020            .dw XT_EXIT
                 PFA_NUMBER0:
00f921 f31e          .dw XT_2TO_R
00f922 f160          .dw XT_ZERO       ; starting value
00f923 f160          .dw XT_ZERO
00f924 f32d          .dw XT_2R_FROM
00f925 f984          .dw XT_TO_NUMBER ; ( 0. addr len -- d addr' len'
                     ; check length of the remaining string.
                     ; if zero: a single cell number is entered
00f926 f0c5          .dw XT_QDUP
00f927 f039          .dw XT_DOCONDBRANCH
00f928 f945          DEST(PFA_NUMBER1)
                     ; if equal 1: mayba a trailing dot? --> double cell number
00f929 f040          .dw XT_DOLITERAL
00f92a 0001          .dw 1
00f92b fd9d          .dw XT_EQUAL
00f92c f039          .dw XT_DOCONDBRANCH
00f92d f93c          DEST(PFA_NUMBER2)
                 	; excatly one character is left
00f92e f0a4      	.dw XT_CFETCH
00f92f f040      	.dw XT_DOLITERAL
00f930 002e      	.dw 46 ; .
00f931 fd9d      	.dw XT_EQUAL
00f932 f039      	.dw XT_DOCONDBRANCH
00f933 f93d      	DEST(PFA_NUMBER6)
                 	; its a double cell number
                         ; incorporate sign into number
00f934 f102      	.dw XT_R_FROM
00f935 f039              .dw XT_DOCONDBRANCH
00f936 f938      	DEST(PFA_NUMBER3)
00f937 fcff              .dw XT_DNEGATE
                 PFA_NUMBER3:
00f938 f040      	.dw XT_DOLITERAL
00f939 0002      	.dw 2
00f93a f02f      	.dw XT_DOBRANCH
00f93b f94c      	DEST(PFA_NUMBER5)
                 PFA_NUMBER2:
00f93c f0e5      	.dw XT_DROP
                 PFA_NUMBER6:
00f93d f588      	.dw XT_2DROP
00f93e f102      	.dw XT_R_FROM
00f93f f0e5      	.dw XT_DROP
00f940 f102              .dw XT_R_FROM
00f941 f56b              .dw XT_BASE
00f942 f08d              .dw XT_STORE
00f943 f160      	.dw XT_ZERO
00f944 f020      	.dw XT_EXIT
                 PFA_NUMBER1:
00f945 f588          .dw XT_2DROP ; remove the address
                     ; incorporate sign into number
00f946 f102          .dw XT_R_FROM
00f947 f039          .dw XT_DOCONDBRANCH
00f948 f94a          DEST(PFA_NUMBER4)
00f949 f660          .dw XT_NEGATE
                 PFA_NUMBER4:
00f94a f040          .dw XT_DOLITERAL
00f94b 0001          .dw 1
                 PFA_NUMBER5:
00f94c f102          .dw XT_R_FROM
00f94d f56b          .dw XT_BASE
00f94e f08d          .dw XT_STORE
00f94f f157          .dw XT_TRUE
00f950 f020          .dw XT_EXIT
                 .include "words/q-sign.asm"
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 XT_QSIGN:
00f951 f000          .dw DO_COLON 
                 PFA_QSIGN:        ; ( c -- ) 
                 .endif
00f952 f0db          .dw XT_OVER    ; ( -- addr len addr )
00f953 f0a4          .dw XT_CFETCH
00f954 f040          .dw XT_DOLITERAL
00f955 002d          .dw '-'
00f956 fd9d          .dw XT_EQUAL  ; ( -- addr len flag )
00f957 f0bd          .dw XT_DUP
00f958 f10b          .dw XT_TO_R
00f959 f039          .dw XT_DOCONDBRANCH
00f95a f95e          DEST(PFA_NUMBERSIGN_DONE)
00f95b f040          .dw XT_DOLITERAL      ; skip sign character
00f95c 0001          .dw 1
00f95d f9c2          .dw XT_SLASHSTRING
                 PFA_NUMBERSIGN_DONE:
00f95e f102          .dw XT_R_FROM
00f95f f020          .dw XT_EXIT
                 .include "words/set-base.asm"
                 
                 ; Numeric IO
                 ; skip a numeric prefix character
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 XT_BASES:
00f960 f05b          .dw PFA_DOCONSTANT
                 .endif
00f961 000a
00f962 0010
00f963 0002
00f964 000a          .dw 10,16,2,10 ; last one could a 8 instead.
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 XT_SET_BASE:
00f965 f000          .dw DO_COLON 
                 PFA_SET_BASE:        ; ( adr1 len1 -- adr2 len2 ) 
                 .endif
00f966 f0db          .dw XT_OVER
00f967 f0a4          .dw XT_CFETCH
00f968 f040          .dw XT_DOLITERAL
00f969 0023          .dw 35
00f96a f19f          .dw XT_MINUS
00f96b f0bd          .dw XT_DUP
00f96c f160          .dw XT_ZERO
00f96d f040          .dw XT_DOLITERAL
00f96e 0004          .dw 4
00f96f f69b          .dw XT_WITHIN
00f970 f039          .dw XT_DOCONDBRANCH
00f971 f97c          DEST(SET_BASE1)
                 	.if cpu_msp430==1
                 	.endif
00f972 f960      	.dw XT_BASES
00f973 f1a9      	.dw XT_PLUS
00f974 f3d2      	.dw XT_FETCHI
00f975 f56b      	.dw XT_BASE
00f976 f08d      	.dw XT_STORE
00f977 f040      	.dw XT_DOLITERAL
00f978 0001      	.dw 1
00f979 f9c2      	.dw XT_SLASHSTRING
00f97a f02f      	.dw XT_DOBRANCH
00f97b f97d      	DEST(SET_BASE2)
                 SET_BASE1:
00f97c f0e5      	.dw XT_DROP
                 SET_BASE2:
00f97d f020          .dw XT_EXIT 
                 
                 ; create bases 10 , 16 , 2 , 8 ,
                 ; : set-base 35 - dup 0 4 within if 
                 ;    bases + @i base ! 1 /string 
                 ;   else 
                 ;    drop
                 ;   then ;
                 .include "words/to-number.asm"
                 
                 ; Numeric IO
                 ; convert a string to a number  c-addr2/u2 is the unconverted string
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_TO_NUMBER:
00f97e ff07          .dw $ff07
00f97f 6e3e
00f980 6d75
00f981 6562
00f982 0072          .db ">number",0
00f983 f905          .dw VE_HEAD
                     .set VE_HEAD = VE_TO_NUMBER
                 XT_TO_NUMBER:
00f984 f000          .dw DO_COLON
                 
                 .endif
                 
00f985 f0bd
00f986 f039      TONUM1: .DW XT_DUP,XT_DOCONDBRANCH
00f987 f99d              DEST(TONUM3)
00f988 f0db
00f989 f0a4
00f98a f777              .DW XT_OVER,XT_CFETCH,XT_DIGITQ
00f98b f126
00f98c f039              .DW XT_ZEROEQUAL,XT_DOCONDBRANCH
00f98d f990              DEST(TONUM2)
00f98e f0e5
00f98f f020              .DW XT_DROP,XT_EXIT
00f990 f10b
00f991 fd24
00f992 f56b
00f993 f085
00f994 016d      TONUM2: .DW XT_TO_R,XT_2SWAP,XT_BASE,XT_FETCH,XT_UDSTAR
00f995 f102
00f996 0165
00f997 fd24              .DW XT_R_FROM,XT_MPLUS,XT_2SWAP
00f998 f040
00f999 0001
00f99a f9c2
00f99b f02f              .DW XT_DOLITERAL,1,XT_SLASHSTRING,XT_DOBRANCH
00f99c f985              DEST(TONUM1)
00f99d f020      TONUM3: .DW XT_EXIT
                 
                 ;C >NUMBER  ud adr u -- ud' adr' u'
                 ;C                      convert string to number
                 ;   BEGIN
                 ;   DUP WHILE
                 ;       OVER C@ DIGIT?
                 ;       0= IF DROP EXIT THEN
                 ;       >R 2SWAP BASE @ UD*
                 ;       R> M+ 2SWAP
                 ;       1 /STRING
                 ;   REPEAT ;
                 .include "words/parse.asm"
                 
                 ; String
                 ; in input buffer parse ccc delimited string by the delimiter char.
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_PARSE:
00f99e ff05          .dw $ff05
00f99f 6170
00f9a0 7372
00f9a1 0065          .db "parse",0
00f9a2 f97e          .dw VE_HEAD
                     .set VE_HEAD = VE_PARSE
                 XT_PARSE:
00f9a3 f000          .dw DO_COLON
                 PFA_PARSE:
                 .endif
00f9a4 f10b          .dw XT_TO_R     ; ( -- )
00f9a5 f9b8          .dw XT_SOURCE   ; ( -- addr len)
00f9a6 f598          .dw XT_TO_IN     ; ( -- addr len >in)
00f9a7 f085          .dw XT_FETCH
00f9a8 f9c2          .dw XT_SLASHSTRING ; ( -- addr' len' )
                 
00f9a9 f102          .dw XT_R_FROM      ; ( -- addr' len' c)
00f9aa f88e          .dw XT_CSCAN       ; ( -- addr' len'')
00f9ab f0bd          .dw XT_DUP         ; ( -- addr' len'' len'')
00f9ac f23b          .dw XT_1PLUS
00f9ad f598          .dw XT_TO_IN        ; ( -- addr' len'' len'' >in)
00f9ae f265          .dw XT_PLUSSTORE   ; ( -- addr' len')
00f9af f040          .dw XT_DOLITERAL
00f9b0 0001          .dw 1
00f9b1 f9c2          .dw XT_SLASHSTRING
00f9b2 f020          .dw XT_EXIT
                 .include "words/source.asm"
                 
                 ; System
                 ; address and current length of the input buffer
                 VE_SOURCE:
00f9b3 ff06          .dw $FF06
00f9b4 6f73
00f9b5 7275
00f9b6 6563          .db "source"
00f9b7 f99e          .dw VE_HEAD
                     .set VE_HEAD = VE_SOURCE
                 XT_SOURCE:
00f9b8 fc20          .dw PFA_DODEFER1
                 PFA_SOURCE:
00f9b9 0016          .dw USER_SOURCE
00f9ba fbe9          .dw XT_UDEFERFETCH
00f9bb fbf5          .dw XT_UDEFERSTORE
                 
                 
                 .include "words/slash-string.asm"
                 
                 ; String
                 ; adjust string from addr1 to addr1+n, reduce length from u1 to u2 by n
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SLASHSTRING:
00f9bc ff07          .dw $ff07
00f9bd 732f
00f9be 7274
00f9bf 6e69
00f9c0 0067          .db "/string",0
00f9c1 f9b3          .dw VE_HEAD
                     .set VE_HEAD = VE_SLASHSTRING
                 XT_SLASHSTRING:
00f9c2 f000          .dw DO_COLON
                 PFA_SLASHSTRING:
                 .endif
00f9c3 f0ed          .dw XT_ROT
00f9c4 f0db          .dw XT_OVER
00f9c5 f1a9          .dw XT_PLUS
00f9c6 f0ed          .dw XT_ROT
00f9c7 f0ed          .dw XT_ROT
00f9c8 f19f          .dw XT_MINUS
00f9c9 f020          .dw XT_EXIT
                 
                 .include "words/parse-name.asm"
                 
                 ; String
                 ; In the SOURCE buffer parse whitespace delimited string. Returns string address within SOURCE.
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 VE_PARSENAME:
00f9ca ff0a          .dw $FF0A 
00f9cb 6170
00f9cc 7372
00f9cd 2d65
00f9ce 616e
00f9cf 656d          .db "parse-name"
00f9d0 f9bc          .dw VE_HEAD
                     .set VE_HEAD = VE_PARSENAME
                 XT_PARSENAME:
00f9d1 f000          .dw DO_COLON 
                 PFA_PARSENAME:
                 .endif
00f9d2 f611          .dw XT_BL
00f9d3 f9d5          .dw XT_SKIPSCANCHAR
00f9d4 f020          .dw XT_EXIT 
                 
                 ; ( c -- addr2 len2 ) 
                 ; String
                 ; skips char and scan what's left in source for char
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 ;VE_SKIPSCANCHAR:
                 ;    .dw $FF0A 
                 ;    .db "skipscanchar"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_SKIPSCANCHAR
                 XT_SKIPSCANCHAR:
00f9d5 f000          .dw DO_COLON
                 PFA_SKIPSCANCHAR:
                 .endif
00f9d6 f10b          .dw XT_TO_R
00f9d7 f9b8          .dw XT_SOURCE 
00f9d8 f598          .dw XT_TO_IN 
00f9d9 f085          .dw XT_FETCH 
00f9da f9c2          .dw XT_SLASHSTRING 
                 
00f9db f114          .dw XT_R_FETCH
00f9dc f876          .dw XT_CSKIP
00f9dd f102          .dw XT_R_FROM
00f9de f88e          .dw XT_CSCAN
                 
                     ; adjust >IN
00f9df f57f          .dw XT_2DUP
00f9e0 f1a9          .dw XT_PLUS
00f9e1 f9b8          .dw XT_SOURCE 
00f9e2 f0e5          .dw XT_DROP
00f9e3 f19f          .dw XT_MINUS
00f9e4 f598          .dw XT_TO_IN
00f9e5 f08d          .dw XT_STORE
00f9e6 f020          .dw XT_EXIT
                 .include "words/find-name.asm"
                 
                 ; Tools
                 ; search wordlists for an entry with the name from c-addr/len
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_FINDNAME:
00f9e7 ff09          .dw $ff09
00f9e8 6966
00f9e9 646e
00f9ea 6e2d
00f9eb 6d61
00f9ec 0065          .db "find-name",0
00f9ed f9ca          .dw VE_HEAD
                     .set VE_HEAD = VE_FINDNAME
                 XT_FINDNAME:
00f9ee f000          .dw DO_COLON
                 PFA_FINDNAME:
                 .endif
00f9ef f040          .dw XT_DOLITERAL
00f9f0 f9fa          .dw XT_FINDNAMEA
00f9f1 f040          .dw XT_DOLITERAL
00f9f2 0086          .dw CFG_ORDERLISTLEN
00f9f3 044b          .dw XT_MAPSTACK
00f9f4 f126          .dw XT_ZEROEQUAL
00f9f5 f039          .dw XT_DOCONDBRANCH
00f9f6 f9f9          DEST(PFA_FINDNAME1)
00f9f7 f588            .dw XT_2DROP
00f9f8 f160            .dw XT_ZERO
                 PFA_FINDNAME1:
00f9f9 f020          .dw XT_EXIT
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 XT_FINDNAMEA:
00f9fa f000          .dw DO_COLON
                 PFA_FINDNAMEA:
                 .endif
00f9fb f10b          .dw XT_TO_R
00f9fc f57f          .dw XT_2DUP
00f9fd f102          .dw XT_R_FROM
00f9fe fc32          .dw XT_SEARCH_WORDLIST
00f9ff f0bd          .dw XT_DUP
00fa00 f039          .dw XT_DOCONDBRANCH
00fa01 fa07          DEST(PFA_FINDNAMEA1)
00fa02 f10b            .dw XT_TO_R
00fa03 f0fc            .dw XT_NIP
00fa04 f0fc            .dw XT_NIP
00fa05 f102            .dw XT_R_FROM
00fa06 f157            .dw XT_TRUE
                 PFA_FINDNAMEA1:
00fa07 f020          .dw XT_EXIT
                 
                 .include "words/prompt-ok.asm"
                 
                 ; System
                 ; send the READY prompt to the command line
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 ;VE_PROMPTOK:
                 ;    .dw $ff02
                 ;    .db "ok"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_PROMPTOK
                 XT_PROMPTOK:
00fa08 f000          .dw DO_COLON
                 PFA_PROMPTOK:
00fa09 f791          .dw XT_DOSLITERAL
00fa0a 0003          .dw 3
00fa0b 6f20
00fa0c 006b          .db " ok",0
                 .endif
00fa0d f7c4          .dw XT_ITYPE
00fa0e f020          .dw XT_EXIT
                 .include "words/prompt-ready.asm"
                 
                 ; System
                 ; process the error prompt
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 ;VE_PROMPTRDY:
                 ;    .dw $ff04
                 ;    .db "p_er"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_PROMPTRDY
                 XT_PROMPTREADY:
00fa0f f000          .dw DO_COLON
                 PFA_PROMPTREADY:
00fa10 f791          .dw XT_DOSLITERAL
00fa11 0002          .dw 2
00fa12 203e          .db "> "
                 .endif
00fa13 f7f9          .dw XT_CR
00fa14 f7c4          .dw XT_ITYPE
00fa15 f020          .dw XT_EXIT
                 .include "words/prompt-error.asm"
                 
                 ; System
                 ; process the error prompt
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 ;VE_PROMPTERROR:
                 ;    .dw $ff04
                 ;    .db "p_er"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_PROMPTERROR
                 XT_PROMPTERROR:
00fa16 f000          .dw DO_COLON
                 PFA_PROMPTERROR:
00fa17 f791      	.dw XT_DOSLITERAL
00fa18 0004          .dw 4
00fa19 3f20
00fa1a 203f          .db " ?? "
                 .endif
00fa1b f7c4          .dw XT_ITYPE
00fa1c f56b          .dw XT_BASE
00fa1d f085          .dw XT_FETCH
00fa1e f10b          .dw XT_TO_R
00fa1f f5fe          .dw XT_DECIMAL
00fa20 f746          .dw XT_DOT
00fa21 f598          .dw XT_TO_IN
00fa22 f085          .dw XT_FETCH
00fa23 f746          .dw XT_DOT
00fa24 f102          .dw XT_R_FROM
00fa25 f56b          .dw XT_BASE
00fa26 f08d          .dw XT_STORE
00fa27 f020          .dw XT_EXIT
                 
                 .include "words/quit.asm"
                 
                 ; System
                 ; main loop of amforth. accept - interpret in an endless loop
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_QUIT:
00fa28 ff04          .dw $ff04
00fa29 7571
00fa2a 7469          .db "quit"
00fa2b f9e7          .dw VE_HEAD
                     .set VE_HEAD = VE_QUIT
                 XT_QUIT:
00fa2c f000          .dw DO_COLON
                 PFA_QUIT:
                 .endif
                 PFA_QUIT1:
00fa2d 02f8
00fa2e 02ff
00fa2f f08d          .dw XT_LP0,XT_LP,XT_STORE
00fa30 fa8e          .dw XT_SP0
00fa31 f296          .dw XT_SP_STORE
00fa32 fa9b          .dw XT_RP0
00fa33 f280          .dw XT_RP_STORE
00fa34 039a          .dw XT_LBRACKET
                 
                 PFA_QUIT2:
00fa35 f565          .dw XT_STATE
00fa36 f085          .dw XT_FETCH
00fa37 f126          .dw XT_ZEROEQUAL
00fa38 f039          .dw XT_DOCONDBRANCH
00fa39 fa3b          DEST(PFA_QUIT4)
00fa3a fa0f          .dw XT_PROMPTREADY
                 PFA_QUIT4:
00fa3b f8f8          .dw XT_REFILL
00fa3c f039          .dw XT_DOCONDBRANCH
00fa3d fa35          DEST(PFA_QUIT2)
00fa3e f040          .dw XT_DOLITERAL
00fa3f fab4          .dw XT_INTERPRET
00fa40 f847          .dw XT_CATCH
00fa41 f0c5          .dw XT_QDUP
00fa42 f039          .dw XT_DOCONDBRANCH
00fa43 fa4d          DEST(PFA_QUIT3)
00fa44 f0bd      	.dw XT_DUP
00fa45 f040      	.dw XT_DOLITERAL
00fa46 fffe      	.dw -2
00fa47 f17a      	.dw XT_LESS
00fa48 f039      	.dw XT_DOCONDBRANCH
00fa49 fa4b      	DEST(PFA_QUIT5)
00fa4a fa16      	.dw XT_PROMPTERROR
                 PFA_QUIT5:
00fa4b f02f      	.dw XT_DOBRANCH
00fa4c fa2d      	DEST(PFA_QUIT1)
                 PFA_QUIT3:
00fa4d fa08          .dw XT_PROMPTOK
00fa4e f02f          .dw XT_DOBRANCH
00fa4f fa35          DEST(PFA_QUIT2)
00fa50 f020          .dw XT_EXIT ; never reached
                 
                 .include "words/pause.asm"
                 
                 ; Multitasking
                 ; Fetch pause vector and execute it. may make a context/task switch
                 VE_PAUSE:
00fa51 ff05          .dw $ff05
00fa52 6170
00fa53 7375
00fa54 0065          .db "pause",0
00fa55 fa28          .dw VE_HEAD
                     .set VE_HEAD = VE_PAUSE
                 XT_PAUSE:
00fa56 fc20          .dw PFA_DODEFER1
                 PFA_PAUSE:
00fa57 0225          .dw ram_pause
00fa58 fbd5          .dw XT_RDEFERFETCH
00fa59 fbdf          .dw XT_RDEFERSTORE
                 
                 .dseg
000225           ram_pause: .byte 2
                 .cseg
                 .include "words/cold.asm"
                 
                 ; System
                 ; start up amforth.
                 VE_COLD:
00fa5a ff04          .dw $ff04
00fa5b 6f63
00fa5c 646c          .db "cold"
00fa5d fa51          .dw VE_HEAD
                     .set VE_HEAD = VE_COLD
                 XT_COLD:
00fa5e fa5f          .dw PFA_COLD
                 PFA_COLD:
00fa5f b6a4          in_ mcu_boot, MCUSR
00fa60 2422          clr zerol
00fa61 2433          clr zeroh
00fa62 be24          out_ MCUSR, zerol
                     ; clear RAM
00fa63 e0e0          ldi zl, low(ramstart)
00fa64 e0f2          ldi zh, high(ramstart)
                 clearloop:
00fa65 9221          st Z+, zerol
00fa66 30e0          cpi zl, low(sram_size+ramstart)
00fa67 f7e9          brne clearloop
00fa68 32f2          cpi zh, high(sram_size+ramstart)
00fa69 f7d9          brne clearloop
                     ; init first user data area
                     ; allocate space for User Area
                 .dseg
000227           ram_user1: .byte SYSUSERSIZE + APPUSERSIZE
                 .cseg
00fa6a e2e7          ldi zl, low(ram_user1)
00fa6b e0f2          ldi zh, high(ram_user1)
00fa6c 012f          movw upl, zl
                     ; init return stack pointer
00fa6d ef0f          ldi temp0,low(rstackstart)
00fa6e bf0d          out_ SPL,temp0
00fa6f 8304          std Z+4, temp0
00fa70 e211          ldi temp1,high(rstackstart)
00fa71 bf1e          out_ SPH,temp1
00fa72 8315          std Z+5, temp1
                 
                     ; init parameter stack pointer
00fa73 eacf          ldi yl,low(stackstart)
00fa74 83c6          std Z+6, yl
00fa75 e2d1          ldi yh,high(stackstart)
00fa76 83d7          std Z+7, yh
                 
                     ; load Forth IP with starting word
00fa77 e8a0          ldi XL, low(PFA_WARM)
00fa78 efba          ldi XH, high(PFA_WARM)
                     ; its a far jump...
00fa79 940c f004     jmp_ DO_NEXT
                 .include "words/warm.asm"
                 
                 ; System
                 ; initialize amforth further. executes turnkey operation and go to quit
                 VE_WARM:
00fa7b ff04          .dw $ff04
00fa7c 6177
00fa7d 6d72          .db "warm"
00fa7e fa5a          .dw VE_HEAD
                     .set VE_HEAD = VE_WARM
                 XT_WARM:
00fa7f f000          .dw DO_COLON
                 PFA_WARM:
00fa80 fd6a          .dw XT_INITUSER
00fa81 f040          .dw XT_DOLITERAL
00fa82 fb8b          .dw XT_NOOP
00fa83 f040          .dw XT_DOLITERAL
00fa84 fa56          .dw XT_PAUSE
00fa85 fc00          .dw XT_DEFERSTORE
00fa86 039a          .dw XT_LBRACKET
00fa87 f619          .dw XT_TURNKEY
00fa88 fa2c          .dw XT_QUIT
00fa89 f020          .dw XT_EXIT
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/sp0.asm"
                 
                 ; Stack
                 ; start address of the data stack
                 VE_SP0:
00fa8a ff03          .dw $ff03
00fa8b 7073
00fa8c 0030          .db "sp0",0
00fa8d fa7b          .dw VE_HEAD
                     .set VE_HEAD = VE_SP0
                 XT_SP0:
00fa8e f07b          .dw PFA_DOVALUE1
                 PFA_SP0:
00fa8f 0006          .dw USER_SP0
00fa90 fbe9          .dw XT_UDEFERFETCH
00fa91 fbf5          .dw XT_UDEFERSTORE
                 
                 ; ( -- addr) 
                 ; Stack
                 ; address of user variable to store top-of-stack for inactive tasks
                 VE_SP:
00fa92 ff02          .dw $ff02
00fa93 7073          .db "sp"
00fa94 fa8a          .dw VE_HEAD
                     .set VE_HEAD = VE_SP
                 XT_SP:
00fa95 f061          .dw PFA_DOUSER
                 PFA_SP:
00fa96 0008          .dw USER_SP
                 .include "words/rp0.asm"
                 
                 ; Stack
                 ; start address of return stack
                 VE_RP0:
00fa97 ff03          .dw $ff03
00fa98 7072
00fa99 0030          .db "rp0",0
00fa9a fa92          .dw VE_HEAD
                     .set VE_HEAD = VE_RP0
                 XT_RP0:
00fa9b f000          .dw DO_COLON
                 PFA_RP0:
00fa9c fa9f          .dw XT_DORP0
00fa9d f085          .dw XT_FETCH
00fa9e f020          .dw XT_EXIT
                 
                 ; ( -- addr) 
                 ; Stack
                 ; user variable of the address of the initial return stack
                 ;VE_DORP0:
                 ;    .dw $ff05
                 ;    .db "(rp0)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DORP0
                 XT_DORP0:
00fa9f f061          .dw PFA_DOUSER
                 PFA_DORP0:
00faa0 0004          .dw USER_RP
                 .include "words/depth.asm"
                 
                 ; Stack
                 ; number of single-cell values contained in the data stack before n was placed on the stack.
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DEPTH:
00faa1 ff05          .dw $ff05
00faa2 6564
00faa3 7470
00faa4 0068          .db "depth",0
00faa5 fa97          .dw VE_HEAD
                     .set VE_HEAD = VE_DEPTH
                 XT_DEPTH:
00faa6 f000          .dw DO_COLON
                 PFA_DEPTH:
                 .endif
00faa7 fa8e          .dw XT_SP0
00faa8 f28d          .dw XT_SP_FETCH
00faa9 f19f          .dw XT_MINUS
00faaa f210          .dw XT_2SLASH
00faab f241          .dw XT_1MINUS
00faac f020          .dw XT_EXIT
                 .include "words/interpret.asm"
                 
                 ; System
                 ; Interpret SOURCE word by word.
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_INTERPRET:
00faad ff09          .dw $ff09
00faae 6e69
00faaf 6574
00fab0 7072
00fab1 6572
00fab2 0074          .db "interpret",0
00fab3 faa1          .dw VE_HEAD
                     .set VE_HEAD = VE_INTERPRET
                 XT_INTERPRET:
00fab4 f000          .dw DO_COLON
                 .endif
                 PFA_INTERPRET:
00fab5 f9d1          .dw XT_PARSENAME ; ( -- addr len )
00fab6 f0bd          .dw XT_DUP   ; ( -- addr len flag)
00fab7 f039          .dw XT_DOCONDBRANCH
00fab8 fac4          DEST(PFA_INTERPRET2)
00fab9 facf            .dw XT_DORECOGNIZER
00faba f565            .dw XT_STATE
00fabb f085            .dw XT_FETCH
00fabc f039            .dw XT_DOCONDBRANCH
00fabd fabf          DEST(PFA_INTERPRET1)
00fabe fbb8            .dw XT_ICELLPLUS   ; we need the compile action
                 PFA_INTERPRET1:
00fabf f3d2            .dw XT_FETCHI
00fac0 f02a            .dw XT_EXECUTE
00fac1 fb63            .dw XT_QSTACK
00fac2 f02f          .dw XT_DOBRANCH
00fac3 fab5          DEST(PFA_INTERPRET)
                 PFA_INTERPRET2:
00fac4 f588          .dw XT_2DROP
00fac5 f020          .dw XT_EXIT
                 .include "words/do-recognizer.asm"
                 
                 ; System
                 ; walk the recognizer stack
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DORECOGNIZER:
00fac6 ff0d          .dw $ff0d
00fac7 6f64
00fac8 722d
00fac9 6365
00faca 676f
00facb 696e
00facc 657a
00facd 0072          .db "do-recognizer",0
00face faad          .dw VE_HEAD
                     .set VE_HEAD = VE_DORECOGNIZER
                 XT_DORECOGNIZER:
00facf f000          .dw DO_COLON
                 PFA_DORECOGNIZER:
                 .endif
00fad0 f040          .dw XT_DOLITERAL
00fad1 fadb          .dw XT_DORECOGNIZER_A
00fad2 f040          .dw XT_DOLITERAL
00fad3 0098          .dw CFG_RECOGNIZERLISTLEN
00fad4 044b          .dw XT_MAPSTACK
00fad5 f126          .dw XT_ZEROEQUAL
00fad6 f039          .dw XT_DOCONDBRANCH
00fad7 fada          DEST(PFA_DORECOGNIZER1)
00fad8 f588            .dw XT_2DROP
00fad9 fb56            .dw XT_R_FAIL
                 PFA_DORECOGNIZER1:
00fada f020          .dw XT_EXIT
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 ; ( addr len XT -- addr len [ r:table -1 | 0 ] )
                 XT_DORECOGNIZER_A:
00fadb f000         .dw DO_COLON
                 PFA_DORECOGNIZER_A:
                 .endif
00fadc f0ed         .dw XT_ROT  ; -- len xt addr
00fadd f0ed         .dw XT_ROT  ; -- xt addr len
00fade f57f         .dw XT_2DUP 
00fadf f31e         .dw XT_2TO_R
00fae0 f0ed         .dw XT_ROT  ; -- addr len xt
00fae1 f02a         .dw XT_EXECUTE ; -- i*x r:foo | r:fail
00fae2 f32d         .dw XT_2R_FROM
00fae3 f0ed         .dw XT_ROT
00fae4 f0bd         .dw XT_DUP
00fae5 fb56         .dw XT_R_FAIL
00fae6 fd9d         .dw XT_EQUAL
00fae7 f039         .dw XT_DOCONDBRANCH
00fae8 faec         DEST(PFA_DORECOGNIZER_A1)
00fae9 f0e5           .dw XT_DROP
00faea f160           .dw XT_ZERO
00faeb f020           .dw XT_EXIT
                 PFA_DORECOGNIZER_A1:
00faec f0fc         .dw XT_NIP 
00faed f0fc         .dw XT_NIP
00faee f157         .dw XT_TRUE
00faef f020         .dw XT_EXIT
                 
                 ; : do-recognizer ( addr len -- i*x r:table|r:fail )
                 ;    \ ( addr len -- addr len 0 | i*x r:table -1 )
                 ;    [: rot rot 2dup 2>r rot execute 2r> rot 
                 ;          dup r:fail = ( -- addr len r:table f )
                 ;          if drop 0 else nip nip -1 then
                 ;    ;] 
                 ;    EE_RECOGNIZERLISTLEN map-stack ( -- i*x addr len r:table f )
                 ;    0= if \ a recognizer did the job, remove addr/len
                 ;     2drop r:fail 
                 ;    then
                 ;
                 .include "words/r-intnumber.asm"
                 
                 ; Interpreter
                 ; Method table for single cell integers
                 
                 
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_R_NUM:
00faf0 ff05          .dw $ff05
00faf1 3a72
00faf2 756e
00faf3 006d          .db "r:num",0
00faf4 fac6          .dw VE_HEAD
                     .set VE_HEAD = VE_R_NUM
                 XT_R_NUM:
00faf5 f05b          .dw PFA_DOCONSTANT
                 PFA_R_NUM:
                 .endif
00faf6 fb8b          .dw XT_NOOP    ; interpret
00faf7 0218          .dw XT_LITERAL ; compile
00faf8 fb02          .dw XT_FAILNUM ; postpone
                 
                 ; ( -- addr )
                 ; Interpreter
                 ; Method table for double cell integers
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_R_DNUM:
00faf9 ff06          .dw $ff06
00fafa 3a72
00fafb 6e64
00fafc 6d75          .db "r:dnum"
00fafd faf0          .dw VE_HEAD
                     .set VE_HEAD = VE_R_DNUM
                 XT_R_DNUM:
00fafe f05b          .dw PFA_DOCONSTANT
                 PFA_R_DNUM:
                 .endif
00faff fb8b          .dw XT_NOOP     ; interpret
00fb00 fd91          .dw XT_2LITERAL ; compile
00fb01 fb08          .dw XT_FAILDNUM ; postpone
                 
                 ; ( -- addr )
                 ; Interpreter
                 ; Method to print a number and throw exception "invalid postpone"
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 ;VE_FAILNUM:
                 ;    .dw $ff06
                 ;    .db "fail:i"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_FAILNUM
                 XT_FAILNUM:
00fb02 f000          .dw DO_COLON
                 PFA_FAILNUM:
                 .endif
00fb03 f746          .dw XT_DOT
00fb04 f040          .dw XT_DOLITERAL
00fb05 ffd0          .dw -48
00fb06 f85d          .dw XT_THROW
00fb07 f020          .dw XT_EXIT
                 
                 ; ( -- addr )
                 ; Interpreter
                 ; Method to print a double cell number and throw exception "invalid postpone"
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 VE_FAILDNUM:
                 ;    .dw $ff06
                 ;    .db "fail:d"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_FAILDNUM
                 XT_FAILDNUM:
00fb08 f000          .dw DO_COLON
                 PFA_FAILDNUM:
                 .endif
00fb09 f73e          .dw XT_DDOT
00fb0a f040          .dw XT_DOLITERAL
00fb0b ffd0          .dw -48
00fb0c f85d          .dw XT_THROW
00fb0d f020          .dw XT_EXIT
                 
                 ; ( addr len -- f )
                 ; Interpreter
                 ; recognizer for integer numbers
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 VE_REC_NUM:
00fb0e ff07          .dw $ff07
00fb0f 6572
00fb10 3a63
00fb11 756e
00fb12 006d          .db "rec:num",0
00fb13 faf9          .dw VE_HEAD
                     .set VE_HEAD = VE_REC_NUM
                 XT_REC_NUM:
00fb14 f000          .dw DO_COLON
                 PFA_REC_NUM:
                 .endif
                     ; try converting to a number
00fb15 f90a          .dw XT_NUMBER
00fb16 f039          .dw XT_DOCONDBRANCH
00fb17 fb21          DEST(PFA_REC_NONUMBER)
00fb18 f040          .dw XT_DOLITERAL
00fb19 0001          .dw 1
00fb1a fd9d          .dw XT_EQUAL
00fb1b f039          .dw XT_DOCONDBRANCH
00fb1c fb1f          DEST(PFA_REC_INTNUM2)
00fb1d faf5            .dw XT_R_NUM
00fb1e f020            .dw XT_EXIT
                 PFA_REC_INTNUM2:
00fb1f fafe            .dw XT_R_DNUM
00fb20 f020            .dw XT_EXIT
                 PFA_REC_NONUMBER:
00fb21 fb56          .dw XT_R_FAIL
00fb22 f020          .dw XT_EXIT
                 .include "words/r-word.asm"
                 
                 ; Interpreter
                 ; search for a word
                 .if cpu_msp430==1
                 .endif
                 .if cpu_avr8==1
                 VE_REC_WORD:
00fb23 ff08          .dw $ff08
00fb24 6572
00fb25 3a63
00fb26 6f77
00fb27 6472          .db "rec:word"
00fb28 fb0e          .dw VE_HEAD
                     .set VE_HEAD = VE_REC_WORD
                 XT_REC_WORD:
00fb29 f000          .dw DO_COLON
                 PFA_REC_WORD:
                 .endif
00fb2a f9ee          .DW XT_FINDNAME
00fb2b f0bd          .dw XT_DUP
00fb2c f126          .dw XT_ZEROEQUAL
00fb2d f039          .dw XT_DOCONDBRANCH
00fb2e fb32          DEST(PFA_REC_WORD_FOUND)
00fb2f f0e5              .dw XT_DROP
00fb30 fb56      	.dw XT_R_FAIL
00fb31 f020      	.dw XT_EXIT
                 PFA_REC_WORD_FOUND:
00fb32 fb39          .dw XT_R_WORD
                 
00fb33 f020          .dw XT_EXIT
                 
                 ; ( -- addr )
                 ; Interpreter
                 ; actions to handle execution tokens and their flags
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_R_WORD:
00fb34 ff06          .dw $ff06
00fb35 3a72
00fb36 6f77
00fb37 6472          .db "r:word"
00fb38 fb23          .dw VE_HEAD
                     .set VE_HEAD = VE_R_WORD
                 XT_R_WORD:
00fb39 f05b          .dw PFA_DOCONSTANT
                 PFA_R_WORD:
                 .endif
00fb3a fb3d          .dw XT_R_WORD_INTERPRET
00fb3b fb41          .dw XT_R_WORD_COMPILE
00fb3c fb49          .dw XT_R_WORD_POSTPONE
                 
                 ; ( XT flags -- )
                 ; Interpreter
                 ; interpret method for WORD recognizer
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 XT_R_WORD_INTERPRET:
00fb3d f000          .dw DO_COLON
                 PFA_R_WORD_INTERPRET:
                 .endif
00fb3e f0e5          .dw XT_DROP ; the flags are in the way
00fb3f f02a          .dw XT_EXECUTE
00fb40 f020          .dw XT_EXIT
                 
                 ; ( XT flags -- )
                 ; Interpreter
                 ; Compile method for WORD recognizer
                 .if cpu_msp430==1
                 .endif
                 .if cpu_avr8==1
                 XT_R_WORD_COMPILE:
00fb41 f000          .dw DO_COLON
                 PFA_R_WORD_COMPILE:
                 .endif
00fb42 f12d          .dw XT_ZEROLESS
00fb43 f039          .dw XT_DOCONDBRANCH
00fb44 fb47          DEST(PFA_R_WORD_COMPILE1)
00fb45 0202      	.dw XT_COMMA
00fb46 f020              .dw XT_EXIT
                 PFA_R_WORD_COMPILE1:
00fb47 f02a              .dw XT_EXECUTE
00fb48 f020          .dw XT_EXIT
                 
                 ; ( XT flags -- )
                 ; Interpreter
                 ; Postpone method for WORD recognizer
                 .if cpu_msp430==1
                 .endif
                 .if cpu_avr8==1
                 XT_R_WORD_POSTPONE:
00fb49 f000          .dw DO_COLON
                 PFA_R_WORD_POSTPONE:
                 .endif
00fb4a f12d          .dw XT_ZEROLESS
00fb4b f039          .dw XT_DOCONDBRANCH
00fb4c fb4f          DEST(PFA_R_WORD_POSTPONE1)
00fb4d 01f7            .dw XT_COMPILE
00fb4e 01f7            .dw XT_COMPILE
                 PFA_R_WORD_POSTPONE1:
00fb4f 0202          .dw XT_COMMA
00fb50 f020          .dw XT_EXIT
                 .include "words/r-fail.asm"
                 
                 ; Interpreter
                 ; there is no parser for this recognizer, this is the default and failsafe part
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_R_FAIL:
00fb51 ff06          .dw $ff06
00fb52 3a72
00fb53 6166
00fb54 6c69          .db "r:fail"
00fb55 fb34          .dw VE_HEAD
                     .set VE_HEAD = VE_R_FAIL
                 XT_R_FAIL:
00fb56 f05b          .dw PFA_DOCONSTANT
                 PFA_R_FAIL:
                 .endif
00fb57 fb5a          .dw XT_FAIL  ; interpret
00fb58 fb5a          .dw XT_FAIL  ; compile
00fb59 fb5a          .dw XT_FAIL  ; postpone
                 
                 ; ( addr len -- )
                 ; Interpreter
                 ; default failure action: throw exception -13.
                 .if cpu_msp430==1
                 .endif
                 .if cpu_avr8==1
                 ;VE_FAIL:
                 ;    .dw $ff04
                 ;    .db "fail"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_FAIL
                 XT_FAIL:
00fb5a f000          .dw DO_COLON
                 PFA_FAIL:
                 .endif
00fb5b f040          .dw XT_DOLITERAL
00fb5c fff3          .dw -13
00fb5d f85d          .dw XT_THROW
                 
                 .include "words/q-stack.asm"
                 
                 ; Tools
                 ; check data stack depth and exit to quit if underrun
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_QSTACK:
00fb5e ff06          .dw $ff06
00fb5f 733f
00fb60 6174
00fb61 6b63          .db "?stack"
00fb62 fb51          .dw VE_HEAD
                     .set VE_HEAD = VE_QSTACK
                 XT_QSTACK:
00fb63 f000          .dw DO_COLON
                 PFA_QSTACK:
                 .endif
00fb64 faa6          .dw XT_DEPTH
00fb65 f12d          .dw XT_ZEROLESS
00fb66 f039          .dw XT_DOCONDBRANCH
00fb67 fb6b          DEST(PFA_QSTACK1)
00fb68 f040            .dw XT_DOLITERAL
00fb69 fffc            .dw -4
00fb6a f85d            .dw XT_THROW
                 PFA_QSTACK1:
00fb6b f020          .dw XT_EXIT
                 .include "words/ver.asm"
                 
                 ; Tools
                 ; print the version string
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DOT_VER:
00fb6c ff03          .dw $ff03
00fb6d 6576
../../common\words/ver.asm(12): warning: .cseg .db misalignment - padding zero byte
00fb6e 0072          .db "ver"
00fb6f fb5e          .dw VE_HEAD
                     .set VE_HEAD = VE_DOT_VER
                 XT_DOT_VER:
00fb70 f000          .dw DO_COLON
                 PFA_DOT_VER:
                 .endif
00fb71 f527          .dw XT_ENV_FORTHNAME
00fb72 f7c4          .dw XT_ITYPE
00fb73 f806          .dw XT_SPACE
00fb74 f56b          .dw XT_BASE
00fb75 f085          .dw XT_FETCH
                 
00fb76 f535          .dw XT_ENV_FORTHVERSION
00fb77 f5fe          .dw XT_DECIMAL
00fb78 fd81          .dw XT_S2D
00fb79 f6e2          .dw XT_L_SHARP
00fb7a f6ea          .dw XT_SHARP
00fb7b f040          .dw XT_DOLITERAL
00fb7c 002e          .dw '.'
00fb7d f6d3          .dw XT_HOLD
00fb7e f700          .dw XT_SHARP_S
00fb7f f70b          .dw XT_SHARP_G
00fb80 f81f          .dw XT_TYPE
00fb81 f56b          .dw XT_BASE
00fb82 f08d          .dw XT_STORE
00fb83 f806          .dw XT_SPACE
00fb84 f53d          .dw XT_ENV_CPU
00fb85 f7c4          .dw XT_ITYPE
                 
00fb86 f020          .dw XT_EXIT
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/noop.asm"
                 
                 ; Tools
                 ; do nothing
                 VE_NOOP:
00fb87 ff04          .dw $ff04
00fb88 6f6e
00fb89 706f          .db "noop"
00fb8a fb6c          .dw VE_HEAD
                     .set VE_HEAD = VE_NOOP
                 XT_NOOP:
00fb8b fb8c          .dw PFA_NOOP
                 PFA_NOOP:
00fb8c 940c f004     jmp_ DO_NEXT
                 .include "words/unused.asm"
                 
                 ; Tools
                 ; Amount of available RAM (incl. PAD)
                 VE_UNUSED:
00fb8e ff06          .dw $ff06
00fb8f 6e75
00fb90 7375
00fb91 6465          .db "unused"
00fb92 fb87          .dw VE_HEAD
                     .set VE_HEAD = VE_UNUSED
                 XT_UNUSED:
00fb93 f000          .dw DO_COLON
                 PFA_UNUSED:
00fb94 f28d          .dw XT_SP_FETCH
00fb95 f5df          .dw XT_HERE
00fb96 f19f          .dw XT_MINUS
00fb97 f020          .dw XT_EXIT
                 
                 .include "words/to.asm"
                 
                 ; Tools
                 ; store the TOS to the named value (eeprom cell)
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_TO:
00fb98 0002          .dw $0002
00fb99 6f74          .db "to"
00fb9a fb8e          .dw VE_HEAD
                     .set VE_HEAD = VE_TO
                 XT_TO:
00fb9b f000          .dw DO_COLON
                 PFA_TO:
                 .endif
00fb9c f82e          .dw XT_TICK
00fb9d fd8a          .dw XT_TO_BODY
00fb9e f565          .dw XT_STATE
00fb9f f085          .dw XT_FETCH
00fba0 f039          .dw XT_DOCONDBRANCH
00fba1 fbac          DEST(PFA_TO1)
00fba2 01f7          .dw XT_COMPILE
00fba3 fba6          .dw XT_DOTO
00fba4 0202          .dw XT_COMMA
00fba5 f020          .dw XT_EXIT
                 
                 ; ( n -- ) (R: IP -- IP+1)
                 ; Tools
                 ; runtime portion of to
                 ;VE_DOTO:
                 ;    .dw $ff04
                 ;    .db "(to)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOTO
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 XT_DOTO:
00fba6 f000          .dw DO_COLON
                 PFA_DOTO:
                 .endif
00fba7 f102          .dw XT_R_FROM
00fba8 f0bd          .dw XT_DUP
00fba9 fbb8          .dw XT_ICELLPLUS
00fbaa f10b          .dw XT_TO_R
00fbab f3d2          .dw XT_FETCHI
                 PFA_TO1:
00fbac f0bd          .dw XT_DUP
00fbad fbb8          .dw XT_ICELLPLUS
00fbae fbb8          .dw XT_ICELLPLUS
00fbaf f3d2          .dw XT_FETCHI
00fbb0 f02a          .dw XT_EXECUTE
00fbb1 f020          .dw XT_EXIT
                 .include "words/i-cellplus.asm"
                 
                 ; Compiler
                 ; skip to the next cell in flash
                 VE_ICELLPLUS:
00fbb2 ff07          .dw $FF07
00fbb3 2d69
00fbb4 6563
00fbb5 6c6c
00fbb6 002b          .db "i-cell+",0
00fbb7 fb98          .dw VE_HEAD
                     .set VE_HEAD = VE_ICELLPLUS
                 XT_ICELLPLUS:
00fbb8 f000          .dw DO_COLON
                 PFA_ICELLPLUS:
00fbb9 f23b          .dw XT_1PLUS
00fbba f020          .dw XT_EXIT
                 
                 .include "words/edefer-fetch.asm"
                 
                 ; System
                 ; does the real defer@ for eeprom defers
                 VE_EDEFERFETCH:
00fbbb ff07          .dw $ff07
00fbbc 6445
00fbbd 6665
00fbbe 7265
00fbbf 0040          .db "Edefer@",0
00fbc0 fbb2          .dw VE_HEAD
                     .set VE_HEAD = VE_EDEFERFETCH
                 XT_EDEFERFETCH:
00fbc1 f000          .dw DO_COLON
                 PFA_EDEFERFETCH:
00fbc2 f3d2          .dw XT_FETCHI
00fbc3 f35f          .dw XT_FETCHE
00fbc4 f020          .dw XT_EXIT
                 .include "words/edefer-store.asm"
                 
                 ; System
                 ; does the real defer! for eeprom defers
                 VE_EDEFERSTORE:
00fbc5 ff07          .dw $ff07
00fbc6 6445
00fbc7 6665
00fbc8 7265
00fbc9 0021          .db "Edefer!",0
00fbca fbbb          .dw VE_HEAD
                     .set VE_HEAD = VE_EDEFERSTORE
                 XT_EDEFERSTORE:
00fbcb f000          .dw DO_COLON
                 PFA_EDEFERSTORE:
00fbcc f3d2          .dw XT_FETCHI
00fbcd f33b          .dw XT_STOREE
00fbce f020          .dw XT_EXIT
                 .include "words/rdefer-fetch.asm"
                 
                 ; System
                 ; The defer@ for ram defers
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_RDEFERFETCH:
00fbcf ff07          .dw $ff07
00fbd0 6452
00fbd1 6665
00fbd2 7265
00fbd3 0040          .db "Rdefer@",0
00fbd4 fbc5          .dw VE_HEAD
                     .set VE_HEAD = VE_RDEFERFETCH
                 XT_RDEFERFETCH:
00fbd5 f000          .dw DO_COLON
                 PFA_RDEFERFETCH:
                 .endif
00fbd6 f3d2          .dw XT_FETCHI
00fbd7 f085          .dw XT_FETCH
00fbd8 f020          .dw XT_EXIT
                 .include "words/rdefer-store.asm"
                 
                 ; System
                 ; The defer! for ram defers
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_RDEFERSTORE:
00fbd9 ff07          .dw $ff07
00fbda 6452
00fbdb 6665
00fbdc 7265
00fbdd 0021          .db "Rdefer!",0
00fbde fbcf          .dw VE_HEAD
                     .set VE_HEAD = VE_RDEFERSTORE
                 XT_RDEFERSTORE:
00fbdf f000          .dw DO_COLON
                 PFA_RDEFERSTORE:
                 .endif
00fbe0 f3d2          .dw XT_FETCHI
00fbe1 f08d          .dw XT_STORE
00fbe2 f020          .dw XT_EXIT
                 
                 .include "words/udefer-fetch.asm"
                 
                 ; System
                 ; does the real defer@ for user based defers
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_UDEFERFETCH:
00fbe3 ff07          .dw $ff07
00fbe4 6455
00fbe5 6665
00fbe6 7265
00fbe7 0040          .db "Udefer@",0
00fbe8 fbd9          .dw VE_HEAD
                     .set VE_HEAD = VE_UDEFERFETCH
                 XT_UDEFERFETCH:
00fbe9 f000          .dw DO_COLON
                 PFA_UDEFERFETCH:
                 .endif
00fbea f3d2          .dw XT_FETCHI
00fbeb f302          .dw XT_UP_FETCH
00fbec f1a9          .dw XT_PLUS
00fbed f085          .dw XT_FETCH
00fbee f020          .dw XT_EXIT
                 .include "words/udefer-store.asm"
                 
                 ; System
                 ; does the real defer! for user based defers
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_UDEFERSTORE:
00fbef ff07          .dw $ff07
00fbf0 6455
00fbf1 6665
00fbf2 7265
00fbf3 0021          .db "Udefer!",0
00fbf4 fbe3          .dw VE_HEAD
                     .set VE_HEAD = VE_UDEFERSTORE
                 XT_UDEFERSTORE:
00fbf5 f000          .dw DO_COLON
                 PFA_UDEFERSTORE:
                 .endif
                 
00fbf6 f3d2          .dw XT_FETCHI
00fbf7 f302          .dw XT_UP_FETCH
00fbf8 f1a9          .dw XT_PLUS
00fbf9 f08d          .dw XT_STORE
00fbfa f020          .dw XT_EXIT
                 
                 .include "words/defer-store.asm"
                 
                 ; System
                 ; stores xt1 as the xt to be executed when xt2 is called
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DEFERSTORE:
00fbfb ff06          .dw $ff06
00fbfc 6564
00fbfd 6566
00fbfe 2172          .db "defer!"
00fbff fbef          .dw VE_HEAD
                     .set VE_HEAD = VE_DEFERSTORE
                 XT_DEFERSTORE:
00fc00 f000          .dw DO_COLON
                 PFA_DEFERSTORE:
                 .endif
00fc01 fd8a          .dw XT_TO_BODY
00fc02 f0bd          .dw XT_DUP
00fc03 fbb8          .dw XT_ICELLPLUS
00fc04 fbb8          .dw XT_ICELLPLUS
00fc05 f3d2          .dw XT_FETCHI
00fc06 f02a          .dw XT_EXECUTE
00fc07 f020          .dw XT_EXIT
                 
                 .include "words/defer-fetch.asm"
                 
                 ; System
                 ; returns the XT associated with the given XT
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DEFERFETCH:
00fc08 ff06          .dw $ff06
00fc09 6564
00fc0a 6566
00fc0b 4072          .db "defer@"
00fc0c fbfb          .dw VE_HEAD
                     .set VE_HEAD = VE_DEFERFETCH
                 XT_DEFERFETCH:
00fc0d f000          .dw DO_COLON
                 PFA_DEFERFETCH:
                 .endif
00fc0e fd8a          .dw XT_TO_BODY 
00fc0f f0bd          .dw XT_DUP
00fc10 fbb8          .dw XT_ICELLPLUS
00fc11 f3d2          .dw XT_FETCHI
00fc12 f02a          .dw XT_EXECUTE
00fc13 f020          .dw XT_EXIT
                 .include "words/do-defer.asm"
                 
                 ; System
                 ; runtime of defer
                 VE_DODEFER:
00fc14 ff07          .dw $ff07
00fc15 6428
00fc16 6665
00fc17 7265
00fc18 0029          .db "(defer)", 0
00fc19 fc08          .dw VE_HEAD
                     .set VE_HEAD = VE_DODEFER
                 XT_DODEFER:
00fc1a f000          .dw DO_COLON
                 PFA_DODEFER:
00fc1b 01d1          .dw XT_DOCREATE
00fc1c 0335          .dw XT_REVEAL
00fc1d 01f7          .dw XT_COMPILE
00fc1e fc20          .dw PFA_DODEFER1
00fc1f f020          .dw XT_EXIT
                 PFA_DODEFER1:
00fc20 940e 0359     call_ DO_DODOES
00fc22 f0bd          .dw XT_DUP
00fc23 fbb8          .dw XT_ICELLPLUS
00fc24 f3d2          .dw XT_FETCHI
00fc25 f02a          .dw XT_EXECUTE 
00fc26 f02a          .dw XT_EXECUTE
00fc27 f020          .dw XT_EXIT
                 
                 ; : (defer) <builds does> dup i-cell+ @i execute execute ;
                 
                 
                 .include "words/search-wordlist.asm"
                 
                 ; Search Order
                 ; searches the word list wid for the word at c-addr/len
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SEARCH_WORDLIST:
00fc28 ff0f          .dw $ff0f
00fc29 6573
00fc2a 7261
00fc2b 6863
00fc2c 772d
00fc2d 726f
00fc2e 6c64
00fc2f 7369
00fc30 0074          .db "search-wordlist",0
00fc31 fc14          .dw VE_HEAD
                     .set VE_HEAD = VE_SEARCH_WORDLIST
                 XT_SEARCH_WORDLIST:
00fc32 f000          .dw DO_COLON
                 PFA_SEARCH_WORDLIST:
                 .endif
00fc33 f10b          .dw XT_TO_R
00fc34 f160          .dw XT_ZERO
00fc35 f040          .dw XT_DOLITERAL
00fc36 fc47          .dw XT_ISWORD
00fc37 f102          .dw XT_R_FROM
00fc38 fc64          .dw XT_TRAVERSEWORDLIST
00fc39 f0bd          .dw XT_DUP
00fc3a f126          .dw XT_ZEROEQUAL
00fc3b f039          .dw XT_DOCONDBRANCH
00fc3c fc41          DEST(PFA_SEARCH_WORDLIST1)
00fc3d f588             .dw XT_2DROP
00fc3e f0e5             .dw XT_DROP
00fc3f f160             .dw XT_ZERO
00fc40 f020             .dw XT_EXIT
                 PFA_SEARCH_WORDLIST1:
                       ; ... get the XT ...
00fc41 f0bd            .dw XT_DUP
00fc42 fc8b            .dw XT_NFA2CFA
                       ; .. and get the header flag
00fc43 f0d0            .dw XT_SWAP
00fc44 01a3            .dw XT_NAME2FLAGS
00fc45 0190            .dw XT_IMMEDIATEQ
00fc46 f020          .dw XT_EXIT
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 XT_ISWORD:
00fc47 f000          .dw DO_COLON
                 PFA_ISWORD:
                 .endif
                     ; ( c-addr len 0 nt -- c-addr len 0 true| nt false )
00fc48 f10b          .dw XT_TO_R
00fc49 f0e5          .dw XT_DROP
00fc4a f57f          .dw XT_2DUP
00fc4b f114          .dw XT_R_FETCH  ; -- addr len addr len nt
00fc4c fc7f          .dw XT_NAME2STRING
00fc4d fc95          .dw XT_ICOMPARE      ; (-- addr len f )
00fc4e f039          .dw XT_DOCONDBRANCH
00fc4f fc55          DEST(PFA_ISWORD3)
                       ; not now
00fc50 f102            .dw XT_R_FROM
00fc51 f0e5            .dw XT_DROP
00fc52 f160            .dw XT_ZERO
00fc53 f157            .dw XT_TRUE         ; maybe next word
00fc54 f020            .dw XT_EXIT
                 PFA_ISWORD3:
                       ; we found the word, now clean up iteration data ...
00fc55 f588            .dw XT_2DROP
00fc56 f102            .dw XT_R_FROM
00fc57 f160            .dw XT_ZERO       ; finish traverse-wordlist
00fc58 f020            .dw XT_EXIT
                 .include "words/traverse-wordlist.asm"
                 
                 ; Tools Ext (2012)
                 ; call the xt for every member of the wordlist wid until xt returns false
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_TRAVERSEWORDLIST:
00fc59 ff11          .dw $ff11
00fc5a 7274
00fc5b 7661
00fc5c 7265
00fc5d 6573
00fc5e 772d
00fc5f 726f
00fc60 6c64
00fc61 7369
00fc62 0074          .db "traverse-wordlist",0
00fc63 fc28          .dw VE_HEAD
                     .set VE_HEAD = VE_TRAVERSEWORDLIST
                 XT_TRAVERSEWORDLIST:
00fc64 f000          .dw DO_COLON
                 PFA_TRAVERSEWORDLIST:
                 
                 .endif
00fc65 f35f          .dw XT_FETCHE
                 PFA_TRAVERSEWORDLIST1:
00fc66 f0bd          .dw XT_DUP           ; ( -- xt nt nt )
00fc67 f039          .dw XT_DOCONDBRANCH  ; ( -- nt ) is nfa = counted string
00fc68 fc75          DEST(PFA_TRAVERSEWORDLIST2)
00fc69 f57f          .dw XT_2DUP
00fc6a f31e          .dw XT_2TO_R
00fc6b f0d0          .dw XT_SWAP
00fc6c f02a          .dw XT_EXECUTE
00fc6d f32d          .dw XT_2R_FROM
00fc6e f0ed          .dw XT_ROT
00fc6f f039          .dw XT_DOCONDBRANCH
00fc70 fc75          DEST(PFA_TRAVERSEWORDLIST2)
00fc71 04b2          .dw XT_NFA2LFA
00fc72 f3d2          .dw XT_FETCHI
00fc73 f02f          .dw XT_DOBRANCH      ; ( -- addr )
00fc74 fc66          DEST(PFA_TRAVERSEWORDLIST1)       ; ( -- addr )
                 PFA_TRAVERSEWORDLIST2:
00fc75 f588          .dw XT_2DROP
00fc76 f020          .dw XT_EXIT
                 
                 ; : traverse-wordlist ( i*x xt wid -- i*x' ) 
                 ;        begin @ dup 
                 ;        while 
                 ;          2dup 2>r 
                 ;          cell + swap execute ( i*x nt -- i*x' f ) 
                 ;          2r> rot 
                 ;        while repeat then 2drop ; 
                 .include "words/name2string.asm"
                 
                 ; Tools Ext (2012)
                 ; get a (flash) string from a name token nt
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_NAME2STRING:
00fc77 ff0b          .dw $ff0b
00fc78 616e
00fc79 656d
00fc7a 733e
00fc7b 7274
00fc7c 6e69
00fc7d 0067          .db "name>string",0
00fc7e fc59          .dw VE_HEAD
                     .set VE_HEAD = VE_NAME2STRING
                 XT_NAME2STRING:
00fc7f f000          .dw DO_COLON
                 PFA_NAME2STRING:
                 
                 .endif
00fc80 f7f0          .dw XT_ICOUNT   ; ( -- addr n )
00fc81 f040          .dw XT_DOLITERAL
00fc82 00ff          .dw 255
00fc83 f21f          .dw XT_AND      ; mask immediate bit
00fc84 f020          .dw XT_EXIT
                 .include "words/nfa2cfa.asm"
                 
                 ; Tools
                 ; get the XT from a name token
                 VE_NFA2CFA:
00fc85 ff07          .dw $ff07
00fc86 666e
00fc87 3e61
00fc88 6663
../../avr8\words/nfa2cfa.asm(6): warning: .cseg .db misalignment - padding zero byte
00fc89 0061          .db "nfa>cfa"
00fc8a fc77          .dw VE_HEAD
                     .set VE_HEAD = VE_NFA2CFA
                 XT_NFA2CFA:
00fc8b f000          .dw DO_COLON
                 PFA_NFA2CFA:
00fc8c 04b2          .dw XT_NFA2LFA ; skip to link field
00fc8d f23b          .dw XT_1PLUS   ; next is the execution token
00fc8e f020          .dw XT_EXIT
                 .include "words/icompare.asm"
                 
                 ; Tools
                 ; compares string in RAM with string in flash. f is zero if equal like COMPARE
                 VE_ICOMPARE:
00fc8f ff08          .dw $ff08
00fc90 6369
00fc91 6d6f
00fc92 6170
00fc93 6572          .db "icompare"
00fc94 fc85          .dw VE_HEAD
                     .set VE_HEAD = VE_ICOMPARE
                 XT_ICOMPARE:
00fc95 f000          .dw DO_COLON
                 PFA_ICOMPARE:
00fc96 f10b          .dw XT_TO_R    ; ( -- r-addr r-len f-addr)
00fc97 f0db          .dw XT_OVER    ; ( -- r-addr r-len f-addr r-len)
00fc98 f102          .dw XT_R_FROM  ; ( -- r-addr r-len f-addr r-len f-len )
00fc99 f11f          .dw XT_NOTEQUAL ; ( -- r-addr r-len f-addr flag )
00fc9a f039          .dw XT_DOCONDBRANCH
00fc9b fca0          .dw PFA_ICOMPARE_SAMELEN
00fc9c f588            .dw XT_2DROP
00fc9d f0e5            .dw XT_DROP
00fc9e f157            .dw XT_TRUE
00fc9f f020            .dw XT_EXIT
                 PFA_ICOMPARE_SAMELEN:
00fca0 f0d0          .dw XT_SWAP ; ( -- r-addr f-addr len )
00fca1 f160          .dw XT_ZERO
00fca2 02c1          .dw XT_QDOCHECK
00fca3 f039          .dw XT_DOCONDBRANCH
00fca4 fcc5          .dw PFA_ICOMPARE_DONE
00fca5 f29b          .dw XT_DODO
                 PFA_ICOMPARE_LOOP:
                     ; ( r-addr f-addr --)
00fca6 f0db          .dw XT_OVER
00fca7 f085          .dw XT_FETCH
                 .if WANT_IGNORECASE == 1
00fca8 fcc8          .dw XT_ICOMPARE_LC
                 .endif
00fca9 f0db          .dw XT_OVER
00fcaa f3d2          .dw XT_FETCHI ; ( -- r-addr f-addr r-cc f- cc)
                 .if WANT_IGNORECASE == 1
00fcab fcc8          .dw XT_ICOMPARE_LC
                 .endif
                     ; flash strings are zero-padded at the last cell
                     ; that means: if the flash cell is less $0100, than mask the
                     ; high byte in the ram cell
00fcac f0bd          .dw XT_DUP
                     ;.dw XT_BYTESWAP
00fcad f040          .dw XT_DOLITERAL
00fcae 0100          .dw $100
00fcaf f168          .dw XT_ULESS
00fcb0 f039          .dw XT_DOCONDBRANCH
00fcb1 fcb6          .dw PFA_ICOMPARE_LASTCELL
00fcb2 f0d0          .dw XT_SWAP
00fcb3 f040          .dw XT_DOLITERAL
00fcb4 00ff          .dw $00FF
00fcb5 f21f          .dw XT_AND  ; the final swap can be omitted
                 PFA_ICOMPARE_LASTCELL:
00fcb6 f11f          .dw XT_NOTEQUAL
00fcb7 f039          .dw XT_DOCONDBRANCH
00fcb8 fcbd          .dw PFA_ICOMPARE_NEXTLOOP
00fcb9 f588          .dw XT_2DROP
00fcba f157          .dw XT_TRUE
00fcbb f2d4          .dw XT_UNLOOP
00fcbc f020          .dw XT_EXIT
                 PFA_ICOMPARE_NEXTLOOP:
00fcbd f23b          .dw XT_1PLUS
00fcbe f0d0          .dw XT_SWAP
00fcbf f578          .dw XT_CELLPLUS
00fcc0 f0d0          .dw XT_SWAP
00fcc1 f040          .dw XT_DOLITERAL
00fcc2 0002          .dw 2
00fcc3 f2ba          .dw XT_DOPLUSLOOP
00fcc4 fca6          .dw PFA_ICOMPARE_LOOP
                 PFA_ICOMPARE_DONE:
00fcc5 f588          .dw XT_2DROP
00fcc6 f160          .dw XT_ZERO
00fcc7 f020          .dw XT_EXIT
                 
                 .if WANT_IGNORECASE == 1
                 ; ( cc1 cc2 -- f) 
                 ; Tools
                 ; compares two packed characters 
                 ;VE_ICOMPARELC:
                 ;    .dw $ff08
                 ;    .db "icompare-lower"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_ICOMPARELC
                 XT_ICOMPARE_LC:
00fcc8 f000          .dw DO_COLON
                 PFA_ICOMPARE_LC:
00fcc9 f0bd          .dw XT_DUP
00fcca f040          .dw XT_DOLITERAL
00fccb 00ff          .dw $00ff
00fccc f21f          .dw XT_AND
00fccd f6bc          .dw XT_TOLOWER
00fcce f0d0          .dw XT_SWAP
00fccf f2f9          .dw XT_BYTESWAP
00fcd0 f040          .dw XT_DOLITERAL
00fcd1 00ff          .dw $00ff
00fcd2 f21f          .dw XT_AND
00fcd3 f6bc          .dw XT_TOLOWER
00fcd4 f2f9          .dw XT_BYTESWAP
00fcd5 f228          .dw XT_OR
00fcd6 f020          .dw XT_EXIT
                 .endif
                 
                 .include "words/star.asm"
                 
                 ; Arithmetics
                 ; multiply routine
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_STAR:
00fcd7 ff01          .dw $ff01
00fcd8 002a          .db "*",0
00fcd9 fc8f          .dw VE_HEAD
                     .set VE_HEAD = VE_STAR
                 XT_STAR:
00fcda f000          .dw DO_COLON
                 PFA_STAR:
                 .endif
                 
00fcdb f1b2          .dw XT_MSTAR
00fcdc f0e5          .dw XT_DROP
00fcdd f020          .dw XT_EXIT
                 .include "words/j.asm"
                 
                 ; Compiler
                 ; loop counter of outer loop
                 VE_J:
00fcde ff01          .dw $FF01
00fcdf 006a          .db "j",0
00fce0 fcd7          .dw VE_HEAD
                     .set VE_HEAD = VE_J
                 XT_J:
00fce1 f000          .dw DO_COLON
                 PFA_J:
00fce2 f276          .dw XT_RP_FETCH
00fce3 f040          .dw XT_DOLITERAL
00fce4 0007          .dw 7
00fce5 f1a9          .dw XT_PLUS
00fce6 f085          .dw XT_FETCH
00fce7 f276          .dw XT_RP_FETCH
00fce8 f040          .dw XT_DOLITERAL
00fce9 0009          .dw 9
00fcea f1a9          .dw XT_PLUS
00fceb f085          .dw XT_FETCH
00fcec f1a9          .dw XT_PLUS
00fced f020          .dw XT_EXIT
                 
                 .include "words/dabs.asm"
                 
                 ; Arithmetics
                 ; double cell absolute value
                 VE_DABS:
00fcee ff04          .dw $ff04
00fcef 6164
00fcf0 7362          .db "dabs"
00fcf1 fcde          .dw VE_HEAD
                     .set VE_HEAD = VE_DABS
                 XT_DABS:
00fcf2 f000          .dw DO_COLON
                 PFA_DABS:
00fcf3 f0bd          .dw XT_DUP
00fcf4 f12d          .dw XT_ZEROLESS
00fcf5 f039          .dw XT_DOCONDBRANCH
00fcf6 fcf8          .dw PFA_DABS1
00fcf7 fcff          .dw XT_DNEGATE
                 PFA_DABS1:
00fcf8 f020          .dw XT_EXIT
                 ; : dabs      ( ud1 -- +d2 ) dup 0< if dnegate then ;
                 .include "words/dnegate.asm"
                 
                 ; Arithmetics
                 ; double cell negation
                 VE_DNEGATE:
00fcf9 ff07          .dw $ff07
00fcfa 6e64
00fcfb 6765
00fcfc 7461
00fcfd 0065          .db "dnegate",0
00fcfe fcee          .dw VE_HEAD
                     .set VE_HEAD = VE_DNEGATE
                 XT_DNEGATE:
00fcff f000          .dw DO_COLON
                 PFA_DNEGATE:
00fd00 f445          .dw XT_DINVERT
00fd01 f040          .dw XT_DOLITERAL
00fd02 0001          .dw 1
00fd03 f160          .dw XT_ZERO
00fd04 f41f          .dw XT_DPLUS
00fd05 f020          .dw XT_EXIT
                 ; : dnegate   ( ud1 -- ud2 ) dinvert 1. d+ ;
                 .include "words/cmove.asm"
                 
                 ; Memory
                 ; copy data in RAM, from lower to higher addresses
                 VE_CMOVE:
00fd06 ff05          .dw $ff05
00fd07 6d63
00fd08 766f
00fd09 0065          .db "cmove",0
00fd0a fcf9          .dw VE_HEAD
                     .set VE_HEAD  = VE_CMOVE
                 XT_CMOVE:
00fd0b fd0c          .dw PFA_CMOVE
                 PFA_CMOVE:
00fd0c 93bf          push xh
00fd0d 93af          push xl
00fd0e 91e9          ld zl, Y+
00fd0f 91f9          ld zh, Y+ ; addr-to
00fd10 91a9          ld xl, Y+
00fd11 91b9          ld xh, Y+ ; addr-from
00fd12 2f09          mov temp0, tosh
00fd13 2b08          or temp0, tosl
00fd14 f021          brbs 1, PFA_CMOVE1
                 PFA_CMOVE2:
00fd15 911d          ld temp1, X+
00fd16 9311          st Z+, temp1
00fd17 9701          sbiw tosl, 1
00fd18 f7e1          brbc 1, PFA_CMOVE2
                 PFA_CMOVE1:
00fd19 91af          pop xl
00fd1a 91bf          pop xh
00fd1b 9189
00fd1c 9199          loadtos
00fd1d 940c f004     jmp_ DO_NEXT
                 .include "words/2swap.asm"
                 
                 ; Stack
                 ; Exchange the two top cell pairs
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_2SWAP:
00fd1f ff05          .dw $ff05
00fd20 7332
00fd21 6177
00fd22 0070          .db "2swap",0
00fd23 fd06          .dw VE_HEAD
                     .set VE_HEAD = VE_2SWAP
                 XT_2SWAP:
00fd24 f000          .dw DO_COLON
                 PFA_2SWAP:
                 
                 .endif
00fd25 f0ed          .dw XT_ROT
00fd26 f10b          .dw XT_TO_R
00fd27 f0ed          .dw XT_ROT
00fd28 f102          .dw XT_R_FROM
00fd29 f020          .dw XT_EXIT
                 
                 .include "words/tib.asm"
                 
                 ; System Variable
                 ; terminal input buffer address
                 VE_TIB:
00fd2a ff03          .dw $ff03
00fd2b 6974
00fd2c 0062          .db "tib",0
00fd2d fd1f          .dw VE_HEAD
                     .set VE_HEAD = VE_TIB
                 XT_TIB:
00fd2e f04e          .dw PFA_DOVARIABLE
                 PFA_TIB:
00fd2f 024d          .dw ram_tib
                     
                 .dseg
00024d           ram_tib: .byte TIBSIZE
                 .cseg
                 ; ( -- f ) 
                 ; System
                 ; refills the input buffer
                 VE_REFILLTIB:
00fd30 ff0a          .dw $ff0a
00fd31 6572
00fd32 6966
00fd33 6c6c
00fd34 742d
00fd35 6269          .db "refill-tib"
00fd36 fd2a          .dw VE_HEAD
                     .set VE_HEAD = VE_REFILLTIB
                 XT_REFILLTIB:
00fd37 f000          .dw DO_COLON
                 PFA_REFILLTIB:
00fd38 fd2e          .dw XT_TIB
00fd39 f040          .dw XT_DOLITERAL
00fd3a 005a          .dw TIBSIZE
00fd3b f8ae          .dw XT_ACCEPT
00fd3c f59e          .dw XT_NUMBERTIB
00fd3d f08d          .dw XT_STORE
00fd3e f160          .dw XT_ZERO
00fd3f f598          .dw XT_TO_IN
00fd40 f08d          .dw XT_STORE
00fd41 f157          .dw XT_TRUE ; -1
00fd42 f020          .dw XT_EXIT
                 
                 ; ( -- addr n ) 
                 ; System
                 ; address and current length of the input buffer
                 VE_SOURCETIB:
00fd43 ff0a          .dw $FF0A
00fd44 6f73
00fd45 7275
00fd46 6563
00fd47 742d
00fd48 6269          .db "source-tib"
00fd49 fd30          .dw VE_HEAD
                     .set VE_HEAD = VE_SOURCETIB
                 XT_SOURCETIB:
00fd4a f000          .dw DO_COLON
                 PFA_SOURCETIB:
00fd4b fd2e          .dw XT_TIB
00fd4c f59e          .dw XT_NUMBERTIB
00fd4d f085          .dw XT_FETCH
00fd4e f020          .dw XT_EXIT
                 
                 .include "words/init-user.asm"
                 
                 ; Tools
                 ; copy len cells from eeprom to ram
                 VE_EE2RAM:
00fd4f ff06        .dw $ff06
00fd50 6565
00fd51 723e
00fd52 6d61        .db "ee>ram"
00fd53 fd43        .dw VE_HEAD
                   .set VE_HEAD = VE_EE2RAM
                 XT_EE2RAM:
00fd54 f000        .dw DO_COLON
                 PFA_EE2RAM:          ; ( -- )
00fd55 f160          .dw XT_ZERO
00fd56 f29b          .dw XT_DODO
                 PFA_EE2RAM_1:
                     ; ( -- e-addr r-addr )
00fd57 f0db          .dw XT_OVER
00fd58 f35f          .dw XT_FETCHE
00fd59 f0db          .dw XT_OVER
00fd5a f08d          .dw XT_STORE
00fd5b f578          .dw XT_CELLPLUS
00fd5c f0d0          .dw XT_SWAP
00fd5d f578          .dw XT_CELLPLUS
00fd5e f0d0          .dw XT_SWAP
00fd5f f2c9          .dw XT_DOLOOP
00fd60 fd57          .dw PFA_EE2RAM_1
                 PFA_EE2RAM_2:
00fd61 f588          .dw XT_2DROP
00fd62 f020          .dw XT_EXIT
                 
                 ; ( -- )
                 ; Tools
                 ; setup the default user area from eeprom
                 VE_INITUSER:
00fd63 ff09        .dw $ff09
00fd64 6e69
00fd65 7469
00fd66 752d
00fd67 6573
00fd68 0072        .db "init-user",0
00fd69 fd4f        .dw VE_HEAD
                   .set VE_HEAD = VE_INITUSER
                 XT_INITUSER:
00fd6a f000        .dw DO_COLON
                 PFA_INITUSER:          ; ( -- )
00fd6b f040          .dw XT_DOLITERAL
00fd6c 00a8          .dw EE_INITUSER
00fd6d f302          .dw XT_UP_FETCH
00fd6e f040          .dw XT_DOLITERAL
00fd6f 001c          .dw SYSUSERSIZE
00fd70 f210          .dw XT_2SLASH
00fd71 fd54          .dw XT_EE2RAM
00fd72 f020          .dw XT_EXIT
                 .include "dict/compiler2.inc"
                 
                 ; included almost independently from each other
                 ; on a include-per-use basis
                 ;
                 .if DICT_COMPILER2 == 0
                 .endif
                 .include "words/bounds.asm"
                 
                 ; Tools
                 ; convert a string to an address range
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_BOUNDS:
00fd73 ff06          .dw $ff06
00fd74 6f62
00fd75 6e75
00fd76 7364          .db "bounds"
00fd77 fd63          .dw VE_HEAD
                     .set VE_HEAD = VE_BOUNDS
                 XT_BOUNDS:
00fd78 f000          .dw DO_COLON
                 PFA_BOUNDS:
                 .endif
00fd79 f0db          .dw XT_OVER
00fd7a f1a9          .dw XT_PLUS
00fd7b f0d0          .dw XT_SWAP
00fd7c f020          .dw XT_EXIT
                 .include "words/s-to-d.asm"
                 
                 ; Conversion
                 ; extend (signed) single cell value to double cell
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_S2D:
00fd7d ff03          .dw $ff03
00fd7e 3e73
00fd7f 0064          .db "s>d",0
00fd80 fd73          .dw VE_HEAD
                     .set VE_HEAD = VE_S2D
                 XT_S2D:
00fd81 f000          .dw DO_COLON
                 PFA_S2D:
                 .endif
00fd82 f0bd          .dw XT_DUP
00fd83 f12d          .dw XT_ZEROLESS
00fd84 f020          .dw XT_EXIT
                 .include "words/to-body.asm"
                 
                 ; Core
                 ; get body from XT
                 VE_TO_BODY:
00fd85 ff05          .dw $ff05
00fd86 623e
00fd87 646f
00fd88 0079          .db ">body",0
00fd89 fd7d          .dw VE_HEAD
                     .set VE_HEAD = VE_TO_BODY
                 XT_TO_BODY:
00fd8a f23c          .dw PFA_1PLUS
                 .elif AMFORTH_NRWW_SIZE>4000
                 .elif AMFORTH_NRWW_SIZE>2000
                 .else
                 .endif
                 ; now colon words
                 ;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/2literal.asm"
                 
                 ; Compiler
                 ; compile a cell pair literal in colon definitions
                 VE_2LITERAL:
00fd8b 0008          .dw $0008
00fd8c 6c32
00fd8d 7469
00fd8e 7265
00fd8f 6c61          .db "2literal"
00fd90 fd85          .dw VE_HEAD
                     .set VE_HEAD = VE_2LITERAL
                 XT_2LITERAL:
00fd91 f000          .dw DO_COLON
                 PFA_2LITERAL:
00fd92 f0d0          .dw XT_SWAP
00fd93 01f7          .dw XT_COMPILE
00fd94 f040          .dw XT_DOLITERAL
00fd95 0202          .dw XT_COMMA
00fd96 01f7          .dw XT_COMPILE
00fd97 f040          .dw XT_DOLITERAL
00fd98 0202          .dw XT_COMMA
                     
00fd99 f020          .dw XT_EXIT
                 .include "words/equal.asm"
                 
                 ; Compare
                 ; compares two values for equality
                 VE_EQUAL:
00fd9a ff01          .dw $ff01
00fd9b 003d          .db "=",0
00fd9c fd8b          .dw VE_HEAD
                     .set VE_HEAD = VE_EQUAL
                 XT_EQUAL:
00fd9d f000          .dw DO_COLON
                 PFA_EQUAL:
00fd9e f19f          .dw XT_MINUS
00fd9f f126          .dw XT_ZEROEQUAL
00fda0 f020          .dw XT_EXIT
                 .include "words/num-constants.asm"
                 
                 .endif
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_ONE:
00fda1 ff01          .dw $ff01
00fda2 0031          .db "1",0
00fda3 fd9a          .dw VE_HEAD
                     .set VE_HEAD = VE_ONE
                 XT_ONE:
00fda4 f04e          .dw PFA_DOVARIABLE
                 PFA_ONE:
                 .endif
00fda5 0001              .DW 1
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_TWO:
00fda6 ff01          .dw $ff01
00fda7 0032          .db "2",0
00fda8 fda1          .dw VE_HEAD
                     .set VE_HEAD = VE_TWO
                 XT_TWO:
00fda9 f04e          .dw PFA_DOVARIABLE
                 PFA_TWO:
                 .endif
00fdaa 0002              .DW 2
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_MINUSONE:
00fdab ff02          .dw $ff02
00fdac 312d          .db "-1"
00fdad fda6          .dw VE_HEAD
                     .set VE_HEAD = VE_MINUSONE
                 XT_MINUSONE:
00fdae f04e          .dw PFA_DOVARIABLE
                 PFA_MINUSONE:
                 .endif
00fdaf ffff              .DW -1
                 .include "dict_appl_core.inc"
                 
                 ; do not delete it!
                 
                 .set flashlast = pc
                 .if (pc>FLASHEND)
                 .endif
                 
                 .dseg
                 ; define a label for the 1st free ram address
                 HERESTART:
                 .eseg
                 .include "amforth-eeprom.inc"
000072 ff ff     
                 EE_DP:
000074 5c 05         .dw DPSTART      ; Dictionary Pointer
                 EE_HERE:
000076 a7 02         .dw HERESTART    ; Memory Allocation
                 EE_EHERE:
000078 c6 00         .dw EHERESTART     ; EEProm Memory Allocation
                 EE_TURNKEY:
00007a 4e 05         .dw XT_APPLTURNKEY  ; TURNKEY
                 EE_STOREI:
00007c 7e f3         .dw XT_DO_STOREI  ; Store a cell into flash
                 
                 EE_ENVIRONMENT:
00007e 4c f5         .dw VE_ENVHEAD   ; environmental queries
                 EE_WL_FORTH:
000080 84 00         .dw EE_FORTHWORDLIST; forth-wordlist
                 EE_CURRENT:
000082 84 00         .dw EE_FORTHWORDLIST
                 EE_FORTHWORDLIST:
000084 ab fd         .dw VE_HEAD      ; pre-defined (compiled in) wordlist
                 CFG_ORDERLISTLEN:
000086 01 00         .dw 1
                 CFG_ORDERLIST: ; list of wordlist id, exactly numwordlist entries
000088 84 00         .dw EE_FORTHWORDLIST      ; get/set-order
00008a               .byte  (NUMWORDLISTS-1)*CELLSIZE ; one slot is already used
                 CFG_RECOGNIZERLISTLEN:
000098 02 00         .dw 2
                 CFG_RECOGNIZERLIST:
00009a 29 fb         .dw XT_REC_WORD
00009c 14 fb         .dw XT_REC_NUM
00009e               .byte  (NUMRECOGNIZERS-2)*CELLSIZE ; two slots are already used
                 
                 EE_WLSCOPE:
0000a2 73 04         .dw XT_GET_CURRENT  ; default wordlist scope
                 
                 ; LEAVE stack is between data stack and return stack.
                 EE_LP0:
0000a4 b0 21         .dw stackstart+1
                 
                 ; MARKER saves everything up to here. Nothing beyond gets saved
                 EE_MARKER:
0000a6 a6 00         .dw EE_MARKER
                 
                 ; default user area
                 EE_INITUSER:
0000a8 00 00         .dw 0  ; USER_STATE
0000aa 00 00         .dw 0  ; USER_FOLLOWER
0000ac ff 21         .dw rstackstart  ; USER_RP
0000ae af 21         .dw stackstart   ; USER_SP0
0000b0 af 21         .dw stackstart   ; USER_SP
                     
0000b2 00 00         .dw 0  ; USER_HANDLER
0000b4 0a 00         .dw 10 ; USER_BASE
                     
0000b6 ce 00         .dw XT_TX  ; USER_EMIT
0000b8 dc 00         .dw XT_TXQ ; USER_EMITQ
0000ba a4 00         .dw XT_RX  ; USER_KEY
0000bc be 00         .dw XT_RXQ ; USER_KEYQ
0000be 4a fd         .dw XT_SOURCETIB ; USER_SKEY
0000c0 00 00         .dw 0            ; USER_G_IN
0000c2 37 fd         .dw XT_REFILLTIB ; USER_REFILL  
                 
                 ; calculate baud rate error
                 .equ UBRR_VAL   = ((F_CPU+BAUD*8)/(BAUD*16)-1)  ; smart round
                 .equ BAUD_REAL  = (F_CPU/(16*(UBRR_VAL+1)))     ; effective baud rate
                 .equ BAUD_ERROR = ((BAUD_REAL*1000)/BAUD-1000)  ; error in pro mille
                 
                 .if ((BAUD_ERROR>BAUD_MAXERROR) || (BAUD_ERROR<-BAUD_MAXERROR))       
                 .endif
                 EE_UBRRVAL:
0000c4 19 00         .dw UBRR_VAL     ; BAUDRATE
                 ; 1st free address in EEPROM.
                 EHERESTART:
                 .cseg


RESOURCE USE INFORMATION
------------------------

Notice:
The register and instruction counts are symbol table hit counts,
and hence implicitly used resources are not counted, eg, the
'lpm' instruction without operands implicitly uses r0 and z,
none of which are counted.

x,y,z are separate entities in the symbol table and are
counted separately from r26..r31 here.

.dseg memory usage only counts static data declared with .byte

"ATmega1280" register use summary:
r0 :  20 r1 :   5 r2 :   8 r3 :  11 r4 :   4 r5 :   1 r6 :   0 r7 :   0 
r8 :   0 r9 :   0 r10:   1 r11:   1 r12:   0 r13:   0 r14:  22 r15:  20 
r16:  78 r17:  56 r18:  52 r19:  37 r20:  13 r21:  38 r22:  11 r23:   3 
r24: 191 r25: 136 r26:  39 r27:  21 r28:   7 r29:   4 r30:  83 r31:  45 
x  :   4 y  : 201 z  :  46 
Registers used: 29 out of 35 (82.9%)

"ATmega1280" instruction use summary:
.lds  :   0 .sts  :   0 adc   :  21 add   :  16 adiw  :  18 and   :   4 
andi  :   3 asr   :   2 bclr  :   0 bld   :   0 brbc  :   2 brbs  :   7 
brcc  :   3 brcs  :   1 break :   0 breq  :   6 brge  :   1 brhc  :   0 
brhs  :   0 brid  :   0 brie  :   0 brlo  :   1 brlt  :   3 brmi  :   3 
brne  :  19 brpl  :   1 brsh  :   0 brtc  :   0 brts  :   1 brvc  :   0 
brvs  :   2 bset  :   0 bst   :   0 call  :   2 cbi   :   7 cbr   :   0 
clc   :   2 clh   :   0 cli   :   7 cln   :   0 clr   :  20 cls   :   0 
clt   :   1 clv   :   0 clz   :   0 com   :  16 cp    :  10 cpc   :  10 
cpi   :   2 cpse  :   0 dec   :  10 elpm  :  16 eor   :   3 fmul  :   0 
fmuls :   0 fmulsu:   0 icall :   0 ijmp  :   1 in    :  19 inc   :   3 
jmp   :  10 ld    : 133 ldd   :   4 ldi   :  39 lds   :   2 lpm   :   0 
lsl   :  14 lsr   :   1 mov   :  12 movw  :  65 mul   :   5 muls  :   1 
mulsu :   2 neg   :   0 nop   :   0 or    :   9 ori   :   2 out   :  28 
pop   :  48 push  :  42 rcall :  69 ret   :   6 reti  :   2 rjmp  : 104 
rol   :  32 ror   :   6 sbc   :   9 sbci  :   3 sbi   :   8 sbic  :   3 
sbis  :   0 sbiw  :  14 sbr   :   0 sbrc  :   5 sbrs  :   4 sec   :   1 
seh   :   0 sei   :   1 sen   :   0 ser   :   4 ses   :   0 set   :   2 
sev   :   0 sez   :   0 sleep :   0 spm   :   2 st    :  73 std   :   8 
sts   :   3 sub   :   6 subi  :   3 swap  :   0 tst   :   1 wdr   :   0 

Instructions used: 76 out of 114 (66.7%)

"ATmega1280" memory use summary [bytes]:
Segment   Begin    End      Code   Data   Used    Size   Use%
---------------------------------------------------------------
[.cseg] 0x000000 0x01fb60   2090  14562  16652  131072  12.7%
[.dseg] 0x000200 0x0002a7      0    167    167    8192   2.0%
[.eseg] 0x000000 0x0000c6      0    198    198    4096   4.8%

Assembly complete, 0 errors, 5 warnings
